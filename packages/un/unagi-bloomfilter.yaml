homepage: http://github.com/jberryman/unagi-bloomfilter
changelog-type: ''
hash: c8a831d7041e8a6c77734b0fb828512935ca74dc56de3939ec8872f05c080aa9
test-bench-deps: {}
maintainer: brandon.m.simmons@gmail.com
synopsis: A fast, cache-efficient, concurrent bloom filter
changelog: ''
basic-deps:
  bytestring: -any
  hashabler: ! '>=1.3.0'
  base: ! '>=4.7 && <5'
  atomic-primops: ! '>=0.8'
  primitive: -any
all-versions:
- '0.1.0.0'
- '0.1.1.0'
- '0.1.1.1'
author: Brandon Simmons
latest: '0.1.1.1'
description-type: haddock
description: ! 'This library implements a fast concurrent bloom filter, based on bloom-1
  from

  "Fast Bloom Filters and Their Generalization" by Y Qiao, et al.


  A bloom filter is a probabilistic, constant-space, set-like data structure

  supporting insertion and membership queries. This implementation is backed by

  SipHash so can safely consume untrusted inputs.


  The implementation here compares favorably with traditional set

  implementations in a single-threaded context, e.g. here are 10 inserts or

  lookups compared across some sets of different sizes:


  <<http://i.imgur.com/gei1LW4.png>>


  With the llvm backend benchmarks take around 75-85% of the runtime of the

  native code gen.


  Unfortunately writes in particular don''t seem to scale currently; i.e.

  distributing writes across multiple threads may be /slower/ than in a

  single-threaded context, because of memory effects. We plan to export

  functionality that would support using the filter here in a concurrent

  context with better memory behavior (e.g. a server that shards to a

  thread-pool which handles only a portion of the bloom array).


  <<http://i.imgur.com/RaUSmZB.png>>

'
license-name: BSD3
