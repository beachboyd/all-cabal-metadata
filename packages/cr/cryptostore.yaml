homepage: https://github.com/ocheron/cryptostore
changelog-type: markdown
hash: b9fbaa0d60eb05ec7747a9a0247d14e0feab6d7c2380d933109d9951a3a76785
test-bench-deps:
  bytestring: -any
  hourglass: -any
  base: ! '>=4.9 && <5'
  pem: -any
  asn1-types: ! '>=0.3.1 && <0.4'
  memory: -any
  x509: -any
  cryptostore: -any
  cryptonite: ! '>=0.25'
  tasty-quickcheck: -any
  tasty-hunit: -any
  tasty: -any
maintainer: olivier.cheron@gmail.com
synopsis: Serialization of cryptographic data types
changelog: ! '# Revision history for cryptostore


  ## 0.1.0.0 -- 2018-09-23


  * First version. Released on an unsuspecting world.

'
basic-deps:
  bytestring: -any
  basement: -any
  hourglass: ! '>=0.2'
  base: ! '>=4.9 && <5'
  pem: ! '>=0.1 && <0.3'
  asn1-types: ! '>=0.3.1 && <0.4'
  memory: -any
  x509: ! '>=1.7.3'
  cryptonite: ! '>=0.25'
  asn1-encoding: ! '>=0.9 && <0.10'
all-versions:
- '0.1.0.0'
author: Olivier ChÃ©ron
latest: '0.1.0.0'
description-type: markdown
description: ! "# cryptostore\n\n[![Build Status](https://travis-ci.org/ocheron/cryptostore.png?branch=master)](https://travis-ci.org/ocheron/cryptostore)\n[![BSD](https://b.repl.ca/v1/license-BSD-blue.png)](https://en.wikipedia.org/wiki/BSD_licenses)\n[![Haskell](https://b.repl.ca/v1/language-haskell-lightgrey.png)](https://haskell.org/)\n\nThis
  package allows to read and write cryptographic objects to/from ASN.1.\n\nCurrently
  the following is implemented:\n\n* Reading and writing private keys with optional
  encryption (this extends\n  [x509-store](https://hackage.haskell.org/package/x509-store)
  API)\n\n* Reading and writing public keys, certificates and CRLs\n\n* PKCS #12 container
  format (password-based only)\n\n* Many parts of Cryptographic Message Syntax\n\nPlease
  have a look at the examples below as well as some warnings about\ncryptographic
  algorithms.\n\n## Private Keys\n\nThe API to read and write private keys is available
  in module\n`Crypto.Store.PKCS8`.  When encrypting, some types and functions from
  module\n`Crypto.Store.PKCS5` are also necessary.\n\nReading a private key from disk:\n\n```haskell\n>
  :set -XOverloadedStrings\n> :m Crypto.Store.PKCS8\n> (key : _) <- readKeyFile \"/path/to/privkey.pem\"
  -- assuming single key\n> recover \"mypassword\" key\nRight (PrivKeyRSA ...)\n```\n\nGenerating
  a private key and writing to disk, without encryption:\n\n```haskell\n> :m Crypto.PubKey.RSA
  Crypto.Store.PKCS8 Data.X509\n> privKey <- PrivKeyRSA . snd <$> generate (2048 `div`
  8) 0x10001\n> writeKeyFile PKCS8Format \"/path/to/privkey.pem\" [privKey]\n```\n\nGenerating
  a private key and writing to disk, with password-based encryption:\n\n```haskell\n>
  :set -XOverloadedStrings\n> :m Crypto.PubKey.RSA Crypto.Store.PKCS8 Data.X509 Crypto.Store.PKCS5\n>
  privKey <- PrivKeyRSA . snd <$> generate (2048 `div` 8) 0x10001\n> salt <- generateSalt
  8\n> let kdf = PBKDF2 salt 2048 Nothing PBKDF2_SHA256\n> encParams <- generateEncryptionParams
  (CBC AES256)\n> let pbes = PBES2 (PBES2Parameter kdf encParams)\n> writeEncryptedKeyFile
  \"/path/to/privkey.pem\" pbes \"mypassword\" privKey\nRight ()\n```\n\nParameters
  used in this example are AES-256-CBC as cipher, PBKDF2 as\nkey-derivation function,
  with an 8-byte salt, 2048 iterations and SHA-256 as\npseudorandom function.\n\n##
  Public Keys and Signed Objects\n\nModule `Crypto.Store.X509` provides functions
  to read/write PEM files containing\npublic keys, X.509 certificates and CRLs.  These
  files are never encrypted.\n\nReading a public key and certificate from disk:\n\n```haskell\n>
  :m Data.X509 Crypto.Store.X509\n> readPubKeyFile \"/path/to/pubkey.pem\"\n[PubKeyRSA
  ...]\n> readSignedObject \"/path/to/cert.pem\" :: IO [SignedCertificate]\n[SignedExact
  ...]\n```\n\nWriting back to disk:\n\n```haskell\n> :m Crypto.Store.X509\n> writePubKeyFile
  \"/path/to/pubkey.pem\" [pubKey]\n> writeSignedObject \"/path/to/cert.pem\" [cert]\n```\n\n##
  PKCS #12\n\nPKCS #12 is a complex format with multiple layers of protection, providing\nusually
  both privacy and integrity, with a single password for all or not.  The\nAPI to
  read PKCS #12 files requires some password at each layer.  This API is\navailable
  in module `Crypto.Store.PKCS12`.\n\nReading a binary PKCS #12 file using distinct
  integrity and privacy passwords:\n\n```haskell\n> :set -XOverloadedStrings\n> :m
  Crypto.Store.PKCS12\n> Right p12 <- readP12File \"/path/to/file.p12\"\n> let Right
  pkcs12 = recover \"myintegrityassword\" p12\n> let Right contents = recover \"myprivacypassword\"
  (unPKCS12 pkcs12)\n> getAllSafeX509Certs contents\n[SignedExact {getSigned = ...}]\n>
  recover \"myprivacypassword\" (getAllSafeKeys contents)\nRight [PrivKeyRSA ...]\n```\n\nGenerating
  a PKCS #12 file containing a private key:\n\n```haskell\n> :set -XOverloadedStrings\n\n--
  Generate a private key\n> :m Crypto.PubKey.RSA Data.X509\n> privKey <- PrivKeyRSA
  . snd <$> generate (2048 `div` 8) 0x10001\n\n-- Put the key inside a bag\n> :m Crypto.Store.PKCS12
  Crypto.Store.PKCS8 Crypto.Store.PKCS5 Crypto.Store.CMS\n> let attrs = setFriendlyName
  \"Some Key\" []\n>     keyBag = Bag (KeyBag $ FormattedKey PKCS8Format privKey)
  attrs\n>     contents = SafeContents [keyBag]\n\n-- Encrypt the contents\n> salt
  <- generateSalt 8\n> let kdf = PBKDF2 salt 2048 Nothing PBKDF2_SHA256\n> encParams
  <- generateEncryptionParams (CBC AES256)\n> let pbes = PBES2 (PBES2Parameter kdf
  encParams)\n>     Right pkcs12 = encrypted pbes \"mypassword\" contents\n\n-- Save
  to PKCS #12 with integrity protection (same password)\n> salt' <- generateSalt 8\n>
  let iParams = (DigestAlgorithm SHA256, PBEParameter salt' 2048)\n> writeP12File
  \"/path/to/privkey.p12\" iParams \"mypassword\" pkcs12\nRight ()\n```\n\nThe API
  also provides functions to generate/extract a pair containing a private\nkey and
  a certificate chain.  This pair is the type alias `Credential` in `tls`.\nCurrently
  the functions assume that the PKCS #12 file contains no other data\nthan the credential.\n\n```haskell\n>
  :set -XOverloadedStrings\n> :m Crypto.Store.PKCS12 Crypto.Store.PKCS8 Crypto.Store.PKCS5
  Crypto.Store.CMS\n\n-- Read PKCS #12 content as credential\n> Right p12 <- readP12File
  \"/path/to/file.p12\"\n> let Right pkcs12 = recover \"myintegrityassword\" p12\n>
  let Right (Just cred) = recover \"myprivacypassword\" (toCredential pkcs12)\n> cred\n(CertificateChain
  [...], PrivKeyRSA (...))\n\n-- Scheme to reencrypt the key\n> saltK <- generateSalt
  8\n> let kdfK = PBKDF2 saltK 2048 Nothing PBKDF2_SHA256\n> encParamsK <- generateEncryptionParams
  (CBC AES256)\n> let sKey = PBES2 (PBES2Parameter kdfK encParamsK)\n\n-- Scheme to
  reencrypt the certificate chain\n> saltC <- generateSalt 8\n> let kdfC = PBKDF2
  saltC 1024 Nothing PBKDF2_SHA256\n> encParamsC <- generateEncryptionParams (CBC
  AES128)\n> let sCert = PBES2 (PBES2Parameter kdfC encParamsC)\n\n-- Write the content
  back to a new file\n> let Right pkcs12' = fromCredential (Just sCert) sKey \"myprivacypassword\"
  cred\n> salt <- generateSalt 8\n> let iParams = (DigestAlgorithm SHA256, PBEParameter
  salt 2048)\n> writeP12File \"/path/to/newfile.p12\" iParams \"myintegrityassword\"
  pkcs12'\n```\n\n## Cryptographic Message Syntax\n\nThe API to read and write CMS
  content is available in `Crypto.Store.CMS`.  The\nmain data type `ContentInfo` represents
  a CMS structure.\n\nImplemented content types are:\n\n* data\n* signed data\n* enveloped
  data\n* digested data\n* encrypted data\n* authenticated data\n* and authenticated-enveloped
  data\n\nNotable omissions:\n\n* detached content\n* streaming\n* compressed data\n*
  and S/MIME external format (only PEM is supported, i.e. the textual encoding\n  of
  [RFC 7468](https://tools.ietf.org/html/rfc7468))\n\nThe following examples generate
  a CMS structure enveloping some data to a\npassword recipient, then decrypt the
  data to recover the content.\n\n### Generating enveloped data\n\n```haskell\n> :set
  -XOverloadedStrings\n> :m Crypto.Store.CMS\n\n-- Input content info\n> let info
  = DataCI \"Hi, what will you need from the cryptostore?\"\n\n-- Content encryption
  will use AES-128-CBC\n> ceParams <- generateEncryptionParams (CBC AES128)\n> ceKey
  <- generateKey ceParams :: IO ContentEncryptionKey\n\n-- Encrypt the Content Encryption
  Key with a Password Recipient Info,\n-- i.e. a KDF will derive the Key Encryption
  Key from a password\n-- that the recipient will need to know\n> salt <- generateSalt
  8\n> let kdf = PBKDF2 salt 2048 Nothing PBKDF2_SHA256\n> keParams <- generateEncryptionParams
  (CBC AES128)\n> let pri = forPasswordRecipient \"mypassword\" kdf (PWRIKEK keParams)\n\n--
  Generate the enveloped structure for this single recipient\n> Right envelopedCI
  <- envelopData mempty ceKey ceParams [pri] [] info\n> writeCMSFile \"/path/to/enveloped.pem\"
  [envelopedCI]\n```\n\n### Opening the enveloped data\n\n```haskell\n> :set -XOverloadedStrings\n>
  :m Crypto.Store.CMS\n\n-- Then this recipient just has to read the file and recover
  enveloped\n-- content using the password\n> [EnvelopedDataCI envelopedData] <- readCMSFile
  \"/path/to/enveloped.pem\"\n> openEnvelopedData (withRecipientPassword \"mypassword\")
  envelopedData\nRight (DataCI \"Hi, what will you need from the cryptostore?\")\n```\n\n##
  Algorithms and security\n\nFor compatibility reasons cryptostore implements many
  outdated algorithms that\nare still in use in data formats.  Please check your security
  requirements.  New\napplications should favor PBKDF2 or Scrypt and AEAD ciphers.\n\nAdditionally,
  the package is designed exclusively for store and forward\nscenarios, as most algorithms
  will not be perfectly safe for interactive use.\nECDSA signature generation uses
  the generic ECC implementation from cryptonite\nand could leak the private key under
  timing attack.  A padding oracle on\nCBC-encrypted ciphertext allows to recover
  the plaintext.\n\n## Design\n\nMain dependencies are:\n\n* [cryptonite](https://hackage.haskell.org/package/cryptonite)
  implementation of\n  public-key systems, symmetric ciphers, KDFs, MAC, and one-way
  hash functions\n* [asn1-types](https://hackage.haskell.org/package/asn1-types) and\n
  \ [asn1-encoding](https://hackage.haskell.org/package/asn1-encoding) to encode\n
  \ and decode ASN.1 content\n* [pem](https://hackage.haskell.org/package/pem) to
  read and write PEM files\n* [x509](https://hackage.haskell.org/package/x509) contains
  the certificate and\n  private-key data types\n\nInternally the ASN.1 parser used
  is a local implementation extending the code of\n[asn1-parse](https://hackage.haskell.org/package/asn1-parse).
  \ This extension is\nable to parse `ASN1Repr`, i.e. a stream of ASN.1 tags associated
  with the binary\ndecoding events the tags were originated from.  Similarly generation
  of ASN.1\ncontent does not use the `ASN1S` type but an extension which is able to
  encode a\nstream where some parts have already been encoded.  Retaining the original\nBER/DER
  encoding is required when incorporating MACed or signed content.\n"
license-name: BSD3
