homepage: https://github.com/chemirea/utf8-conversions#readme
changelog-type: markdown
hash: 79feb43efdbfdf288a84be338379d61df3610268fadc3676481e1cbaa5576989
test-bench-deps:
  bytestring: '>=0.10.4 && <0.11'
  text-short: '>=0.1.2 && <0.1.4'
  base: '>=4.7 && <5'
  text: '>=1.0 && <1.3'
  utf8-string: '>=1.0 && <1.2'
  utf8-conversions: -any
maintainer: Shintaro Sakata
synopsis: A conversion library that assumes utf8
changelog: |-
  # Changelog for utf8-conversions

  #### 0.1.0.0.

  init package
basic-deps:
  bytestring: '>=0.10.4 && <0.11'
  text-short: '>=0.1.2 && <0.1.4'
  base: '>=4.7 && <5'
  text: '>=1.0 && <1.3'
  utf8-string: '>=1.0 && <1.2'
all-versions:
- 0.1.0.0
author: Shintaro Sakata
latest: 0.1.0.0
description-type: markdown
description: |-
  # `utf8-conversions` safe and easy

  This package provides a　Data.Convertible.Utf8 library for easy conversion of many string types in Haskell

  ## Support

  - String
  - ByteString
  - ByteStringBuilder
  - LazyByteString
  - ByteStringShort
  - Text
  - LazyText
  - TextBuilder
  - TextShort

  Supports type conversion between the above types.
  Byte string is assumed to be in utf-8 encoding.

  ## Why?

  String conversion in haskell is more difficult than in other languages and needs to be easier.

  In particular, the OverloadedStrings pragma does not work properly when creating a ByteString.

  So why not other conversion libraries?
  There are many other conversion libraries that use the Maybe type for safety or are not explicitly stated as utf8.

  Libraries that use maybe types are very labor intensive.
  Libraries that do not explicitly state UTF8 are insecure

  Therefore, this library clearly states that it assumes UTF8 and performs the conversion without using the MAYBE type, which is both safe and easy.
  。

  ## Get involved!

  If there's a bug or a better way to convert, please report it!
license-name: BSD-3-Clause
