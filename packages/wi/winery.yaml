homepage: https://github.com/fumieval/winery#readme
changelog-type: markdown
hash: e86b3c0d20f2addb10e72ec0bf2f300ea0948e19c4acdbf27f2d664aeb39c107
test-bench-deps:
  serialise: -any
  bytestring: -any
  base: ! '>=4.7 && <5'
  unordered-containers: -any
  text: -any
  megaparsec: -any
  gauge: -any
  containers: -any
  cassava: -any
  binary: -any
  mtl: -any
  hashable: -any
  prettyprinter: -any
  transformers: -any
  deepseq: -any
  scientific: -any
  winery: -any
  cpu: -any
  vector: -any
  prettyprinter-ansi-terminal: -any
maintainer: fumiexcel@gmail.com
synopsis: Sustainable serialisation library
changelog: ! '# 0.1.2


  * Added `Data.Winery.Query`

  * The winery tool now supports a simple jq-like query language


  # 0.1.1


  * Optimised the code


  # 0.1


  Overhauled the encoding; Sorry, incompatible with 0


  # 0


  Initial release

'
basic-deps:
  bytestring: -any
  base: ! '>=4.7 && <5'
  unordered-containers: -any
  text: -any
  megaparsec: -any
  containers: -any
  mtl: -any
  hashable: -any
  prettyprinter: -any
  transformers: -any
  scientific: -any
  winery: -any
  cpu: -any
  vector: -any
  prettyprinter-ansi-terminal: -any
all-versions:
- '0'
- '0.1'
- '0.1.1'
- '0.1.2'
author: Fumiaki Kinoshita
latest: '0.1.2'
description-type: markdown
description: ! "# winery\n\nwinery is a serialisation library for Haskell. It tries
  to achieve two\ngoals: compact representation and perpetual inspectability.\n\nThe
  standard `binary` library has no way to inspect the serialised value without the
  original instance.\n\nThere's `serialise`, which is an alternative library based
  on CBOR. Every value has to be accompanied with tags, so it tends to be redundant
  for arrays of small values. Encoding records with field names is also redudant.\n\n##
  Interface\n\nThe interface is simple; `serialise` encodes a value with its schema,
  and\n`deserialise` decodes a ByteString using the schema in it.\n\n```haskell\nclass
  Serialise a\n\nserialise :: Serialise a => a -> B.ByteString\ndeserialise :: Serialise
  a => B.ByteString -> Either String a\n```\n\nIt's also possible to serialise schemata
  and data separately.\n\n```haskell\n-- Note that 'Schema' is an instance of 'Serialise'\nschema
  :: Serialise a => proxy a -> Schema\nserialiseOnly :: Serialise a => a -> B.ByteString\n```\n\n`getDecoder`
  gives you a deserialiser.\n\n```haskell\ngetDecoder :: Serialise a => Schema ->
  Either StrategyError (ByteString -> a)\n```\n\nFor user-defined datatypes, you can
  either define instances\n\n```haskell\ninstance Serialise Foo where\n  schemaVia
  = gschemaViaRecord\n  toEncoding = gtoEncodingRecord\n  deserialiser = gdeserialiserRecord
  Nothing\n```\n\nfor single-constructor records, or just\n\n```haskell\ninstance
  Serialise Foo\n```\n\nfor any ADT. The former explicitly describes field names in
  the schema, and the\nlatter does constructor names.\n\n## The schema\n\nThe definition
  of `Schema` is as follows:\n\n```haskell\ndata Schema = SSchema !Word8\n  | SUnit\n
  \ | SBool\n  | SChar\n  | SWord8\n  | SWord16\n  | SWord32\n  | SWord64\n  | SInt8\n
  \ | SInt16\n  | SInt32\n  | SInt64\n  | SInteger\n  | SFloat\n  | SDouble\n  | SBytes\n
  \ | SText\n  | SList !Schema\n  | SArray !(VarInt Int) !Schema -- fixed size\n  |
  SProduct [Schema]\n  | SProductFixed [(VarInt Int, Schema)] -- fixed size\n  | SRecord
  [(T.Text, Schema)]\n  | SVariant [(T.Text, [Schema])]\n  | SFix Schema -- ^ binds
  a fixpoint\n  | SSelf !Word8 -- ^ @SSelf n@ refers to the n-th innermost fixpoint\n
  \ deriving (Show, Read, Eq, Generic)\n```\n\nThe `Serialise` instance is derived
  by generics.\n\nThere are some special schemata:\n\n* `SSchema n` is a schema of
  schema. The winery library stores the concrete schema of `Schema` for each version,
  so it can deserialise data even if the schema changes.\n* `SFix` binds a fixpoint.\n*
  `SSelf n` refers to the n-th innermost fixpoint bound by `SFix`. This allows it
  to provide schemata for inductive datatypes.\n\n## Backward compatibility\n\nIf
  having default values for missing fields is sufficient, you can pass a\ndefault
  value to `gdeserialiserRecord`:\n\n```haskell\n  deserialiser = gdeserialiserRecord
  $ Just $ Foo \"\" 42 0\n```\n\nYou can also build a custom deserialiser using the
  Alternative instance and combinators such as `extractField`, `extractConstructor`,
  etc.\n\n## Pretty-printing\n\n`Term` can be deserialised from any winery data. It
  can be pretty-printed using the `Pretty` instance:\n\n```\n{ bar: \"hello\"\n, baz:
  3.141592653589793\n, foo: Just 42\n}\n```\n\nYou can use the `winery` command-line
  tool to inspect values.\n\n```\n$ winery '.[:10] | .first_name .last_name' benchmarks/data.winery\nShane
  Plett\nMata Snead\nLevon Sammes\nIrina Gourlay\nBrooks Titlow\nAntons Culleton\nRegine
  Emerton\nStarlin Laying\nOrv Kempshall\nElizabeth Joseff\nCathee Eberz\n```\n\n##
  Benchmark\n\n```haskell\ndata TestRec = TestRec\n  { id_ :: !Int\n  , first_name
  :: !Text\n  , last_name :: !Text\n  , email :: !Text\n  , gender :: !Gender\n  ,
  num :: !Int\n  , latitude :: !Double\n  , longitude :: !Double\n  } deriving (Show,
  Generic)\n```\n\n(De)serialisation of the datatype above using generic instances:\n\n```\nserialise/winery
  \                        mean 658.6 μs  ( +- 45.04 μs  )\nserialise/binary                         mean
  1.056 ms  ( +- 58.95 μs  )\nserialise/serialise                      mean 258.8
  μs  ( +- 5.654 μs  )\ndeserialise/winery                       mean 706.4 μs  (
  +- 52.41 μs  )\ndeserialise/binary                       mean 1.393 ms  ( +- 56.71
  μs  )\ndeserialise/serialise                    mean 765.8 μs  ( +- 30.26 μs  )\n```\n\nNot
  bad, considering that binary and serialise don't encode field names.\n"
license-name: BSD3
