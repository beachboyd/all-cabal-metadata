homepage: ''
changelog-type: ''
hash: 144b60d7fa70a6d3ae4fd1bc21fff8802c22e01f4862d13348c3be82d0a77e5c
test-bench-deps:
  bytestring: '>=0.10.0 && <0.11'
  base: '>=4.7 && <5.0'
  time: -any
  unordered-containers: -any
  hspec: '>=1.8'
  text: -any
  semigroups: -any
  containers: -any
  iso8601-time: -any
  mtl: '>=2.2.1'
  neptune-backend: -any
  transformers: '>=0.4.0.0'
  QuickCheck: -any
  aeson: -any
  vector: -any
maintainer: jiasenwu@hotmail.com
synopsis: Neptune Client
changelog: ''
basic-deps:
  http-client: '>=0.5 && <0.7'
  modern-uri: -any
  envy: -any
  exceptions: '>=0.4'
  rio: -any
  katip: '>=0.8 && <1.0'
  bytestring: '>=0.10.0 && <0.11'
  lens-aeson: -any
  case-insensitive: -any
  unix: -any
  base: '>=4.7 && <5.0'
  time: '>=1.5'
  base64-bytestring: '>1.0 && <2.0'
  unordered-containers: -any
  text: '>=0.11 && <1.3'
  uuid: -any
  retry: -any
  safe-exceptions: <0.2
  http-api-data: '>=0.3.4 && <0.5'
  network: '>=2.6.2 && <3.9'
  websockets: -any
  req: -any
  jwt: -any
  containers: '>=0.5.0.0 && <0.8'
  lens: -any
  concurrent-extra: -any
  iso8601-time: '>=0.1.3 && <0.2.0'
  http-client-tls: -any
  wuss: -any
  mtl: '>=2.2.1'
  neptune-backend: -any
  transformers: '>=0.4.0.0'
  random: '>=1.1'
  deepseq: '>=1.4 && <1.6'
  http-types: '>=0.8 && <0.13'
  microlens: '>=0.4.3 && <0.5'
  aeson: '>=1.0 && <2.0'
  http-media: '>=0.4 && <0.9'
  vector: '>=0.10.9 && <0.13'
all-versions:
- 0.1.1
- 0.1.2
- 0.2.1
author: Jiasen Wu
latest: 0.2.1
description-type: markdown
description: "## Neptune high-level API\n\n```haskell\nmain = do\n    -- Experiment
  'sandbox' must be created from the Neptune dashboard\n    withNept \"jiasen/sandbox\"
  $ \\_ experiment -> do\n        forM_ [1..10::Int] $ \\i -> do\n            -- You
  can log arbitrary name/value (current limited to double values)\n            nlog
  experiment \"counter\" (fromIntegral (i * i) :: Double)\n            threadDelay
  1000000\n```\n\n## TODOs\n* Support logging text, image value.\n* Create project\n*
  Support system channels\n* Get git information\n\n## OpenAPI Auto-Generated http-client
  Bindings to Neptune Backend API\n\nThis library is intended to be imported qualified.\n\n###
  Modules\n\n| MODULE              | NOTES                                               |\n|
  ------------------- | --------------------------------------------------- |\n| NeptuneBackend.Client
  \   | use the \"dispatch\" functions to send requests       |\n| NeptuneBackend.Core
  \     | core funcions, config and request types             |\n| NeptuneBackend.API
  \      | construct api requests                              |\n| NeptuneBackend.Model
  \    | describes api models                                |\n| NeptuneBackend.MimeTypes
  | encoding/decoding MIME types (content-types/accept) |\n| NeptuneBackend.ModelLens
  | lenses for model fields                             |\n| NeptuneBackend.Logging
  \  | logging functions and utils                         |\n\n\n### MimeTypes\n\nThis
  library adds type safety around what OpenAPI specifies as\nProduces and Consumes
  for each Operation (e.g. the list of MIME types an\nOperation can Produce (using
  'accept' headers) and Consume (using 'content-type' headers).\n\nFor example, if
  there is an Operation named _addFoo_, there will be a\ndata type generated named
  _AddFoo_ (note the capitalization), which\ndescribes additional constraints and
  actions on the _addFoo_ operation\nvia its typeclass instances. These typeclass
  instances can be viewed\nin GHCi or via the Haddocks.\n\n* required parameters are
  included as function arguments to _addFoo_\n* optional non-body parameters are included
  by using  `applyOptionalParam`\n* optional body parameters are set by using  `setBodyParam`\n\nExample
  code generated for pretend _addFoo_ operation: \n\n```haskell\ndata AddFoo \t\ninstance
  Consumes AddFoo MimeJSON\ninstance Produces AddFoo MimeJSON\ninstance Produces AddFoo
  MimeXML\ninstance HasBodyParam AddFoo FooModel\ninstance HasOptionalParam AddFoo
  FooName\ninstance HasOptionalParam AddFoo FooId\n```\n\nthis would indicate that:\n\n*
  the _addFoo_ operation can consume JSON\n* the _addFoo_ operation produces JSON
  or XML, depending on the argument passed to the dispatch function\n* the _addFoo_
  operation can set it's body param of _FooModel_ via `setBodyParam`\n* the _addFoo_
  operation can set 2 different optional parameters via `applyOptionalParam`\n\nIf
  the OpenAPI spec doesn't declare it can accept or produce a certain\nMIME type for
  a given Operation, you should either add a Produces or\nConsumes instance for the
  desired MIME types (assuming the server\nsupports it), use `dispatchLbsUnsafe` or
  modify the OpenAPI spec and\nrun the generator again.\n\nNew MIME type instances
  can be added via MimeType/MimeRender/MimeUnrender\n\nOnly JSON instances are generated
  by default, and in some case\nx-www-form-urlencoded instances (FromFrom, ToForm)
  will also be\ngenerated if the model fields are primitive types, and there are\nOperations
  using x-www-form-urlencoded which use those models.\n\n### Authentication\n\nA haskell
  data type will be generated for each OpenAPI authentication type.\n\nIf for example
  the AuthMethod `AuthOAuthFoo` is generated for OAuth operations, then\n`addAuthMethod`
  should be used to add the AuthMethod config.\n\nWhen a request is dispatched, if
  a matching auth method is found in\nthe config, it will be applied to the request.\n\n###
  Example\n\n```haskell\nmgr <- newManager defaultManagerSettings\nconfig0 <- withStdoutLogging
  =<< newConfig \nlet config = config0\n    `addAuthMethod` AuthOAuthFoo \"secret-key\"\n\nlet
  addFooRequest = \n  addFoo \n    (ContentType MimeJSON) \n    (Accept MimeXML) \n
  \   (ParamBar paramBar)\n    (ParamQux paramQux)\n    modelBaz\n  `applyOptionalParam`
  FooId 1\n  `applyOptionalParam` FooName \"name\"\n  `setHeader` [(\"qux_header\",\"xxyy\")]\naddFooResult
  <- dispatchMime mgr config addFooRequest\n```\n\nSee the example app and the haddocks
  for details.\n"
license-name: BSD-3-Clause
