homepage: https://github.com/robrix/fused-effects
changelog-type: markdown
hash: eb834636d6ca53f2ea06cdcbcf7b5b524165111dff087ae3f4756ff6097ff160
test-bench-deps:
  base: ! '>=4.9 && <4.12'
  hspec: ! '>=2.4.1'
  doctest: ! '>=0.7 && <1.0'
  fused-effects: -any
maintainer: robrix@github.com
synopsis: A fast, flexible, fused effect system.
changelog: ! '# 0.1.0.0


  Initial release.

'
basic-deps:
  MonadRandom: ! '>=0.5 && <0.6'
  base: ! '>=4.9 && <4.12'
  random: -any
  deepseq: ! '>=1.4.3 && <1.5'
all-versions:
- '0.1.0.0'
author: Rob Rix, Patrick Thomson
latest: '0.1.0.0'
description-type: markdown
description: ! "# A fast, flexible, fused effect system for Haskell\n\n[![Build Status](https://travis-ci.com/robrix/fused-effects.svg?branch=master)](https://travis-ci.com/robrix/fused-effects)\n\n-
  [Overview](#overview)\n  - [Algebraic effects](#algebraic-effects)\n  - [Higher-order
  effects](#fused-effects)\n  - [Fusion](#fusion)\n- [Usage](#usage)\n  - [Using built-in
  effects](#using-built-in-effects)\n  - [Running effects](#running-effects)\n  -
  [Defining new effects](#defining-new-effects)\n  - [Defining effect handlers](#defining-effect-handlers)\n-
  [Benchmarks](#benchmarks)\n- [Related work](#related-work)\n  - [Comparison to `mtl`](#comparison-to--mtl-)\n
  \ - [Comparison to `freer-simple`](#comparison-to--freer-simple-)\n\n\n## Overview\n\n`fused-effects`
  is an effect system for Haskell emphasizing expressivity and efficiency. The former
  is achieved by encoding [algebraic](#algebraic-effects), [higher-order](#fused-effects)
  effects, while the latter is the result of [fusing](#fusion) effect handlers all
  the way through computations.\n\nReaders already familiar with effect systems may
  wish to start with the [usage](#usage) instead.\n\n\n### Algebraic effects\n\nIn
  `fused-effects` and other systems with _algebraic_ (or, sometimes, _extensible_)
  effects, effectful programs are split into two parts: the specification (or _syntax_)
  of the actions to be performed, and the interpretation (or _semantics_) given to
  them. Thus, a program written using the syntax of an effect can be given different
  meanings by using different effect handlers.\n\nThese roles are performed by the
  effect and carrier types, respectively. Effects are datatypes with one constructor
  for each action. Carriers are generally `newtype`s, with a `Carrier` instance specifying
  how an effect’s constructors should be interpreted. Each carrier handles one effect,
  but multiple carriers can be defined for the same effect, corresponding to different
  interpreters for the effect’s syntax.\n\n\n### Higher-order effects\n\nUnlike most
  other effect systems, `fused-effects` offers _higher-order_ (or _scoped_) effects
  in addition to first-order algebraic effects. In a strictly first-order algebraic
  effect system, operations (like `local` or `catchError`) which specify some action
  limited to a given scope must be implemented as interpreters, hard-coding their
  meaning in precisely the manner algebraic effects were designed to avoid. By specifying
  effects as higher-order functors, these operations are likewise able to be given
  a variety of interpretations. This means, for example, that you can introspect and
  redefine both the `local` and `ask` operations provided by the `Reader` effect,
  rather than solely `ask` (as is the case with certain formulations of algebraic
  effects).\n\nAs Nicolas Wu et al showed in _[Effect Handlers in Scope][]_, this
  has implications for the expressiveness of effect systems. It also has the benefit
  of making effect handling more consistent, since scoped operations are just syntax
  which can be interpreted like any other, and are thus simpler to reason about.\n\n\n###
  Fusion\n\nIn order to maximize efficiency, `fused-effects` applies _fusion laws_,
  avoiding the construction of intermediate representations of effectful computations
  between effect handlers. In fact, this is applied as far as the initial construction
  as well: there is no representation of the computation as a free monad parameterized
  by some syntax type. As such, `fused-effects` avoids the overhead associated with
  constructing and evaluating any underlying free or freer monad.\n\nInstead, computations
  are performed in a monad named `Eff`, parameterized by the carrier type for the
  syntax. This carrier is specific to the effect handler selected, but since it isn’t
  described until the handler is applied, the separation between specification and
  interpretation is maintained. Computations are written against an abstract effectful
  signature, and only specialized to some concrete carrier when their effects are
  interpreted.\n\nCarriers needn’t be `Functor`s (let alone `Monad`s), allowing a
  great deal of freedom in the interpretation of effects. And since the interpretation
  is written as a typeclass instance which `ghc` is eager to inline, performance is
  excellent: approximately on par with `mtl`.\n\nFinally, since the fusion of carrier
  algebras occurs as a result of the selection of the carriers, it doesn’t depend
  on complex `RULES` pragmas, making it very easy to reason about and tune.\n\n\n##
  Usage\n\n### Using built-in effects\n\nLike other effect systems, effects are performed
  in a `Monad` extended with operations relating to the effect. In `fused-effects`,
  this is done by means of a `Member` constraint to require the effect’s presence
  in a _signature_, and a `Carrier` constraint to relate the signature to the `Monad`.
  For example, to use a `State` effect managing a `String`, one would write:\n\n```haskell\naction
  :: (Member (State String) sig, Carrier sig m) => m ()\n```\n\n(Additional constraints
  may be necessary depending on the precise operations required, e.g. to make the
  `Monad` methods available.)\n\nMultiple effects can be required simply by adding
  their corresponding `Member` constraints to the context. For example, to add a `Reader`
  effect managing an `Int`, we would write:\n\n```haskell\naction :: (Member (State
  String) sig, Member (Reader Int) sig, Carrier sig m) => m ()\n```\n\nDifferent effects
  make different operations available; see the documentation for individual effects
  for more information about their operations. Note that we generally don't program
  against an explicit list of effect components: we take the typeclass-oriented approach,
  adding new constraints to `sig` as new capabilities become necessary. If you want
  to name and share some predefined list of effects, it's best to use the `-XConstraintKinds`
  extension to GHC, capturing the elements of `sig` as a type synonym of kind `Constraint`:\n\n```haskell\ntype
  Shared sig = ( Member (State String) sig\n                  , Member (Reader Int)
  \  sig\n                  , Member (Writer Graph) sig\n                  )\n\nmyFunction
  :: (Shared sig, Carrier sig m) => Int -> m ()\n```\n\n### Running effects\n\nEffects
  are run with _effect handlers_, specified as functions (generally starting with
  `run…`) invoking some specific `Carrier` instance. For example, we can run a `State`
  computation using `runState`:\n\n```haskell\nexample1 :: (Carrier sig m, Effect
  sig) => [a] -> m (Int, ())\nexample1 list = runState 0 $ do\n  i <- get\n  put (i
  + length list)\n```\n\n`runState` returns a tuple of both the computed value (the
  `()`) and the final state (the `Int`), visible in the result of the returned computation.\n\nSince
  this function returns a value in some carrier `m`, effect handlers can be chained
  to run multiple effects. Here, we get the list to compute the length of from a `Reader`
  effect:\n\n```haskell\nexample2 :: (Carrier sig m, Effect sig, Monad m) => m (Int,
  ())\nexample2 = runReader \"hello\" . runState 0 $ do\n  list <- ask\n  put (length
  (list :: String))\n```\n\n(Note that the type annotation on `list` is necessary
  to disambiguate the requested value, since otherwise all the typechecker knows is
  that it’s an arbitrary `Foldable`. For more information, see the [comparison to
  `mtl`](#comparison-to--mtl-).)\n\nWhen all effects have been handled, a computation’s
  final value can be extracted with `run`:\n\n```haskell\nexample3 :: (Int, ())\nexample3
  = run . runReader \"hello\" . runState 0 $ do\n  list <- ask\n  put (length (list
  :: String))\n```\n\n`run` is itself actually an effect handler for the `Void` effect,
  which has no operations and thus can only represent a final result value.\n\nAlternatively,
  arbitrary `Monad`s can be embedded into effectful computations using the `Lift`
  effect. In this case, the underlying `Monad`ic computation can be extracted using
  `runM`. Here, we use the `MonadIO` instance for `Eff` to lift `putStrLn` into the
  middle of our computation:\n\n```haskell\nexample4 :: IO (Int, ())\nexample4 = runM
  . runReader \"hello\" . runState 0 $ do\n  list <- ask\n  liftIO (putStrLn list)\n
  \ put (length list)\n```\n\n(Note that we no longer need to give a type annotation
  for `list`, since `putStrLn` constrains the type for us.)\n\n\n### Defining new
  effects\n\nEffects are a powerful mechanism for abstraction, and so defining new
  effects is a valuable tool for system architecture. Effects are modelled as (higher-order)
  functors, with an explicit continuation denoting the remainder of the computation
  after the effect.\n\nIt’s often helpful to start by specifying the types of the
  desired operations. For our example, we’re going to define a `Teletype` effect,
  with `read` and `write` operations, which read a string from some input and write
  a string to some output, respectively:\n\n```haskell\ndata Teletype (m :: * -> *)
  k\nread :: (Member Teletype sig, Carrier sig m) => m String\nwrite :: (Member Teletype
  sig, Carrier sig m) => String -> m ()\n```\n\nEffect types must have two type parameters:
  `m`, denoting any computations which the effect embeds, and `k`, denoting the remainder
  of the computation after the effect. Note that since `Teletype` doesn’t use `m`,
  the compiler will infer it as being of kind `*` by default. The explicit kind annotation
  on `m` corrects that.\n\nNext, we can flesh out the definition of the `Teletype`
  effect by providing constructors for each primitive operation:\n\n```haskell\ndata
  Teletype (m :: * -> *) k\n  = Read (String -> k)\n  | Write String k\n  deriving
  (Functor)\n```\n\nThe `Read` operation returns a `String`, and hence its continuation
  is represented as a function _taking_ a `String`. Thus, to continue the computation,
  a handler will have to provide a `String`. But since the effect type doesn’t say
  anything about where that `String` should come from, handlers are free to read from
  `stdin`, use a constant value, etc.\n\nOn the other hand, the `Write` operation
  returns `()`. Since a function `() -> k` is equivalent to a (non-strict) `k`, we
  can omit the function parameter.\n\nIn addition to a `Functor` instance (derived
  here using `-XDeriveFunctor`), we need two other instances: `HFunctor` and `Effect`.
  `HFunctor`, named for “higher-order functor,” has one non-default operation, `hmap`,
  which applies a function to any embedded computations inside an effect. Since `Teletype`
  is first-order (i.e. it doesn’t have any embedded computations), the definition
  of `hmap` can be given using `coerce`:\n\n```haskell\ninstance HFunctor Teletype
  where\n  hmap _ = coerce\n```\n\n`Effect` plays a similar role to the combination
  of `Functor` (which operates on continuations) and `HFunctor` (which operates on
  embedded computations). It’s used by `Carrier` instances to service any requests
  for their effect occurring inside other computations—whether embedded or in the
  continuations. Since these may require some state to be maintained, `handle` takes
  an initial state parameter (encoded as some arbitrary functor filled with `()`),
  and its function is phrased as a _distributive law_, mapping state functors containing
  unhandled computations to handled computations producing the state functor alongside
  any results.\n\nSince `Teletype`’s operations don’t have any embedded computations,
  the `Effect` instance only has to operate on the continuations, by wrapping the
  computations in the state and applying the handler:\n\n```haskell\ninstance Effect
  Teletype where\n  handle state handler (Read    k) = Read (handler . (<$ state)
  . k)\n  handle state handler (Write s k) = Write s (handler (k <$ state))\n```\n\nNow
  that we have our effect datatype, we can give definitions for `read` and `write`:\n\n```haskell\nread
  :: (Member Teletype sig, Carrier sig m) => m String\nread = send (Read ret)\n\nwrite
  :: (Member Teletype sig, Carrier sig m) => String -> m ()\nwrite s = send (Write
  s (ret ()))\n```\n\nThis gives us enough to write computations using the `Teletype`
  effect. The next section discusses how to run `Teletype` computations.\n\n\n###
  Defining effect handlers\n\nEffects only specify actions, they don’t actually perform
  them. That task is left up to effect handlers, typically defined as functions calling
  `interpret` to apply a given `Carrier` instance.\n\nFollowing from the above section,
  we can define a carrier for the `Teletype` effect which runs the calls in an underlying
  `MonadIO` instance:\n\n```haskell\nnewtype TeletypeIOC m a = TeletypeIOC { runTeletypeIOC
  :: m a }\n\ninstance (Carrier sig m, MonadIO m) => Carrier (Teletype :+: sig) (TeletypeIOC
  m) where\n  ret = TeletypeIOC . ret\n\n  eff = TeletypeIOC . handleSum (eff . handleCoercible)
  (\\ t -> case t of\n    Read    k -> liftIO getLine      >>= runTeletypeIOC . k\n
  \   Write s k -> liftIO (putStrLn s) >>  runTeletypeIOC   k)\n```\n\nHere, `ret`
  is responsible for wrapping pure values in the carrier, and `eff` is responsible
  for handling an effectful computations. Since the `Carrier` instance handles a sum
  (`:+:`) of `Teletype` and the remaining signature, `eff` has two parts: a handler
  for `Teletype` (`alg`), and a handler for teletype effects that might be embedded
  in other effects in the signature.\n\nIn this case, since the `Teletype` carrier
  is just a thin wrapper around the underlying computation, we can use `handleCoercible`
  to handle any embedded `TeletypeIOC` carriers by simply mapping `coerce` over them.\n\nThat
  leaves `alg`, which handles `Teletype` effects with one case per constructor. Since
  we’re assuming the existence of a `MonadIO` instance for the underlying computation,
  we can use `liftIO` to inject the `getLine` and `putStrLn` actions into it, and
  then proceed with the continuations, unwrapping them in the process.\n\nUsers could
  use `interpret` directly to run the effect, but it’s more convenient to provide
  effect handler functions applying `interpret` and then unwrapping the carrier:\n\n```haskell\nrunTeletypeIO
  :: (MonadIO m, Carrier sig m) => Eff (TeletypeIOC m) a -> m a\nrunTeletypeIO = runTeletypeIOC
  . interpret\n```\n\nIn general, carriers don’t have to be `Functor`s, let alone
  `Monad`s. However, sometimes—especially in cases where the carrier is a thin wrapper
  like this—they can be more convenient to write using (derived) `Monad` instances.
  In this case, by using `-XGeneralizedNewtypeDeriving`, we can derive `Functor`,
  `Applicative`, `Monad`, and `MonadIO` instances for `TeletypeIOC`:\n\n```haskell\nnewtype
  TeletypeIOC m a = TeletypeIOC { runTeletypeIOC :: m a }\n  deriving (Applicative,
  Functor, Monad, MonadIO)\n```\n\nThis allows us to use `liftIO` directly on the
  carrier itself, instead of only in the underlying `m`; likewise with `>>=`, `>>`,
  and `pure`:\n\n```haskell\ninstance (MonadIO m, Carrier sig m) => Carrier (Teletype
  :+: sig) (TeletypeIOC m) where\n  ret = pure\n  eff = handleSum (TeletypeIOC . eff
  . handleCoercible) (\\ t -> case t of\n    Read    k -> liftIO getLine      >>=
  k\n    Write s k -> liftIO (putStrLn s) >>  k)\n```\n\n\n## Benchmarks\n\n`fused-effects`
  has been [benchmarked against a number of other effect systems](https://github.com/joshvera/freemonad-benchmark).
  See also [@patrickt’s benchmarks](https://github.com/patrickt/effects-benchmarks).\n\n\n##
  Related work\n\n`fused-effects` is an encoding of higher-order algebraic effects
  following the recipes in _[Effect Handlers in Scope][]_ (Nicolas Wu, Tom Schrijvers,
  Ralf Hinze), _[Monad Transformers and Modular Algebraic Effects: What Binds Them
  Together][]_ (Tom Schrijvers, Maciej Piróg, Nicolas Wu, Mauro Jaskelioff), and _[Fusion
  for Free—Efficient Algebraic Effect Handlers][]_ (Nicolas Wu, Tom Schrijvers).\n\n[Effect
  Handlers in Scope]: http://www.cs.ox.ac.uk/people/nicolas.wu/papers/Scope.pdf\n[Monad
  Transformers and Modular Algebraic Effects: What Binds Them Together]: http://www.cs.kuleuven.be/publicaties/rapporten/cw/CW699.pdf\n[Fusion
  for Free—Efficient Algebraic Effect Handlers]: https://people.cs.kuleuven.be/~tom.schrijvers/Research/papers/mpc2015.pdf\n\n\n###
  Comparison to `mtl`\n\nLike [`mtl`][], `fused-effects` provides a library of monadic
  effects which can be given different interpretations. In `mtl` this is done by defining
  new instances of the typeclasses encoding the actions of the effect, e.g. `MonadState`.
  In `fused-effects`, this is done by defining new instances of the `Carrier` typeclass
  for the effect.\n\nAlso like `mtl`, `fused-effects` allows scoped operations like
  `local` and `catchError` to be given different interpretations. As with first-order
  operations, `mtl` achieves this with a final tagless encoding via methods, whereas
  `fused-effects` achieves this with an initial algebra encoding via `Carrier` instances.\n\nUnlike
  `mtl`, effects are automatically available regardless of where they occur in the
  signature; in `mtl` this requires instances for all valid orderings of the transformers
  (O(n²) of them, in general).\n\nAlso unlike `mtl`, there can be more than one `State`
  or `Reader` effect in a signature. This is a tradeoff: `mtl` is able to provide
  excellent type inference for effectful operations like `get`, since the functional
  dependencies can resolve the state type from the monad type. On the other hand,
  this behaviour can be recovered in `fused-effects` using `newtype` wrappers with
  phantom type parameters and helper functions, e.g.:\n\n```haskell\nnewtype Wrapper
  s m a = Wrapper { runWrapper :: Eff m a }\n  deriving (Applicative, Functor, Monad)\n\ninstance
  Carrier sig m => Carrier sig (Wrapper s m) where …\n\ngetState :: (Carrier sig m,
  Member (State s) m) => Wrapper m s\ngetState = get\n```\n\nIndeed, `Wrapper` can
  now be made an instance of `MonadState`:\n\n```haskell\ninstance (Carrier sig m,
  Member (State s) m) => MTL.MonadState s (Wrapper s m) where\n  get = get\n  put
  = put\n```\n\nThus, the approaches aren’t mutually exclusive; consumers are free
  to decide which approach makes the most sense for their situation.\n\nUnlike `fused-effects`,
  `mtl` provides a `ContT` monad transformer; however, it’s worth noting that many
  behaviours possible with delimited continuations (e.g. resumable exceptions) are
  directly encodable as effects. Further, `fused-effects` provides a relatively large
  palette of these, including resumable exceptions, tracing, resource management,
  and others, as well as tools to define your own.\n\nFinally, thanks to the fusion
  and inlining of carriers, `fused-effects` is approximately as fast as `mtl` (see
  [benchmarks](#benchmarks)).\n\n[`mtl`]: http://hackage.haskell.org/package/mtl\n\n\n###
  Comparison to `freer-simple`\n\nLike [`freer-simple`][], `fused-effects` uses an
  initial encoding of library- and user-defined effects as syntax which can then be
  given different interpretations. In `freer-simple`, this is done with a family of
  interpreter functions (which cover a variety of needs, and which can be extended
  for more bespoke needs), whereas in `fused-effects` this is done with `Carrier`
  instances for `newtype`s.\n\n(Technically, it is possible to define handlers like
  `freer-simple`’s `interpret` using `fused-effects`, but passing handlers in as higher-order
  functions defeats the fusion and inlining of `Carrier` instances which makes `fused-effects`
  so efficient.)\n\nUnlike `fused-effects`, in `freer-simple`, scoped operations like
  `catchError` and `local` are implemented as interpreters, and can therefore not
  be given new interpretations.\n\nUnlike `freer-simple`, `fused-effects` has relatively
  little attention paid to compiler error messaging, which can make common (compile-time)
  errors somewhat more confusing to diagnose. Similarly, `freer-simple`’s family of
  interpreter functions can make the job of defining new effect handlers somewhat
  easier than in `fused-effects`. Further, `freer-simple` provides many of the same
  effects as `fused-effects`, plus a coroutine effect, but minus resource management
  and random generation.\n\nFinally, `fused-effects` has been [benchmarked](#benchmarks)
  as faster than `freer-simple`.\n\n[`freer-simple`]: http://hackage.haskell.org/package/freer-simple\n"
license-name: BSD3
