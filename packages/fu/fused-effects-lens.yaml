homepage: https://github.com/patrickt/fused-effects-lens#readme
changelog-type: markdown
hash: 881c08793ce23bca3096991a1dc39ba8f06dca46fb6a88b24f6d1f422923451e
test-bench-deps:
  base: ! '>=4.7 && <5.0'
  hspec: ! '>=2.4.1'
  fused-effects-lens: -any
  lens: ! '>=4 && <5'
  fused-effects: ! '>=0.1.2 && <1'
maintainer: patrickt@github.com
synopsis: Monadic lens combinators for fused-effects.
changelog: |
  # v0.1.0.0

  Initial release.
basic-deps:
  base: ! '>=4.7 && <5'
  lens: ! '>=4 && <5'
  fused-effects: ! '>=0.1.2 && <1'
all-versions:
- 0.1.0.0
author: Patrick Thomson
latest: 0.1.0.0
description-type: markdown
description: "# fused-effects-lens\n\nThis package provides an interface to the [lens](github.com/ekmett/lens)
  library that is compatible with [fused-effects](github.com/robrix/fused-effects).
  The standard formulation of `lens` combinators for operating in `MonadState` contextsâ€”`use`,
  `.=`, et alâ€”rely on `mtl` for `MonadState` and `MonadReader`, which is not applicable
  to `Reader` and `State` effects.\n\nThis package is meant to be used alongside `lens`,
  like so:\n\n``` haskell\nimport Control.Lens hiding (view, use, assign)\nimport
  Control.Effect.Lens (view, use, assign)\n```\n\n## Example\n\nGiven a `Context`
  type that we will use in a `State` effect:\n\n``` haskell\ndata Context = Context\n
  \ { _amount :: Int\n  , _disabled :: Bool\n  } deriving (Eq, Show)\n  \nmakeLenses
  ''Context\n```\n\nWe can can use the `use` combinators to extract a lens target
  from the current state, and `assign` to write to a field of that state:\n\n``` haskell\nstateTest
  :: (Member (State Context) sig, Carrier sig m, Monad m) => m Int\nstateTest = do\n
  \ initial <- use amount\n  assign amount (initial + 1)\n  assign disabled True\n
  \ use amount\n```\n\nYou can find a more complete example, including one that works
  with multiple `State` constraints in a single computation, in the `test` directory.\n\n##
  License\n\nBSD3, like `fused-effects`.\n"
license-name: BSD-3-Clause
