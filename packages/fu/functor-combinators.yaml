homepage: https://github.com/mstksg/functor-combinators#readme
changelog-type: markdown
hash: 4e8856ede04fa7c3150fd686dc53c61485bf7491fe346fe5ff03443cec1b8ad4
test-bench-deps:
  semigroupoids: -any
  free: -any
  dependent-sum: -any
  base: '>=4.12 && <5'
  tasty-hedgehog: -any
  functor-combinators: -any
  nonempty-containers: -any
  hedgehog: '>=0.6'
  bifunctors: -any
  trivial-constraint: '>=0.5'
  transformers: -any
  tasty: -any
maintainer: justin@jle.im
synopsis: Tools for functor combinator-based program design
changelog: |
  Changelog
  =========

  Version 0.3.0.0
  ---------------

  *August 5, 2020*

  <https://github.com/mstksg/functor-combinators/releases/tag/v0.3.0.0>

  *   *Data.HBifunctor.Associative*, *Data.HBifunctor.Tensor*: Support for
      `Contravariant` and `Invariant` functor combinators. Main change to the
      infrastructure: add a `FunctorBy` associated constraint to `Associative` to
      signal what "sort of functor" the tensor supports: it should either be
      `Unconstrained`, `Functor`, `Contravariant`, or `Invariant`.
  *   *Data.Functor.Contravariant.Divise*, *Data.Functor.Contravariant.Decide*,
      and *Data.Functor.Contravariant.Conclude*: Temporarily add in the
      semigroupoidal contravariant typeclasses. These should only be needed until
      they get merged into *semigroupoids*.
  *   *Data.Functor.Contravariant.Divisible*: Add free structures for
      contravariant typeclass hierarchy.
  *   Added in some new day convolutions:

      *   *Data.Functor.Contravariant.Night*: `Night`, a contravariant day
          convolution using `Either`, which is the tensor that generates
          `Conclude` (and `Decidable` kinda).
      *   *Data.Functor.Invariant.Day*: `Day`, an *invariant* day convolution
          using tuples.
      *   *Data.Functor.Invariant.Night*: `Night`, an *invariant* day convolution
          using either.

      For the invariant day convolutions, we *could* write free monoids on them
      (like `Ap`/`Div`/`Dec`).  But instead we just outsource our free structures
      to `Chain`, providing useful pattern synonyms and folding functions to
      pretend like we had an actual free structure.
  *   *Data.Functor.Combinator*: Useful functions in for working with divisible
      and decidable contravariant functors: `divideN`, `diviseN`, `concludeN`,
      `decideN`, `divideNRec`, and `diviseNRec`.
  *   `Contravariant` and `Invariant` instances for many types.
  *   *Data.HFunctor.Final*: `FreeOf` adjusted to allow for contravariant free
      types.
  *   *Data.Functor.Combinator.Unsafe*: Add `unsafeDivise` and `unsafeConclude`,
      to mirror the situation with `unsafeApply` and `unsafePlus`.

  Version 0.2.0.0
  ---------------

  *November 11, 2019*

  <https://github.com/mstksg/functor-combinators/releases/tag/v0.2.0.0>

  *   Major restructuring of the hbifunctor-based classes. `Data.HBifunctor.Associative`
      and `Data.HBifunctor.Tensor` are more or less completely rewritten; the
      typeclasses are restructured in order to more properly reflect the math
      that motivates them.  See the updated type classes to see what methods
      ended up where.

      However, much of the external API that is independent of the underlying
      abstraction is effectively unchanged (`biget`, etc.)

      For the most part, the migration would involve:

      *   `SF`, `MF` are now `NonEmptyBy` and `ListBy`, respectively.
      *   `-SF` and `-MF` as suffixes for function names now become `-NE` and
          `-LB`.

  *   `upgradeC` no longer exists; use unsafe functions from
      *Data.Functor.Combinator.Unsafe* instead, on a per-tensor basis.

  *   Restructuring of `Interpret`: It now takes an extra type parameter, the
      type to interpret into.  This makes it more consistent with the new `MonoidIn`
      and `SemigroupIn`.  Most of the external API should be effectively
      unchanged.

      For the most part, the migration would only affect people who *write*
      instances of `Interpret`.  Instead of

      ```haskell
      instance Interpret MyType where
          type C MyType = Monad
      ```

      you would write:

      ```haskell
      instance Monad f => Interpret MyType f where
      ```


  Version 0.1.1.1
  ---------------

  *July 13, 2019*

  <https://github.com/mstksg/functor-combinators/releases/tag/v0.1.1.1>

  *   Moved to *trivial-constraints-0.6.0.0*

  Version 0.1.1.0
  ---------------

  *June 19, 2019*

  <https://github.com/mstksg/functor-combinators/releases/tag/v0.1.1.0>

  *   `appendChain` and `appendChain1`

  Version 0.1.0.1
  ---------------

  *June 19, 2019*

  <https://github.com/mstksg/functor-combinators/releases/tag/v0.1.0.1>

  *   Small tweaks for haddock generation and dependency bounds.

  Version 0.1.0.0
  ---------------

  *June 19, 2019*

  <https://github.com/mstksg/functor-combinators/releases/tag/v0.1.0.0>

  *   Initial release
basic-deps:
  semigroupoids: -any
  free: -any
  these: -any
  sop-core: -any
  base: '>=4.12 && <5'
  comonad: -any
  deriving-compat: -any
  pointed: -any
  assoc: -any
  invariant: -any
  nonempty-containers: -any
  kan-extensions: -any
  constraints: -any
  tagged: -any
  containers: -any
  vinyl: -any
  bifunctors: -any
  contravariant: -any
  mtl: -any
  natural-transformation: -any
  trivial-constraint: '>=0.5'
  mmorph: -any
  transformers: -any
  profunctors: -any
all-versions:
- 0.1.0.0
- 0.1.0.1
- 0.1.1.0
- 0.1.1.1
- 0.2.0.0
- 0.3.0.0
author: Justin Le
latest: 0.3.0.0
description-type: markdown
description: |
  functor-combinators
  ===================

  *[Introductory Blog Post][combinatorpedia]* / *[Hackage][hackage]*

  [combinatorpedia]: https://blog.jle.im/entry/functor-combinatorpedia.html
  [hackage]: https://hackage.haskell.org/package/functor-combinators

  Tools for working with *functor combinators*: types that take functors (or
  other indexed types) and returns a new functor that "enhances" or "mixes" them
  in some way.

  The main functionality is exported in *Data.Functor.Combinators*, but more
  fine-grained functionality and extra combinators (some of them
  re-implementations for compatibility) are available in other modules as well.

  The goal is to represent schemas, DSL's, and computations (things like parsers,
  things to execute, things to consume or produce data) by assembling
  "self-evident" basic primitives and subjecting them to many *different*
  successive transformations and combiners.  The process of doing so:

  1.  Forces you to make explicit decisions about the structure of your
      computation type as an ADT.
  2.  Allows you to retain isolation of fundamental parts of your domain as
      separate types
  3.  Lets you manipulate the structure of your final computation type through
      *normal Haskell techniques* like pattern matching.  The structure is
      available throughout the entire process, so you can replace individual
      components and values within your structure.
  4.  Allows you to fully *reflect* the structure of your final computation
      through pattern matching and folds, so you can inspect the structure and
      produce useful summaries.

  The main benefit of this library in specific is to allow you to be able to work
  with different functor combinators with a uniform and lawful interface, so the
  real functionality here is the wide variety of functor combinators from all
  around the Haskell ecosystem.  This library does not provide the functor
  combinators, as much as it re-exports them with a unified interface.  However,
  it does "fill in the matrix", in a sense, of functor combinators in specific
  roles that are missing from the haskell ecosystem.

  To jump into using it, import *Data.Functor.Combinator*.  For a full
  introduction, check out the *[Functor Combinatorpedia][combinatorpedia]*, which
  goes in-depth into the motivation behind functor combinator-driven development,
  examples of the functor combinators in this library, and details about how to
  use these abstractions!

  Comparisons
  -----------

  On the surface, *functor-combinators* look like it fills a similar space to
  effects systems and libraries like *[mtl][]*, *[polysemy][]*,
  *[freer-simple][]*, or *[fused-effects][]*.  However, the functor combinator
  design pattern actually exists on a different level.

  [mtl]: https://hackage.haskell.org/package/mtl
  [polysemy]: https://hackage.haskell.org/package/polysemy
  [freer-simple]: https://hackage.haskell.org/package/freer-simple
  [fused-effects]: https://hackage.haskell.org/package/fused-effects

  Functor combinator design patterns can be used to help build the *structure* of
  the *data types* and schemas that define your program/DSL.  Once you build
  these nice structures, you then *interpret* them into some target context. This
  "target context" is the realm that libraries like *mtl* and *polysemy* can
  fill; functor combinators serve to help you define a structure for your program
  *before* you interpret it into whatever Applicative or Monad or effects system
  you end up using.
license-name: BSD-3-Clause
