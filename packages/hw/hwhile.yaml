homepage: ''
changelog-type: ''
hash: 792b762e2fd9f49b6665301ef009f66e026c489754221f040ce8916238ae2180
test-bench-deps:
  hwhile: -any
  Cabal: -any
  base: ! '>=4.8 && <4.11'
  array: ! '>=0.5 && <0.6'
  containers: ! '>=0.5 && <0.6'
  mtl: -any
maintainer: apjeffery136@gmail.com
synopsis: An implementation of Neil D. Jones' While language
changelog: ''
basic-deps:
  hwhile: -any
  haskeline: ! '>=0.7 && <0.8'
  base: ! '>=4.8 && <4.11'
  filepath: ! '>=1.2 && <1.5'
  array: ==0.5.*
  repline: ! '>=0.1.6 && <0.1.8'
  containers: ==0.5.*
  mtl: ==2.2.*
all-versions:
- '0.1.1.0'
- '0.1.1.1'
- '0.1.1.2'
- '0.1.1.3'
author: Alex Jeffery
latest: '0.1.1.3'
description-type: markdown
description: ! "## HWhile\nHWhile is an interpreter for a simple While language originally
  used by Neil\nJones in his book “Computability and Complexity\". The While language
  is a simple\nimperative programming language with while-loops, assignment and conditionals.\nIt
  has a single data type: binary trees. The HWhile interpreter is written in\nHaskell.\n\nThis
  current implementation also includes syntactic sugar such as switch\nstatements,
  macros, list notation, equality, and natural number literals. It\ntherefore supports
  (almost fully) the version of While used in Bernhard Reus’\ntextbook [Limits of
  Computation - From a Programming Perspective](http:limits.bernhardreus.com)\nand
  has been developed in co-operation with Bernhard to support students on the\ncorresponding
  module at Sussex University.\nThis version also allows one to translate while programs
  into programs as data.\nFor this to work,  all the syntax sugar (extensions) of
  a While program has to\nbe removed again.\n\nMore about the syntax and the semantics
  (and usage) of the While language can be\nfound in Bernhard’s textbook (Chapter
  3-5), and we also include a summary below.\n\n### Instructions\n\n#### Installing
  Prerequisites\nAll the tools required to compile and run HWhile are included in
  the\n[Haskell Platform](http://www.haskell.org/platform/). Make sure you install
  the\n_full_ version as opposed to the _core_ version.\n\nNote that you may need
  to add the Haskell Platform's binaries to your system's\npath variable. If you're
  on windows this should happen automatically. Otherwise\nsome configuration may be
  required.\n\n#### Installing HWhile\nOnce the Haskell Platform is installed and
  configured correctly, you can install\nHWhile by running:\n\n    stack install hwhile\n\nThis
  will download HWhile and its depenencies (if necessary) and compile and\ninstall
  them.\n\n#### Invocation\nIf installed correctly, HWhile can be run with the command:\n\n
  \   hwhile <FLAG> <FILE> <EXPR>\n\nFor example:\n\n    hwhile -i examples/count.while
  \"[1, 2, 3]\"\n\nThis example takes a list of numbers as its argument and outputs
  their sum, so\nyou should see `6` as the output.\n\n### Syntax\nThe grammar below
  gives exactly the concrete syntax of this implementation:\n\n    PROG  ::= ID read
  ID BLOCK write ID\n\n    BLOCK ::= { CMDS }\n            | {}\n\n    CMDS  ::= CMD
  ; CMD\n            | CMD\n\n    CMD   ::= ID := EXP                     // Assignment\n
  \           | while EXP BLOCK               // While loops\n            | if EXP
  BLOCK else BLOCK       // If-then-else statements\n            | if EXP BLOCK                  //
  If-then statements\n            | ID := <ID> EXP                // Macro calls\n
  \           | switch EXP { CASES            // Switch statements\n\n    CASES ::=
  case EXP : CMDS CASES\n            | default : CMDS }\n            | }\n\n    EXP
  \  ::= LIT\n            | cons EXP EXP\n            | hd EXP\n            | tl EXP\n
  \           | (EXP)\n            | EXP = EXP\n            | ID\n            | []\n
  \           | [ EXP LIST\n\n    LIST  ::= , EXP LIST\n            | ]\n\n    LIT
  \  ::= nil\n            | true\n            | false\n            | <LIT.LIT>\n            |
  NAT\n            | @asgn\n            | @:=\n            | @doAsgn\n            |
  @while\n            | @doWhile\n            | @if\n            | @doIf\n            |
  @var\n            | @quote\n            | @hd\n            | @doHd\n            |
  @tl\n            | @doTl\n            | @cons\n            | @doCons\n\n    NAT
  \  ::= 0|[1-9][0-9]+\n\n    ID    ::= [a-zA-Z_'][a-zA-Z0-9_']*\n\nCommand line input
  must conform to the following grammar:\n\n    INP    ::= nil\n            | true\n
  \           | false\n            | <LIT.LIT>\n            | NAT\n            | []\n
  \           | [ INP INPLST\n            | @asgn\n            | @:=\n            |
  @doAsgn\n            | @while\n            | @doWhile\n            | @if\n            |
  @doIf\n            | @var\n            | @quote\n            | @hd\n            |
  @doHd\n            | @tl\n            | @doTl\n            | @cons\n            |
  @doCons\n\n    INPLST ::= , INP INPLST\n            | ]\n\n### Semantics\nThe semantics
  of HWhile programs are defined by functions. These functions take\na program construct
  - an expression, block, command or program, and a _store_ -\na function of type
  `X -> T` that maps variable names to trees.\n\nWe first define two functions over
  stores - addition, which adds a new binding,\nand lookup, which retrieves the tree
  bound to the given name.\n\n    σ + (x -> T) = σ, x -> T       if x ∉ σ\n                 |
  σ', x -> T, σ'' if σ = σ', x -> U, σ''\n\n    σ(x) = T   if σ = σ', x -> T, σ''\n
  \        | nil if x ∉ σ\n\nSemantics for expressions are defined as follows:\n\n
  \   [e] : EXP -> (X -> T) -> T\n\n    [x] σ = σ(x)\n    [hd e] σ = nil if [e] σ
  = nil\n             | H   if [e] σ = <H.T>\n    [tl e] σ = nil if [e] σ = nil\n
  \            | T   if [e] σ = <H.T>\n    [e = e'] σ = nil if [e] σ /= [e'] σ\n               |
  T   if [e] σ  = [e'] σ where T /= nil\n    [cons e e'] σ = <H.T> where H = [e] σ,
  T = [e'] σ\n\nFor blocks:\n\n    [b] : BLOCK -> (X -> T) -> (X -> T)\n\n    [{}]
  σ = σ\n    [{c; cs}] σ = [{cs}] ([c] σ)\n\nFor commands, we define semantics only
  for pure commands (assignment, while\nloops and if-then-else statements). The semantics
  for switch statements and\nmacro calls are given by translation to pure commands.
  The semantics for pure\ncommands are given as follows:\n\n    [c] : CMD -> (X ->
  T) -> (X -> T)\n\n    [x := e] σ = σ + (x -> [e] σ)\n    [while e b] σ = σ                   if
  [e] σ  = nil\n                  | [while e b] ([b] σ) if [e] σ /= nil\n    [if e
  b else b'] σ = [b]  σ if [e] σ /= nil\n                       | [b'] σ if [e] σ
  \ = nil\n\nThe translations for if-then statements, switch statements and macros
  are\ndefined as follows:\n\n    if e b = if e b else {}\n\n    switch e {} = {}\n
  \   switch e { default : cs } = { cs }\n    switch e { case e : cs cases } = if
  e { cs } else switch e { cases }\n\n    x := <macro> e = disjoin(cmds); x := y\n
  \   where macro.while = macro read z { cmds } write y\n\nThe function `disjoin`
  renames the variable names in `cmds` such that there are\nno names in common with
  the program in which the macro call occurs.\n\nFinally, the semantics for programs
  are defined as follows:\n\n    [p] : PROG -> T -> T\n\n    [n read x b write y]
  T = ([b] (x -> T))(y)\n"
license-name: GPL-3
