homepage: ''
changelog-type: markdown
hash: 87ef43d4e3f7f184cd889d6b82a61cf2fae85d841cedc691b175408d1c4ff0ab
test-bench-deps:
  base: ! '>=4.7 && <5'
  text: -any
  containers: -any
  mtl: -any
  elminator: -any
  aeson: -any
  template-haskell: -any
maintainer: sandeep@sras.me
synopsis: Generate ELM types/encoders/decoders from Haskell types.
changelog: |
  # Changelog for elminator

  ## Unreleased changes
basic-deps:
  base: ! '>=4.7 && <5'
  text: -any
  containers: -any
  mtl: -any
  aeson: -any
  template-haskell: -any
all-versions:
- 0.0.0.0
- 0.1.0.0
author: Sandeep.C.R
latest: 0.1.0.0
description-type: markdown
description: "# Elminator\n\nGenerate Elm type definitions and json encoders/decoders
  from Haskell source.\n\n1. Supports generation of polymorphic types in Elm including
  types with phantom type variables.\n2. Supports generation of direct and indirect
  recursive types as long as the recursive types are not polymorphic.\n3. Generates
  code that does not depend on external Elm libraries.\n4. Does not have limits on
  the number of fields that the constructors of your type can have.\n5. Supports json
  encoding options exported by the Aeson library comprehensively.\n6. Supports generation
  of code that depend on user defined types and encoders/decoders in Elm.\n\n### How
  to use?\n\nTo generate Elm code for a Haskell type, the Haskell type needs to have
  an instance of the `ToHType` type class.\nThis can be automatically derivied, provided
  all your constructor field types have `ToHType` instances. A sample can be seen
  below. Please note that language extensions `DeriveGeneric` and `DeriveAnyClass`
  should be enabled to make this work.\n\n```haskell\n{-# Language DeriveGeneric #-}\n{-#
  Language DeriveAnyClass #-}\n\nmodule Lib  where\n\nimport Elminator\nimport GHC.Generics
  (Generic)\n\ndata SingleCon = SingleCon Int String deriving (Generic, ToHType)\n\n```\n\nSince
  this library uses template haskell to look up type information (in addition to Generics),
  we need to run the code generation code in a template Haskell splice. \nA usage
  sample can be seen in the following code used in the round trip tests for this library.\n\n\n```haskell\n{-#
  Language OverloadedStrings #-}\n{-# Language TemplateHaskell #-}\n\nmodule CodeGen
  where\n\nimport Data.Proxy\nimport Elminator\nimport Data.Text.IO\nimport Data.Text\n\nimport
  Lib\n\nelmSource :: Text\nelmSource = $(generateFor Elm19 myDefaultOptions (Just
  \"elm-app/src/Autogen.elm\") $ do\n  include (Proxy :: Proxy SingleCon) $ Everything
  Mono\n  include (Proxy :: Proxy SingleRecCon) $ Everything Mono\n  include (Proxy
  :: Proxy SingleConOneField)$ Everything Mono\n  include (Proxy :: Proxy SingleRecConOneField)
  $ Everything Mono\n  include (Proxy :: Proxy TwoCons) $ Everything Mono \n  include
  (Proxy :: Proxy TwoRecCons) $ Everything Mono \n  include (Proxy :: Proxy BigCon)
  $ Everything Mono \n  include (Proxy :: Proxy BigRecCon) $ Everything Mono \n  include
  (Proxy :: Proxy MixedCons) $ Everything Mono \n  include (Proxy :: Proxy Comment)
  $ Everything Mono \n  include (Proxy :: Proxy WithMaybes) $ Everything Mono\n  include
  (Proxy :: Proxy WithSimpleMaybes) $ Everything Mono \n  include (Proxy :: Proxy
  (WithMaybesPoly (Maybe String) Float)) $ Definiton Poly\n  include (Proxy :: Proxy
  (WithMaybesPoly (Maybe String) Float)) $ EncoderDecoder\n  include (Proxy :: Proxy
  (Phantom ())) $ Everything Poly\n  include (Proxy :: Proxy (TypeWithPhantom Float))
  $ Everything Poly\n  include (Proxy :: Proxy RecWithList) $ Everything Mono\n  include
  (Proxy :: Proxy IndRecStart) $ Everything Mono\n  include (Proxy :: Proxy IndRec2)
  $ Everything Mono\n  include (Proxy :: Proxy IndRec3) $ Everything Mono\n  include
  (Proxy :: Proxy NTSingleCon) $ Everything Mono\n  include (Proxy :: Proxy NTSingleCon2)
  $ Everything Poly\n  include (Proxy :: Proxy Tuples) $ Everything Mono\n  include
  (Proxy :: Proxy NestedTuples) $ Everything Mono\n  include (Proxy :: Proxy (TypeWithExt
  ())) $ Everything Poly\n  include (Proxy :: Proxy (WithEmptyTuple ())) $ Everything
  Poly\n  include (Proxy :: Proxy (Phantom2 ())) $ Everything Poly\n  include (Proxy
  :: Proxy PhantomWrapper) $ Everything Poly\n  )\n\n-- The `generateFor` function
  accepts an elm version (only Elm19 as of now), a value of type `Options` from the
  Aeson library\n-- , and optional `FilePath` to which the generated source will be
  written to, and a `Builder` value.\n-- The `Builder` is just a `State` monad that
  aggregates the configuration parameters from the include\n-- calls. The first parameter
  of the include function is a `proxy` value that denotes the type that requires Elm
  code generation.\n-- The second value is a value of type `GenOption` that selects
  which entites needs to be generation, and also selects if the\n-- type generated
  at Elm should be polymorphic. It is defined as follows.\n\ndata GenOption\n  = Definiton
  PolyConfig  -- Generate Type definition in Elm. PolyConfig field decides if the
  type has to be polymorphic\n  | EncoderDecoder -- Generate Encoder and Decoder in
  Elm\n  | Everything PolyConfig -- Generate both type definition, encoders and decoders.
  PolyConfig field decides if the type has to be polymorphic.\n\ndata PolyConfig\n
  \ = Mono | Poly \n```\n\nThe Elm code generated by the above code can be seen [here](https://bitbucket.org/sras/elminator-test/src/master/elm-app/src/Autogen.elm)\n\n###
  How to depend on predefined types and encoders/decoders\n\nThis is intended to be
  an escape hatch in cases where the types you want to generate elm code for, inturn
  contains types that you didn't define, and do not have access to the internals of.\nThis
  feature basically allows you to define the Elm type and encoders/decoders yourself,
  and let the generated code import it and use them in the generated code. \n\nTo
  use this, derive the `ToHType` instance for the type using the `HExternal` constructor
  of the `HType` type. Sample code can be seen below, where we define a `ToHType`
  instance for a type called `MyExtType`.\n\n```haskell\ninstance (ToHType a, ToHType
  b) => ToHType (MyExtType a b) where\n  toHType _ = do\n    ha <- toHType (Proxy
  :: Proxy a)\n    hb <- toHType (Proxy :: Proxy b)\n    pure $\n      HExternal\n
  \       (ExInfo\n          (ExItem \"Lib\" \"MyExtType\") \n          (Just $ ExItem
  \"Lib\" \"encodeMyExtType\")\n          (Just $ ExItem \"Lib\" \"decodeMyExtType\"))\n
  \       [ha, hb]\n```\n\n### Installing\n\nIf you are using the Stack tool, then
  for the time being, you have to add Elminator to the extra deps section of stack.yaml
  as follows.\n\n```yaml\nextra-deps:\n  elminator-0.1.0.0\n```\n\n"
license-name: BSD-3-Clause
