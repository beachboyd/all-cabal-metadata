homepage: ''
changelog-type: markdown
hash: 89caf4fae85a3289edeece7ff9e10ccd0cbc96dc84899a1fe87ab394a4827c95
test-bench-deps:
  base: ! '>=4.7 && <5'
  text: -any
  containers: -any
  mtl: -any
  elminator: -any
  aeson: -any
  template-haskell: -any
maintainer: sandeep@sras.me
synopsis: Generate ELM types/encoders/decoders from Haskell types.
changelog: |
  # Changelog for elminator

  ## Unreleased changes
basic-deps:
  base: ! '>=4.7 && <5'
  text: -any
  containers: -any
  mtl: -any
  aeson: -any
  template-haskell: -any
all-versions:
- 0.0.0.0
- 0.1.0.0
- 0.2.0.0
- 0.2.1.0
- 0.2.2.0
- 0.2.2.1
- 0.2.3.0
author: Sandeep.C.R
latest: 0.2.3.0
description-type: markdown
description: "# Elminator\n\nGenerate Elm type definitions and JSON encoders/decoders
  from Haskell source (for Elm 0.19 and 0.18)\n\n1. Supports generation of polymorphic
  types (as well as concrete ones) in Elm from possibly polymorphic Haskell types,
  including types with phantom type variables.\n2. Supports generation of direct and
  indirect recursive types as long as the recursive types are not polymorphic.\n3.
  Generates code that does not depend on external Elm libraries.\n4. Does not have
  limits on the number of fields that the constructors of your type can have.\n5.
  Supports JSON encoding options exported by the Aeson library comprehensively (The
  tests exhaustively check the Elm/Haskell round tripping of values for all possible
  configurations of Aeson.options)\n6. Supports generation of code that depend on
  user defined types and encoders/decoders in Elm.\n\n### How to use?\n\nTo generate
  Elm code for a Haskell type, the Haskell type needs to have an instance of the `ToHType`
  type class.\nThis can be automatically derived, provided all your constructor field
  types have `ToHType` instances. A sample can be seen below. Please note that language
  extensions `DeriveGeneric` and `DeriveAnyClass` should be enabled to make this work.\n\n```haskell\n{-#
  Language DeriveGeneric #-}\n{-# Language DeriveAnyClass #-}\n\nmodule Lib  where\n\nimport
  Elminator\nimport GHC.Generics (Generic)\n\ndata SingleCon = SingleCon Int String
  deriving (Generic, ToHType)\n\n```\n\nSince this library uses template Haskell to
  look up type information (in addition to Generics), we need to run the code generation
  code in a template Haskell splice. \nA usage sample can be seen in the following
  code used in the round trip tests for this library.\n\n\n```haskell\n{-# Language
  OverloadedStrings #-}\n{-# Language TemplateHaskell #-}\n\nmodule CodeGen where\n\nimport
  Data.Proxy\nimport Elminator\nimport Data.Text.IO\nimport Data.Text\n\nimport Lib\n\nelmSource
  :: Text\nelmSource =\n  $(generateFor Elm0p19 myDefaultOptions (Just \"./elm-app/src/Autogen.elm\")
  $ do\n      include (Proxy :: Proxy SingleCon) $ Everything Mono\n      include
  (Proxy :: Proxy SingleRecCon) $ Everything Mono\n      include (Proxy :: Proxy SingleConOneField)
  $ Everything Mono\n      include (Proxy :: Proxy SingleRecConOneField) $ Everything
  Mono\n      include (Proxy :: Proxy TwoCons) $ Everything Mono\n      include (Proxy
  :: Proxy TwoRecCons) $ Everything Mono\n      include (Proxy :: Proxy BigCon) $
  Everything Mono\n      include (Proxy :: Proxy BigRecCon) $ Everything Mono\n      include
  (Proxy :: Proxy MixedCons) $ Everything Mono\n      include (Proxy :: Proxy Comment)
  $ Everything Mono\n      include (Proxy :: Proxy WithMaybes) $ Everything Mono\n
  \     include (Proxy :: Proxy WithSimpleMaybes) $ Everything Mono\n      include
  (Proxy :: Proxy (WithMaybesPoly (Maybe String) Float)) $\n        Definiton Poly\n
  \     include\n        (Proxy :: Proxy (WithMaybesPoly (Maybe String) Float))\n
  \       EncoderDecoder\n      include (Proxy :: Proxy (Phantom ())) $ Everything
  Poly\n      include (Proxy :: Proxy (TypeWithPhantom Float)) $ Everything Poly\n
  \     include (Proxy :: Proxy RecWithList) $ Everything Mono\n      include (Proxy
  :: Proxy IndRecStart) $ Everything Mono\n      include (Proxy :: Proxy IndRec2)
  $ Everything Mono\n      include (Proxy :: Proxy IndRec3) $ Everything Mono\n      include
  (Proxy :: Proxy NTSingleCon) $ Everything Mono\n      include (Proxy :: Proxy NTSingleCon2)
  $ Everything Poly\n      include (Proxy :: Proxy Tuples) $ Everything Mono\n      include
  (Proxy :: Proxy NestedTuples) $ Everything Mono\n      include (Proxy :: Proxy (NestedTuplesPoly
  ())) $ Definiton Poly\n      include (Proxy :: Proxy (TypeWithExt ())) $ Everything
  Poly\n      include (Proxy :: Proxy (WithEmptyTuple ())) $ Everything Poly\n      include
  (Proxy :: Proxy (Phantom2 ())) $ Everything Poly\n      include (Proxy :: Proxy
  PhantomWrapper) $ Everything Poly)\n\n-- The `generateFor` function accepts an elm
  version (Elm0p19 or Elm0p18), a value of type `Options` from the Aeson library\n--
  , and optional `FilePath` to which the generated source will be written to, and
  a `Builder` value.\n-- The `Builder` is just a `State` monad that aggregates the
  configuration parameters from the include\n-- calls. The first parameter of the
  include function is a `proxy` value that denotes the type that requires Elm code
  generation.\n-- The second value is a value of type `GenOption` that selects which
  entities needs to be generation, and also selects if the\n-- type generated at Elm
  should be polymorphic. It is defined as follows.\n\ndata GenOption\n  = Definiton
  PolyConfig  -- Generate Type definition in Elm. PolyConfig field decides if the
  type has to be polymorphic\n  | EncoderDecoder -- Generate Encoder and Decoder in
  Elm\n  | Everything PolyConfig -- Generate both type definition, encoders and decoders.
  PolyConfig field decides if the type has to be polymorphic.\n\ndata PolyConfig\n
  \ = Mono | Poly \n```\n\nThe Elm code generated by the above code can be seen [here](https://bitbucket.org/sras/elminator-test/src/master/elm-app/src/Autogen.elm)\n\n###
  How to depend on predefined types and encoders/decoders\n\nThis is intended to be
  an escape hatch in cases where the types you want to generate elm code for, in turn
  contains types that you didn't define, and do not have access to the internals of.\nThis
  feature basically allows you to define the Elm type and encoders/decoders yourself,
  and let the generated code import it and use them in the generated code. \n\nTo
  use this, derive the `ToHType` instance for the type using the `HExternal` constructor
  of the `HType` type. Sample code can be seen below, where we define a `ToHType`
  instance for a type called `MyExtType`.\n\n```haskell\ninstance (ToHType a, ToHType
  b) => ToHType (MyExtType a b) where\n  toHType _ = do\n    ha <- toHType (Proxy
  :: Proxy a)\n    hb <- toHType (Proxy :: Proxy b)\n    pure $\n      HExternal\n
  \       (ExInfo\n           (\"External\", \"MyExtType\")\n           (Just (\"External\",
  \"encodeMyExtType\"))\n           (Just (\"External\", \"decodeMyExtType\"))\n           [ha,
  hb])\n```\n\n### Tests\n\nThis is being tested by round tripping a bunch of JSON
  encoded values from an Elm front end to a Haskell back end, where it is decoded
  and sent back to Elm where it is again decoded and checked for equality with the
  value that was initially sent. These right now, are in the form of a quick hack
  Python script that makes the Haskell builds and auto generated Elm source for all
  possible values of Aeson.Options and testing the round tripping of included types
  using a headless Chromium browser. The test repo is separate for now and is available
  at https://bitbucket.org/sras/elminator-test.\n\n### Installing\n\nIf you are using
  the Stack tool, then for the time being, you have to add Elminator to the 'extra-deps'
  section of stack.yaml as follows (Please use the latest available version here).\n\n```yaml\nextra-deps:\n
  \ elminator-0.2.1.0\n```\n\n"
license-name: BSD-3-Clause
