homepage: https://github.com/RyanGlScott/eliminators
changelog-type: markdown
hash: 2e0bf27209903cd18ad8b08dc8fc1ff5cad0cb61394f2946828699d3f931b77c
test-bench-deps:
  base: ! '>=4.12 && <4.13'
  hspec: ! '>=2 && <3'
  singletons: ! '>=2.5 && <2.6'
  singleton-nats: ! '>=0.4.2 && <0.5'
  eliminators: -any
maintainer: Ryan Scott <ryan.gl.scott@gmail.com>
synopsis: Dependently typed elimination functions using singletons
changelog: ! "## 0.5 [2018.09.18]\n* Require `singletons-2.5` and GHC 8.6.\n\n###
  0.4.1 [2018.02.13]\n* Add `elimVoid` to `Data.Eliminator`.\n\n## 0.4 [2018.01.09]\n*
  Require `singletons-2.4` and GHC 8.4.\n\n## 0.3 [2017-11-07]\n* Migrate the old
  `elimNat` from `Data.Eliminator` (which worked over the `Nat`\n  from `GHC.TypeNats`)
  to `Data.Eliminator.TypeNats`. There `elimNat` that now\n  lives in `Data.Eliminator`
  is for an unrelated `Nat` data type from the\n  `singleton-nats` package (which
  is a proper, inductively defined, Peano\n  natural number type).\n\n## 0.2 [2017-07-22]\n*
  Introduce the `Data.Eliminator.TH` module, which provides functionality for\n  generating
  eliminator functions using Template Haskell. Currently, only\n  simple algebraic
  data types that do not use polymorphic recursion are\n  supported.\n* All eliminators
  now use predicates with `(~>)`.\n\n## 0.1 [2017-07-02]\n* Initial release.\n"
basic-deps:
  extra: ! '>=1.4.2 && <1.7'
  base: ! '>=4.12 && <4.13'
  th-abstraction: ! '>=0.2.3 && <0.3'
  singletons: ! '>=2.5 && <2.6'
  singleton-nats: ! '>=0.4.2 && <0.5'
  th-desugar: ! '>=1.9 && <1.10'
  template-haskell: ! '>=2.14 && <2.15'
all-versions:
- '0.1'
- '0.2'
- '0.3'
- '0.4'
- 0.4.1
- '0.5'
author: Ryan Scott
latest: '0.5'
description-type: markdown
description: ! "# `eliminators`\n[![Hackage](https://img.shields.io/hackage/v/eliminators.svg)][Hackage:
  eliminators]\n[![Hackage Dependencies](https://img.shields.io/hackage-deps/v/eliminators.svg)](http://packdeps.haskellers.com/reverse/eliminators)\n[![Haskell
  Programming Language](https://img.shields.io/badge/language-Haskell-blue.svg)][Haskell.org]\n[![BSD3
  License](http://img.shields.io/badge/license-BSD3-brightgreen.svg)][tl;dr Legal:
  BSD3]\n[![Build](https://img.shields.io/travis/RyanGlScott/eliminators.svg)](https://travis-ci.org/RyanGlScott/eliminators)\n\n[Hackage:
  eliminators]:\n  http://hackage.haskell.org/package/eliminators\n  \"eliminators
  package on Hackage\"\n[Haskell.org]:\n  http://www.haskell.org\n  \"The Haskell
  Programming Language\"\n[tl;dr Legal: BSD3]:\n  https://tldrlegal.com/license/bsd-3-clause-license-%28revised%29\n
  \ \"BSD 3-Clause License (Revised)\"\n\nThis library provides eliminators for inductive
  data types, leveraging the power of the `singletons` library to allow dependently
  typed elimination.\n"
license-name: BSD-3-Clause
