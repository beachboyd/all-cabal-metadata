homepage: https://github.com/infinity0/hs-mutable-lens
changelog-type: markdown
hash: efe692373c2c55489d5fb43fb17119182476cec1acf7271141ad48d41669a4ad
test-bench-deps:
  stm: -any
  base: ==4.*
  doctest: -any
  containers: -any
  lens: -any
  mutable-lens: -any
  tasty-hunit: -any
  transformers: -any
  tasty: -any
  primitive: -any
maintainer: infinity0@pwned.gg
synopsis: Interoperate mutable references with regular lens
changelog: |
  # Revision history for mutable-lens

  ## 0.4.0.0 -- 2020-05-29

  * Split IsoLST into FromLST, of which there are more instances.
  * Update to GHC 8.10.1

  ## 0.3.0.0 -- 2020-05-28

  * Add Allocable typeclass for creating new references.

  ## 0.2.0.0 -- 2020-05-17

  * More convenience functions, including ALens compat.

  ## 0.1.0.0 -- 2020-04-16

  * First release, with basic features.
basic-deps:
  stm: -any
  base: '>=4.12.0.0 && <5'
  lens: -any
  primitive: -any
all-versions:
- 0.1.0.0
- 0.2.0.0
- 0.3.0.0
- 0.4.0.0
author: Ximin Luo
latest: 0.4.0.0
description-type: haddock
description: |-
  Use mutable references as lens, compose them with other lens, and run them.

  You may have heard of lens being described as "functional" or "first-class"
  references, with some nice properties such as composition. However the
  equivalence is more than just abstract - mutable references can be readily
  converted into lens form, interoperable with other pure lens. This makes use
  of the fact that "mutability" in a high-level language focusing on purity, is
  really just an alias for a pure state monad that is treated specially by the
  runtime system. A mutable reference over a value of type @a@ with world state
  of type @s@, *is* therefore an actual @Lens s s a a@. There is no need for
  handwaving or connotative language, the isomorphism is direct and concrete.

  This package demonstrates this isomorphism, converting between the two forms.
  You then have access to the whole of the lens ecosystem and its compositional
  properties, and use them with mutable references without other special-cased
  shims or mutable-specific abstractions.

  Uniformity of API is another major benefit - if you want to switch to a
  different reference type, you only have to change your type definitions and
  imports, you don't have to change all @readSomeVar@ to @readOtherVar@,
  @writeSomeVar@ to @writeOtherVar@, or was it @putOtherVar@, and does the
  @atomicModifyVar@ function take a @s -> (a, s)@ or a @s -> (s, a)@ again?

  On the other hand, this package has not been optimised for performance, and
  currently only supports GHC. We would certainly welcome contributions in
  these areas, if you are interested in running this code in production. Until
  that happens, please be cautious and treat this code as experimental.

  For what it's worth, the API is likely to be very stable: an isomorphism to
  another well-established library, is not a complex API.

  See unit tests for example usage, e.g.
  <https://github.com/infinity0/hs-mutable-lens/tree/master/test/Control/Lens/MutableTest.hs MutableTest>
license-name: Apache-2.0
