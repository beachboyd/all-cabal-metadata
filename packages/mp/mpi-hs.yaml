homepage: https://github.com/eschnett/mpi-hs#readme
changelog-type: ''
hash: df41af61cc21d7fcf4473c9110c384bbd76ab4364a781c61c84ec3dfb0eb72ac
test-bench-deps:
  unix: -any
  base: -any
  monad-loops: -any
  tasty-hspec: -any
  criterion: -any
  mpi-hs: -any
  tasty-hunit: -any
  tasty: -any
maintainer: Erik Schnetter
synopsis: MPI bindings for Haskell
changelog: ''
basic-deps:
  base: ==4.11.*
  mpi-hs: -any
all-versions:
- '0.1.0.1'
author: Erik Schnetter
latest: '0.1.0.1'
description-type: markdown
description: ! "# [mpi-hs](https://github.com/eschnett/mpi-hs)\n\n[MPI](https://www.mpi-forum.org)
  bindings for Haskell\n\n[![CircleCI](https://circleci.com/gh/eschnett/mpi-hs.svg?style=svg)](https://circleci.com/gh/eschnett/mpi-hs)\n\n\n\n##
  Overview\n\nMPI (the _Message Passing Interface_) is widely used standard for\ndistributed-memory
  programming on HPC (High Performance Computing)\nsystems. MPI allows exchanging
  data (_messages_) between programs\nrunning in parallel. There are several high-quality
  open source MPI\nimplementations (e.g. MPICH, MVAPICH, OpenMPI) as well as a variety
  of\nclosed-source implementations. These libraries can typically make use\nof high-bandwidth
  low-latency communication hardware such as\nInfiniBand.\n\nThis library `mpi-hs`
  provides Haskell bindings for MPI. It is based\non ideas taken from\n[haskell-mpi](https://github.com/bjpop/haskell-mpi),\n[Boost.MPI](https://www.boost.org/doc/libs/1_64_0/doc/html/mpi.html),\nand
  [MPI for Python](https://mpi4py.readthedocs.io/en/stable/).\n\n`mpi-hs` provides
  two API levels: A low-level API gives rather direct\naccess to the MPI API, apart
  from certain \"reasonable\" mappings from C\nto Haskell (e.g. output arguments that
  are in C stored to a pointer\nare in Haskell regular return values). A high-level
  API simplifies\nexchanging arbitrary values that can be serialized.\n\n\n\n## Example\n\nThis
  is a typical MPI C code:\n```C\n#include <stdio.h>\n#include <mpi.h>\n\nint main(int
  argc, char** argv) {\n  MPI_Init(&argc, &argv);\n  int rank, size;\n  MPI_Comm_rank(MPI_COMM_WORLD,
  &rank);\n  MPI_Comm_size(MPI_COMM_WORLD, &size);\n  printf(\"This is process %d
  of %d\\n\", rank, size);\n  MPI_Finalize();\n  return 0;\n}\n```\n\nThe Haskell
  equivalent looks like this:\n```Haskell\nimport Control.Distributed.MPI as MPI\n\nmain
  :: IO ()\nmain =\n  do MPI.init\n     rank <- MPI.commRank MPI.commWorld\n     size
  <- MPI.commSize MPI.commWorld\n     putStrLn $ \"This is process \" ++ show rank
  ++ \" of \" ++ show size\n     MPI.finalize\n```\n"
license-name: Apache-2.0
