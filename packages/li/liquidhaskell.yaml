homepage: https://github.com/ucsd-progsys/liquidhaskell
changelog-type: markdown
hash: a18654baabee17c4eafc021075a1ae60948fbab1160c46259325701683f54b1c
test-bench-deps:
  ghc: -any
  bytestring: -any
  stm: ! '>=2.4'
  base: ! '>=4.8.1.0 && <5'
  time: ! '>=1.4'
  text: -any
  syb: -any
  hpc: ! '>=0.6'
  filepath: ! '>=1.3'
  process: ! '>=1.2'
  parsec: -any
  array: ! '>=0.5'
  tagged: ! '>=0.7.3'
  containers: ! '>=0.5'
  ghc-boot: -any
  liquid-fixpoint: ! '>=0.7.0.5'
  mtl: ! '>=2.1'
  tasty-hunit: ! '>=0.9'
  liquidhaskell: -any
  tasty-rerun: ! '>=1.1'
  transformers: ! '>=0.3'
  optparse-applicative: ! '>=0.11'
  tasty: ! '>=0.10'
  template-haskell: ! '>=2.9'
  tasty-ant-xml: -any
  directory: ! '>=1.2'
maintainer: Ranjit Jhala <jhala@cs.ucsd.edu>
synopsis: Liquid Types for Haskell
changelog: ! "# Changes\n\n## NEXT\n\n- Add support for *inductive predicates* see
  `tests/pos/Ind{Even,Perm,Star}.hs`\n  for examples.\n\n## 0.8.0.1\n\n- Support for
  GHC 8.0.2 \n\n## 0.7.0.1\n\n- **DELETED** the gsDcons and generally carrying DataConP
  beyond Bare; this _may_ cause\n  problems with `target` as I removed the `dconEnv`
  field in `TargetState`. Is it live?\n  To restore: have to apply the substitution
  syms/su in Bare.hs ALSO to gsDconsP (after \n  restoring the gsDconsP field to [(DataCon,
  DataConP)])\n\n\n- **breaking change** Remove the `Bool` vs. `Prop` distinction.
  This means that: \n\n    * signatures that use(d) `Prop` as a type, e.g. \n      `foo
  :: Int -> Prop` should just be `foo :: Int -> Bool`.\n\n    * refinements that use(d)
  `Prop v` e.g. \n      `isNull :: xs:[a] -> {v:Bool | Prop v <=> len xs > 0}`\n      should
  just be `isNull :: xs:[a] -> {v:Bool | v <=> len xs > 0}`.\n\n- Add `--eliminate={none,
  some, all}`. Here\n  * `none` means don't use eliminate at all, use qualifiers everywhere
  (old-style)\n  * `some` which is the **DEFAULT**  -- means eliminate all the **non-cut**
  variables\n  * `all`  means eliminate where you can, and solve *cut* variables to
  `True`.\n\n- Change `--higherorder` so that it uses *only* the qualifiers obtained
  from\n  type aliases (e.g. `type Nat = {v:Int | ... }`) and nothing else. This\n
  \ requires `eliminate=some`.\n\n- Add a `--json` flag that runs in quiet mode where
  all output is\n  suppressed and only the list of errors is returned as a JSON object
  to be\n  consumed by an editor.\n\n- Add `--checks` flag (formerly `--binders`),
  which checks a given binder's\n  definition, assuming specified types for all callees
  (but inferring types for\n  callees without signatures.)\n\n- Add `--time-binds`
  which is like the above, but checks all binders in a module\n  and prints out time
  taken for each.\n\n## 0.5.0.1\n\n- Fixed a bug in the specification for `Data.Traversable.sequence`\n-
  Make interpreted mul and div the default, when `solver = z3`\n- Use `--higherorder`
  to allow higher order binders into the fixpoint environment \n\n## 0.5.0.0\n\n-
  Added support for building with `stack`\n\n- Added support for GHC 7.10 (in addition
  to 7.8)\n\n- Added '--cabaldir' option that will automatically find a .cabal file
  in the ancestor\n  path from which the target file belongs, and then add the relevant
  source and dependencies\n  to the paths searched for by LiquidHaskell.\n\n  This
  means we don't have to manually do `-i src` etc. when checking large projects,\n
  \ which can be tedious e.g. within emacs.\n\n\n## 0.4.0.0\n\n- Bounds as an alternative
  for logical constraints see `benchmarks/icfp15/pos/Overview.lhs`\n\n## 0.3.0.0\n\n-
  Logical constraints: add extra subtyping constraints to signatures, e.g.\n\n    {-@
  \n    (.) :: forall <p :: b -> c -> Prop, q :: a -> b -> Prop, r :: a -> c -> Prop>.
  \n           {x::a, w::b<q x> |- c<p w> <: c<r x>}\n           (y:b -> c<p y>)\n
  \       -> (z:a -> b<q z>)\n        ->  x:a -> c<r x>\n    @-}\n    (.) f g x =
  f (g x)\n\n- Inlining haskell functions as predicates and expressions, e.g.\n\n
  \   {-@ inline max @-}\n    max x y = if x >= y then x else y\n\n- Refining class
  instances. For example\n\n    {-@ instance Compare Int where\n        cmax :: Odd
  -> Odd -> Odd @-}\n\n- Major restructuring of internal APIs\n\n## 0.2.1.0\n- Experimental
  support for lifting haskell functions to measures\nIf you annotate a Haskell function
  `foo` with {-@ measure foo @-}, LiquidHaskell will attempt to derive an equivalent
  measure from `foo`'s definition. This should help eliminate some boilerplate measures
  that used to be required.\n\n## 0.2.0.0\n\n- Move to GHC-7.8.3\nLiquidHaskell now
  *requires* ghc-7.8.3.\n\n- Termination\nLiquidHaskell will now attempt to prove
  all recursive functions terminating. It tries to prove that some parameter (or combination
  thereof) decreases at each recursive callsite. By default, this will be the first
  parameter with an associated size measure (see Size Measures), but can be overridden
  with the `Decreases` annotation or a termination expression (see Termination Expressions).
  \n\nIf proving termination is too big of burden, it can be disabled on a per-module
  basis with the `--no-termination` flag, or on a per-function basis with the `Lazy`
  annotation.\n\n- Size Measures\nData declarations now optionally take a *size measure*,
  which LiquidHaskell will use to prove termination of recursive functions. The syntax
  is:\n\n    {-@ data List a [len] = Nil | Cons a (List a) @-}\n\n- Termination Expressions\nTermination
  Expressions can be used to specify the decreasing metric of a recursive function.
  They can be any valid LiquidHaskell expression and must be placed after the function's
  LiquidHaskell type, e.g.\n\n    {-@ map :: (a -> b) -> xs:[a] -> [a] / [len xs]
  @-}\n\n- Type Holes\nTo reduce the annotation burden, LiquidHaskell now accepts
  `_` as a placeholder for types and refinements. It can take the place of any base
  Haskell type and LiquidHaskell will query GHC to fill in the blanks, or it can take
  the place of a refinement predicate, in which case LiquidHaskell will infer an appropriate
  refinement. For example,\n\n    {-@ add :: x:_ -> y:_ -> {v:_ | v = x + y} @-}\n
  \   add x y = x + y\n\nbecomes\n\n    {-@ add :: Num a => x:a -> y:a -> {v:a | v
  = x + y} @-}\n    add x y = x + y\n\n- Assumed Specifications\nThe `assume` annotation
  now works as you might expect it to, i.e. LiquidHaskell will *not* verify that the
  implementation is correct. Furthermore, `assume` can be used to locally override
  the type of an imported function.\n\n- Derived Measure Selectors\nGiven a data definition\n\n
  \   {-@ data Foo = Foo { bar :: Int, baz :: Bool } @-}\n\nLiquidHaskell will automatically
  derive measures\n\n    {-@ measure bar :: Foo -> Int @-}\n    {-@ measure baz ::
  Foo -> Bool @-}\n\n- Type-Class Specifications\nLiquidHaskell can now verify prove
  that type-class instances satisfy a specification. Simply use the new `class` annotation\n\n
  \   {-@ class Num a where\n          (+) :: x:a -> y:a -> {v:a | v = x + y}\n          (-)
  :: x:a -> y:a -> {v:a | v = x - y}\n          ...\n      @-}\n\nand LiquidHaskell
  will attempt to prove at each instance declaration that the implementations satisfy
  the class specification.\n\nWhen defining type-class specifications you may find
  the need to use overloaded measures, to allow for type-specific definitions (see
  Type-Indexed Measures).\n\n- Type-Indexed Measures\nLiquidHaskell now accepts measures
  with *type-specific* definitions, e.g. a measure to describe the size of a value.
  Such measures are defined using the `class measure` syntax\n\n    {-@ class measure
  size :: forall a. a -> Int @-}\n\nand instances can be defined using the `instance
  measure` syntax, which mirrors the regular measure syntax\n\n    {-@ instance measure
  size :: [a] -> Int\n        size ([])   = 0\n        size (x:xs) = 1 + size xs\n
  \     @-}\n    {-@ instance measure size :: Tree a -> Int\n        size (Leaf)       =
  0\n        size (Node l x r) = 1 + size l + size r\n      @-}\n\n- Parsing\nWe have
  greatly improved our parser to require fewer parentheses! Yay!\n\n- Emacs/Vim Support\nLiquidHaskell
  now comes with syntax checkers for [flycheck](https://github.com/flycheck/flycheck)
  in Emacs and [syntastic](https://github.com/scrooloose/syntastic) in Vim. \n\n-
  Incremental Checking\nLiquidHaskell has a new `--diffcheck` flag that will only
  check binders that have changed since the last run, which can drastically improve
  verification times.\n\n- Experimental Support for Z3's theory of real numbers with
  the `--real` flag.\n"
basic-deps:
  exceptions: ! '>=0.6'
  cereal: -any
  located-base: -any
  ghc: ==8.2.1
  bytestring: ! '>=0.10'
  fingertree: ! '>=0.1'
  Cabal: ! '>=1.18'
  base: ! '>=4.8.1.0 && <5'
  time: ! '>=1.4'
  Diff: ! '>=0.3'
  unordered-containers: ! '>=0.2'
  text: ! '>=1.2'
  syb: ! '>=0.4.4'
  hint: -any
  hpc: ! '>=0.6'
  filepath: ! '>=1.3'
  process: ! '>=1.2'
  parsec: ! '>=3.1'
  data-default: ! '>=0.5'
  array: ! '>=0.5'
  containers: ! '>=0.5'
  ghc-paths: ! '>=0.1'
  bifunctors: ! '>=5.1'
  ghc-boot: ==8.2.1
  binary: -any
  ghc-prim: -any
  liquid-fixpoint: ! '>=0.7.0.5'
  mtl: ! '>=2.1'
  cmdargs: ! '>=0.10'
  hashable: ! '>=1.2'
  liquidhaskell: -any
  transformers: ! '>=0.3'
  temporary: ! '>=1.2'
  text-format: -any
  deepseq: ! '>=1.3'
  hscolour: ! '>=1.22'
  QuickCheck: ! '>=2.7'
  th-lift: -any
  pretty: ! '>=1.1'
  aeson: ! '>=1.2 && <1.3'
  template-haskell: ! '>=2.9'
  vector: ! '>=0.10'
  directory: ! '>=1.2'
all-versions:
- '0.1'
- '0.2.0.0'
- '0.2.1.0'
- '0.3.0.0'
- '0.3.1.0'
- '0.4.0.0'
- '0.4.0.1'
- '0.4.1.0'
- '0.4.1.1'
- '0.5.0.0'
- '0.5.0.1'
- '0.6.0.0'
- '0.7.0.0'
- '0.8.0.0'
- '0.8.0.1'
- '0.8.0.2'
- '0.8.0.3'
- '0.8.0.5'
- '0.8.2.0'
author: Ranjit Jhala, Niki Vazou, Eric Seidel
latest: '0.8.2.0'
description-type: markdown
description: ! "![LiquidHaskell](/resources/logo.png)\n\n\n[![Hackage](https://img.shields.io/hackage/v/liquidhaskell.svg)](https://hackage.haskell.org/package/liquidhaskell)
  [![Hackage-Deps](https://img.shields.io/hackage-deps/v/liquidhaskell.svg)](http://packdeps.haskellers.com/feed?needle=liquidhaskell)
  [![Build Status](https://img.shields.io/circleci/project/ucsd-progsys/liquidhaskell/master.svg)](https://circleci.com/gh/ucsd-progsys/liquidhaskell)\n\nMain
  Web site\n-------------\n\n* [Splash page with examples and link to blog](https://ucsd-progsys.github.io/liquidhaskell-blog/)\n*
  [120 minute workshop with more examples](http://ucsd-progsys.github.io/lh-workshop/01-index.html)\n*
  [Long ish Tutorial](http://ucsd-progsys.github.io/liquidhaskell-tutorial/)\n\nContributing
  Guide\n------------------\n\nPlease see the [contributing guide](CONTRIBUTING.md)\n\nRequirements\n------------\n\nLiquidHaskell
  requires (in addition to the cabal dependencies)\n\n- SMTLIB2 compatible solver\n\nHow
  To Clone, Build and Install\n-------------------------------\n\nSee [install instructions](INSTALL.md)\n\nHow
  To Run\n----------\n\nTo verify a file called `foo.hs` at type\n\n    $ liquid foo.hs\n\nHow
  to Run inside GHCi\n----------------------\n\nTo run inside `ghci` e.g. when developing
  do:\n\n    $ stack ghci liquidhaskell\n    ghci> :m +Language.Haskell.Liquid.Liquid\n
  \   ghci> liquid [\"tests/pos/Abs.hs\"]\n\nSee [this file](NIX.md) for instructions
  on running inside a custom `nix`-shell.\n\nHow To Run Regression Tests\n---------------------------\n\n
  \   $ stack test\n\nTo use threads to speed up the tests\n\n    $ make THREADS=30
  test\n\nOr your favorite number of threads, depending on cores etc.\n\nYou can directly
  extend and run the tests by modifying\n\n    tests/test.hs\n\nTo run the regression
  test *and* the benchmarks run\n\n    $ make all-test\n\nHow to Profile\n--------------\n\n1.
  Build with profiling on\n\n    ```\n    $ make pdeps && make prof\n    ```\n\n2.
  Run with profiling\n\n    ```\n    $ time liquid range.hs +RTS -hc -p\n    $ time
  liquid range.hs +RTS -hy -p\n    ```\n\n    Followed by this which shows the stats
  file\n\n    ```\n    $ more liquid.prof\n    ```\n\n    or by this to see the graph\n\n
  \   ```\n    $ hp2ps -e8in -c liquid.hp\n    $ gv liquid.ps\n    ```\n\n    etc.\n\nHow
  to Get Stack Traces On Exceptions\n-------------------------------------\n\n1. Build
  with profiling on\n\n    ```\n    $ make pdeps && make prof\n    ```\n\n2. Run with
  backtraces\n\n    ```\n    $ liquid +RTS -xc -RTS foo.hs\n    ```\n\nWorking With
  Submodules\n-----------------------\n\n - To update the `liquid-fixpoint` submodule,
  run\n\n    ```\n    cd ./liquid-fixpoint\n    git fetch --all\n    git checkout
  <remote>/<branch>\n    cd ..\n    ```\n\n   This will update `liquid-fixpoint` to
  the latest version on `<branch>`\n   (usually `master`) from `<remote>` (usually
  `origin`).\n\n - After updating `liquid-fixpoint`, make sure to include this change
  in a\n   commit! Running\n\n    ```\n    git add ./liquid-fixpoint\n    ```\n\n
  \  will save the current commit hash of `liquid-fixpoint` in your next commit\n
  \  to the `liquidhaskell` repository.\n\n - For the best experience, **don't** make
  changes directly to the\n   `./liquid-fixpoint` submodule, or else git may get confused.
  Do any\n   `liquid-fixpoint` development inside a separate clone/copy elsewhere.\n\n
  - If something goes wrong, run\n\n    ```\n    rm -r ./liquid-fixpoint\n    git
  submodule update --init\n    ```\n\n   to blow away your copy of the `liquid-fixpoint`
  submodule and revert to the\n   last saved commit hash.\n\n - Want to work fully
  offline? git lets you add a local directory as a remote.\n   Run\n\n    ```\n    cd
  ./liquid-fixpoint\n    git remote add local /path/to/your/fixpoint/clone\n    cd
  ..\n    ```\n\n   Then to update the submodule from your local clone, you can run\n\n
  \   ```\n    cd ./liquid-fixpoint\n    git fetch local\n    git checkout local/<branch>\n
  \   cd ..\n    ```\n\nCommand Line Options\n====================\n\nLiquidHaskell
  supports several command line options, to configure the\nchecking. Each option can
  be passed in at the command line, or directly\nadded to the source file via:\n\n
  \   {-@ LIQUID \"option-within-quotes\" @-}\n\nfor example, to disable termination
  checking (see below)\n\n    {-@ LIQUID \"--notermination\" @-}\n\nYou may also put
  command line options in the environment variable\n`LIQUIDHASKELL_OPTS`. For example,
  if you add the line:\n\n    LIQUIDHASKELL_OPTS=\"--diff\"\n\nto your `.bashrc` then,
  by default, all files will be\n*incrementally checked* unless you run with the overriding\n`--full`
  flag (see below).\n\nIncremental Checking\n--------------------\n\nLiquidHaskell
  supports *incremental* checking where each run only checks\nthe part of the program
  that has been modified since the previous run.\n\n    $ liquid --diff foo.hs\n\nEach
  run of `liquid` saves the file to a `.bak` file and the *subsequent*\nrun\n    +
  does a `diff` to see what has changed w.r.t. the `.bak` file\n    + only generates
  constraints for the `[CoreBind]` corresponding to the\n       changed top-level
  binders and their transitive dependencies.\n\nThe time savings are quite significant.
  For example:\n\n    $ time liquid --notermination -i . Data/ByteString.hs > log
  2>&1\n\n    real\t7m3.179s\n    user\t4m18.628s\n    sys\t    0m21.549s\n\nNow if
  you go and tweak the definition of `spanEnd` on line 1192 and re-run:\n\n    $ time
  liquid -d --notermination -i . Data/ByteString.hs > log 2>&1\n\n    real\t0m11.584s\n
  \   user\t0m6.008s\n    sys\t    0m0.696s\n\nThe diff is only performed against
  **code**, i.e. if you only change\nspecifications, qualifiers, measures, etc. `liquid
  -d` will not perform\nany checks. In this case, you may specify individual definitions
  to verify:\n\n    $ liquid -b bar -b baz foo.hs\n\nThis will verify `bar` and `baz`,
  as well as any functions they use.\n\nIf you always want to run a given file with
  diff-checking, add\nthe pragma:\n\n    {-@ LIQUID \"--diff\" @-}\n\n\nFull Checking
  (DEFAULT)\n-----------------------\n\nTo force LiquidHaskell to check the **whole**
  file (DEFAULT), use:\n\n    $ liquid --full foo.hs\n\nto the file. This will override
  any other `--diff` incantation\nelsewhere (e.g. inside the file.)\n\n\nIf you always
  want to run a given file with full-checking, add\nthe pragma:\n\n    {-@ LIQUID
  \"--full\" @-}\n\nSpecifying Different SMT Solvers\n--------------------------------\n\nBy
  default, LiquidHaskell uses the SMTLIB2 interface for Z3.\n\nTo run a different
  solver (supporting SMTLIB2) do:\n\n    $ liquid --smtsolver=NAME foo.hs\n\nCurrently,
  LiquidHaskell supports\n\n+ [CVC4](http://cvc4.cs.nyu.edu/)\n+ [MathSat](http://mathsat.fbk.eu/download.html
  )\n\nTo use these solvers, you must install the corresponding binaries\nfrom the
  above web-pages into your `PATH`.\n\nYou can also build and link against the Z3
  API (faster but requires more\ndependencies). If you do so, you can use that interface
  with:\n\n    $ liquid --smtsolver=z3mem foo.hs\n\n\nShort Error Messages\n--------------------\n\nBy
  default, subtyping error messages will contain the inferred type, the\nexpected
  type -- which is **not** a super-type, hence the error -- and a\ncontext containing
  relevant variables and their type to help you understand\nthe error. If you don't
  want the above and instead, want only the\n**source position** of the error use:\n\n
  \   --short-errors\n\nShort (Unqualified) Module Names\n-------------------------------\n\nBy
  default, the inferred types will have fully qualified module names.\nTo use unqualified
  names, much easier to read, use:\n\n    --short-names\n\n\nTotality Check\n--------------\n\nLiquidHaskell
  proves the absence of pattern match failures.\n\nFor example, the definition\n\n
  \   fromJust :: Maybe a -> a\n    fromJust (Just a) = a\n\nis not total and it will
  create an error message.\nIf we exclude `Nothing` from its domain, for example using
  the following specification\n\n    {-@ fromJust :: {v:Maybe a | (isJust v)} -> a
  @-}\n\n`fromJust` will be safe.\n\nUse the `no-totality` flag to disable totality
  checking.\n\n    liquid --no-totality test.hs\n\nTermination Check\n-----------------\n\nBy
  **default** a termination check is performed on all recursive functions.\n\nUse
  the `no-termination` option to disable the check\n\n    liquid --no-termination
  test.hs\n\nIn recursive functions the *first* algebraic or integer argument should
  be decreasing.\n\nThe default decreasing measure for lists is length and Integers
  its value.\n\nThe user can specify the decreasing measure in data definitions:\n\n
  \   {-@ data L [llen] a = Nil | Cons (x::a) (xs:: L a) @-}\n\nDefines that `llen`
  is the decreasing measure (to be defined by the user).\n\nFor example, in the function
  `foldl`\n\n    foldl k acc N           = acc\n    foldl k acc (Cons x xs) = foldl
  k (x `k` acc) xs\n\nby default the *second* argument (the first non-function argument)
  will be\nchecked to be decreasing. However, the explicit hint\n\n    {-@ Decrease
  foo 3 @-}\n\ntells LiquidHaskell to instead use the *third* argument.\n\nApart from
  specifying a specific decreasing measure for an Algebraic Data Type,\nthe user can
  specify that the ADT follows the expected decreasing measure by\n\n    {-@ autosize
  L @-}\n\nThen, LiquidHaskell will define an instance of the function `autosize`
  for `L` that decreases by 1 at each recursive call and use `autosize` at functions
  that recurse on `L`.\n\nFor example, `autosize L` will refine the data constructors
  of `L a` with the `autosize :: a -> Int` information, such that\n\n    Nil  :: {v:L
  a | autosize v = 0}\n    Cons :: x:a -> xs:L a -> {v:L a | autosize v = 1 + autosize
  xs}\n\nAlso, an invariant that `autosize` is non negative will be generated\n\n
  \   invariant  {v:L a| autosize v >= 0 }\n\nThis information is all LiquidHaskell
  needs to prove termination on functions that recurse on `L a` (on ADTs in general.)\n\n\nTo
  *disable* termination checking for `foo` that is, to *assume* that it\nis terminating
  (possibly for some complicated reason currently beyond the\nscope of LiquidHaskell)
  you can write\n\n    {-@ Lazy foo @-}\n\nSome functions do not decrease on a single
  argument, but rather a\ncombination of arguments, e.g. the Ackermann function.\n\n
  \   ack m n\n      | m == 0          = n + 1\n      | m > 0 && n == 0 = ack (m-1)
  1\n      | m > 0 && n >  0 = ack (m-1) (ack m (n-1))\n\nIn all but one recursive
  call `m` decreases, in the final call `m`\ndoes not decrease but `n` does. We can
  capture this notion of \"x\nnormally decreases, but if it does not, y will\" with
  an extended\nannotation\n\n    {-@ Decrease ack 1 2 @-}\n\nAn alternative way to
  express this specification is by annotating\nthe function's type with the appropriate
  *numeric* decreasing expressions.\nAs an example, you can give `ack` a type\n\n
  \   {-@ ack :: m:Nat -> n:Nat -> Nat / [m,n] @-}\n\nstating that the *numeric* expressions
  `[m, n]` are lexicographically decreasing.\n\nDecreasing expressions can be arbitrary
  refinement expressions, e.g.,\n\n    {-@ merge :: Ord a => xs:[a] -> ys:[a] -> [a]
  / [(len xs) + (len ys)] @-}\n\nstates that at each recursive call of `merge` the
  sum of the lengths\nof its arguments will be decreased.\n\nWhen dealing with mutually
  recursive functions you may run into a\nsituation where the decreasing parameter
  must be measured *across* a\nseries of invocations, e.g.\n\n    even 0 = True\n
  \   even n = odd (n-1)\n\n    odd  n = not $ even n\n\nIn this case, you can introduce
  a ghost parameter that orders the *functions*\n\n    even 0 _ = True\n    even n
  _ = odd (n-1) 1\n\n    odd  n _ = not $ even n 0\n\nthus recovering a decreasing
  measure for the pair of functions, the\npair of arguments. This can be encoded with
  the lexicographic\ntermination annotation `{-@ Decrease even 1 2 @-}` (see\n[tests/pos/mutrec.hs](tests/pos/mutrec.hs)
  for the full example).\n\n\n\nTotal Haskell\n--------------\n\nLiquidHaskell provides
  a total Haskell flag that checks both totallity and termination of the program,\noverriding
  a potential no-termination flag.\n\n    liquid --total-Haskell test.hs\n\n\nLazy
  Variables\n--------------\n\nA variable can be specified as `LAZYVAR`\n\n    {-@
  LAZYVAR z @-}\n\nWith this annotation the definition of `z` will be checked at the
  points where\nit is used. For example, with the above annotation the following code
  is SAFE:\n\n    foo   = if x > 0 then z else x\n      where\n        z = 42 `safeDiv`
  x\n        x = choose 0\n\nBy default, all the variables starting with `fail` are
  marked as LAZY, to defer\nfailing checks at the point where these variables are
  used.\n\nNo measure fields\n------------------\n\nWhen a data type is refined, Liquid
  Haskell automatically turns the data constructor fields into measures.\nFor example,\n\n
  \  {-@ data L a = N | C {hd :: a, tl :: L a} @-}\n\nwill automatically create two
  measures `hd` and `td`.\nTo deactivate this automatic measure definition, and speed
  up verification, you can use the `no-measure-fields` flag.\n\n  liquid --no-measure-fields
  test.hs\n\n\n\nPrune Unsorted Predicates\n-------------------------\n\nConsider
  a measure over lists of integers\n\n  sum :: [Int] -> Int\n  sum [] = 0 \n  sum
  (x:xs) = 1 + sum xs \n\nThis measure will translate into strengthening the types
  of list constructors \n\n  [] :: {v:[Int] | sum v = 0 }\n  (:) :: x:Int -> xs:[Int]
  -> {v:[Int] | sum v = x + sum xs}\n\nBut what if our list is polymorphic `[a]` and
  later instantiate to list of ints?\nThe hack we do right now is to strengthen the
  polymorphic list with the `sum` information \n\n  [] :: {v:[a] | sum v = 0 }\n  (:)
  :: x:a -> xs:[a] -> {v:[a] | sum v = x + sum xs}\n\nBut for non numeric `a`s, expressions
  like `x + sum xs` is unsorted causing the logic to crash. \nWe use the flag `--prune-unsorted`
  to prune away unsorted expressions (like `x + sum xs`) in the logic. \n\n\n    liquid
  --prune-unsorted test.hs\n\n\nCase Expansion\n-------------------------\n\nBy default
  LiquidHaskell expands all data constructors to the case statements.\nFor example,\nif
  `F = A1 | A2 | .. | A10`,\nthen LiquidHaskell will expand the code\n`case f of {A1
  -> True; _ -> False}`\nto `case f of {A1 -> True; A2 -> False; ...; A10 -> False}`.\nThis
  expansion can lead to more precise code analysis\nbut it can get really expensive
  due to code explosion.\nThe `no-case-expand` flag prevents this expansion and keeps
  the user\nprovided cases for the case expression.\n\n    liquid --no-case-expand
  test.hs\n\n\nHigher order logic\n-------------------\nThe flag `--higherorder` allows
  reasoning about higher order functions.\n\n\nRestriction to Linear Arithmetic\n---------------------------------\nWhen
  using `z3` as the solver, LiquidHaskell allows for non-linear arithmetic:\ndivision
  and multiplication on integers are interpreted by `z3`. To treat division\nand multiplication
  as uninterpreted functions use the `linear` flag\n\n    liquid --linear test.hs\n\nCounter
  examples (Experimental!)\n--------------------------------\nWhen given the `--counter-examples`
  flag, LiquidHaskell will attempt to produce\ncounter-examples for the type errors
  it discovers. For example, see\n[tests/neg/ListElem.hs](https://github.com/ucsd-progsys/liquidhaskell/blob/master/tests/neg/ListElem.hs)\n\n```\n%
  liquid --counter-examples tests/neg/ListElem.hs\n\n...\n\ntests/neg/ListElem.hs:12:1-8:
  Error: Liquid Type Mismatch\n\n 12 | listElem _ []      = False\n      ^^^^^^^^\n\n
  \  Inferred type\n     VV : {VV : Bool | VV == True}\n     VV = True\n\n   not a
  subtype of Required type\n     VV : {VV : Bool | Prop VV <=> Set_mem ?b (listElts
  ?a)}\n\n   In Context\n     ?a : {?a : [a] | len ?a >= 0}\n     ?a = [1]\n\n     ?b
  : a\n     ?b = 0\n```\n\nThe `--counter-examples` flag requires that each type in
  the context be\nan instance of `GHC.Generics.Generic` or `Test.Targetable.Targetable`\n(provided
  as part of LiquidHaskell).  LiquidHaskell cannot generate\ncounter-examples for
  polymorphic types, but will try (naively) to\ninstantiate type variables with `Int`
  (as seen in the example above).\n\nWriting Specifications\n======================\n\nModules
  WITHOUT code\n--------------------\n\nWhen checking a file `target.hs`, you can
  specify an _include_ directory by\n\n    liquid -i /path/to/include/  target.hs\n\nNow,
  to write specifications for some **external module** `Foo.Bar.Baz` for which\nyou
  **do not have the code**, you can create a `.spec` file at:\n\n    /path/to/include/Foo/Bar/Baz.spec\n\nSee,
  for example, the contents of\n\n+ [include/Prelude.spec](https://github.com/ucsd-progsys/liquidhaskell/blob/master/include/Prelude.spec)\n+
  [include/Data/List.spec](https://github.com/ucsd-progsys/liquidhaskell/blob/master/include/Data/List.spec)\n+
  [include/Data/Vector.spec](https://github.com/ucsd-progsys/liquidhaskell/blob/master/include/Data/Vector.spec)\n\n**Note**:\n\n+
  The above directories are part of the LH prelude, and included by\n  default when
  running `liquid`.\n+ The `.spec` mechanism is *only for external modules** without
  code,\n  see below for standalone specifications for **internal** or **home** modules.\n\n\nModules
  WITH code: Data\n-----------------------\n\nWrite the specification directly into
  the .hs or .lhs file,\nabove the data definition. See, for example, [tests/pos/Map.hs](tests/pos/Map.hs)\n\n
  \   {-@\n    data Map k a <l :: k -> k -> Prop, r :: k -> k -> Prop>\n      = Tip\n
  \     | Bin (sz    :: Size)\n            (key   :: k)\n            (value :: a)\n
  \           (left  :: Map <l, r> (k <l key>) a)\n            (right :: Map <l, r>
  (k <r key>) a)\n    @-}\n    data Map k a = Tip\n                 | Bin Size k a
  (Map k a) (Map k a)\n\nYou can also write invariants for data type definitions\ntogether
  with the types. For example, see [tests/pos/record0.hs](tests/pos/record0.hs)\n\n
  \   {-@ data LL a = BXYZ { size  :: {v: Int | v > 0 }\n                         ,
  elems :: {v: [a] | (len v) = size }\n                         }\n    @-}\n\nFinally
  you can specify the variance of type variables for data types.\nFor example, see
  [tests/pos/Variance.hs](tests/pos/Variance.hs), where data type `Foo` has four\ntype
  variables `a`, `b`, `c`, `d`, specified as invariant, bivariant,\ncovariant and
  contravariant, respectively.\n\n    data Foo a b c d\n    {-@ data variance Foo
  invariant bivariant covariant contravariant @-}\n\n\nModules WITH code: Functions\n----------------------------\n\nWrite
  the specification directly into the .hs or .lhs file,\nabove the function definition.
  [For example](tests/pos/spec0.hs)\n\n    {-@ incr :: x:{v: Int | v > 0} -> {v: Int
  | v > x} @-}\n    incr   :: Int -> Int\n    incr x = x + 1\n\nModules WITH code:
  Type Classes\n-------------------------------\n\nWrite the specification directly
  into the .hs or .lhs file,\nabove the type class definition. [For example](tests/pos/Class.hs)\n\n
  \   {-@ class Sized s where\n          size :: forall a. x:s a -> {v:Int | v = (size
  x)}\n    @-}\n    class Sized s where\n      size :: s a -> Int\n\nAny measures
  used in the refined class definition will need to be\n*generic* (see [Specifying
  Measures](#specifying-measures)).\n\n\nAs an alternative, you can refine class instances.\n[For
  example](tests/pos/LiquidClass.hs)\n\n~~~~\ninstance Compare Int where\n\n{-@ instance
  Compare Int where\n    cmax :: Odd -> Odd -> Odd\n  @-}\n\ncmax y x = if x >= y
  then x else y\n~~~~\n\nWhen `cmax` method is used on `Int`, liquidHaskell will give
  it\nthe refined type `Odd -> Odd -> Odd`.\n\nNote that currently liquidHaskell does
  not allow refining instances of\nrefined classes.\n\nModules WITH code: QuasiQuotation\n---------------------------------\n\nInstead
  of writing both a Haskell type signature *and* a\nLiquidHaskell specification for
  a function, the `lq`\nquasiquoter in the `LiquidHaskell` module can be used\nto
  generate both from just the LiquidHaskell specification.\n\n```haskell\nmodule Nats
  (nats) where\n\n{-@ nats :: [{v:Int | 0 <= v}] @-}\nnats :: [Int]\nnats = [1,2,3]\n```\n\ncan
  be written as\n\n```haskell\n{-# LANGUAGE QuasiQuotes #-}\nmodule Nats (nats) where\n\nimport
  LiquidHaskell\n\n[lq| nats :: [{v:Int | 0 <= v}] |]\nnats = [1,2,3]\n```\n\nand
  the `lq` quasiquoter will generate the plain `nats :: [Int]` when GHC\ncompiles
  the module.\n\nRefined type aliases (see the next section) can also be written inside
  `lq`; for\nexample:\n\n```haskell\n{-# LANGUAGE QuasiQuoters #-}\nmodule Nats (Nat,
  nats) where\n\n[lq| type Nat = {v:Int | 0 <= v} |]\n\n[lq| nats :: [Nat] |]\nnats
  = [1,2,3]\n```\n\nHere, the `lq` quasiquoter will generate a plain Haskell\ntype
  synonym for `Nat` as well as the refined one.\n\nNote that this is still an experimental
  feature, and\ncurrently requires that one depend on LiquidHaskell\nas a build dependency
  for your project; the quasiquoter\nwill be split out eventually into an independent,\ndependency-light
  package. Also, at this time, writing\na type inside `lq` which refers to a refined
  type alias\nfor which there is not a plain Haskell type synonym of the\nsame name
  will result in a \"not in scope\" error from GHC.\n\nStandalone Specifications for
  Internal Modules\n----------------------------------------------\n\nRecall that
  the `.spec` mechanism is only for modules whose\ncode is absent; if code is present
  then there can be multiple,\npossibly conflicting specifications. Nevertheless,
  you may want,\nfor one reason or another, to write (assumed) specifications\noutside
  the file implementing the module.\n\nYou can do this as follows.\n\n`Lib.hs`\n\n```haskell\nmodule
  Lib (foo) where\n\nfoo a = a\n```\n\nnow, instead of a `.spec` file, just use a
  haskell module, e.g. `LibSpec.hs`\n\n```haskell\nmodule LibSpec ( module Lib ) where\n\nimport
  Lib\n\n-- Don't forget to qualify the name!\n\n{-@ Lib.foo :: {v:a | false} -> a
  @-}\n```\n\nand then here's `Client.hs`\n\n```haskell\nmodule Client where\n\nimport
  Lib      -- use this if you DON'T want the spec\nimport LibSpec  -- use this if
  you DO want the spec, in addition to OR instead of the previous import.\n\nbar =
  foo 1     -- if you `import LibSpec` then this call is rejected by LH\n```\nRefinement
  Type Aliases\n-----------------------\n\n#### Predicate Aliases\n\nOften, the propositions
  in the refinements can get rather long and\nverbose. You can write predicate aliases
  like so:\n\n    {-@ predicate Lt X Y = X < Y        @-}\n    {-@ predicate Ge X
  Y = not (Lt X Y) @-}\n\nand then use the aliases inside refinements, [for example](tests/pos/pred.hs)\n\n
  \   {-@ incr :: x:{v:Int | (Pos v)} -> { v:Int | ((Pos v) && (Ge v x))} @-}\n    incr
  :: Int -> Int\n    incr x = x + 1\n\nSee [Data.Map](benchmarks/esop2013-submission/Base.hs)
  for a more substantial\nand compelling example.\n\n**Syntax:** The key requirements
  for type aliases are:\n\n- Value parameters are specified in **upper**case: `X`,
  `Y`, `Z` etc.\n\n\n#### Type Aliases\n\n\nSimilarly, it is often quite tedious to
  keep writing\n\n    {v: Int | v > 0}\n\nThus, LiquidHaskell supports refinement-type
  aliases of the form:\n\n    {-@ type Gt      N = {v: Int | N <  v} @-}\n    {-@
  type GeNum a N = {v: a   | N <= v} @-}\n\nor\n\n    {-@ type SortedList a = [a]<{\\fld
  v -> (v >= fld)}> @-}\n\nor\n\n    {-@ type OMap k a = Map <{\\root v -> v < root},
  {\\root v -> v > root}> k a @-}\n\nor\n\n    {-@ type MinSPair a = (a, OSplay a)
  <\\fld -> {v : Splay {v:a|v>fld} | 0=0}> @-}\n\nand then use the above in signatures
  like:\n\n    {-@ incr: x: Int -> GeNum Int x @-}\n\nor\n\n    {-@ incr: x: Int ->
  Gt x @-}\n\nand:\n\n    {-@ assert insert :: (Ord a) => a -> SortedList a -> SortedList
  a @-}\n\nsee [tests/pos/ListSort.hs](tests/pos/ListSort.hs)\n\nand:\n\n    {-@ assert
  insert :: (Ord k) => k -> a -> OMap k a -> OMap k a @-}\n\nsee [tests/pos/Map.hs](tests/pos/Map.hs)\n\n**Syntax:**
  The key requirements for type aliases are:\n\n1. Type parameters are specified in
  **lower**case: `a`, `b`, `c` etc.\n2. Value parameters are specified in **upper**case:
  `X`, `Y`, `Z` etc.\n\n\nInfix Logic Operators\n---------------------\n\nYou can
  define infix operators in logic, following [Haskell's infix notation](Build in Haskell
  ops https://www.haskell.org/onlinereport/decls.html#fixity).\nFor example, if (+++)
  is defined as a measure or reflected function, you can use it infix by declaring\n\n
  \  {-@ infixl 9 +++ @-}\n\n\nNote: infix operators cannot contain the dot character
  `.`.\n\n\nSpecifying Measures\n-------------------\n\nCan be placed in .spec file
  or in .hs/.lhs file wrapped around `{-@ @-}`\n\nValue measures: [include/GHC/Base.spec](include/GHC/Base.spec)\n\n
  \   measure len :: forall a. [a] -> GHC.Types.Int\n    len ([])     = 0\n    len
  (y:ys)   = 1 + len(ys)\n\nPropositional measures: [tests/pos/LambdaEval.hs](tests/pos/LambdaEval.hs)\n\n
  \   {-@\n    measure isValue      :: Expr -> Bool\n    isValue (Const i)    = true\n
  \   isValue (Lam x e)    = true\n    isValue (Var x)      = false\n    isValue (App
  e1 e2)  = false\n    isValue (Plus e1 e2) = false\n    isValue (Fst e)      = false\n
  \   isValue (Snd e)      = false\n    isValue (Pair e1 e2) = ((? (isValue(e1)))
  && (? (isValue(e2))))\n    @-}\n\nRaw measures: [tests/pos/meas8.hs](tests/pos/meas8.hs)\n\n
  \   {-@ measure rlen :: [a] -> Int\n    rlen ([])   = {v | v = 0}\n    rlen (y:ys)
  = {v | v = (1 + rlen(ys))}\n    @-}\n\nGeneric measures: [tests/pos/Class.hs](tests/pos/Class.hs)\n\n
  \   {-@ class measure size :: a -> Int @-}\n    {-@ instance measure size :: [a]
  -> Int\n        size ([])   = 0\n        size (x:xs) = 1 + (size xs)\n    @-}\n
  \   {-@ instance measure size :: Tree a -> Int\n        size (Leaf)       = 0\n
  \       size (Node x l r) = 1 + (size l) + (size r)\n    @-}\n\n**Note:** Measure
  names **do not** have to be the same as\nfield name, e.g. we could call the measure
  `sz` in the above\nas shown in [tests/pos/Class2.hs](tests/pos/Class2.hs).\n\n\nHaskell
  Functions as Measures (beta): [tests/pos/HaskellMeasure.hs](tests/pos/HaskellMeasure.hs)\n\nInductive
  Haskell Functions from Data Types to some type can be lifted to logic\n\n    {-@
  measure llen @-}\n    llen        :: [a] -> Int\n    llen []     = 0\n    llen (x:xs)
  = 1 + llen xs\n\nThe above definition\n  - refines list's data constructors types
  with the llen information, and\n  - specifies a singleton type for the haskell function\n
  \       `llen :: xs:[a] -> {v:Int | v == llen xs}`\n    If the user specifies another
  type for llen, say\n        `llen :: xs:[a] -> {v:Int | llen xs >= 0}`\n    then
  the auto generated singleton type is overwritten.\n\nSelf-Invariants\n===============\n\nSometimes,
  we require specifications that allow *inner* components of a\ntype to refer to the
  *outer* components, typically, to measure-based\nproperties of outer components.
  For example, the following invariant\nabout `Maybe` values\n\n    {-@ type IMaybe
  a = {v0 : Maybe {v : a | ((isJust v0) && v = (fromJust v0))} | 0 = 0 } @-}\n\nstates
  that the *inner* `a` enjoys the property that the *outer* container\nis definitely
  a `Just` and furthermore, the inner value is exactly the same\nas the `fromJust`
  property of the outer container.\n\nAs another example, suppose we have a [measure](include/Data/Set.spec):\n\n
  \   measure listElts :: [a] -> (Set a)\n    listElts([])   = {v | (? Set_emp(v))}\n
  \   listElts(x:xs) = {v | v = Set_cup(Set_sng(x), listElts(xs)) }\n\nNow, all lists
  enjoy the property\n\n    {-@ type IList a = {v0 : List  {v : a | (Set_mem v (listElts
  v0)) } | true } @-}\n\nwhich simply states that each *inner* element is indeed,
  a member of the\nset of the elements belonging to the entire list.\n\nOne often
  needs these *circular* or *self* invariants to connect different\nlevels (or rather,
  to *reify* the connections between the two levels.) See\n[this test](tests/pos/maybe4.hs)
  for a simple example and `hedgeUnion` and\n[Data.Map.Base](benchmarks/esop2013-submission/Base.hs)
  for a complex one.\n\n\n\nAbstract and Bounded Refinements\n================================\n\nThis
  is probably the best example of the abstract refinement syntax:\n\n+ [Abstract Refinements](tests/pos/Map.hs)\n+
  [Bounded Refinements](benchmarks/icfp15/pos/Overview.lhs)\n\nUnfortunately, the
  best documentation for these two advanced features\nis the relevant papers at\n\n+
  [ESOP 2013](https://ranjitjhala.github.io/static/abstract_refinement_types.pdf)\n+
  [ICFP 2015](https://arxiv.org/abs/1507.00385)\n\nThe bounds correspond to Horn implications
  between abstract refinements,\nwhich, as in the classical setting, correspond to
  subtyping constraints\nthat must be satisfied by the concrete refinements used at
  any call-site.\n\nDependent Pairs\n===============\nDependent Pairs are expressed
  by binding the initial tuples of the pair. For example \n`incrPair` defines an increasing
  pair.\n\n    {-@ incrPair :: Int -> (x::Int, {v:Int | x <= v}) @-}\n    incrPair
  i = (i, i+1)\n\nInternally dependent pairs are implemented using abstract refinement
  types. \nThat is `(x::a, {v:b | p x})` desugars to `(a,b)<\\x -> {v:b | p x}>`.\n\nInvariants\n==========\n\nLH
  lets you locally associate invariants with specific data types.\n\nFor example,
  in [tests/pos/StreamInvariants.hs](tests/pos/StreamInvariants.hs) every\nlist is
  treated as a Stream. To establish this local invariant one can use the\n`using`
  declaration\n\n    {-@ using ([a]) as  {v:[a] | (len v > 0)} @-}\n\ndenoting that
  each list is not empty.\n\nThen, LiquidHaskell will prove that this invariant holds,
  by proving that *all\ncalls* to List's constructors (ie., `:` and `[]`) satisfy
  it, and\nwill assume that each list element that is created satisfies\nthis invariant.\n\nWith
  this, at the [above](tests/neg/StreamInvariants.hs) test LiquidHaskell\nproves that
  taking the `head` of a list is safe.\nBut, at [tests/neg/StreamInvariants.hs](tests/neg/StreamInvariants.hs)
  the usage of\n`[]` falsifies this local invariant resulting in an \"Invariant Check\"
  error.\n\n\n**WARNING:** There is an older _global_ invariant mechanism that \nattaches
  a refinement to a datatype globally.\nDo not use this mechanism -- it is *unsound*
  and about to \ndeprecated in favor of something that is [actually sound](https://github.com/ucsd-progsys/liquidhaskell/issues/126)\n\nForexample,
  \ the length of a list cannot be negative\n\n    {-@ invariant {v:[a] | (len v >=
  0)} @-}\n\nLiquidHaskell can prove that this invariant holds, by proving that all
  List's\nconstructors (ie., `:` and `[]`) satisfy it.(TODO!) Then, LiquidHaskell
  \nassumes that each list element that is created satisfies\nthis invariant.\n\nFormal
  Grammar of Refinement Predicates\n=======================================\n\n(C)onstants\n-----------\n\n
  \   c := 0, 1, 2, ...\n\n(V)ariables\n-----------\n\n    v := x, y, z, ...\n\n\n(E)xpressions\n-------------\n\n
  \   e := v                      -- variable\n       | c                      --
  constant\n       | (e + e)                -- addition\n       | (e - e)                --
  subtraction\n       | (c * e)                -- multiplication by constant\n       |
  (v e1 e2 ... en)       -- uninterpreted function application\n       | (if p then
  e else e)   -- if-then-else\n\n(R)elations\n-----------\n\n    r := ==               --
  equality\n       | /=               -- disequality\n       | >=               --
  greater than or equal\n       | <=               -- less than or equal\n       |
  >                -- greater than\n       | <                -- less than\n\n\n(P)redicates\n------------\n\n
  \   p := (e r e)          -- binary relation\n       | (v e1 e2 ... en) -- predicate
  (or alias) application\n       | (p && p)         -- and\n       | (p || p)         --
  or\n       | (p => p)         -- implies\n       | (not p)          -- negation\n
  \      | true\n       | false\n\n\nSpecifying Qualifiers\n=====================\n\nThere
  are several ways to specify qualifiers.\n\nBy Separate `.hquals` Files\n---------------------------\n\nYou
  can write qualifier files e.g. [Prelude.hquals](include/Prelude.hquals)\n\nIf a
  module is called or imports\n\n    Foo.Bar.Baz\n\nThen the system automatically
  searches for\n\n    include/Foo/Bar/Baz.hquals\n\nBy Including `.hquals` Files\n----------------------------\n\nAdditional
  qualifiers may be used by adding lines of the form:\n\n    {-@ include <path/to/file.hquals>
  @-}\n\nto the Haskell source. See, [this](tests/pos/meas5.hs) for example.\n\n\nIn
  Haskell Source or Spec Files\n-------------------------------\n\nFinally, you can
  specifiers directly inside source (.hs or .lhs) or spec (.spec)\nfiles by writing
  as shown [here](tests/pos/qualTest.hs)\n\n    {-@ qualif Foo(v:Int, a: Int) : (v
  = a + 100)   @-}\n\n\n**Note** In addition to these, LiquidHaskell scrapes qualifiers
  from all\nthe specifications you write i.e.\n\n1. all imported type signatures,\n2.
  measure bodies and,\n3. data constructor definitions.\n\n\nGenerating HTML Output\n======================\n\nThe
  system produces HTML files with colorized source, and mouseover\ninferred type annotations,
  which are quite handy for debugging failed\nverification attempts.\n\n- **Regular
  Haskell** When you run: `liquid foo.hs` you get a file\n  `foo.hs.html` with the
  annotations. The coloring is done using\n  `hscolour`.\n\n- **Markdown + Literate
  Haskell** You can also feed in literate haskell files\n  where the comments are
  in [Pandoc markdown](http://johnmacfarlane.net/pandoc/demo/example9/pandocs-markdown.html).\n
  \ In this case, the tool will run `pandoc` to generate the HTML from the comments.\n
  \ Of course, this requires that you have `pandoc` installed as a binary on\n  your
  system. If not, `hscolour` is used to render the HTML.\n\n  It is also possible
  to generate *slide shows* from the above.\n  See the [slides directory](docs/slides)
  for an example.\n\nEditor Integration\n==================\n\n+ [Emacs/Flycheck](https://github.com/ucsd-progsys/liquid-types.el)\n+
  [Vim/Syntastic](https://github.com/ucsd-progsys/liquid-types.vim)\n\nCommand Line
  Options\n====================\n\nTo see all options, run `liquid --help`. Here are
  some common options:\n\n- `--cabaldir` will automatically find a .cabal file in
  the ancestor\n  path from which the target file belongs, and then add the relevant\n
  \ source and dependencies to the paths searched for by LiquidHaskell.\n\n  This
  means we don't have to manually do `-i src` etc. when checking\n  large projects,
  which can be tedious e.g. within emacs.\n\n- `--diff` performs differential checking,
  i.e. only checks those binders\n  that have transitively affected by edits since
  the previous check.\n  Can speed things up greatly during editing.\n\n- `--short-names`
  prints out non-qualified names i.e. `Int` instead of\n  `GHC.Types.Int` for inferred
  type annotations and error messages.\n\n**Pragmas** are useful for embedding options
  directly within the source file,\nthat is, somewhere in the file (perhaps at the
  top) put in:\n\n    {-@ LIQUID \"--diff\"        @-}\n    {-@ LIQUID \"--short-names\"
  @-}\n    {-@ LIQUID \"--cabaldir\"    @-}\n\nto have the relevant option be used
  for that file.\n\nGenerating Performance Reports\n------------------------------\n\nWe
  have set up infrastructure to generate performance reports using [Gipeda](https://github.com/nomeata/gipeda).\n\nGipeda
  will generate a static webpage that tracks the performance improvements\nand regressions
  between commits. To generate the site, first ensure you have the\nfollowing dependencies
  available:\n\n* Git\n* Cabal >= 1.18\n* GHC\n* Make\n* Bash (installed at `/bin/bash`)\n\nAfter
  ensuring all dependencies are available, from the Liquid Haskell\ndirectory, execute:\n\n
  \   cd scripts/performance\n    ./deploy-gipeda.bash\n\nThis will download and install
  all the relevant repositories and files. Next, to\ngenerate the performance report,
  use the `generate-site.bash` script. This script\nhas a few options:\n\n* `-s [hash]`:
  Do not attempt to generate performance reports for any commit\nolder than the commit
  specified by the entered git hash\n* `-e [hash]`: Do not attempt to generate performance
  reports for any commit\nnewer than the commit specified by the entered git hash\n*
  `-f`: The default behavior of `generate-site.bash` is to first check if logs\nhave
  been created for a given hash. If logs already exist, `generate-site.bash`\nwill
  not recreate them. Specify this option to skip this check and regenerate\nall logs.\n\nYou
  should expect this process to take a very long time. `generate-site.bash`\nwill
  compile each commit, then run the entire test suite and benchmark suite\nfor each
  commit. It is suggested to provide a manageable range to `generate-site.bash`:\n\n
  \   ./generate-site.bash -s [starting hash] -e [ending hash]\n\n...will generate
  reports for all commits between (inclusive) [starting hash]\nand [ending hash].\n\n
  \   ./generate-site.bash -s [starting hash]\n\n... will generate reports for all
  commits newer than [starting hash]. This command\ncan be the basis for some automated
  report generation process (i.e. a cron job).\n\nFinally, to remove the Gipeda infrastructure
  from your computer, you may execute:\n\n    ./cleanup-gipeda.bash\n\n...which will
  remove any files created by `deploy-gipeda.bash` and `generate-site.bash`\nfrom
  your computer.\n\n\nConfiguration Management\n------------------------\n\nIt is
  very important that the version of Liquid Haskell be maintained properly.\n\nSuppose
  that the current version of Liquid Haskell is `A.B.C.D`:\n\n+ After a release to
  hackage is made, if any of the components `B`, `C`, or `D` are missing, they shall
  be added and set to `0`. Then the `D` component of Liquid Haskell shall be incremented
  by `1`. The version of Liquid Haskell is now `A.B.C.(D + 1)`\n\n+ The first time
  a new function or type is exported from Liquid Haskell, if any of the components
  `B`, or `C` are missing, they shall be added and set to `0`. Then the `C` component
  shall be incremented by `1`, and the `D` component shall stripped. The version of
  Liquid Haskell is now `A.B.(C + 1)`\n\n+ The first time the signature of an exported
  function or type is changed, or an exported function or type is removed (this includes
  functions or types that Liquid Haskell re-exports from its own dependencies), if
  the `B` component is missing, it shall be added and set to `0`. Then the `B` component
  shall be incremented by `1`, and the `C` and `D` components shall be stripped. The
  version of Liquid Haskell is now `A.(B + 1)`\n\n+ The `A` component shall be updated
  at the sole discretion of the project owners.\n\nProof Automation\n----------------\nThe
  `liquidinstances` automatically generates proof terms using symbolic evaluation.
  [See](https://github.com/ucsd-progsys/liquidhaskell/blob/develop/benchmarks/proofautomation/pos/MonoidList.hs).\n\n```\n{-@
  LIQUID \"--automatic-instances=liquidinstances\" @-}\n```\n\nThis flag is **global**
  and will symbolically evaluation all the terms that appear in the specifications.
  \n\nAs an alternative, the `liquidinstanceslocal` flag has local behavior. [See](https://github.com/ucsd-progsys/liquidhaskell/blob/develop/benchmarks/proofautomation/pos/Unification.hs)\n\n```\n{-@
  LIQUID \"--automatic-instances=liquidinstanceslocal\" @-}\n```\n\nwill only evaluate
  terms appearing in the specifications of the function `theorem`, in the function
  `theorem` is annotated \nfor automatic instantiation using the following liquid
  annotation\n\n```\n{-@ automatic-instances theorem @-}\n```\n"
license-name: BSD3
