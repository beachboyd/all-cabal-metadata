homepage: https://hslua.github.io/
changelog-type: markdown
hash: aa52053c949518b1fdbdefe288549b4500864eb4976c8874c7a74c12d93c60bb
test-bench-deps:
  exceptions: ! '>=0.8 && <0.11'
  bytestring: ! '>=0.10.2 && <0.11'
  fail: ! '>=4.9 && <5'
  base: ! '>=4.8 && <5'
  text: ! '>=1.0 && <1.3'
  criterion: ! '>=1.0 && <1.6'
  containers: ! '>=0.5 && <0.7'
  quickcheck-instances: ! '>=0.3'
  tasty-quickcheck: ! '>=0.8'
  mtl: ! '>=2.2 && <2.3'
  tasty-hunit: ! '>=0.9'
  tasty: ! '>=0.11'
  deepseq: ! '>=1.4.1 && <1.5'
  QuickCheck: ! '>=2.7'
  hslua: -any
maintainer: albert+hslua@zeitkraut.de
synopsis: Bindings to Lua, an embeddable scripting language
changelog: ! "## Changelog\n\n### 1.0.1\n\n- Exposed more functions from Lua's `lauxlib`
  library:\n\n  + `getmetafield`,\n  + `getmetatable'`,\n  + `getsubtable`, and\n
  \ + `traceback`.\n\n  The function `getsubtable` is a reimplementation instead of
  a wrapper\n  to the C function for simplicity (thereby avoiding additional C\n  wrappers).\n\n-
  Fixed tests for GHC 8.6 by no longer depending on failable pattern\n  matching.\n\n\n###
  1.0.0\n\n#### New features\n\n- Error handling at language borders has been vastly
  improved and is now\n  mostly automatic. Haskell's `Foreign.Lua.Exception`s are
  transformed\n  into Lua errors and *vice versa*. Lua-side wrappers are no longer\n
  \ necessary.\n\n- Haskell functions are no longer pushed as userdata by\n  `pushHaskellFunction`,
  but as C functions. This simplifies tasks where\n  Lua expects true function objects
  object (for example when looking for\n  module loaders).\n\n- Added stack instance
  for\n\n  + Data.Set.Set,\n  + Integer,\n  + Int,\n  + Float, and\n  + Double.\n\n
  \ Instances for numbers fall back to strings when the\n  representation as a Lua
  number would cause a loss of precision.\n\n- Haskell functions pushed with `pushHaskellFunction`
  can now be\n  garbage collected by Lua without having to call back into\n  Haskell.
  The callback into Haskell by the GC had previously\n  caused programs to hang in
  some situations.\n\n- Bindings to more Lua C API functions and macros: `isinteger`,
  `load`,\n  `loadbuffer`, and `pushglobaltable`.\n\n- Any Haskell value can be pushed
  to the Lua stack as userdata via\n  `pushAny` and retrieved via `peekAny`. Additional
  functions are\n  provided to setup the userdata metatable.\n\n- The C preprocessor
  constants `LUA_LOADED_TABLE` and\n  `LUA_PRELOAD_TABLE` are made available as\n
  \ `loadedTableRegistryField` and `preloadTableRegistryField`,\n  respectively.\n\n-
  Additional small helper functions:\n\n  + `peekRead` -- read value from a string.\n
  \ + `popValue` -- peek value at the top of the Lua stack, then\n    remove it from
  the stack regardless of whether peeking was\n    successful or not.\n\n#### Naming\n\n-
  The *Lua* prefix was removed from types (`State`, `Integer`, `Number`,\n  `Exception`)
  and the respective infix from functions (`try`, `run`,\n  `runWith`, `runEither`).
  HsLua should be imported qualified to avoid\n  name collisions.\n\n- Terminology
  now consistently uses *exception* to refer to Haskell\n  exceptions, and *error*
  for Lua errors; function names changed\n  accordingly (`throwException`, `catchException`,\n
  \ `withExceptionMessage`).\n\n- Module *Foreign.Lua.Api* was renamed to *Foreign.Lua.Core*.\n\n-
  *Foreign.Lua.lerror* was renamed to *Foreign.Lua.error*.\n\n- Typeclass *ToLuaStack*
  was renamed to *Pushable*.\n\n- Typeclass *FromLuaStack* was renamed to *Peekable*.\n\n-
  Cabal flag *use-pkgconfig* was renamed to *pkg-config* (which is the\n   flag name
  used by other projects such a zlib).\n\n\n#### Type signatures\n\n- The return value
  of `lua_newuserdata` is *CSize* (was *CInt*).\n\n- Table index parameter in `rawgeti`
  and `rawseti` must be of type\n  *LuaInteger*, but were of type *Int*.\n\n- The
  number of upvalues passed to `pushcclosure` must be of type\n  *NumArgs*.\n\n- `Lua.error`
  has type *Lua NumResults*, simplifying its use in\n    HaskellFunctions.\n\n- Retrieval
  functions which can fail, i.e. `tocfunction`, `tointeger`,\n  `tonumber`, `tostring`,
  `tothread`, and `touserdata`, use the *Maybe*\n  type to indicate success or failure,
  avoiding the need to perform\n  additional checks.\n\n#### Removed Features\n\n-
  Support for Lua versions before 5.3 has been dropped.\n\n- Support for GHC 7.8 has
  been dropped.\n\n- `wrapHaskellFunction` has been made internal and is no longer\n
  \  exported.\n\n#### Changed behavior\n\n- Peekable instances for numbers and strings
  became more forgiving.\n  Peeking of basic types now follows Lua's default conversion
  rules:\n\n  + numbers can be given as strings, and *vice versa*;\n  + any value
  can be converted into a boolean -- only `nil` and `false`\n    are peeked as `False`,
  all other as `True`.\n\n#### Other\n\n- Many internal improvements and additions
  such as a benchmarking suite,\n  code cleanups, better tests, etc.\n\n### 0.9.5.{1,2}\n\n-
  Relaxed upper bound on *exceptions*.\n\n### 0.9.5\n\n- Provide Optional as a replacement
  for OrNil. Exports of the latter\n  have been fixed.\n- Provide utility function
  `raiseError`: Its argument will be thrown as\n  an error in Lua.\n- Add `modifyLuaError`:
  The function lives in Foreign.Lua.Error and\n  allows to alter error messages. This
  is most useful for amending\n  errors with additional information.\n- Fixed a bug
  in `toList` which left a element on the stack if\n  deserializing that element lead
  to an error. This also affected the\n  FromLuaStack instance for lists.\n- Fixed
  a bug in `pairsFromTable` which left a key-value pair on the\n  stack if either
  of them could not be read into the expected type. This\n  also affected the FromLuaStack
  instance for Map.\n\n### 0.9.4\n\n- Make Lua an instance of MonadMask: MonadMask
  from Control.Monad.Catch\n  allows to mask asynchronous exceptions. This allows
  to define a\n  finalizer for Lua operations.\n- Add functions and constants to refer
  to stack indices: The functions\n  `nthFromBottom`, `nthFromTop` as well as the
  constants `stackTop` and\n  `stackBottom` have been introduced. Numeric constants
  are less clear,\n  and named constants can aid readability.\n- Add type OrNil: This
  type can be used when dealing with optional\n  arguments to Lua functions.\n- Add
  function absindex: it converts the acceptable index `idx` into an\n  equivalent
  absolute index (that is, one that does not depend on the\n  stack top). The function
  calls `lua_absindex` when compiled with Lua\n  5.2 or later; for Lua 5.1, it is
  reimplemented in Haskell.\n- Functions in `tasty` which have been deprecated have
  been replaced\n  with non-deprecated alternatives.\n\n\n### 0.9.3\n\n- Re-export
  more FunctionCalling helpers in `Foreign.Lua`: The typeclass\n  `ToHaskellFunction`
  and the helper function `toHaskellFunction` are\n  useful when working with functions.
  Importing them separately from\n  `Foreign.Lua.FunctionCalling` was an unnecessary
  burden; they are\n  therefor now re-exported by the main module.\n- Export registry-relatd
  constants `refnil` and `noref`: The constants\n  are related to Lua's registry functions
  (`ref` and `unref`).\n- Add helper to convert functions into CFunction: A new helper\n
  \ `wrapHaskellFunction` is provided. It expects a\n  HaskellImportedFunction userdata
  (as produced by\n  `pushHaskellFunction`) on top of the stack and replaces it with
  a C\n  function. The new function converts error values generated with\n  `lerror`
  into Lua errors, i.e. it calls `lua_error`.\n- Add utility function `setglobal'`:
  It works like `setglobal`, but\n  works with packages and nested tables (dot-notation
  only).\n\n### 0.9.2\n\n- Add cabal flag 'export-dynamic': Default behavior is to
  include all symbols in\n  the dynamic symbol table, as this enables users to load
  dynamic lua libraries.\n  However, it is sometimes desirable to disable, e.g., when
  compiling a fully\n  static binary. See jgm/pandoc#3986.\n\n### 0.9.1\n\n- Increase
  user-friendlyness of error messages: The error message returned by\n  `toHaskellFunction`
  hinted at the fact that the failing function is a Haskell\n  function. This is mostly
  unnecessary information and might have confused\n  users.\n\n### 0.9.0\n\n- Added
  cabal flag to allow fully safe garbage collection: Lua garbage\n  collection can
  occur in most of the API functions, even in those usually not\n  calling back into
  haskell and hence marked as optimizable. The effect of this\n  is that finalizers
  which call Haskell functions will cause the program to\n  hang. A new flag `allow-unsafe-gc`
  is introduced and enabled by default.\n  Disabling this flag will mark more C API
  functions as potentially calling back\n  into Haskell. This has a serious performance
  impact.\n- `FromLuaStack` and `ToLuaStack` instances for lazy ByteStrings are added.\n-
  None-string error messages are handled properly: Lua allows error messages to\n
  \ be of any type, but the haskell error handlers expected string values. Tables,\n
  \ booleans, and other non-string values are now handled as well and converted to\n
  \ strings.\n\n### 0.8.0\n\n- Use newtype definitions instead of type aliases for
  LuaNumber and LuaInteger.\n  This makes it easier to ensure the correct numeric
  instances in situations\n  where Lua might have been compiled with 32-bit numbers.\n-
  Instances of `FromLuaStack` and `ToLuaStack` for `Int` are removed. The\n  correctness
  of these instances cannot be guaranteed if Lua was compiled with a\n  non-standard
  integer type.\n\n### 0.7.1\n\n- The flag `lua_32bits` was added to allow users to
  compile Lua for 32-bit\n  systems.\n- When reading a list, throw an error if the
  lua value isn't a table instead of\n  silently returning an empty list.\n\n### 0.7.0\n\n-
  Tuples from pairs to octuples have been made instances of `FromLuaStack` and\n  `ToLuaStack`.\n-
  New functions `dostring` and `dofile` are provided to load and run strings and\n
  \ files in a single step.\n- `LuaStatus` was renamed to `Status`, the *Lua* prefix
  was removed from its\n  type constructors.\n- The constructor `ErrFile` was added
  to `Status`. It is returned by `loadfile`\n  if the file cannot be read.\n- Remove
  unused FFI bindings and unused types, including all functions unsafe to\n  use from
  within Haskell and the library functions added with 0.5.0. Users with\n  special
  requirements should define their own wrappers and raw bindings.\n- The module *Foreign.Lua.Api.SafeBindings*
  was merge into\n  *Foreign.Lua.Api.RawBindings*.\n- FFI bindings are changed to
  use newtypes where sensible, most notably\n  `StackIndex`, `NumArgs`, and `NumResults`,
  but also the newly introduced\n  newtypes `StatusCode`, `TypeCode`, and `LuaBool`.\n-
  Add functions `tointegerx` and `tonumberx` which can be used to get and check\n
  \ values from the stack in a single step.\n- The signature of `concat` was changed
  from `Int -> Lua ()` to\n  `NumArgs -> Lua ()`.\n- The signature of `loadfile` was
  changed from `String -> Lua Int` to\n  `String -> Lua Status`.\n- The type `LTYPE`
  was renamed to `Type`, its constructors were renamed to\n  follow the pattern `Type<Typename>`.
  `LuaRelation` was renamed to\n  `RelationalOperator`, the *Lua* prefix was removed
  from its constructors.\n- Add function `tolist` to allow getting a generic list
  from the stack without\n  having to worry about the overlapping instance with `[Char]`.\n\n\n###
  0.6.0\n\n* Supported Lua Versions now include Lua 5.2 and Lua 5.3. LuaJIT and Lua
  5.1\n  remain supported as well.\n* Flag `use-pkgconfig` was added to allow discovery
  of library and include paths\n  via pkg-config. Setting a specific Lua version flag
  now implies `system-lua`.\n  (Sean Proctor)\n* The module was renamed from `Scripting.Lua`
  to `Foreign.Lua`. The code is now\n  split over multiple sub-modules. Files processed
  with hsc2hs are restricted to\n  Foreign.Lua.Api.\n* A `Lua` monad (reader monad
  over LuaState) is introduced. Functions which took\n  a LuaState as their first
  argument are changed into monadic functions within\n  that monad.\n* Error handling
  has been redesigned completely. A new LuaException was\n  introduced and is thrown
  in unexpected situations. Errors in lua which are\n  leading to a `longjmp` are
  now caught with the help of additional C wrapper\n  functions. Those no longer lead
  to uncontrolled program termination but are\n  converted into a LuaException.\n*
  `peek` no longer returns `Maybe a` but just `a`. A LuaException is thrown if\n  an
  error occurs (i.e. in situtations where Nothing would have been returned\n  previously).\n*
  The `StackValue` typeclass has been split into `FromLuaStack` and\n  `ToLuaStack`.
  Instances not satisfying the law `x == push x *> peek (-1)` have\n  been dropped.\n*
  Documentation of API functions was improved. Most docstrings have been copied\n
  \ from the official Lua manual, enriched with proper markup and links, and\n  changed
  to properly describe hslua specifics when necessary.\n* Example programs have been
  moved to a separate repository.\n* Unused files were removed. (Sean Proctor)\n\n###
  0.5.0\n\n* New raw functions for `luaopen_base`, `luaopen_package`, `luaopen_string`,\n
  \ `luaopen_table`, `luaopen_math`, `luaopen_io`, `luaopen_os`, `luaopen_debug`\n
  \ and their high-level wrappers (with names `openbase`, `opentable` etc.)\n  implemented.\n*
  Remove custom versions of `loadfile` and `loadstring`.\n* Drop support for GHC versions
  < 7.8, avoid compiler warnings.\n* Ensure no symbols are stripped when linking the
  bundled lua interpreter.\n* Simplify `tostring` function definition. (Sean Proctor)\n*
  Explicitly deprecate `strlen`. (Sean Proctor)\n* Add links to lua documentation
  for functions wrapping the official lua C API.\n  (Sean Proctor).\n\n### 0.4.1\n\n*
  Bugfix(#30): `tolist` wasn't popping elements of the list from stack.\n\n### 0.4.0\n\n*
  `pushstring` and `tostring` now uses `ByteString` instead of `[Char]`.\n* `StackValue
  [Char]` instance is removed, `StackValue ByteString` is added.\n* `StackValue a
  => StackValue [a]` instance is added. It pushes a Lua array to\n  the stack. `pushlist`,
  `islist` and `tolist` functions are added.\n* Type errors in Haskell functions now
  propagated differently. See the\n  `Scripting.Lua` documentation for detailed explanation.
  This should fix\n  segfaults reported several times.\n* `lua_error` function is
  removed, it's never safe to call in Haskell.\n\nRelated issues and pull requests:
  #12, #26, #24, #23, #18.\n\n### 0.3.14\n\n* Pkgconf-based setup removed. Cabal is
  now using `extra-libraries` to link with Lua.\n* `luajit` flag is added to link
  hslua with LuaJIT.\n\n### 0.3.13\n\n* Small bugfix related with GHCi running under
  Windows.\n\n### 0.3.12\n\n* `pushrawhsfunction` and `registerrawhsfunction` functions
  are added.\n* `apicheck` flag is added to Cabal package to enable Lua API checking.
  (useful for debugging)\n\n### 0.3.11\n\n* `luaL_ref` and `luaL_unref` functions
  are added.\n"
basic-deps:
  exceptions: ! '>=0.8 && <0.11'
  bytestring: ! '>=0.10.2 && <0.11'
  fail: ! '>=4.9 && <5'
  base: ! '>=4.8 && <5'
  text: ! '>=1.0 && <1.3'
  containers: ! '>=0.5 && <0.7'
  mtl: ! '>=2.2 && <2.3'
all-versions:
- '0.1'
- '0.2'
- '0.3'
- '0.3.2'
- '0.3.3'
- '0.3.4'
- '0.3.5'
- '0.3.6'
- '0.3.6.1'
- '0.3.7'
- '0.3.8'
- '0.3.9'
- '0.3.10'
- '0.3.11'
- '0.3.12'
- '0.3.13'
- '0.4.0'
- '0.4.1'
- '0.5.0'
- '0.6.0'
- '0.7.0'
- '0.7.1'
- '0.8.0'
- '0.9.0'
- '0.9.1'
- '0.9.2'
- '0.9.3'
- '0.9.4'
- '0.9.5'
- '0.9.5.1'
- '0.9.5.2'
- '1.0.0'
- '1.0.1'
author: Gracjan Polak, Ömer Sinan Ağacan
latest: '1.0.1'
description-type: markdown
description: ! "# HsLua – Bindings to Lua, an embeddable scripting language\n\n[![Build
  Status]](https://travis-ci.org/hslua/hslua)\n[![AppVeyor Status]](https://ci.appveyor.com/project/tarleb/hslua-r2y18)\n[![Hackage]](https://hackage.haskell.org/package/hslua)\n\nHsLua
  provides bindings, wrappers, types, and helper functions to bridge\nHaskell and
  Lua.\n\n[Build Status]: https://travis-ci.org/hslua/hslua.svg?branch=master\n[AppVeyor
  Status]: https://ci.appveyor.com/api/projects/status/ldutrilgxhpcau94/branch/master?svg=true\n[Hackage]:
  https://img.shields.io/hackage/v/hslua.svg\n\n\nOverview\n--------\n\n[Lua](https://lua.org)
  is a small, well-designed, embeddable scripting language.\nIt has become the de-facto
  default to make programs extensible and is widely\nused everywhere from servers
  over games and desktop applications up to security\nsoftware and embedded devices.
  This package provides Haskell bindings to Lua,\nenable coders to embed the language
  into their programs, making them scriptable.\n\nHsLua ships with batteries included
  and includes the most recent Lua version\n(i.e., Lua 5.3.5). Cabal flags make it
  easy to compile against a system-wide Lua\ninstallation.\n\n\nInteracting with Lua\n--------------------\n\nHsLua
  provides the `Lua` type to define Lua operations. The operations are\nexecuted by
  calling `run`. A simple \"Hello, World\" program, using the Lua\n`print` function,
  is given below:\n\n``` haskell\nimport Foreign.Lua as Lua\n\nmain :: IO ()\nmain
  = Lua.run prog\n  where\n    prog :: Lua ()\n    prog = do\n      Lua.openlibs  --
  load Lua libraries so we can use 'print'\n      Lua.callFunc \"print\" \"Hello,
  World!\"\n```\n\n### The Lua stack\n\nLua's API is stack-centered: most operations
  involve pushing values to the stack\nor receiving items from the stack. E.g., calling
  a function is performed by\npushing the function onto the stack, followed by the
  function arguments in the\norder they should be passed to the function. The API
  function `call` then\ninvokes the function with given numbers of arguments, pops
  the function and\nparameters of the stack, and pushes the results.\n\n    ,----------.\n
  \   |  arg 3   |\n    +----------+\n    |  arg 2   |\n    +----------+\n    |  arg
  1   |\n    +----------+                  ,----------.\n    | function |    call
  3 1      | result 1 |\n    +----------+   ===========>   +----------+\n    |          |
  \                 |          |\n    |  stack   |                  |  stack   |\n
  \   |          |                  |          |\n\nManually pushing and pulling arguments
  can become tiresome, so HsLua makes\nfunction calling simple by providing `callFunc`.
  It uses type-magic to allow\ndifferent numbers of arguments. Think about it as having
  the signature\n\n    callFunc :: String -> a1 -> a2 -> … -> res\n\nwhere the arguments
  `a1, a2, …` must be of a type which can be pushed to the Lua\nstack, and the result-type
  `res` must be constructable from a value on the Lua\nstack.\n\n### Getting values
  from and to the Lua stack\n\nConversion between Haskell and Lua values is governed
  by two type classes:\n\n``` haskell\n-- | A value that can be read from the Lua
  stack.\nclass Peekable a where\n  -- | Check if at index @n@ there is a convertible
  Lua value and\n  --   if so return it.  Throws a @'LuaException'@ otherwise.\n  peek
  :: StackIndex -> Lua a\n```\n\nand\n\n``` haskell\n-- | A value that can be pushed
  to the Lua stack.\nclass Pushable a where\n  -- | Pushes a value onto Lua stack,
  casting it into meaningfully\n  --   nearest Lua type.\n  push :: a -> Lua ()\n```\n\nMany
  basic data types (except for numeric types, see the FAQ) have instances for\nthese
  type classes. New instances can be defined for custom types using the\nfunctions
  in `Foreign.Lua.Core` (also exported in `Foreign.Lua`).\n\n\nBuild flags\n-----------\n\nThe
  following cabal build flags are supported:\n\n- `system-lua`: Use the locally installed
  Lua version instead of the version\n  shipped as part of HsLua.\n\n- `pkg-config`:
  Use *pkg-config* to discover library and include paths. Setting\n  this flag implies
  `system-lua`.\n\n- `allow-unsafe-gc`: Allow optimizations which make Lua's garbage
  collection\n  potentially unsafe; haskell finalizers must be handled with extreme
  care. This\n  is *enabled* per default, as this is rarely a problem in practice.\n\n-
  `apicheck`: Compile Lua with its API checks enabled.\n\n- `lua_32bits`: Compile
  Lua for a 32-bits system (e.g., i386, PowerPC G4).\n\n- `export-dynamic`: Add all
  symbols to dynamic symbol table; disabling this\n  will make it possible to create
  fully static binaries, but renders loading\n  of dynamic C libraries impossible.\n\n\n###
  Example: using a different lua version\n\nTo use a system-wide installed Lua when
  linking hslua as a dependency,\nbuild/install your package using `--constraint=\"hslua
  +system-lua\"`. For\nexample, you can install Pandoc with hslua that uses system-wide
  Lua like\nthis:\n\n``` sh\ncabal install pandoc --constraint=\"hslua +system-lua\"\n```\n\nor
  with stack:\n\n``` sh\nstack install pandoc --flag=hslua:system-lua\n```\n\n\nQ&A\n---\n\n-
  **Can I see some examples?** Basic examples are available in the\n    [*hslua-examples*](https://github.com/hslua/hslua-examples)
  repository.\n\n    A big project build with hslua is [Pandoc](https://pandoc.org),
  the\n    universal document converter. It is written in Haskell and includes a Lua\n
  \   interpreter, enabling programmatic modifications of documents via Lua.\n    Furthermore,
  custom output formats can be defined via Lua scripts.\n\n- **Where are the coroutine
  related functions?** Yielding from a coroutine works\n    via `longjmp`, which plays
  very badly with Haskell's RTS. Tests to get\n    coroutines working with HsLua were
  unsuccessful. No coroutine related\n    functions are exported from the default
  module for that reason. Pull\n    requests intended to fix this are very welcome.\n"
license-name: MIT
