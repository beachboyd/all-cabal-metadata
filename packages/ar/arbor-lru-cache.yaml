homepage: https://github.com/arbor/arbor-lru-cache#readme
changelog-type: markdown
hash: 323eea6f9100c429eb4ccec72862546e4df02a92e47b283efbd6937427cf417d
test-bench-deps:
  stm: -any
  base: ! '>=4.7 && <5'
  hspec: -any
  arbor-lru-cache: -any
  hedgehog: -any
  containers: -any
  lens: -any
  generic-lens: -any
  hw-hspec-hedgehog: -any
maintainer: mayhem@arbor.net
synopsis: ''
changelog: ! '# Changelog for arbor-lru-cache


  ## Unreleased changes

'
basic-deps:
  stm: -any
  base: ! '>=4.7 && <5'
  containers: -any
  lens: -any
  generic-lens: -any
all-versions:
- '0.1.1.0'
author: Arbor Networks
latest: '0.1.1.0'
description-type: markdown
description: ! "# arbor-lru-cache\n\nA thread-safe LRU cache library.\n\n## Example\n\nTo
  use the cache:\n\n```haskell\nmain :: IO\nmain = do\n  -- Provide a configuration
  that includes how many simultaneous in\n  -- flight requests are allowed and now
  many entries the cache can store\n  let config = A.CacheConfig\n        { A.maxRequestsInFlight
  = 1\n        , A.maxOccupancy        = 1\n        }\n\n  -- Create a cache providing
  the config and functions that handle retrieval\n  -- and eviction.\n  cache <- A.makeCache
  config retrieve evict\n\n  -- Perform your lookups\n  _ <- A.lookup 1 cache\n  _
  <- A.lookup 2 cache\n  _ <- A.lookup 3 cache\n\n  return ()\n\n-- Implement value
  retrieval function.  If the same key is looked up multiple\n-- times, the cache
  guarantees that the retrieve function is called only once\n-- for that key up until
  it is evicted.\nretrieve :: Int -> IO String\nretrieve mk = ...\n\n-- Perform any
  cleanup that should occur when an entry is evicted\n-- Please be aware that if your
  code is concurrent, the eviction function may\n-- be called whilst the you code
  is concurrently using a value it has looked up.\n-- Your code is wholly responsible
  for ensuring this case still works.\nevict :: Int -> String -> IO ()\nevict mk mv
  = ...\n```\n"
license-name: MIT
