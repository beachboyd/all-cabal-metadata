homepage: ''
changelog-type: markdown
hash: 9605b3d97ec4d06c40a799a7966b462fd1f2fbbaacce831b73bede5f620b45fb
test-bench-deps:
  base: ! '>=4.9'
  tasty-quickcheck: -any
  tasty-hunit: -any
  tasty: -any
  shh: -any
maintainer: lukec@themk.net
synopsis: Simple shell scripting from Haskell
changelog: |
  # Revision history for shh

  ## 0.3.X.X -- 2019-03-10

  * Changes how lazy reading works. We no longer terminate the process, we
    just close the handles and wait for the process to terminate naturally.

    This eliminates a source of non-determinism

  ## 0.2.X.X -- 2019-01-23

  * Extended the ExecArg typeclass to handle lists.

  ## 0.1.X.X  -- 2018-11-02

  * First version. Released on an unsuspecting world.
basic-deps:
  unix: ! '>=2.7.2 && <2.8'
  split: ! '>=0.2.3 && <0.3'
  base: ! '>=4.11 && <4.13'
  filepath: ! '>=1.4.2 && <1.5'
  process: ! '>=1.6.3 && <1.7'
  async: ! '>=2.2.1 && <2.3'
  containers: ! '>=0.5.11 && <0.7'
  mtl: ! '>=2.2.2 && <2.3'
  hashable: -any
  temporary: -any
  deepseq: ! '>=1.4.3 && <1.5'
  shh: -any
  template-haskell: ! '>=2.13.0 && <2.15'
  directory: ! '>=1.3.1 && <1.4'
all-versions:
- 0.1.0.0
- 0.1.0.1
- 0.1.1.0
- 0.2.0.0
- 0.2.0.1
- 0.2.0.2
- 0.2.0.3
- 0.2.0.4
- 0.2.0.5
- 0.2.0.6
- 0.3.0.0
- 0.3.0.1
- 0.3.1.0
- 0.3.1.1
- 0.3.1.2
- 0.3.1.3
author: Luke Clifton
latest: 0.3.1.3
description-type: markdown
description: "# Shh\n\n[![](https://img.shields.io/hackage/v/shh.svg?colorB=%23999&label=shh)](http://hackage.haskell.org/package/shh)\n[![](https://img.shields.io/hackage/v/shh-extras.svg?colorB=%23999&label=shh-extras)](http://hackage.haskell.org/package/shh-extras)\n[![](https://builds.sr.ht/~lukec/shh/nix.yml.svg)](https://builds.sr.ht/~lukec/shh/nix.yml?)\n[![](https://travis-ci.org/luke-clifton/shh.svg?branch=master)](https://travis-ci.org/luke-clifton/shh)\n\nShh
  is a library to enable convinient shell-like programming in Haskell.\nIt works well
  in scripts, and from GHCi, allowing you to use GHCi as a shell.\n\nIt is also a
  wrapper tool around launching GHCi as a shell.\n\nIt supports\n\n * Automatically
  defining a function for each executable on your `$PATH`\n   using template Haskell,
  as well as a runtime check to ensure they all\n   exist on startup.\n\n * Redirction
  of stdout and stderr\n       \n       -- Redirect stdout\n       λ echo \"Hello\"
  &> StdErr\n       λ echo \"Hello\" &> Truncate \".tmp_file\"\n\n       -- Redirect
  stderr\n       λ echo \"Hello\" &!> Append \"/dev/null\"\n       λ echo \"Hello\"
  &!> StdOut\n\n\n * Piping stdout or stderr to the input of a chained process\n       \n
  \      λ cat \"/dev/urandom\" |> xxd |> head \"-n\" 5\n\n * Multiple processes sequentially
  feeding a single process\n\n       λ (echo 1 >> echo 2) |> cat\n\n * Use of Haskells
  concurrency primitives.\n\n       λ race (sleep 1) $ curl \"http://this_needs_to_timeout_after_1_second\"\n\n
  \      λ d <- readTrim $ mktemp \"-d\"\n       λ :{\n       | System.Directory.withCurrentDirectory
  d $ do\n       |   mapConcurrently_ (curl \"-LOJs\")\n       |     [ \"https://raw.githubusercontent.com/luke-clifton/shh/master/shell.nix\"\n
  \      |     , \"https://raw.githubusercontent.com/luke-clifton/shh/master/shh.cabal\"\n
  \      |     ]\n       |   ls\n       | :}\n\n * Capturing of process output\n\n
  \      λ loggedIn <- nub . words <$> readProc users\n       λ putStrLn $ \"Logged
  in users: \" ++ show loggedIn\n\n       λ mapM_ putStrLn =<< readSplit0 (Shh.Example.find
  \"-maxdepth\" 1 \"-print0\")\n\n * Capturing infinite output of a process lazily\n\n
  \      λ withRead (cat \"/dev/urandom\" |> xxd) $ mapM_ putStrLn . take 3 . lines\n
  \      00000000: 8fcb ebee 9228 a897 3bfc 1d05 491d aceb  .....(..;...I...\n       00000010:
  47de 3ea3 2788 44ac 9b85 0a0f a458 b949  G.>.'.D......X.I\n       00000020: 5308
  ddfe 5790 5a5f 39e3 bbb6 b689 2b03  S...W.Z_9.....+.\n\n * Write strings to stdin
  of a process.\n\n       λ writeProc cat \"Hello\\n\"\n       Hello\n\n       λ \"Hello\"
  >>> shasum\n       f7ff9e8b7bb2e09b70935a5d785e0cc5d9d0abf0  -\n\n       λ shasum
  <<< \"Hello\"\n       f7ff9e8b7bb2e09b70935a5d785e0cc5d9d0abf0  -\n\n * Proper exceptions,
  when a process exits with a failure code, an exception\n   is thrown. You can catch
  these normally. The exception includes the error\n   code, the command, and all
  it's arguments.\n\n       λ false \"Ha, it died\"\n       *** Exception: Command
  `false \"Ha, it died\"` failed [exit 1]\n\n       λ catchCode false\n       1\n\n##
  Mnemonics \n\nShh has many symbols that might seem intimidating at first, but there\nis
  a simple mnemonic for them.\n\n    |     Piping. Looks like a pipe, same as in POSIX
  shells.\n    &     Redirection, think of the shell `2>&1`\n    >,<   The direction
  of flow of a command\n    !     Operate on stderr instead of stdout\n\nSo, for example,\n\n
  \   ls |> cat      Pipe the stdout of `ls` into stdin of `cat`\n    cat <| ls      Same
  as above\n    ls &> StdErr   Redirect stdout of `ls` to wherever stderr is going.\n
  \   StdErr <& ls   Same as above\n    ls &!> StdOut  Redirect stderr of `ls` to
  wherever stdout is going.\n    StdOut <!& ls  Same as above\n\n## Globbing\n\nCurrently
  Shh does not have any built in globbing support. Rather, it is\ncurrently suggested
  to use another library to do globbing. For example,\nusing the [Glob](http://hackage.haskell.org/package/Glob)
  package, it is\npossible to do something like\n\n    wc =<< glob \"*.md\"\n\nCertainly
  more verbose than the Bash equivalent, however, also more explicit,\nwhich is probably
  a good thing. If this turns out to be too cumbersome, we\nmight introduce a more
  succinct globbing feature, though it will always be\nexplicit, and thus always more
  verbose than most other shells.\n\n## Usage\n\nEnable Temlpate Haskell and load
  the environment\n\n    {-# LANGUAGE TemplateHaskell #-}\n    $(loadEnv SearchPath)\n\nYou
  now have all your executables available as simple to read\nHaskell functions.\n\nIf
  you want to check that all the dependenies still exist, you can use\n`missingExecutables
  :: IO [String]`, which will tell you if anything is\nmissing.\n\n### Usage in GHCi\n\nIf
  you want `^D` to be recognised as a EOF marker (when running commands\nthat read
  from stdin) when running in GHCi, you will need to run the\n`initInteractive` function.
  This sets the line buffering appropriately and\nensures the terminal is in canonical
  mode.\n\n### Shh as a Shell\n\nThere is a tool called `shh` which is a fairly small
  wrapper around launching\nGHCi which automatically loads your environment and allows
  you to have custom\nconfig when using GHCi as a shell.\n\nThe `shh` binary will
  look in your `$SHH_DIR` (defaults to `$HOME/.shh`) for\na `Shell.hs`, `init.ghci`
  and `wrapper` files. If these don't exist default\nones will be created.\n\nThe
  `Shell.hs` file should contain any top level definitions that you would\nlike to
  be available in your Shell. By default it loads your environment.\n\nThe `init.ghci`
  file is loaded by GHCi after your `.ghci` files. This lets\nyou specify settings
  that you want to take effect when using GHCi as a shell.\nBy default it sets a shell-like
  prompt.\n\nThe `wrapper` file is an executable that is called with the command that
  is\nto be executed. By default it just calls `exec` with the arguments passed to\nit.
  The use-case for this is to be able to set up the environment for `shh`.\nYou might,
  for example, wrap the execution in a `nix-shell`. Either way,\nit is up to you to
  make sure that the compiler, and packages you require are\navailable, either globally,
  or provided by the `wrapper` script.\n\n#### Nix Wrapper Example\n\nThe following
  snippet could act as a `wrapper` file to set up a suitable\nenvironment using `nix-shell`\n\n
  \   #! /usr/bin/env nix-shell\n    #! nix-shell -i bash -p \"(haskellPackages.ghcWithPackages
  (p: with p; [shh shh-extras]))\"\n    exec \"$@\"\n\n### Script Usage\n\nTODO: Fill
  this in once the user experience is better.\n    \n"
license-name: BSD-3-Clause
