homepage: https://github.com/yesodweb/Shelly.hs
changelog-type: markdown
hash: 93f4ccb7b2e77149da3247838d3424792fd9aa20cb3dfd05c935282e4debae03
test-bench-deps:
  exceptions: -any
  hspec-contrib: -any
  bytestring: ! '>=0.10'
  base: ! '>=4.6'
  time: ! '>=1.3 && <1.9'
  hspec: ! '>=2.0'
  text: ! '>=0.11'
  enclosed-exceptions: -any
  system-fileio: <0.4
  monad-control: -any
  unix-compat: <0.6
  filepath: -any
  process: ! '>=1.1.0'
  async: -any
  lifted-base: -any
  HUnit: ! '>=1.2'
  containers: ! '>=0.5.0.0'
  mtl: ! '>=2'
  lifted-async: -any
  transformers-base: -any
  transformers: -any
  system-filepath: ! '>=0.4.7 && <0.5'
  directory: ! '>=1.1.0.0 && <1.4.0.0'
maintainer: Greg Weber <greg@gregweber.info>
synopsis: shell-like (systems) programming in Haskell
changelog: ! '# 1.8.0


  * `cp_r` now uses upper case R: `cp -R`


  # 1.7.2


  * Support exceptions-0.9


  # 1.7.0.1


  * Fix FindSpec.hs tests. Fixes [#150](https://github.com/yesodweb/Shelly.hs/issues/150),
  [#162](https://github.com/yesodweb/Shelly.hs/issues/162)


  # 1.6.8.7


  * Relax unix-compat constraints


  # 1.6.8.6


  * Fix Build issue [#156](https://github.com/yesodweb/Shelly.hs/issues/156)


  # 1.6.8.5


  * Fix Windows build [#155](https://github.com/yesodweb/Shelly.hs/pull/155)


  # 1.6.8


  * added sshPairsWithOptions function


  # 1.6.7


  * flush stdout when using `echo`, not just `echo_n`

  * fix should be able to silence stderr when using `runHandle`

  * expose RunFailed


  # 1.6.6


  * add prependToPath function


  # 1.6.5


  * expose MonadShControl


  # 1.6.4.1


  * add writeBinary function

'
basic-deps:
  exceptions: ! '>=0.6'
  bytestring: -any
  base: ! '>=4.6 && <5'
  time: ! '>=1.3 && <1.9'
  text: -any
  enclosed-exceptions: -any
  system-fileio: <0.4
  monad-control: ! '>=0.3.2 && <1.1'
  unix-compat: <0.6
  process: ! '>=1.0'
  async: -any
  lifted-base: -any
  containers: ! '>=0.4.2.0'
  mtl: ! '>=2'
  lifted-async: -any
  transformers-base: -any
  transformers: -any
  system-filepath: ! '>=0.4.7 && <0.5'
  directory: ! '>=1.1.0.0 && <1.4.0.0'
all-versions:
- '0.3.0'
- '0.3.0.1'
- '0.3.0.2'
- '0.3.1'
- '0.4'
- '0.4.1'
- '0.5.0'
- '0.5.1'
- '0.6'
- '0.7'
- '0.7.1'
- '0.8.0.1'
- '0.8.0.2'
- '0.9.0'
- '0.9.2'
- '0.9.3'
- '0.9.4.1'
- '0.9.4.2'
- '0.9.5'
- '0.9.5.1'
- '0.9.6'
- '0.9.7'
- '0.9.7.1'
- '0.9.7.2'
- '0.9.7.3'
- '0.10'
- '0.10.0.1'
- '0.11'
- '0.12'
- '0.12.0.1'
- '0.12.0.2'
- '0.12.1'
- '0.12.1.1'
- '0.12.2'
- '0.13'
- '0.13.0.1'
- '0.13.1'
- '0.13.2'
- '0.13.2.1'
- '0.13.3'
- '0.13.4'
- '0.13.5'
- '0.13.5.1'
- '0.14'
- '0.14.0.1'
- '0.14.1'
- '0.14.2'
- '0.14.2.1'
- '0.14.2.2'
- '0.14.2.3'
- '0.14.3'
- '0.15.0'
- '0.15.1'
- '0.15.2'
- '0.15.3'
- '0.15.3.1'
- '0.15.3.2'
- '0.15.3.3'
- '0.15.4'
- '0.15.4.1'
- '1.0.0.0'
- '1.1.0.0'
- '1.2.0.0'
- '1.3.0.0'
- '1.3.0.1'
- '1.3.0.2'
- '1.3.0.3'
- '1.3.0.4'
- '1.3.0.5'
- '1.3.0.6'
- '1.3.0.7'
- '1.3.1'
- '1.3.2'
- '1.4.0.1'
- '1.4.0.2'
- '1.4.1'
- '1.4.2'
- '1.4.3'
- '1.4.3.1'
- '1.4.4'
- '1.4.4.1'
- '1.4.4.2'
- '1.5.0.1'
- '1.5.1'
- '1.5.1.1'
- '1.5.2'
- '1.5.3.1'
- '1.5.3.2'
- '1.5.4'
- '1.5.4.1'
- '1.5.5'
- '1.5.6'
- '1.5.7'
- '1.6.0'
- '1.6.0.1'
- '1.6.1'
- '1.6.1.1'
- '1.6.1.2'
- '1.6.2'
- '1.6.2.1'
- '1.6.2.2'
- '1.6.2.3'
- '1.6.2.4'
- '1.6.2.5'
- '1.6.3'
- '1.6.3.1'
- '1.6.3.2'
- '1.6.3.3'
- '1.6.3.4'
- '1.6.4'
- '1.6.4.1'
- '1.6.5'
- '1.6.6'
- '1.6.7'
- '1.6.8'
- '1.6.8.1'
- '1.6.8.2'
- '1.6.8.3'
- '1.6.8.4'
- '1.6.8.5'
- '1.6.8.6'
- '1.6.8.7'
- '1.6.9'
- '1.7.0'
- '1.7.0.1'
- '1.7.1'
- '1.7.2'
- '1.8.0'
author: Greg Weber, Petr Rockai
latest: '1.8.0'
description-type: markdown
description: ! "# Shelly\n\n[![Build Status](https://travis-ci.org/yesodweb/Shelly.hs.svg?branch=master)](https://travis-ci.org/yesodweb/Shelly.hs)\n[![Hackage](https://img.shields.io/hackage/v/shelly.svg)](https://hackage.haskell.org/package/shelly)\n[![Stackage
  Nightly](http://stackage.org/package/shelly/badge/nightly)](http://stackage.org/nightly/package/shelly)\n[![Stackage
  LTS](http://stackage.org/package/shelly/badge/lts)](http://stackage.org/lts/package/shelly)\n\nShelly
  provides a single module for convenient systems programming in Haskell.\n\n* is
  aimed at convenience and getting things done rather than being a demonstration of
  elegance.\n* has detailed and useful error messages\n* maintains its own environment,
  making it thread-safe\n* is modern, using Text and system-filepath/system-fileio\n*
  has low memory usage\n  * `run_` and other underscore variants that don't return
  stdout\n  * `runFoldLines` to run a fold operation over each line rather than loading
  all of stdout into memory\n  * `runHandle` and `runHandles` for complete control
  over handles\n\nLooking to put your Haskell learning to immediate practical use?
  You don't have to create artifical intelligence, try just automating some of your
  boring tasks.\n\nThe focus of this library on convenience combined with good error
  messages should make shelly approachable for newer users of Haskell.\nI have published
  [an introductory article to scripting with shelly, targeted towards those not familiar
  with Haskell](http://www.linux-magazin.de/Online-Artikel/Shell-scripting-with-type-safety-using-Haskell/).
  There is a paid version in German from Linux Magazin.\nThat article uses the version
  `shelly < 1.0` which uses lazy text. `shelly > 1.0` uses strict text.\n\n\n\n##
  More shelly packages\n\nThe [shelly-extra](http://hackage.haskell.org/package/shelly-extra)
  package has some additional functionality that requires additional dependencies,
  currently including a convenient concurrency/futures implementation. If you are
  following along the above article you need to install it.\n\n\n## Examples\n\n*
  [A small deployment script](http://www.alfredodinapoli.com/posts/2015-11-03-how-i-deploy-haskell-code.html)\n*
  [Yesod development installer](https://github.com/yesodweb/scripts/blob/master/install.hs)\n*
  [cabal-meta, a haskell install tool](https://github.com/yesodweb/cabal-meta/blob/master/main.hs)\n*
  [antigen-hs, a zsh plugin manager](https://github.com/Tarrasch/antigen-hs)\n\n\n###
  Blog Posts\n\n* [Shelly automation with Literate Haskell](http://www.scholarslab.org/dh-developer/shell-programming-in-haskell-converting-s5-slides-to-pdf/)\n\n\n###
  Testimonials\n\n* [a beginning Haskeller does automation](http://www.reddit.com/r/haskell/comments/w86gu/my_current_job_task_is_boring_so_i_wrote_a_simple/)\n\n###
  Help\n\n* [google group for Haskell shell scripting](https://groups.google.com/forum/#!forum/haskell-shell-scripting)\n\n##
  Alternatives\n\n### Haskell shell scripting libraries\n\n\n* [HSH](http://hackage.haskell.org/package/HSH)
  - A good alternative if you want to mixup usage of String and ByteString rather
  than just use Text.\n* [HsShellScript](http://hackage.haskell.org/packages/archive/hsshellscript/3.1.0/doc/html/HsShellScript.html)
  - Has extensive low-level shell capabilities.\n* [shell-conduit](http://hackage.haskell.org/package/shell-conduit)
  - efficient streaming via conduits. Makes some portability sacrifices by\n  * encouraging
  one to just use the shell instead of cross-platform Haskell code\n  * encouraging
  one to use a convenience function that searches the PATH at compile-time\n* [shell-monad](http://hackage.haskell.org/package/shell-monad)
  - compile Haskell code down to shell script. This is a different approach from all
  the rest of the libraries. Writing your script is not as user-friendly as the other
  Haskell libraries, but it nicely solves the deployment issue.\n* [turtle](http://hackage.haskell.org/package/turtle)
  - In some sense a [redesign of Shelly designed for beginner-friendliness](http://www.reddit.com/r/haskell/comments/2u6b8m/use_haskell_for_shell_scripting/co5ucq9)\n\nHSH
  and HsShellScript (unlike Shelly currently) implement very efficient mechanisms
  for piping/redirecting in the system.\nturtle, like Shelly offers folding as a way
  to efficiently deal with a stream.\n\nNone of the alternatives to Shelly offer command
  tracing.\nFor some this is an absolutely critical feature, particularly given that
  Haskell does not yet offer up stack traces.\n\n\n### Haskell file-finding supplements\n\n*
  [find-conduit](http://hackage.haskell.org/package/find-conduit) - uses conduits,
  similar speed to GNU find\n* [FileManip](hackage.haskell.org/package/FileManip)
  - uses Lazy IO\n\nShelly's finders load all files into memory. This is simpler to
  use if you control the filesystem structure and know the system is bounded in size.
  However, if the filesystem structure is unbounded it consumes unbounded memory.\n\n\n###
  Shell commands with richer input/output\n\nShelly does not change the nature of
  shell scripting (text in, text out).\nIf you want something more revolutionary you
  might try these:\n\n* PowerShell is probably the best known.\n* [Haskell project](https://github.com/pkamenarsky/ytools)
  using typed JSON\n* [RecordStream](https://github.com/benbernard/RecordStream) untyped
  JSON]\n\n\n## Usage\n\nShelly's main goal is ease of use.\nThere should be a primitive
  for every shell operation you need so you can easily build abstractions, so there
  are many of the usual file and environment operations.\n\nThere are 2 main entry
  points for running arbitrary commands: `run` and `cmd`.\nThey take a FilePath as
  their first argument. `run` takes a [Text] as its second argument.\n`cmd` takes
  a variadic number of arguments, and they can be either Text or FilePath.\n\nFun
  Example: shows an infectious script: it uploads itself to a server and runs itself
  over ssh.\nOf course, the development machine may need to be exactly the same OS
  as the server.\n\nI recommend using the boilerplate at the top of this example in
  your projects.\nThis includes setting line buffering if you are dealing with text
  and not binary data.\n\n~~~~~ {.haskell}\n    {-# LANGUAGE OverloadedStrings #-}\n
  \   {-# LANGUAGE ExtendedDefaultRules #-}\n    {-# OPTIONS_GHC -fno-warn-type-defaults
  #-}\n    import Shelly\n    import Data.Text as T\n    default (T.Text)\n\n    main
  =  do\n      hSetBuffering stdout LineBuffering\n      shelly $ verbosely $ do\n
  \       host <- run \"uname\" [\"-n\"]\n        if T.stripEnd host === \"local-machine\"\n
  \         then do d <- cmd \"date\"\n                  c <- escaping False $ cmd
  \"git\" \"log -1 | head -1 | awk '{print $2}'\"\n                  appendfile \"log/deploy.log\"
  $ T.intercalate \" - \" [T.stripEnd d, c]\n                  uploads \"my-server:/remote/path/\"
  [\"deploy\"]\n                  sshPairs_ \"my-server\" [(\"cd\", [\"/remote/path\"]),
  (\"./deploy\", [])]\n          else do\n                cmd \"./script/angel\"\n\n
  \   -- same path on remote host\n    -- will create directories\n    uploads ::
  Text -> [Text] -> Sh ()\n    uploads remote locals = rsync $ [\"--relative\"] ++
  locals ++ [remote]\n\n    rsync args = run_ \"rsync\" $ [\"--delete\", \"-avz\",
  \"--no-g\"] ++ args\n~~~~~\n\n### Variadic arguments to cmd\n\nYes, as seen above
  you can write variadic functions in Haskell quite easily, you just can't compose
  them as easily.\nI find `cmd` to be more convenient, but I often use `run` and `command`
  variants when I am building up abstractions.\nBuilding up abstractions with cmd
  will require type signatures.\n\n    -- easy signature, but only allows one argument\n
  \   let cabal = cmd \"cabal\" :: Text -> Sh Text\n\n    -- more complex signature
  that allows partial application of cmd\n    let cabal = cmd \"cabal\" :: Shelly.ShellCmd
  result => result\n\n\n\n### Escaping\n\nBy default, all commands are shell escaped.\nIf
  you want the shell to interpret special characters such as `*`, just use `escaping
  False $ do ...`\n\n### Using Text and FilePath together\n\nShelly's usage of system-filepath
  means you may need to convert between Text and FilePath sometimes.\nThis should
  be infrequent though because\n\n* `cmd` will convert FilePath to Text\n* The `</>`
  and `<.>` combinators convert String/Text into a FilePath automatically\n\nManual
  conversion is done through `toTextIgnore` or `toTextWarn`.\n\n\n### Thread-safe
  working directory and relative paths\n\n`cd` does not change the process working
  directory (essentially a global variable), but instead changes the shelly state
  (which is thread safe).\nAll of the Shelly API takes this into account, internally
  shelly converts all paths to absolute paths. You can turn a relative path into an
  absolute with `absPath` or `canonic` or you can make a path relative to the Shelly
  working directory with `relPath`.\n\n\n### Good error messages\n\nHaskell's #1 weakness
  for IO code is a lack of stack traces.\nShelly gives you something different: detailed
  logging.\nIn most cases this should be more useful than a stack trace.\nShelly keeps
  a log of API usage and saves it to a .shelly directory on failure.\nIf you use `shellyNoDir`,
  the log will instead be printed to stderr.\nThis is in addition to the `verbosely`
  settings that will print out commands and their output as the program is running.\nShelly's
  own error messages are detailed and in some cases it will catch Haskell exceptions
  and re-throw them with better messages.\n\nIf you make your own primitive functions
  that don't use the existing Shelly API, you can create a wrapper in the Sh monad
  that use `trace` or `tag` to log what they are doing.\nYou can turn tracing off
  (not generally recommended) by setting `tracing False`.\n\n\n## Future plans\n\n*
  Don't use the filepath library\n"
license-name: BSD3
