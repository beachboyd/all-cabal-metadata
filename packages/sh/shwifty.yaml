homepage: ''
changelog-type: markdown
hash: b548d7d934a394db8145de369d13530261601b7e26226d83608b75a5a7b3fba0
test-bench-deps: {}
maintainer: chessai <chessai1996@gmail.com>
synopsis: Generate swift types from haskell types.
changelog: |
  # Revision history for shwifty

  ## 0.0.1.0 -- 2020-02-03

  * First version. Released on an unsuspecting world.
basic-deps:
  bytestring: ! '>=0.10 && <0.11'
  case-insensitive: ! '>=1.2 && <1.3'
  base: ! '>=4.11 && <4.14'
  time: ! '>=1.8 && <1.10'
  unordered-containers: ! '>=0.2 && <0.3'
  text: ! '>=1.2 && <1.3'
  th-abstraction: ! '>=0.3 && <0.4'
  containers: ! '>=0.5.9 && <0.7'
  mtl: ! '>=2.2 && <2.3'
  uuid-types: ! '>=1.0 && <1.1'
  template-haskell: ! '>=2.11 && <2.17'
  primitive: ! '>=0.7 && <0.8'
  vector: ! '>=0.12 && <0.13'
all-versions:
- 0.0.1.0
author: chessai
latest: 0.0.1.0
description-type: markdown
description: "# Shwifty\n\n## Generate Swift types from Haskell types\n\nExamples:
  \n\n#### A simple sum type\n```haskell\ndata SumType = Sum1 | Sum2 | Sum3\ngetShwifty
  ''SumType\n```\n\n```swift\nenum SumType {\n    case sum1\n    case sum2\n    case
  sum3\n}\n```\n\n#### A simple product type\n```haskell\ndata ProductType = ProductType
  { x :: Int, y :: Int }\ngetShwifty ''ProductType\n```\n\n```swift\nstruct ProductType
  {\n    let x: Int\n    let y: Int\n}\n```\n\n#### A sum type with type variables\n```haskell\ndata
  SumType a b = SumL a | SumR b\ngetShwifty ''SumType\n```\n\n```swift\nenum SumType<A,
  B> {\n    case sumL(A)\n    case sumR(B)\n}\n```\n\n#### A product type with type
  variables\n```haskell\ndata ProductType a b = ProductType \n  { aField :: a\n  ,
  bField :: b \n  }\ngetShwifty ''ProductType\n```\n\n```swift\nstruct ProductType<A,
  B> {\n    let aField: A\n    let bField: B\n}\n```\n\n#### A newtype\n```haskell\nnewtype
  Newtype a = Newtype { getNewtype :: a }\ngetShwifty ''Newtype\n```\n\n```swift\nstruct
  Newtype<A> {\n    let getNewtype: A\n}\n```\n\n#### A type with a function field\n```haskell\nnewtype
  Endo a = Endo { appEndo :: a -> a }\ngetShwifty ''Endo\n```\n\n```swift\nstruct
  Endo<A> {\n    let appEndo: ((A) -> A)\n}\n```\n\n#### A weird type with nested
  fields. Also note the Result's types being flipped from that of the Either.\n```haskell\ndata
  YouveGotProblems a b = YouveGotProblems \n  { field1 :: Maybe (Maybe (Maybe a))\n
  \ , field2 :: Either (Maybe a) (Maybe b) \n  }\ngetShwifty ''YouveGotProblems\n```\n\n```swift\nstruct
  YouveGotProblems<A, B> {\n    let field1: A???\n    let field2: Result<B?, A?>\n}\n```\n\n####
  A type with polykinded type variables\n```haskell\ndata PolyKinded (a :: k) = PolyKinded\ngetShwifty
  ''PolyKinded\n```\n\n```swift\nstruct PolyKinded<A> { }\n```\n\n#### A sum type
  where constructors might be records\n```haskell\ndata SumType a b (c :: k) \n  =
  Sum1 Int a (Maybe b) \n  | Sum2 b \n  | Sum3 { x :: Int, y :: Int }\ngetShwifty
  ''SumType\n```\n\n```swift\nenum SumType<A, B, C> {\n  case field1(Int, A, B?)\n
  \ case field2(B)\n  case field3(_ x: Int, _ y: Int)\n}\n```\n\n#### A type containing
  another type with instance generated by 'getShwifty'\n```haskell\nnewtype MyFirstType
  a = MyFirstType { getMyFirstType :: a }\ngetShwifty ''MyFirstType\n\ndata Contains
  a = Contains \n  { x :: MyFirstType Int\n  , y :: MyFirstType a \n  }\ngetShwifty
  ''Contains\n```\n\n```swift\nstruct MyFirstType<A> {\n  let getMyFirstType: A\n}\n\nstruct
  Contains<A> {\n  let x: MyFirstType<Int>\n  let y: MyFirstType<A>\n}\n```\n"
license-name: MIT
