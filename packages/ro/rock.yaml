homepage: https://github.com/ollef/rock#readme
changelog-type: markdown
hash: 2988ee83076c9938dd2a07613db9d98a9aeaff5cae097570bf58203779c4784d
test-bench-deps: {}
maintainer: fredriksson.olle@gmail.com
synopsis: A build system for incremental, parallel, and demand-driven computations
changelog: |
  # Unreleased

  # 0.2.0.0

  - Stop using hashes when verifying traces (gets rid of the `Rock.HashTag` and `Rock.Hashed` modules)
  - Add reverse dependency tracking

  # 0.1.0.1

  - Fix base-4.12 compatibility

  # 0.1.0.0

  - Initial release
basic-deps:
  dependent-sum: -any
  dependent-sum-template: -any
  base: ! '>=4.7 && <5'
  deriving-compat: -any
  rock: -any
  dependent-map: -any
  protolude: -any
  containers: -any
  mtl: -any
  transformers: -any
all-versions:
- 0.1.0.0
- 0.1.0.1
- 0.2.0.0
author: Olle Fredriksson
latest: 0.2.0.0
description-type: markdown
description: |
  # rock [![Hackage](https://img.shields.io/hackage/v/rock.svg)](https://hackage.haskell.org/package/rock)

  A build system inspired by [Build systems Ã  la carte](https://www.microsoft.com/en-us/research/publication/build-systems-la-carte/) and [Haxl](http://hackage.haskell.org/package/haxl).

  Used in [Sixten](https://github.com/ollef/sixten) and
  [Sixty](https://github.com/ollef/sixty) to achieve incremental and query driven
  compiler architectures.

  # Example

  ```haskell
  {-# language GADTs #-}
  {-# language NoImplicitPrelude #-}
  {-# language OverloadedStrings #-}
  {-# language StandaloneDeriving #-}
  {-# language TemplateHaskell #-}

  import Protolude

  import Data.GADT.Compare.TH (deriveGEq, deriveGCompare)
  import qualified Rock

  data Query a where
    A :: Query Integer
    B :: Query Integer
    C :: Query Integer
    D :: Query Integer

  deriving instance Show (Query a)

  deriveGEq ''Query
  deriveGCompare ''Query

  rules :: Rock.Rules Query
  rules key = do
    putText $ "Fetching " <> show key
    case key of
      A -> pure 10
      B -> do
        a <- Rock.fetch A
        pure $ a + 20
      C -> do
        a <- Rock.fetch A
        pure $ a + 30
      D ->
        (+) <$> Rock.fetch B <*> Rock.fetch C

  main :: IO ()
  main = do
    do
      putText "Running"
      result <- Rock.runTask Rock.sequentially rules (Rock.fetch D)
      print result
    do
      putText "Running with memoisation"
      memoVar <- newMVar mempty
      result <-
        Rock.runTask
          Rock.sequentially
          (Rock.memoise memoVar rules)
          (Rock.fetch D)
      print result
    do
      putText "Running with memoisation using the parallel strategy"
      memoVar <- newMVar mempty
      result <-
        Rock.runTask
          Rock.inParallel
          (Rock.memoise memoVar rules)
          (Rock.fetch D)
      print result
  ```

  Prints

  ```
  Running
  Fetching D
  Fetching B
  Fetching A
  Fetching C
  Fetching A
  70
  Running with memoisation
  Fetching D
  Fetching B
  Fetching A
  Fetching C
  70
  Running with memoisation using the parallel strategy
  Fetching D
  Fetching C
  Fetching B
  Fetching A
  70
  ```

  # Related projects

  * [Shake](http://hackage.haskell.org/package/shake)
  * [Salsa](https://crates.io/crates/salsa)

  # Contributions

  ... are very welcome, especially in the areas of documentation, examples,
  testing, and benchmarking.
license-name: BSD-3-Clause
