homepage: https://github.com/isovector/polysemy#readme
changelog-type: markdown
hash: 8b90933dab7a8f0ffd1d072dfc7b2858bb0118417c94f434370df5245cd61847
test-bench-deps:
  free: -any
  first-class-families: ! '>=0.5.0.0 && <0.6'
  stm: ==2.*
  base: ! '>=4.9 && <5'
  freer-simple: -any
  hspec: ! '>=2.6.0 && <3'
  type-errors-pretty: ! '>=0.0.0.0 && <0.1'
  syb: ==0.7.*
  criterion: -any
  async: ! '>=2.2 && <3'
  doctest: ! '>=0.16.0.1 && <0.17'
  th-abstraction: ! '>=0.3.1.0 && <0.4'
  containers: ! '>=0.5 && <0.7'
  inspection-testing: ! '>=0.4.2 && <0.5'
  mtl: ! '>=2.2.2 && <3'
  unagi-chan: ! '>=0.4.0.0 && <0.5'
  polysemy: -any
  transformers: ! '>=0.5.2.0 && <0.6'
  type-errors: ! '>=0.2.0.0'
  template-haskell: ! '>=2.12.0.0 && <3'
maintainer: sandy@sandymaguire.me
synopsis: Higher-order, low-boilerplate, zero-cost free monads.
changelog: |+
  # Changelog for polysemy

  ## 1.1.0.0 (2019-08-15)

  ### Breaking Changes

  - `MonadFail` is now implemented in terms of `Fail`, instead of `NonDet`(thanks to @KingoftheHomeless)
  - `State` and `Writer` now have better strictness semantics

  ### Other Changes

  - Added `AtomicState` effect (thanks to @KingoftheHomeless)
  - Added `Fail` effect (thanks to @KingoftheHomeless)
  - Added `runOutputSem` (thanks to @cnr)
  - Added right-associative variants of `runOutputMonoid` and `runWriter` (thanks to @KingoftheHomeless)
  - Improved `Fixpoint` so it won't always diverge (thanks to @KingoftheHomeless)
  - `makeSem` will now complain if `DataKinds` isn't enabled (thanks to @pepegar)


  ## 1.0.0.0 (2019-07-24)

  ### Breaking Changes

  - Renamed `Lift`  to `Embed` (thanks to @googleson78)
  - Renamed `runAsyncInIO` to `lowerAsync`
  - Renamed `runAsync` to `asyncToIO`
  - Renamed `runBatchOutput` to `runOutputBatched`
  - Renamed `runConstInput` to `runInputConst`
  - Renamed `runEmbed` to `runEmbedded` (thanks to @googleson78)
  - Renamed `runEmbedded` to `lowerEmbedded`
  - Renamed `runErrorAsAnother` to `mapError`
  - Renamed `runErrorInIO` to `lowerError`
  - Renamed `runFoldMapOutput` to `runOutputMonoid`
  - Renamed `runIO` to `embedToMonadIO`
  - Renamed `runIgnoringOutput` to `ignoreOutput`
  - Renamed `runIgnoringTrace` to `ignoreTrace`
  - Renamed `runInputAsReader` to `inputToReader`
  - Renamed `runListInput` to `runInputList`
  - Renamed `runMonadicInput` to `runInputSem`
  - Renamed `runOutputAsList` to `runOutputList`
  - Renamed `runOutputAsTrace` to `outputToTrace`
  - Renamed `runOutputAsWriter` to `outputToWriter`
  - Renamed `runResourceBase` to `resourceToIO`
  - Renamed `runResourceInIO` to `lowerResource`
  - Renamed `runStateInIORef` to `runStateIORef`
  - Renamed `runTraceAsList` to `runTraceList`
  - Renamed `runTraceAsOutput` to `traceToOutput`
  - Renamed `runTraceIO` to `traceToIO`
  - Renamed `sendM` to `embed` (thanks to @googleson78)
  - The `NonDet` effect is now higher-order (thanks to @KingoftheHomeless)

  ### Other Changes

  - Added `evalState` and `evalLazyState`
  - Added `runNonDetMaybe` (thanks to @KingoftheHomeless)
  - Added `nonDetToError` (thanks to @KingoftheHomeless)
  - Haddock documentation for smart constructors generated via `makeSem` will no
      longer have weird variable names (thanks to @TheMatten)


  ## 0.7.0.0 (2019-07-08)

  ### Breaking Changes

  - Added a `Pass` constructor to `Writer` (thanks to @KingoftheHomeless)
  - Fixed a bug in `runWriter` where the MTL semantics wouldn't be respected (thanks to @KingoftheHomeless)
  - Removed the `Censor` constructor of `Writer` (thanks to @KingoftheHomeless)
  - Renamed `Yo` to `Weaving`
  - Changed the visible type applications for `asks`, `gets`, and `runErrorAsAnother`

  ### Other Changes

  - Fixed haddock generation

  ## 0.6.0.0 (2019-07-04)

  ### Breaking Changes

  - Changed the type of `runBatchOutput` to be more useful (thanks to @Infinisil)

  ### Other Changes

  - **THE ERROR MESSAGES ARE SO MUCH BETTER** :party: :party: :party:
  - Added `runEmbedded` to `Polysemy.IO`
  - Added `runOutputAsList` to `Polysemy.Output` (thanks to @googleson78)
  - Asymptotically improved the performance of `runTraceAsList` (thanks to
      @googleson78)

  ## 0.5.1.0 (2019-06-28)

  - New combinators for `Polysemy.Error`: `fromEither` and `fromEitherM`

  ## 0.5.0.1 (2019-06-27)

  - Fixed a bug where `intercept` and `interceptH` wouldn't correctly handle
      higher-order effects

  ## 0.5.0.0 (2019-06-26)

  ### Breaking Changes

  - Removed the internal `Effect` machinery

  ### New Effects and Interpretations

  - New effect; `Async`, for describing asynchronous computations
  - New interpretation for `Resource`: `runResourceBase`, which can lower
      `Resource` effects without giving a lowering natural transformation
  - New interpretation for `Trace`: `runTraceAsList`
  - New combinator: `withLowerToIO`, which is capable of transforming
      `IO`-invariant functions as effects.

  ### Other Changes

  - Lots of hard work on the package and CI infrastructure to make it green on
      GHC 8.4.4 (thanks to @jkachmar)
  - Changed the order of the types for `runMonadicInput` to be more helpful
      (thanks to @tempname11)
  - Improved the error machinery to be more selective about when it runs
  - Factored out the TH into a common library for third-party consumers

  ## 0.4.0.0 (2019-06-12)

  ### Breaking Changes

  - Renamed `runResource` to `runResourceInIO`

  ### Other Changes

  - Added `runResource`, which runs a `Resource` purely
  - Added `onException`, `finally` and `bracketOnError` to `Resource`
  - Added a new function, `runResource` which performs bracketing for pure code

  ## 0.3.0.1 (2019-06-09)

  - Fixed a type error in the benchmark caused by deprecation of `Semantic`

  ## 0.3.0.0 (2019-06-01)

  ### Breaking Changes

  - Removed all deprecated names
  - Moved `Random` effect to `polysemy-zoo`

  ### Other Changes

  - `makeSem` can now be used to create term-level operators (thanks to
      @TheMatten)

  ## 0.2.2.0 (2019-05-30)

  - Added `getInspectorT` to the `Tactical` functions, which allows polysemy code
      to be run in external callbacks
  - A complete rewrite of `Polysemy.Internal.TH.Effect` (thanks to @TheMatten)
  - Fixed a bug in the TH generation of effects where the splices could contain
      usages of effects that were ambiguous

  ## 0.2.1.0 (2019-05-27)

  - Fixed a bug in the `Alternative` instance for `Sem`, where it would choose the
      *last* success instead of the first
  - Added `MonadPlus` and `MonadFail` instances for `Sem`

  ## 0.2.0.0 (2019-05-23)

  ### Breaking Changes

  - Lower precedence of `.@` and `.@@` to 8, from 9

  ### Other Changes

  - Fixed a serious bug in `interpretH` and friends, where higher-order effects
      would always be run with the current interpreter.
  - Users need no longer require `inlineRecursiveCalls` --- the
      `polysemy-plugin-0.2.0.0` will do  it automatically when compiling with `-O`
  - Deprecated `inlineRecursiveCalls`; slated for removal in the next version

  ## 0.1.2.1 (2019-05-18)

  - Give explicit package bounds for dependencies
  - Haddock improvements
  - Remove `Typeable` machinery from `Polysemy.Internal.Union` (thanks to
      @googleson78)

  ## 0.1.2.0 (2019-04-26)

  - `runInputAsReader`, `runTraceAsOutput` and `runOutputAsWriter` have more
      generalized types
  - Added `runStateInIO`
  - Added `runOutputAsTrace`
  - Added `Members` (thanks to @TheMatten)


  ## 0.1.1.0 (2019-04-14)

  - Added `runIO` interpretation (thanks to @adamConnerSax)
  - Minor documentation fixes


  ## 0.1.0.0 (2019-04-11)

  - Initial release

  ## Unreleased changes

  - Changed the tyvars of `fromEitherM`, `runErrorAsAnother`, `runEmbedded`,
    `asks` and `gets`

basic-deps:
  first-class-families: ! '>=0.5.0.0 && <0.6'
  stm: ! '>=2 && <3'
  base: ! '>=4.9 && <5'
  type-errors-pretty: ! '>=0.0.0.0 && <0.1'
  syb: ! '>=0.7 && <0.8'
  unsupported-ghc-version: ! '>1 && <1'
  async: ! '>=2.2 && <3'
  th-abstraction: ! '>=0.3.1.0 && <0.4'
  containers: ! '>=0.5 && <0.7'
  mtl: ! '>=2.2.2 && <3'
  unagi-chan: ! '>=0.4.0.0 && <0.5'
  transformers: ! '>=0.5.2.0 && <0.6'
  type-errors: ! '>=0.2.0.0'
  template-haskell: ! '>=2.12.0.0 && <3'
all-versions:
- 0.2.1.0
- 0.2.2.0
- 0.3.0.0
- 0.3.0.1
- 0.4.0.0
- 0.5.0.0
- 0.5.0.1
- 0.5.1.0
- 0.6.0.0
- 0.7.0.0
- 1.0.0.0
- 1.1.0.0
author: Sandy Maguire
latest: 1.1.0.0
description-type: markdown
description: "<p align=\"center\">\n<img src=\"https://raw.githubusercontent.com/isovector/polysemy/master/polysemy.png\"
  alt=\"Polysemy\" title=\"Polysemy\">\n</p>\n\n<p>&nbsp;</p>\n\n# polysemy\n\n[![Build
  Status](https://api.travis-ci.org/polysemy-research/polysemy.svg?branch=master)](https://travis-ci.org/polysemy-research/polysemy)\n[![Hackage](https://img.shields.io/hackage/v/polysemy.svg?logo=haskell&label=polysemy)](https://hackage.haskell.org/package/polysemy)\n[![Hackage](https://img.shields.io/hackage/v/polysemy-plugin.svg?logo=haskell&label=polysemy-plugin)](https://hackage.haskell.org/package/polysemy-plugin)\n\n##
  Dedication\n\n> The word 'good' has many meanings. For example, if a man were to
  shoot his\n> grandmother at a range of five hundred yards, I should call him a good
  shot,\n> but not necessarily a good man.\n>\n> Gilbert K. Chesterton\n\n\n## Overview\n\n`polysemy`
  is a library for writing high-power, low-boilerplate, zero-cost,\ndomain specific
  languages. It allows you to separate your business logic from\nyour implementation
  details. And in doing so, `polysemy` lets you turn your\nimplementation code into
  reusable library code.\n\nIt's like `mtl` but composes better, requires less boilerplate,
  and avoids the\nO(n^2) instances problem.\n\nIt's like `freer-simple` but more powerful
  and 35x faster.\n\nIt's like `fused-effects` but with an order of magnitude less
  boilerplate.\n\nAdditionally, unlike `mtl`, `polysemy` has no functional dependencies,
  so you\ncan use multiple copies of the same effect. This alleviates the need for
  ~~ugly\nhacks~~ band-aids like [classy\nlenses](http://hackage.haskell.org/package/lens-4.17.1/docs/Control-Lens-TH.html#v:makeClassy),\nthe
  [`ReaderT`\npattern](https://www.fpcomplete.com/blog/2017/06/readert-design-pattern)
  and\nnicely solves the [trouble with typed\nerrors](https://www.parsonsmatt.org/2018/11/03/trouble_with_typed_errors.html).\n\nConcerned
  about type inference? Check out\n[polysemy-plugin](https://github.com/isovector/polysemy/tree/master/polysemy-plugin),\nwhich
  should perform just as well as `mtl`'s! Add `polysemy-plugin` to your package.yaml\nor
  .cabal file's dependencies section to use. Then turn it on with a pragma in your
  source-files:\n\n```haskell\n{-# OPTIONS_GHC -fplugin=Polysemy.Plugin #-}\n```\nOr
  by adding `-fplugin=Polysemy.Plugin` to your package.yaml/.cabal file `ghc-options`
  section.\n\n\n## Features\n\n* *Effects are higher-order,* meaning it's trivial
  to write `bracket` and `local`\n    as first-class effects.\n* *Effects are low-boilerplate,*
  meaning you can create new effects in a\n    single-digit number of lines. New interpreters
  are nothing but functions and\n    pattern matching.\n* *Effects are zero-cost,*
  meaning that GHC<sup>[1](#fn1)</sup> can optimize\n    away the entire abstraction
  at compile time.\n\n\n<sup><a name=\"fn1\">1</a></sup>: Unfortunately this is not
  true in GHC 8.6.3, but\nwill be true in GHC 8.10.1.\n\n\n## Examples\n\nMake sure
  you read the [Necessary Language\nExtensions](https://github.com/isovector/polysemy#necessary-language-extensions)\nbefore
  trying these yourself!\n\nTeletype effect:\n\n```haskell\n{-# LANGUAGE TemplateHaskell
  #-}\n{-# LANGUAGE LambdaCase, BlockArguments #-}\n{-# LANGUAGE GADTs, FlexibleContexts,
  TypeOperators, DataKinds, PolyKinds #-}\n\nimport Polysemy\nimport Polysemy.Input\nimport
  Polysemy.Output\n\ndata Teletype m a where\n  ReadTTY  :: Teletype m String\n  WriteTTY
  :: String -> Teletype m ()\n\nmakeSem ''Teletype\n\nteletypeToIO :: Member (Embed
  IO) r => Sem (Teletype ': r) a -> Sem r a\nteletypeToIO = interpret $ \\case\n  ReadTTY
  \     -> embed getLine\n  WriteTTY msg -> embed $ putStrLn msg\n\nrunTeletypePure
  :: [String] -> Sem (Teletype ': r) a -> Sem r ([String], a)\nrunTeletypePure i\n
  \ = runOutputMonoid pure  -- For each WriteTTY in our program, consume an output
  by appending it to the list in a ([String], a)\n  . runInputList i         -- Treat
  each element of our list of strings as a line of input\n  . reinterpret2 \\case
  \    -- Reinterpret our effect in terms of Input and Output\n      ReadTTY -> maybe
  \"\" id <$> input\n      WriteTTY msg -> output msg\n\n\necho :: Member Teletype
  r => Sem r ()\necho = do\n  i <- readTTY\n  case i of\n    \"\" -> pure ()\n    _
  \ -> writeTTY i >> echo\n\n\n-- Let's pretend\nechoPure :: [String] -> Sem '[] ([String],
  ())\nechoPure = flip runTeletypePure echo\n\npureOutput :: [String] -> [String]\npureOutput
  = fst . run . echoPure\n\n-- echo forever\nmain :: IO ()\nmain = runM . teletypeToIO
  $ echo\n```\n\n\nResource effect:\n\n```haskell\n{-# LANGUAGE TemplateHaskell #-}\n{-#
  LANGUAGE LambdaCase, BlockArguments #-}\n{-# LANGUAGE GADTs, FlexibleContexts, TypeOperators,
  DataKinds, PolyKinds, TypeApplications #-}\n\nimport Polysemy\nimport Polysemy.Input\nimport
  Polysemy.Output\nimport Polysemy.Error\nimport Polysemy.Resource\n\n-- Using Teletype
  effect from above\n\ndata CustomException = ThisException | ThatException deriving
  Show\n\nprogram :: Members '[Resource, Teletype, Error CustomException] r => Sem
  r ()\nprogram = catch @CustomException work $ \\e -> writeTTY (\"Caught \" ++ show
  e)\n  where work = bracket (readTTY) (const $ writeTTY \"exiting bracket\") $ \\input
  -> do\n          writeTTY \"entering bracket\"\n          case input of\n            \"explode\"
  \    -> throw ThisException\n            \"weird stuff\" -> writeTTY input >> throw
  ThatException\n            _             -> writeTTY input >> writeTTY \"no exceptions\"\n\nmain
  :: IO (Either CustomException ())\nmain = (runM .@ lowerResource .@@ lowerError
  @CustomException) . teletypeToIO $ program\n```\n\nEasy.\n\n\n## Friendly Error
  Messages\n\nFree monad libraries aren't well known for their ease-of-use. But following
  in\nthe shoes of `freer-simple`, `polysemy` takes a serious stance on providing\nhelpful
  error messages.\n\nFor example, the library exposes both the `interpret` and `interpretH`\ncombinators.
  If you use the wrong one, the library's got your back:\n\n```haskell\nrunResource\n
  \   :: forall r a\n     . Sem (Resource ': r) a\n    -> Sem r a\nrunResource = interpret
  $ \\case\n  ...\n```\n\nmakes the helpful suggestion:\n\n```\n    • 'Resource' is
  higher-order, but 'interpret' can help only\n      with first-order effects.\n      Fix:\n
  \       use 'interpretH' instead.\n    • In the expression:\n        interpret\n
  \         $ \\case\n```\n\nLikewise it will give you tips on what to do if you forget
  a `TypeApplication`\nor forget to handle an effect.\n\nDon't like helpful errors?
  That's OK too --- just flip the `error-messages` flag\nand enjoy the raw, unadulterated
  fury of the typesystem.\n\n\n## Necessary Language Extensions\n\nYou're going to
  want to stick all of this into your `package.yaml` file.\n\n```yaml\n  ghc-options:
  -O2 -flate-specialise -fspecialise-aggressively\n  default-extensions:\n    - DataKinds\n
  \   - FlexibleContexts\n    - GADTs\n    - LambdaCase\n    - PolyKinds\n    - RankNTypes\n
  \   - ScopedTypeVariables\n    - TypeApplications\n    - TypeOperators\n    - TypeFamilies\n```\n\n##
  Stellar Engineering - Aligning the stars to optimize `polysemy` away\n\nSeveral
  things need to be in place to fully realize our performance goals: \n\n- GHC Version\n
  \ - GHC 8.9+\n- Your code\n  - The module you want to be optimized needs to import
  `Polysemy.Internal` somewhere in its dependency tree (sufficient to `import Polysemy`)\n-
  GHC Flags\n  - `-O` or `-O2`\n  - `-flate-specialise` (this should be automatically
  turned on by the plugin, but it's worth mentioning)\n- Plugin\n  - `-fplugin=Polysemy.Plugin`\n-
  Additional concerns:\n  - additional core passes (turned on by the plugin)\n\n"
license-name: BSD-3-Clause
