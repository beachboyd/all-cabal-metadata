homepage: https://github.com/jfischoff/port-utils#readme
changelog-type: markdown
hash: f19c6c80acf9964b8248d7a74c2cfc4a2d4cec40d272cec583638dbea585e104
test-bench-deps:
  stm: -any
  base: ! '>=4.7 && <5'
  hspec: -any
  port-utils: -any
  network: -any
  async: -any
  transformers: -any
maintainer: jonathangfischoff@gmail.com
synopsis: Utilities for creating and waiting on ports
changelog: ! '# Changelog for wait-on-port

  - 0.0.0.1 First version


  - 0.2.0.0 Rework internals and change `EventHandlers` to `EventHandlers m`. Fix
  bug if host could not be found. It would loop forever and now throws.

'
basic-deps:
  base: ! '>=4.7 && <5'
  network: -any
all-versions:
- '0.1.0.0'
- '0.1.0.1'
- '0.1.0.2'
- '0.1.0.3'
- '0.1.0.4'
- '0.2.0.0'
author: Jonathan Fischoff
latest: '0.2.0.0'
description-type: markdown
description: ! '# port-utils


  ## openFreePort


  This is another version of `warp`''s `openFreePort` function. This function has
  fewer dependencies than the `warp` version.


  `openFreePort` returns a socket on a random port and the port it has been bound
  to.


  ```haskell

  openFreePort :: IO (Int, Socket)

  ```


  ## wait


  `wait` will attempt to connect to a host and port until it is successful. Between
  each unsuccessful attempt, it sleeps for 10 ms.


  Here is an example of the primary function:


  ```haskell

  import Network.Socket.Wait (wait)


  void $ forkIO $ Warp.run 7000 app

  -- Wait for the server to start listening on the socket

  wait "127.0.0.1" 7000

  -- Communicate with the server

  ...

  ```


  In bash one could write:


  ```bash

  while ! nc -z localhost 7000 ; do sleep 0.01 ; done

  ```


  The bash script above was copied from this stackoverflow answer https://stackoverflow.com/a/50008755'
license-name: BSD3
