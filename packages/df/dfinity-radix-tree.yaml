homepage: https://github.com/dfinity-lab/dev
changelog-type: markdown
hash: 3eaa424a63072446ee4d9e614663c9d1e67ede64c27eb4912b754ac493b24b3a
test-bench-deps:
  BoundedChan: -any
  bytestring: -any
  base: ! '>=4.10 && <5'
  unordered-containers: -any
  text: -any
  filepath: -any
  conduit: -any
  dfinity-radix-tree: -any
  leveldb-haskell: -any
  containers: -any
  concurrent-extra: -any
  tasty-quickcheck: -any
  mtl: -any
  tasty-hunit: -any
  base16-bytestring: -any
  transformers: -any
  temporary: -any
  blake2: -any
  tasty: -any
  QuickCheck: -any
  resourcet: -any
  aeson: -any
maintainer: Enzo Haussecker <enzo@dfinity.org>, Remy Goldschmidt <remy@dfinity.org>,
  Armando Ramirez <armando@dfinity.org>
synopsis: A generic data integrity layer.
changelog: ! "0.5.2 Enzo Haussecker <enzo@dfinity.org> Fri Oct 19 2018\n\n * Fix bug
  related to search strategy.\n\n0.5.1 Enzo Haussecker <enzo@dfinity.org> Fri Oct
  19 2018\n\n * Expose lens-based interface to radix tree data structures.\n\n0.5.0
  Enzo Haussecker <enzo@dfinity.org> Fri Oct 19 2018\n\n * Implement Merkle proofs.\n
  * Reduce memory footprint of parallel download combinators.\n\n0.4.0 Enzo Haussecker
  <enzo@dfinity.org> Tue Sep 25 2018\n\n * Change hash function from SHA-256 to BLAKE-256.\n
  * Clean-up documentation.\n\n0.3.1 Enzo Haussecker <enzo@dfinity.org> Mon Aug 06
  2018\n\n *  Relax monadic constraint on radix database instance.\n\n0.3.0 Enzo Haussecker
  <enzo@dfinity.org> Thu Aug 02 2018\n\n * Add thread safety to parallel download
  combinators.\n * Separate impure code from base module.\n * Remove deprecated functions.\n\n0.2.1
  Enzo Haussecker <enzo@dfinity.org> Wed Jul 25 2018\n\n * Fix bug related to temporary
  reference creation.\n\n0.2.0 Enzo Haussecker <enzo@dfinity.org> Sat Jul 21 2018\n\n
  * Remove configuration parameter from type class.\n\n0.1.1 Enzo Haussecker <enzo@dfinity.org>
  Thu Jul 12 2018\n\n * Create aliases for verbose functions.\n * Implement debug
  utilities.\n * Clean-up documentation.\n\n0.1.0 Enzo Haussecker <enzo@dfinity.org>
  Tue Jul 03 2018\n\n * Abstract database to type class.\n * Implement radix tree
  construction via conduit.\n * Clean-up documentation.\n"
basic-deps:
  lmdb-simple: -any
  BoundedChan: -any
  serialise: -any
  lens-simple: -any
  bytestring: -any
  stm: -any
  base: ! '>=4.10 && <5'
  data-default-class: -any
  criterion: -any
  dlist: -any
  conduit: -any
  semigroups: -any
  dfinity-radix-tree: -any
  leveldb-haskell: -any
  containers: -any
  concurrent-extra: -any
  hashtables: -any
  ghc-prim: -any
  lrucaching: -any
  mtl: -any
  cmdargs: -any
  base16-bytestring: -any
  transformers: -any
  temporary: -any
  blake2: -any
  deepseq: -any
  bloomfilter: -any
  resourcet: -any
  reducers: -any
  directory: -any
all-versions:
- 0.0.0
- 0.1.0
- 0.1.1
- 0.2.0
- 0.2.1
- 0.3.0
- 0.3.1
- 0.4.0
- 0.5.0
- 0.5.1
- 0.5.2
author: Enzo Haussecker <enzo@dfinity.org>, Remy Goldschmidt <remy@dfinity.org>, Armando
  Ramirez <armando@dfinity.org>
latest: 0.5.2
description-type: markdown
description: ! "# dfinity-radix-tree: A generic data integrity layer.\n\n[![DFINITY][dfinity-shield]][dfinity]\n[![Build
  Status][build-shield]][build]\n[![Hackage][hackage-shield]][hackage]\n[![Dependencies][deps-shield]][deps]\n[![License:
  GPLv3][license-shield]][license]\n\n## Overview\n\nThis library allows you to construct
  a [Merkle tree][wiki-merkle-tree] on top of\nany underlying key-value database.
  It works by organizing your key-value pairs\ninto a binary [radix tree][wiki-radix-tree],
  which is well suited for storing\nlarge dictionaries of fairly random keys, and
  is optimized for storing keys of\nthe same length.\n\n## Usage\n\nDefine your database
  as an instance of the [`RadixDatabase`][] type class.\nInstances for [LevelDB][hackage-leveldb-haskell]
  and [LMDB][hackage-lmdb-simple]\nare already provided.\n\n```haskell\n{-# LANGUAGE
  FlexibleInstances #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n\nimport Control.Monad.IO.Class
  (MonadIO)\nimport Database.LevelDB (DB, defaultReadOptions, defaultWriteOptions,
  get, put)\n\nimport DFINITY.RadixTree\n\ninstance MonadIO m => RadixDatabase m DB
  where\n   load database = get database defaultReadOptions\n   store database = put
  database defaultWriteOptions\n```\n\nCreate a [`RadixTree`][] that is parameterized
  by your database. If you want to\nmake things more explicit, then you can define
  a simple type alias and wrapper\nfunction.\n\n```haskell\nimport Control.Monad.Trans.Resource
  (MonadResource)\nimport Database.LevelDB (DB, Options(..), defaultOptions, open)\n\nimport
  DFINITY.RadixTree\n\ntype RadixTree' = RadixTree DB\n\ncreateRadixTree'\n   :: MonadResource
  m\n   => FilePath -- Database.\n   -> Maybe RadixRoot -- State root.\n   -> m RadixTree'\ncreateRadixTree'
  file root = do\n   handle <- open file options\n   createRadixTree bloomSize cacheSize
  root handle\n   where\n   bloomSize = 262144\n   cacheSize = 2048\n   options   =
  defaultOptions { createIfMissing = True }\n```\n\nUsing the definitions above, you
  can create a radix tree, perform some basic\noperations on it, and see that its
  contents is uniquely defined by its\n[`RadixRoot`][].\n\n```haskell\n{-# LANGUAGE
  OverloadedStrings #-}\n\nimport Control.Monad.IO.Class (liftIO)\nimport Control.Monad.Trans.Resource
  (runResourceT)\nimport Data.ByteString.Base16 (encode)\nimport Data.ByteString.Char8
  (unpack)\nimport Data.ByteString.Short (fromShort)\n\nimport DFINITY.RadixTree\n\nmain
  :: IO ()\nmain = runResourceT $ do\n\n   -- Create a radix tree, insert a key-value
  pair, and Merkleize.\n   tree  <- createRadixTree' \"/path/to/database\" Nothing\n
  \  tree' <- insertRadixTree \"Hello\" \"World\" tree\n   root  <- fst <$> merkleizeRadixTree
  tree'\n\n   -- Print the state root.\n   liftIO $ putStrLn $ \"State Root: 0x\"
  ++ pretty root\n   where pretty = unpack . encode . fromShort\n```\n\nRunning the
  program above should produce the following result.\n\n```\nState Root: 0xb638755216858bc84de8b80f480f15ca5c733e95\n```\n\n##
  Contribute\n\nFeel free to join in. All are welcome. Open an [issue][issue-tracker]!\n\n##
  License\n\n`dfinity-radix-tree` is licensed under the\n[GNU General Public License
  version 3][license].\n\n[//]: # (----------------------------------------------------------------------)\n\n[dfinity]:\n
  \   https://dfinity.org\n[dfinity-shield]:\n    https://img.shields.io/badge/made%20by-DFINITY-29abe2.svg\n[build]:\n
  \   https://travis-ci.org/dfinity-lab/hs-dfinity-radix-tree\n[build-shield]:\n    https://travis-ci.org/dfinity-lab/hs-dfinity-radix-tree.svg?branch=master\n[hackage]:\n
  \   https://hackage.haskell.org/package/dfinity-radix-tree\n[hackage-shield]:\n
  \   https://img.shields.io/hackage/v/dfinity-radix-tree.svg\n[deps]:\n    https://packdeps.haskellers.com/feed?needle=dfinity-radix-tree\n[deps-shield]:\n
  \   https://img.shields.io/hackage-deps/v/dfinity-radix-tree.svg\n[license]:\n    https://www.gnu.org/licenses/gpl-3.0\n[license-shield]:\n
  \   https://img.shields.io/badge/license-GPLv3-29abe2.svg\n[wiki-radix-tree]:\n
  \   https://en.wikipedia.org/wiki/Radix_tree\n[wiki-merkle-tree]:\n    https://en.wikipedia.org/wiki/Merkle_tree\n[hackage-leveldb-haskell]:\n
  \   https://hackage.haskell.org/package/leveldb-haskell\n[hackage-lmdb-simple]:\n
  \   https://hackage.haskell.org/package/lmdb-simple\n[`RadixDatabase`]:\n    https://hackage.haskell.org/package/dfinity-radix-tree/docs/DFINITY-RadixTree.html#t:RadixDatabase\n[`RadixTree`]:\n
  \   https://hackage.haskell.org/package/dfinity-radix-tree/docs/DFINITY-RadixTree.html#t:RadixTree\n[`RadixRoot`]:\n
  \   https://hackage.haskell.org/package/dfinity-radix-tree/docs/DFINITY-RadixTree.html#t:RadixRoot\n[issue-tracker]:\n
  \   https://github.com/dfinity-lab/hs-radix-tree/issues\n\n[//]: # (----------------------------------------------------------------------)\n"
license-name: GPL-3.0-only
