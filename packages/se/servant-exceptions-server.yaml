homepage: https://github.com/ch1bo/servant-exceptions#readme
changelog-type: markdown
hash: f81dca501797404ddc1907dfb46a39d1a09d325b75b3d7922ef70f84fb3095f9
test-bench-deps: {}
maintainer: sebastian.nagel@ncoding.at
synopsis: Extensible exceptions for servant API servers
changelog: |
  # Changelog

  ## 0.2.0 - 2020-11-25

   * **BREAKING** Split into two packages `servant-exceptions` and
     `servant-exceptions-server`.
   * Add support for `servant > 0.16`.

  ## 0.1.1 - 2018-01-23

   * Add support for `servant-0.12`.

  ## 0.1.0 - 2017-12-16
basic-deps:
  exceptions: -any
  wai: -any
  base: '>=4.7 && <5'
  text: -any
  servant-server: '>=0.11'
  servant: '>=0.11'
  mtl: -any
  servant-exceptions: -any
  http-types: -any
  http-media: -any
all-versions:
- 0.2.0
author: Sebastian Nagel
latest: 0.2.0
description-type: markdown
description: |
  # servant-exceptions [![Build Status](https://travis-ci.org/ch1bo/servant-exceptions.svg?branch=master)](https://travis-ci.org/ch1bo/servant-exceptions)
  Servant servers typically run their handlers in some form of `IO`. Either directly in the builtin `Handler` monad or a custom monad transformer on top it. When APIs fail, one would typically use the `MonadError ServantError` instance via `throwError` to create an error response of type `ServantErr`.

  This approach has two problems:

  * `Handler` (basically being `ExceptT ServantErr IO`) is considered an anti-pattern by some, as it suggests to novice users that only `ServantErr` would occur, but in `IO` any exception can be raised to abort execution
  * `ServantErr` values need to be created at the call site of `throwError`, where the requested content type and/or headers are not available

  `servant-exceptions` tries to help with both by making it easy to catch specific error types with an instance of `Exception` and provide automatic encoding into the requested content-type.

  The API combinator `Throws e` can be used to catch exceptions of type `e` in the server, for example:

  ```haskell
  type API = "api" :> Throws UsersError :> "users" :> Get '[JSON, PlainText] [User]
  ```

  The type `UsersError` can then be used to describe expected errors and their conversion via type class instances:

  ```haskell
  data UsersError = UserNotFound
                  | UserAlreadyExists
                  | InternalError
                  deriving (Show)

  instance Exception UsersError

  instance ToServantErr UsersError where
    status UserNotFound = status404
    status UserAlreadyExists = status409
    status InternalError = status500

  instance ToJSON UsersError where
    toJSON e = object [ "type" .= show (typeOf e)
                      , "message" .= message e
                      ]

  instance MimeRender PlainText UsersError where
    mimeRender ct = mimeRender ct . show
  ```

  ## Planned features

  This package lacks at least

  * `servant-client` support
  * `servant-docs` support
  * Documentation, more examples

  ## Credit

  This package is inspired by `servant-checked-exceptions` (Throws combinator) and
  the generalized error handling in `cardano-sl`.
license-name: BSD-3-Clause
