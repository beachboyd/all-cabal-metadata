homepage: https://github.com/snowleopard/selective
changelog-type: ''
hash: b2c769493c82e23265fd010271164c92cc622b955ad4bc457b7b0207f5740619
test-bench-deps:
  checkers: -any
  base: ! '>=4.7 && <5'
  tasty-expected-failure: ! '>=0.11.1.1'
  containers: ! '>=0.5.7.1 && <7'
  selective: -any
  tasty-quickcheck: ! '>=0.10'
  mtl: ! '>=2.2.1 && <2.3'
  tasty: ! '>=1.2'
  QuickCheck: ! '>=2.9 && <2.13'
maintainer: ! 'Andrey Mokhov <andrey.mokhov@gmail.com>, github: @snowleopard'
synopsis: Selective applicative functors
changelog: ''
basic-deps:
  base: ! '>=4.7 && <5'
  containers: ! '>=0.5.7.1 && <7'
  mtl: ! '>=2.2.1 && <2.3'
  transformers: ! '>=0.5.2.0 && <0.6'
all-versions:
- 0.1.0
author: ! 'Andrey Mokhov <andrey.mokhov@gmail.com>, github: @snowleopard'
latest: 0.1.0
description-type: markdown
description: "# Selective applicative functors\n\nThis is a library for *selective
  applicative functors*, or just *selective functors*\nfor short, an abstraction between
  applicative functors and monads, introduced in\n[this paper](https://www.staff.ncl.ac.uk/andrey.mokhov/selective-functors.pdf).\n\nAbstract
  of the paper:\n\nApplicative functors and monads have conquered the world of functional
  programming by\nproviding general and powerful ways of describing effectful computations
  using pure\nfunctions. Applicative functors provide a way to compose *independent
  effects* that\ncannot depend on values produced by earlier computations, and all
  of which are declared\nstatically. Monads extend the applicative interface by making
  it possible to compose\n*dependent effects*, where the value computed by one effect
  determines all subsequent\neffects, dynamically.\n\nThis paper introduces an intermediate
  abstraction called *selective applicative functors*\nthat requires all effects to
  be declared statically, but provides a way to select which\nof the effects to execute
  dynamically. We demonstrate applications of the new\nabstraction on several examples,
  including two real-life case studies.\n\n\n## What are selective functors?\n\nWhile
  you're encouraged to read the paper, here is a brief description of\nthe main idea.
  Consider the following new type class introduced between\n`Applicative` and `Monad`:\n\n```haskell\nclass
  Applicative f => Selective f where\n    select :: f (Either a b) -> f (a -> b) ->
  f b\n\n-- | An operator alias for 'select'.\n(<*?) :: Selective f => f (Either a
  b) -> f (a -> b) -> f b\n(<*?) = select\n\ninfixl 4 <*?\n```\n\nThink of `select`
  as a *selective function application*: you **must apply** the function\nof type
  `a -> b` when given a value of type `Left a`, but you **may skip** the\nfunction
  and associated effects, and simply return `b` when given `Right b`.\n\nNote that
  you can write a function with this type signature using\n`Applicative` functors,
  but it will always execute the effects associated\nwith the second argument, hence
  being potentially less efficient:\n\n```haskell\nselectA :: Applicative f => f (Either
  a b) -> f (a -> b) -> f b\nselectA x f = (\\e f -> either f id e) <$> x <*> f\n```\n\nAny
  `Applicative` instance can thus be given a corresponding `Selective`\ninstance simply
  by defining `select = selectA`. The opposite is also true\nin the sense that one
  can recover the operator `<*>` from `select` as\nfollows (I'll use the suffix `S`
  to denote `Selective` equivalents of\ncommonly known functions).\n\n```haskell\napS
  :: Selective f => f (a -> b) -> f a -> f b\napS f x = select (Left <$> f) (flip
  ($) <$> x)\n```\n\nHere we wrap a given function `a -> b` into `Left` and turn the
  value `a`\ninto a function `($a)`, which simply feeds itself to the function `a
  -> b`\nyielding `b` as desired. Note: `apS` is a perfectly legal\napplication operator
  `<*>`, i.e. it satisfies the laws dictated by the\n`Applicative` type class as long
  as [the laws](#laws) of the `Selective`\ntype class hold.\n\nThe `branch` function
  is a natural generalisation of `select`: instead of\nskipping an unnecessary effect,
  it chooses which of the two given effectful\nfunctions to apply to a given argument;
  the other effect is unnecessary. It\nis possible to implement `branch` in terms
  of `select`, which is a good\npuzzle (give it a try!).\n\n```haskell\nbranch ::
  Selective f => f (Either a b) -> f (a -> c) -> f (b -> c) -> f c\nbranch = ... --
  Try to figure out the implementation!\n```\n\nFinally, any `Monad` is `Selective`:\n\n```haskell\nselectM
  :: Monad f => f (Either a b) -> f (a -> b) -> f b\nselectM mx mf = do\n    x <-
  mx\n    case x of\n        Left  a -> fmap ($a) mf\n        Right b -> pure b\n```\n\nSelective
  functors are sufficient for implementing many conditional constructs,\nwhich traditionally
  require the (more powerful) `Monad` type class. For example:\n\n```haskell\n-- |
  Branch on a Boolean value, skipping unnecessary effects.\nifS :: Selective f =>
  f Bool -> f a -> f a -> f a\nifS i t e = branch (bool (Right ()) (Left ()) <$> i)
  (const <$> t) (const <$> e)\n\n-- | Conditionally perform an effect.\nwhenS :: Selective
  f => f Bool -> f () -> f ()\nwhenS x act = ifS x act (pure ())\n\n-- | Keep checking
  an effectful condition while it holds.\nwhileS :: Selective f => f Bool -> f ()\nwhileS
  act = whenS act (whileS act)\n\n-- | A lifted version of lazy Boolean OR.\n(<||>)
  :: Selective f => f Bool -> f Bool -> f Bool\n(<||>) a b = ifS a (pure True) b\n\n--
  | A lifted version of 'any'. Retains the short-circuiting behaviour.\nanyS :: Selective
  f => (a -> f Bool) -> [a] -> f Bool\nanyS p = foldr ((<||>) . p) (pure False)\n\n--
  | Return the first @Right@ value. If both are @Left@'s, accumulate errors.\norElse
  :: (Selective f, Semigroup e) => f (Either e a) -> f (Either e a) -> f (Either e
  a)\norElse x = select (Right <$> x) . fmap (\\y e -> first (e <>) y)\n```\n\nSee
  more examples in [src/Control/Selective.hs](src/Control/Selective.hs).\n\nCode written
  using selective combinators can be both statically analysed\n(by reporting all possible
  effects of a computation) and efficiently\nexecuted (by skipping unnecessary effects).\n\n##
  Laws\n\nInstances of the `Selective` type class must satisfy a few laws to make\nit
  possible to refactor selective computations. These laws also allow us\nto establish
  a formal relation with the `Applicative` and `Monad` type\nclasses. \n\n* Identity:\n
  \   ```haskell\n    x <*? pure id = either id id <$> x\n    ```\n\n* Distributivity
  (note that `y` and `z` have the same type `f (a -> b)`):\n    ```haskell\n    pure
  x <*? (y *> z) = (pure x <*? y) *> (pure x <*? z)\n    ```\n* Associativity:\n    ```haskell\n
  \   x <*? (y <*? z) = (f <$> x) <*? (g <$> y) <*? (h <$> z)\n      where\n        f
  x = Right <$> x\n        g y = \\a -> bimap (,a) ($a) y\n        h z = uncurry z\n
  \   ```\n* Monadic select (for selective functors that are also monads):\n    ```haskell\n
  \   select = selectM\n    ```\n\nThere are also a few useful theorems:\n\n* Apply
  a pure function to the result:\n    ```haskell\n    f <$> select x y = select (fmap
  f <$> x) (fmap f <$> y)\n    ```\n\n* Apply a pure function to the `Left` case of
  the first argument:\n    ```haskell\n    select (first f <$> x) y = select x ((.
  f) <$> y)\n    ```\n\n* Apply a pure function to the second argument:\n    ```haskell\n
  \   select x (f <$> y) = select (first (flip f) <$> x) (flip ($) <$> y)\n    ```\n\n*
  Generalised identity:\n    ```haskell\n    x <*? pure y = either y id <$> x\n    ```\n\n*
  A selective functor is *rigid* if it satisfies `<*> = apS`. The following\n*interchange*
  law holds for rigid selective functors:\n    ```haskell\n    x *> (y <*? z) = (x
  *> y) <*? z\n    ```\n\nNote that there are no laws for selective application of
  a function to a pure\n`Left` or `Right` value, i.e. we do not require that the following
  laws hold:\n\n```haskell\nselect (pure (Left  x)) y = ($x) <$> y -- Pure-Left\nselect
  (pure (Right x)) y = pure x     -- Pure-Right\n```\n\nIn particular, the following
  is allowed too:\n\n```haskell\nselect (pure (Left  x)) y = pure ()       -- when
  y :: f (a -> ())\nselect (pure (Right x)) y = const x <$> y\n```\n\nWe therefore
  allow `select` to be selective about effects in these cases, which\nin practice
  allows to under- or over-approximate possible effects in static\nanalysis using
  instances like `Under` and `Over`.\n\nIf `f` is also a `Monad`, we require that
  `select = selectM`, from which one\ncan prove `apS = <*>`, and furthermore the above
  `Pure-Left` and `Pure-Right` \nproperties now hold.\n\n## Static analysis of selective
  functors\n\nLike applicative functors, selective functors can be analysed statically.\nWe
  can make the `Const` functor an instance of `Selective` as follows.\n\n```haskell\ninstance
  Monoid m => Selective (Const m) where\n    select = selectA\n```\n\nAlthough we
  don't need the function `Const m (a -> b)` (note that\n`Const m (Either a b)` holds
  no values of type `a`), we choose to\naccumulate the effects associated with it.
  This allows us to extract\nthe static structure of any selective computation very
  similarly\nto how this is done with applicative computations.\n\nThe `Validation`
  instance is perhaps a bit more interesting.\n\n```haskell\ndata Validation e a =
  Failure e | Success a deriving (Functor, Show)\n\ninstance Semigroup e => Applicative
  (Validation e) where\n    pure = Success\n    Failure e1 <*> Failure e2 = Failure
  (e1 <> e2)\n    Failure e1 <*> Success _  = Failure e1\n    Success _  <*> Failure
  e2 = Failure e2\n    Success f  <*> Success a  = Success (f a)\n\ninstance Semigroup
  e => Selective (Validation e) where\n    select (Success (Right b)) _ = Success
  b\n    select (Success (Left  a)) f = Success ($a) <*> f\n    select (Failure e
  \       ) _ = Failure e\n```\n\nHere, the last line is particularly interesting:
  unlike the `Const`\ninstance, we choose to actually skip the function effect in
  case of\n`Failure`. This allows us not to report any validation errors which\nare
  hidden behind a failed conditional.\n\nLet's clarify this with an example. Here
  we define a function to\nconstruct a `Shape` (a circle or a rectangle) given a choice
  of the\nshape `s` and the shape's parameters (`r`, `w`, `h`) in a selective\ncontext
  `f`.\n\n```haskell\ntype Radius = Int\ntype Width  = Int\ntype Height = Int\n\ndata
  Shape = Circle Radius | Rectangle Width Height deriving Show\n\nshape :: Selective
  f => f Bool -> f Radius -> f Width -> f Height -> f Shape\nshape s r w h = ifS s
  (Circle <$> r) (Rectangle <$> w <*> h)\n```\n\nWe choose `f = Validation [String]`
  to report the errors that occurred\nwhen parsing a value. Let's see how it works.\n\n```haskell\n>
  shape (Success True) (Success 10) (Failure [\"no width\"]) (Failure [\"no height\"])\nSuccess
  (Circle 10)\n\n> shape (Success False) (Failure [\"no radius\"]) (Success 20) (Success
  30)\nSuccess (Rectangle 20 30)\n\n> shape (Success False) (Failure [\"no radius\"])
  (Success 20) (Failure [\"no height\"])\nFailure [\"no height\"]\n\n> shape (Success
  False) (Failure [\"no radius\"]) (Failure [\"no width\"]) (Failure [\"no height\"])\nFailure
  [\"no width\",\"no height\"]\n\n> shape (Failure [\"no choice\"]) (Failure [\"no
  radius\"]) (Success 20) (Failure [\"no height\"])\nFailure [\"no choice\"]\n```\n\nIn
  the last example, since we failed to parse which shape has been chosen,\nwe do not
  report any subsequent errors. But it doesn't mean we are short-circuiting\nthe validation.
  We will continue accumulating errors as soon as we get out of the\nopaque conditional,
  as demonstrated below.\n\n```haskell\ntwoShapes :: Selective f => f Shape -> f Shape
  -> f (Shape, Shape)\ntwoShapes s1 s2 = (,) <$> s1 <*> s2\n\n> s1 = shape (Failure
  [\"no choice 1\"]) (Failure [\"no radius 1\"]) (Success 20) (Failure [\"no height
  1\"])\n> s2 = shape (Success False) (Failure [\"no radius 2\"]) (Success 20) (Failure
  [\"no height 2\"])\n> twoShapes s1 s2\nFailure [\"no choice 1\",\"no height 2\"]\n```\n\n##
  Do we still need monads?\n\nYes! Here is what selective functors cannot do: `join
  :: Selective f => f (f a) -> f a`.\n\n## Further reading\n\n* A paper introducing
  selective functors: https://www.staff.ncl.ac.uk/andrey.mokhov/selective-functors.pdf.\n*
  An older blog post introducing selective functors: https://blogs.ncl.ac.uk/andreymokhov/selective.\n"
license-name: MIT
