homepage: https://github.com/athanclark/sets#readme
changelog-type: ''
hash: 24c059a1f08cbc72c1fb3086fe3f7e6fd50281715726018ac424860311c6c466
test-bench-deps:
  semigroupoids: -any
  bytestring: -any
  witherable: -any
  base: ! '>=4.11 && <5.0'
  unordered-containers: -any
  composition: -any
  criterion: -any
  semigroups: -any
  containers: -any
  keys: -any
  quickcheck-instances: -any
  commutative: -any
  contravariant: -any
  tasty-quickcheck: -any
  mtl: -any
  hashable: -any
  tasty-hunit: -any
  transformers-base: -any
  transformers: -any
  tasty: -any
  QuickCheck: ! '>=2.9.2'
  vector: -any
  sets: -any
maintainer: athan.clark@localcooking.com
synopsis: Ducktyped set interface for Haskell containers.
changelog: ''
basic-deps:
  semigroupoids: -any
  bytestring: -any
  witherable: -any
  base: ! '>=4.11 && <5.0'
  unordered-containers: -any
  composition: -any
  semigroups: -any
  containers: -any
  keys: -any
  commutative: ! '>=0.0.2'
  contravariant: -any
  mtl: -any
  hashable: -any
  transformers-base: -any
  transformers: -any
  QuickCheck: ! '>=2.9.2'
  vector: -any
all-versions:
- 0.0.4.1
- 0.0.5
- 0.0.5.1
- 0.0.5.2
- 0.0.6
author: Athan Clark
latest: 0.0.6
description-type: markdown
description: ! "sets\n====\n\nThis package provides overloaded terms, commonly used
  with set-like types,\nlike `Map` and `Set` from `containers`. There are also unorthodox,
  mostly useless\ndata types defined here - playing with ordering, uniqueness and
  finiteness.\n\n## Usage\n\nThe following actions are overloaded:\n\n__Binary Operators__:\n\n-
  `union`\n- `intersection`\n- `difference`\n- `complement`\n\n__Top and Bottom Elements__:\n\n-
  `empty`\n- `total`\n\n__Element-Wise Operations__:\n\n- `singleton`\n- `insert`\n-
  `delete`\n\n__Metrics and Comparison__:\n\n- `size`\n- `isSubsetOf` `isProperSubsetOf`\n\n---\n\nEach
  of the operations has their own typeclass. We have also made newtype wrappers\nfor
  lists, for different restrictions:\n\n- Ordered Sets\n    - Multiple\n- Unordered
  Sets\n    - Unique\n    - Multiple\n\nThis way, we can expect the following to work:\n\n```haskell\nuniqueAppend
  :: Eq a => [a] -> [a] -> [a]\nuniqueAppend xs ys = unUUSet $ fromFoldable xs `union`
  fromFoldable ys\n\norderedAppend :: Ord a => [a] -> [a] -> [a]\norderedAppend xs
  ys = unOMSet $ fromFoldable xs `union` fromFoldable ys\n```\n\n---\n\nWe've also
  made a few newtypes to encode our binary operations, for `Monoid`\nand `Semigroup`
  instances:\n\n```haskell\ninstance (HasUnion s, HasEmpty s) => Monoid (Union s)
  where\n  mempty = empty\n  mappend = union\n```\n\n### Multiple Set Types\n\nTo
  use the overloaded terms, they need to be the only ones in scope. To make this\ncorrect,
  we need to import our container with caution:\n\n```haskell\nimport qualified Data.Set
  as Set\nimport Data.Map (Map) -- only the type name to designate behavior\n\nfoo
  :: Map\nfoo = x `union` y\n\nbar :: Set.Set\nbar = a `union` b\n```\n\nThis way,
  we can keep our code more readable while still having set-like intuition.\n\n##
  Testing and Benchmarking\n\n> You can view the results [here](https://github.com/athanclark/sets/raw/master/profile.html)\n>
  (__warning__: it's a 7MB text file - your browser will hate you)\n\nThe tests are
  built with QuickCheck - it's pretty easy to get them working for you:\n\n```bash\ncabal
  install --enable-tests\ncabal test --show-details=always\n```\n\n(...or for the
  stack folk...)\n\n```bash\nstack build\nstack test\n```\n\n---\n\nTo benchmark (it
  usually takes about 10 minutes on my laptop), run the command!\n\n```bash\ncabal
  install --enable-benchmarks\ncabal bench\n```\n\n(...stiggitty-stack is co-wiggity-whack...)\n\n```bash\nstack
  build\nstack bench --benchmark-arguments=\"--output profile.html\"\n```\n"
license-name: BSD-3-Clause
