homepage: http://github.com/haskell-servant/servant-auth#readme
changelog-type: markdown
hash: 60ad7436fd52b42b9fdd404e5bbc2649a2348f27a849adbe91a09dcee654b1f3
test-bench-deps:
  warp: ! '>=3.2.25 && <3.3'
  http-client: ! '>=0.5.13.1 && <0.7'
  servant-auth-server: -any
  bytestring: -any
  lens-aeson: ! '>=1.0.2 && <1.1'
  wai: -any
  case-insensitive: -any
  base: -any
  time: -any
  hspec: ! '>=2.5.5 && <2.8'
  jose: -any
  servant-server: -any
  servant: -any
  wreq: ! '>=0.5.2.1 && <0.6'
  lens: -any
  servant-auth: -any
  mtl: -any
  transformers: -any
  QuickCheck: ! '>=2.11.3 && <2.14'
  http-types: -any
  aeson: -any
maintainer: jkarni@gmail.com
synopsis: servant-server/servant-auth compatibility
changelog: |
  # Changelog

  All notable changes to this project will be documented in this file.

  The format is based on [Keep a Changelog](http://keepachangelog.com/en/1.0.0/)
  and this project adheres to [PVP Versioning](https://pvp.haskell.org/).

  ## [Unreleased]

  ## [0.4.4.0] - 2019-03-02

  ### Added
  - #141 Support Stream combinator [@domenkozar]
  - #143 Allow servant-0.16 [@phadej]

  ## [0.4.3.0] - 2019-01-17

  ## Changed
  - #117 Avoid running auth checks unnecessarily [@sopvop]
  - #110 Get rid of crypto-api dependency [@domenkozar]
  - #130 clearSession: improve cross-browser compatibility [@domenkozar]
  - #136 weed out bytestring-conversion [@stephenirl]

  ## [0.4.2.0] - 2018-11-05

  ### Added
  - `Headers hs a` instance for AddSetCookieApi [@domenkozar]
  - GHC 8.6.x support [@domenkozar]

  ## [0.4.1.0] - 2018-10-05

  ### Added
  - #125 Allow setting domain name for a cookie [@domenkozar]

  ## Changed
  - bump http-api-data to 0.3.10 that includes Cookie orphan instances previously located in servant-auth-server [@phadej]
  - #114 Export `HasSecurity` typeclass [@rockbmb]

  ## [0.4.0.1] - 2018-09-23

  ### Security
  - #123 Session cookie did not apply SameSite attribute [@domenkozar]

  ### Added
  - #112 HasLink instance for Auth combinator [@adetokunbo]
  - #111 Documentation for using hoistServer [@mschristiansen]
  - #107 Add utility functions for reading and writing a key to a file [@mschristiansen]

  ## [0.4.0.0] - 2018-06-17

  ### Added
  - Support GHC 8.4 by @phadej and @domenkozar
  - Support for servant-0.14 by @phadej
  - #96 Support for jose-0.7 by @xaviershay
  - #92 add `clearSession` for logout by @plredmond and @3noch
  - #95 makeJWT: allow setting Alg via defaultJWTSettings by @domenkozar
  - #89 Validate JWT against a JWKSet instead of JWK by @sopvop

  ### Changed
  - #92 Rename CSRF to XSRF by @plredmond and @3noch
  - #92 extract 'XsrfCookieSettings' from 'CookieSettings' and make XSRF checking optional
    by @plredmond and @3noch
  - #69 export SameSite by @domenkozar
  - #102 Reuse Servant.Api.IsSecure instead of duplicating ADT by @domenkozar

  ### Deprecated
  - #92 Renamed 'makeCsrfCookie' to 'makeXsrfCookie' and marked the former as deprecated
    by @plredmond and @3noc
  - #92 Made several changes to the structure of 'CookieSettings' which will require
    attention by users who have modified the XSRF settings by @plredmond and @3noch

  ### Security
  - #94 Force cookie expiration on serverside by @karshan

  ## [0.3.2.0] - 2018-02-21

  ### Added
  - #76 Export wwwAuthenticatedErr and elaborate its annotation by @defanor
  - Support for servant-0.14 by @phadej

  ### Changed
  - Disable the readme executable for ghcjs builds by @hamishmack
  - #84 Make AddSetCookieApi type family open by @qnikst
  - #79 Make CSRF checks optional for GET requests by @harendra-kumar

  ## [0.3.1.0] - 2017-11-08

  ### Added
  - Support for servant-0.12 by @phadej

  ## [0.3.0.0] - 2017-11-07

  ### Changed
  - #47 'cookiePath' and 'xsrfCookiePath' added to 'CookieSettings' by @mchaver

  ## [0.2.8.0] - 2017-05-26

  ### Added
  - #45 Support for servant-0.11 by @phadej

  ## [0.2.7.0] - 2017-02-11

  ### Changed
  - #27 #41 'acceptLogin' and 'makeCsrfCookie' functions by @bts
basic-deps:
  cookie: ! '>=0.4.4 && <0.5'
  bytestring: ! '>=0.10.6.0 && <0.11'
  wai: ! '>=3.2.1.2 && <3.3'
  case-insensitive: ! '>=1.2.0.11 && <1.3'
  base: ! '>=4.8 && <4.13'
  data-default-class: ! '>=0.1.2.0 && <0.2'
  time: ! '>=1.5.0.1 && <1.9'
  base64-bytestring: ! '>=1.0.0.1 && <1.1'
  unordered-containers: ! '>=0.2.9.0 && <0.3'
  text: ! '>=1.2.3.0 && <1.3'
  entropy: ! '>=0.4.1.3 && <0.5'
  jose: ! '>=0.7.0.0 && <0.9'
  servant-server: ! '>=0.13 && <0.17'
  servant: ! '>=0.13 && <0.17'
  monad-time: ! '>=0.3.1.0 && <0.4'
  memory: ! '>=0.14.16 && <0.15'
  tagged: ! '>=0.8.4 && <0.9'
  blaze-builder: ! '>=0.4.1.0 && <0.5'
  lens: ! '>=4.16.1 && <4.18'
  servant-auth: ==0.3.*
  mtl: ! '>=2.2.2 && <2.3'
  http-types: ! '>=0.12.2 && <0.13'
  aeson: ! '>=1.3.1.1 && <1.5'
all-versions:
- 0.1.0.0
- 0.1.0.1
- 0.2.0.0
- 0.2.1.0
- 0.2.3.0
- 0.2.4.0
- 0.2.6.0
- 0.2.6.1
- 0.2.7.0
- 0.2.8.0
- 0.3.0.0
- 0.3.1.0
- 0.3.2.0
- 0.4.0.0
- 0.4.0.1
- 0.4.1.0
- 0.4.2.0
- 0.4.3.0
- 0.4.4.0
author: Julian K. Arni
latest: 0.4.4.0
description-type: text
description: "# servant-auth\n\n[![Build Status](https://travis-ci.org/haskell-servant/servant-auth.svg?branch=master)](https://travis-ci.org/haskell-servant/servant-auth)\n\nThese
  packages provides safe and easy-to-use authentication options for\n`servant`. The
  same API can be protected via:\n- basicauth\n- cookies\n- JWT tokens\n\n\n| Package
  \             | Hackage                                                                                                                           |\n|
  -------------------- | ---------------------------------------------------------------------------------------------------------------------------------
  |\n| servant-auth         | [![Hackage](https://img.shields.io/hackage/v/servant-auth.svg)](https://hackage.haskell.org/package/servant-auth)
  \                |\n| servant-auth-server  | [![Hackage](https://img.shields.io/hackage/v/servant-auth-server.svg)](https://hackage.haskell.org/package/servant-auth-server)
  \  |\n| servant-auth-client  | [![Hackage](https://img.shields.io/hackage/v/servant-auth-client.svg)](https://hackage.haskell.org/package/servant-auth-client)
  \  |\n| servant-auth-swagger | [![Hackage](https://img.shields.io/hackage/v/servant-auth-swagger.svg)](https://hackage.haskell.org/package/servant-auth-swagger)
  |\n| servant-auth-docs    | [![Hackage](https://img.shields.io/hackage/v/servant-auth-docs.svg)](https://hackage.haskell.org/package/servant-auth-docs)
  \      |\n\n## How it works\n\nFirst some imports:\n\n~~~ haskell\n{-# OPTIONS_GHC
  -fno-warn-unused-binds #-}\n{-# OPTIONS_GHC -fno-warn-deprecations #-}\nimport Control.Concurrent
  (forkIO)\nimport Control.Monad (forever)\nimport Control.Monad.Trans (liftIO)\nimport
  Data.Aeson (FromJSON, ToJSON)\nimport GHC.Generics (Generic)\nimport Network.Wai.Handler.Warp
  (run)\nimport System.Environment (getArgs)\nimport Servant\nimport Servant.Auth.Server\nimport
  Servant.Auth.Server.SetCookieOrphan ()\n~~~\n\n`servant-auth` library introduces
  a combinator `Auth`:\n\n~~~ haskell\ndata Auth (auths :: [*]) val\n~~~\n\nWhat `Auth
  [Auth1, Auth2] Something :> API` means is that `API` is protected by\n*either* `Auth1`
  *or* `Auth2`, and the result of authentication will be of type\n`AuthResult Something`,
  where :\n\n~~~ haskell\ndata AuthResult val\n  = BadPassword\n  | NoSuchUser\n  |
  Authenticated val\n  | Indefinite\n~~~\n\nYour handlers will get a value of type
  `AuthResult Something`, and can decide\nwhat to do with it.\n\n~~~ haskell\n\ndata
  User = User { name :: String, email :: String }\n   deriving (Eq, Show, Read, Generic)\n\ninstance
  ToJSON User\ninstance ToJWT User\ninstance FromJSON User\ninstance FromJWT User\n\ndata
  Login = Login { username :: String, password :: String }\n   deriving (Eq, Show,
  Read, Generic)\n\ninstance ToJSON Login\ninstance FromJSON Login\n\ntype Protected\n
  \  = \"name\" :> Get '[JSON] String\n :<|> \"email\" :> Get '[JSON] String\n\n\n--
  | 'Protected' will be protected by 'auths', which we still have to specify.\nprotected
  :: Servant.Auth.Server.AuthResult User -> Server Protected\n-- If we get an \"Authenticated
  v\", we can trust the information in v, since\n-- it was signed by a key we trust.\nprotected
  (Servant.Auth.Server.Authenticated user) = return (name user) :<|> return (email
  user)\n-- Otherwise, we return a 401.\nprotected _ = throwAll err401\n\ntype Unprotected
  =\n \"login\"\n     :> ReqBody '[JSON] Login\n     :> PostNoContent '[JSON] (Headers
  '[ Header \"Set-Cookie\" SetCookie\n                                        , Header
  \"Set-Cookie\" SetCookie]\n                                       NoContent)\n  :<|>
  Raw\n\nunprotected :: CookieSettings -> JWTSettings -> Server Unprotected\nunprotected
  cs jwts = checkCreds cs jwts :<|> serveDirectory \"example/static\"\n\ntype API
  auths = (Servant.Auth.Server.Auth auths User :> Protected) :<|> Unprotected\n\nserver
  :: CookieSettings -> JWTSettings -> Server (API auths)\nserver cs jwts = protected
  :<|> unprotected cs jwts\n\n~~~\n\nThe code is common to all authentications. In
  order to pick one or more specific\nauthentication methods, all we need to do is
  provide the expect configuration\nparameters.\n\n## API tokens\n\nThe following
  example illustrates how to protect an API with tokens.\n\n\n~~~ haskell\n-- In main,
  we fork the server, and allow new tokens to be created in the\n-- command line for
  the specified user name and email.\nmainWithJWT :: IO ()\nmainWithJWT = do\n  --
  We generate the key for signing tokens. This would generally be persisted,\n  --
  and kept safely\n  myKey <- generateKey\n  -- Adding some configurations. All authentications
  require CookieSettings to\n  -- be in the context.\n  let jwtCfg = defaultJWTSettings
  myKey\n      cfg = defaultCookieSettings :. jwtCfg :. EmptyContext\n      --- Here
  we actually make concrete\n      api = Proxy :: Proxy (API '[JWT])\n  _ <- forkIO
  $ run 7249 $ serveWithContext api cfg (server defaultCookieSettings jwtCfg)\n\n
  \ putStrLn \"Started server on localhost:7249\"\n  putStrLn \"Enter name and email
  separated by a space for a new token\"\n\n  forever $ do\n     xs <- words <$> getLine\n
  \    case xs of\n       [name', email'] -> do\n         etoken <- makeJWT (User
  name' email') jwtCfg Nothing\n         case etoken of\n           Left e -> putStrLn
  $ \"Error generating token:t\" ++ show e\n           Right v -> putStrLn $ \"New
  token:\\t\" ++ show v\n       _ -> putStrLn \"Expecting a name and email separated
  by spaces\"\n\n~~~\n\nAnd indeed:\n\n~~~ bash\n\n./readme JWT\n\n    Started server
  on localhost:7249\n    Enter name and email separated by a space for a new token\n
  \   alice alice@gmail.com\n    New token:\t\"eyJhbGciOiJIUzI1NiJ9.eyJkYXQiOnsiZW1haWwiOiJhbGljZUBnbWFpbC5jb20iLCJuYW1lIjoiYWxpY2UifX0.xzOIrx_A9VOKzVO-R1c1JYKBqK9risF625HOxpBzpzE\"\n\ncurl
  localhost:7249/name -v\n\n    * Hostname was NOT found in DNS cache\n    *   Trying
  127.0.0.1...\n    * Connected to localhost (127.0.0.1) port 7249 (#0)\n    > GET
  /name HTTP/1.1\n    > User-Agent: curl/7.35.0\n    > Host: localhost:7249\n    >
  Accept: */*\n    >\n    < HTTP/1.1 401 Unauthorized\n    < Transfer-Encoding: chunked\n
  \   < Date: Wed, 07 Sep 2016 20:17:17 GMT\n    * Server Warp/3.2.7 is not blacklisted\n
  \   < Server: Warp/3.2.7\n    <\n    * Connection #0 to host localhost left intact\n\ncurl
  -H \"Authorization: Bearer eyJhbGciOiJIUzI1NiJ9.eyJkYXQiOnsiZW1haWwiOiJhbGljZUBnbWFpbC5jb20iLCJuYW1lIjoiYWxpY2UifX0.xzOIrx_A9VOKzVO-R1c1JYKBqK9risF625HOxpBzpzE\"
  \\\n  localhost:7249/name -v\n\n    * Hostname was NOT found in DNS cache\n    *
  \  Trying 127.0.0.1...\n    * Connected to localhost (127.0.0.1) port 7249 (#0)\n
  \   > GET /name HTTP/1.1\n    > User-Agent: curl/7.35.0\n    > Host: localhost:7249\n
  \   > Accept: */*\n    > Authorization: Bearer eyJhbGciOiJIUzI1NiJ9.eyJkYXQiOnsiZW1haWwiOiJhbGljZUBnbWFpbC5jb20iLCJuYW1lIjoiYWxpY2UifX0.xzOIrx_A9VOKzVO-R1c1JYKBqK9risF625HOxpBzpzE\n
  \   >\n    < HTTP/1.1 200 OK\n    < Transfer-Encoding: chunked\n    < Date: Wed,
  07 Sep 2016 20:16:11 GMT\n    * Server Warp/3.2.7 is not blacklisted\n    < Server:
  Warp/3.2.7\n    < Content-Type: application/json\n    < Set-Cookie: JWT-Cookie=eyJhbGciOiJIUzI1NiJ9.eyJkYXQiOnsiZW1haWwiOiJhbGljZUBnbWFpbC5jb20iLCJuYW1lIjoiYWxpY2UifX0.xzOIrx_A9VOKzVO-R1c1JYKBqK9risF625HOxpBzpzE;
  HttpOnly; Secure\n    <  Set-Cookie: XSRF-TOKEN=TWcdPnHr2QHcVyTw/TTBLQ==; Secure\n
  \   <\n    * Connection #0 to host localhost left intact\n    \"alice\"%\n\n\n~~~\n\n##
  Cookies\n\nWhat if, in addition to API tokens, we want to expose our API to browsers?
  All\nwe need to do is say so!\n\n~~~ haskell\nmainWithCookies :: IO ()\nmainWithCookies
  = do\n  -- We *also* need a key to sign the cookies\n  myKey <- generateKey\n  --
  Adding some configurations. 'Cookie' requires, in addition to\n  -- CookieSettings,
  JWTSettings (for signing), so everything is just as before\n  let jwtCfg = defaultJWTSettings
  myKey\n      cfg = defaultCookieSettings :. jwtCfg :. EmptyContext\n      --- Here
  is the actual change\n      api = Proxy :: Proxy (API '[Cookie])\n  run 7249 $ serveWithContext
  api cfg (server defaultCookieSettings jwtCfg)\n\n-- Here is the login handler\ncheckCreds
  :: CookieSettings\n           -> JWTSettings\n           -> Login\n           ->
  Handler (Headers '[ Header \"Set-Cookie\" SetCookie\n                                ,
  Header \"Set-Cookie\" SetCookie]\n                               NoContent)\ncheckCreds
  cookieSettings jwtSettings (Login \"Ali Baba\" \"Open Sesame\") = do\n   -- Usually
  you would ask a database for the user info. This is just a\n   -- regular servant
  handler, so you can follow your normal database access\n   -- patterns (including
  using 'enter').\n   let usr = User \"Ali Baba\" \"ali@email.com\"\n   mApplyCookies
  <- liftIO $ acceptLogin cookieSettings jwtSettings usr\n   case mApplyCookies of\n
  \    Nothing           -> throwError err401\n     Just applyCookies -> return $
  applyCookies NoContent\ncheckCreds _ _ _ = throwError err401\n~~~\n\n### XSRF and
  the frontend\n\nXSRF protection works by requiring that there be a header of the
  same value as\na distinguished cookie that is set by the server on each request.
  What the\ncookie and header name are can be configured (see `xsrfCookieName` and\n`xsrfHeaderName`
  in `CookieSettings`), but by default they are \"XSRF-TOKEN\" and\n\"X-XSRF-TOKEN\".
  This means that, if your client is a browser and your are using\ncookies, Javascript
  on the client must set the header of each request by\nreading the cookie. For jQuery,
  and with the default values, that might be:\n\n~~~ javascript\n\nvar token = (function()
  {\n  r = document.cookie.match(new RegExp('XSRF-TOKEN=([^;]+)'))\n  if (r) return
  r[1];\n)();\n\n\n$.ajaxPrefilter(function(opts, origOpts, xhr) {\n  xhr.setRequestHeader('X-XSRF-TOKEN',
  token);\n  }\n\n~~~\n\nI *believe* nothing at all needs to be done if you're using
  Angular's `$http`\ndirective, but I haven't tested this.\n\nXSRF protection can
  be disabled just for `GET` requests by setting\n`xsrfExcludeGet = False`. You might
  want this if you're relying on the browser\nto navigate between pages that require
  cookie authentication.\n\nXSRF protection can be completely disabled by setting
  `cookieXsrfSetting =\nNothing` in `CookieSettings`. This is not recommended! If
  your cookie\nauthenticated web application runs any javascript, it's recommended
  to send the\nXSRF header. However, if your web application runs no javascript, disabling\nXSRF
  entirely may be required.\n\n# Note on this README\n\nThis README is a literate
  haskell file. Here is 'main', allowing you to pick\nbetween the examples above.\n\n~~~
  haskell\n\nmain :: IO ()\nmain = do\n  args <- getArgs\n  let usage = \"Usage: readme
  (JWT|Cookie)\"\n  case args of\n    [\"JWT\"] -> mainWithJWT\n    [\"Cookie\"] ->
  mainWithCookies\n    e -> putStrLn $ \"Arguments: \\\"\" ++ unwords e ++ \"\\\"
  not understood\\n\" ++ usage\n\n~~~\n"
license-name: BSD-3-Clause
