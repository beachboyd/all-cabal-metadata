homepage: http://docs.servant.dev/
changelog-type: markdown
hash: 494007c6d22e95c74d65cedcdfc77cd1d0dcef9f1b3d1b0809e193f035a256c1
test-bench-deps:
  base: -any
  hspec: ! '>=2.6.0 && <2.8'
  servant-client-core: -any
  base-compat: -any
  deepseq: ! '>=1.4.2.0 && <1.5'
  QuickCheck: ! '>=2.12.6.1 && <2.14'
maintainer: haskell-servant-maintainers@googlegroups.com
synopsis: Core functionality and class for client function generation for servant
  APIs
changelog: |
  [The latest version of this document is on GitHub.](https://github.com/haskell-servant/servant/blob/master/servant-client-core/CHANGELOG.md)
  [Changelog for `servant` package contains significant entries for all core packages.](https://github.com/haskell-servant/servant/blob/master/servant/CHANGELOG.md)

  0.16
  ----

  - Rename `ServantError` to `ClientError`, `ServantErr` to `ServerError`
    [#1131](https://github.com/haskell-servant/servant/pull/1131)

  - *servant-client-core* Rearrange modules. No more `Internal` modules, whole
    API is versioned.
    [#1130](https://github.com/haskell-servant/servant/pull/1130)

  - *servant-client-core* `RequestBody` is now

      ```haskell
      = RequestBodyLBS LBS.ByteString
      | RequestBodyBS BS.ByteString
      | RequestBodySource (SourceIO LBS.ByteString)
      ```

    i.e. no more replicates `http-client`s API.
    [#1117](https://github.com/haskell-servant/servant/pull/1117)

  - *servant-client-core* Keep structured exceptions in `ConnectionError`
    constructor of `ClientError`
    [#1115](https://github.com/haskell-servant/servant/pull/1115)

      ```diff
      -| ConnectionError Text
      +| ConnectionError SomeException
      ```

  - *servant-client-core* Preserve failing request in `FailureResponse`
    constructor of `ClientError`
    [#1114](https://github.com/haskell-servant/servant/pull/1114)

      ```diff
      -FailureResponse Response
      +-- | The server returned an error response including the
      +-- failing request. 'requestPath' includes the 'BaseUrl' and the
      +-- path of the request.
      +FailureResponse (RequestF () (BaseUrl, BS.ByteString)) Response
      ```

  - *servant-client* Fix (implement) `StreamBody` instance
    [#1110](https://github.com/haskell-servant/servant/pull/1110)

  - *servant-client* Update CookieJar with intermediate request/responses (redirects)
    [#1104](https://github.com/haskell-servant/servant/pull/1104)

  0.15
  ----

  - Streaming refactoring.
    [#991](https://github.com/haskell-servant/servant/pull/991)
    [#1076](https://github.com/haskell-servant/servant/pull/1076)
    [#1077](https://github.com/haskell-servant/servant/pull/1077)

    The streaming functionality (`Servant.API.Stream`) is refactored to use
    `servant`'s own `SourceIO` type (see `Servant.Types.SourceT` documentation),
    which replaces both `StreamGenerator` and `ResultStream` types.

    New conversion type-classes are `ToSourceIO` and `FromSourceIO`
    (replacing `ToStreamGenerator` and `BuildFromStream`).
    There are instances for *conduit*, *pipes* and *machines* in new packages:
    [servant-conduit](https://hackage.haskell.org/package/servant-conduit)
    [servant-pipes](https://hackage.haskell.org/package/servant-pipes) and
    [servant-machines](https://hackage.haskell.org/package/servant-machines)
    respectively.

    Writing new framing strategies is simpler. Check existing strategies for examples.

    This change shouldn't affect you, if you don't use streaming endpoints.

  - *servant-client* Separate streaming client.
    [#1066](https://github.com/haskell-servant/servant/pull/1066)

    We now have two `http-client` based clients,
    in `Servant.Client` and `Servant.Client.Streaming`.

    Their API is the same, except for
    - `Servant.Client` **cannot** request `Stream` endpoints.
    - `Servant.Client` is *run* by direct
      `runClientM :: ClientM a -> ClientEnv -> IO (Either ServantError a)`
    - `Servant.Client.Streaming` **can** request `Stream` endpoints.
    - `Servant.Client.Streaming` is *used* by CPSised
      `withClientM :: ClientM a -> ClientEnv -> (Either ServantError a -> IO b) -> IO b`

    To access `Stream` endpoints use `Servant.Client.Streaming` with
    `withClientM`; otherwise you can continue using `Servant.Client` with `runClientM`.
    You can use both too, `ClientEnv` and `BaseUrl` types are same for both.

    **Note:** `Servant.Client.Streaming` doesn't *stream* non-`Stream` endpoints.
    Requesting ordinary `Verb` endpoints (e.g. `Get`) will block until
    the whole response is received.

    There is `Servant.Client.Streaming.runClientM` function, but it has
    restricted type. `NFData a` constraint prevents using it with
    `SourceT`, `Conduit` etc. response types.

    ```haskell
    runClientM :: NFData a => ClientM a -> ClientEnv -> IO (Either ServantError a)
    ```

    This change shouldn't affect you, if you don't use streaming endpoints.

  - *servant-client-core* Related to the previous:
    `streamingResponse` is removed from `RunClient`.
    We have a new type-class:

    ```haskell
    class RunClient m =>  RunStreamingClient m where
        withStreamingRequest :: Request -> (StreamingResponse -> IO a) ->  m a
    ```

  - Drop support for GHC older than 8.0
    [#1008](https://github.com/haskell-servant/servant/pull/1008)
    [#1009](https://github.com/haskell-servant/servant/pull/1009)

  - *servant-client-core* Add `NFData (GenResponse a)` and `NFData ServantError` instances.
    [#1076](https://github.com/haskell-servant/servant/pull/1076)

  - *servant-client-core* Add `aeson` and `Lift BaseUrl` instances
    [#1037](https://github.com/haskell-servant/servant/pull/1037)

  0.14.1
  ------

  - Merge in `servant-generic` (by [Patrick Chilton](https://github.com/chpatrick))
    into `servant` (`Servant.API.Generic`),
    `servant-client-code` (`Servant.Client.Generic`)
    and `servant-server` (`Servant.Server.Generic`).

  0.14
  ----

  - `Stream` takes a status code argument

    ```diff
    -Stream method        framing ctype a
    +Stream method status framing ctype a
    ```

    ([#966](https://github.com/haskell-servant/servant/pull/966)
     [#972](https://github.com/haskell-servant/servant/pull/972))

  - `ToStreamGenerator` definition changed, so it's possible to write an instance
    for conduits.

    ```diff
    -class ToStreamGenerator f a where
    -   toStreamGenerator :: f a -> StreamGenerator a
    +class ToStreamGenerator a b | a -> b where
    +   toStreamGenerator :: a -> StreamGenerator b
    ```

    ([#959](https://github.com/haskell-servant/servant/pull/959))

  - Added `NoFraming` streaming strategy
    ([#959](https://github.com/haskell-servant/servant/pull/959))

  - *servant-client-core* Free `Client` implementation.
    Useful for testing `HasClient` instances.
    ([#920](https://github.com/haskell-servant/servant/pull/920))

  - *servant-client-core* Add `hoistClient` to `HasClient`.
    Just like `hoistServer` allows us to change the monad in which request handlers
    of a web application live in, we also have `hoistClient` for changing the monad
    in which *client functions* live.
    Read [tutorial section for more information](https://haskell-servant.readthedocs.io/en/release-0.14/tutorial/Client.html#changing-the-monad-the-client-functions-live-in).
    ([#936](https://github.com/haskell-servant/servant/pull/936))

    iF you have own combinators, you'll need to define a new method of
    `HasClient` class, for example:

    ```haskell
    type Client m (MyCombinator :> api) = MyValue :> Client m api
    hoistClientMonad pm _ nt cl = hoistClientMonad pm (Proxy :: Proxy api) nt . cl
    ```

  0.13.0.1
  --------

  - Support `base-compat-0.10`

  0.13
  ----

  - Streaming endpoint support.
    ([#836](https://github.com/haskell-servant/servant/pull/836))
  - *servant* Add `Servant.API.Modifiers`
    ([#873](https://github.com/haskell-servant/servant/pull/873))

  0.12
  ----

  - First version. Factored out of `servant-client` all the functionality that was
    independent of the `http-client` backend.
basic-deps:
  exceptions: ! '>=0.10.0 && <0.11'
  free: ! '>=5.1 && <5.2'
  bytestring: ! '>=0.10.8.1 && <0.11'
  base: ! '>=4.9 && <4.13'
  base64-bytestring: ! '>=1.0.0.1 && <1.1'
  text: ! '>=1.2.3.0 && <1.3'
  servant: ! '>=0.16 && <0.17'
  containers: ! '>=0.5.7.1 && <0.7'
  base-compat: ! '>=0.10.5 && <0.11'
  bifunctors: ! '>=5.5.3 && <5.6'
  network-uri: ! '>=2.6.1.0 && <2.7'
  transformers: ! '>=0.5.2.0 && <0.6'
  deepseq: ! '>=1.4.2.0 && <1.5'
  http-types: ! '>=0.12.2 && <0.13'
  aeson: ! '>=1.4.1.0 && <1.5'
  template-haskell: ! '>=2.11.1.0 && <2.15'
  safe: ! '>=0.3.17 && <0.4'
  http-media: ! '>=0.7.1.3 && <0.9'
all-versions:
- '0.12'
- '0.13'
- 0.13.0.1
- '0.14'
- 0.14.1
- '0.15'
- '0.16'
author: Servant Contributors
latest: '0.16'
description-type: markdown
description: |
  # servant-client-core

  ![servant](https://raw.githubusercontent.com/haskell-servant/servant/master/servant.png)

  HTTP-client-agnostic client functions for servant APIs.

  This library should mainly be of interest to backend- and combinator-writers.

  ## For backend-writers

  If you are creating a new backend, you'll need to:

  1. Define a `RunClient` instance for your datatype (call it `MyMonad`)
  2. Define a `ClientLike` instance. This will look like:

  ``` haskell
  instance ClientLike (MyMonad a) (MyMonad a) where
    mkClient = id
  ```

  3. Re-export the module Servant.Client.Core.Reexport so that your end-users
     can be blissfully unaware of 'servant-client-core', and so each
     backend-package comes closer to the warm hearth of the drop-in-replacement
     equivalence class.

  ## For combinator-writers

  You'll need to define a new `HasClient` instance for your combinator. There are
  plenty of examples to guide you in the
  [HasClient](src/Servant/Client/Core/Internal/HasClient.hs) module.
license-name: BSD-3-Clause
