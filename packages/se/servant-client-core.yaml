homepage: http://haskell-servant.readthedocs.org/
changelog-type: markdown
hash: f3c435187eb8cb97504bc81b9557946ad57e30770815a2906bcc8f09d5162b92
test-bench-deps:
  base: -any
  hspec: ! '>=2.6.0 && <2.7'
  servant-client-core: -any
  base-compat: -any
  deepseq: ! '>=1.4.2.0 && <1.5'
  QuickCheck: ! '>=2.12.6.1 && <2.13'
maintainer: haskell-servant-maintainers@googlegroups.com
synopsis: Core functionality and class for client function generation for servant
  APIs
changelog: ! "[The latest version of this document is on GitHub.](https://github.com/haskell-servant/servant/blob/master/servant-client-core/CHANGELOG.md)\n[Changelog
  for `servant` package contains significant entries for all core packages.](https://github.com/haskell-servant/servant/blob/master/servant/CHANGELOG.md)\n\n0.15\n----\n\n-
  Streaming refactoring.\n  [#991](https://github.com/haskell-servant/servant/pull/991)\n
  \ [#1076](https://github.com/haskell-servant/servant/pull/1076)\n  [#1077](https://github.com/haskell-servant/servant/pull/1077)\n\n
  \ The streaming functionality (`Servant.API.Stream`) is refactored to use\n  `servant`'s
  own `SourceIO` type (see `Servant.Types.SourceT` documentation),\n  which replaces
  both `StreamGenerator` and `ResultStream` types.\n\n  New conversion type-classes
  are `ToSourceIO` and `FromSourceIO`\n  (replacing `ToStreamGenerator` and `BuildFromStream`).\n
  \ There are instances for *conduit*, *pipes* and *machines* in new packages:\n  [servant-conduit](https://hackage.haskell.org/package/servant-conduit)\n
  \ [servant-pipes](https://hackage.haskell.org/package/servant-pipes) and\n  [servant-machines](https://hackage.haskell.org/package/servant-machines)\n
  \ respectively.\n\n  Writing new framing strategies is simpler. Check existing strategies
  for examples.\n\n  This change shouldn't affect you, if you don't use streaming
  endpoints.\n\n- *servant-client* Separate streaming client.\n  [#1066](https://github.com/haskell-servant/servant/pull/1066)\n\n
  \ We now have two `http-client` based clients,\n  in `Servant.Client` and `Servant.Client.Streaming`.\n\n
  \ Their API is the same, except for\n  - `Servant.Client` **cannot** request `Stream`
  endpoints.\n  - `Servant.Client` is *run* by direct\n    `runClientM :: ClientM
  a -> ClientEnv -> IO (Either ServantError a)`\n  - `Servant.Client.Streaming` **can**
  request `Stream` endpoints.\n  - `Servant.Client.Streaming` is *used* by CPSised\n
  \   `withClientM :: ClientM a -> ClientEnv -> (Either ServantError a -> IO b) ->
  IO b`\n\n  To access `Stream` endpoints use `Servant.Client.Streaming` with\n  `withClientM`;
  otherwise you can continue using `Servant.Client` with `runClientM`.\n  You can
  use both too, `ClientEnv` and `BaseUrl` types are same for both.\n\n  **Note:**
  `Servant.Client.Streaming` doesn't *stream* non-`Stream` endpoints.\n  Requesting
  ordinary `Verb` endpoints (e.g. `Get`) will block until\n  the whole response is
  received.\n\n  There is `Servant.Client.Streaming.runClientM` function, but it has\n
  \ restricted type. `NFData a` constraint prevents using it with\n  `SourceT`, `Conduit`
  etc. response types.\n\n  ```haskell\n  runClientM :: NFData a => ClientM a -> ClientEnv
  -> IO (Either ServantError a)\n  ```\n\n  This change shouldn't affect you, if you
  don't use streaming endpoints.\n\n- *servant-client-core* Related to the previous:\n
  \ `streamingResponse` is removed from `RunClient`.\n  We have a new type-class:\n\n
  \ ```haskell\n  class RunClient m =>  RunStreamingClient m where\n      withStreamingRequest
  :: Request -> (StreamingResponse -> IO a) ->  m a\n  ```\n\n- Drop support for GHC
  older than 8.0\n  [#1008](https://github.com/haskell-servant/servant/pull/1008)\n
  \ [#1009](https://github.com/haskell-servant/servant/pull/1009)\n\n- *servant-client-core*
  Add `NFData (GenResponse a)` and `NFData ServantError` instances.\n  [#1076](https://github.com/haskell-servant/servant/pull/1076)\n\n-
  *servant-client-core* Add `aeson` and `Lift BaseUrl` instances\n  [#1037](https://github.com/haskell-servant/servant/pull/1037)\n\n0.14.1\n------\n\n-
  Merge in `servant-generic` (by [Patrick Chilton](https://github.com/chpatrick))\n
  \ into `servant` (`Servant.API.Generic`),\n  `servant-client-code` (`Servant.Client.Generic`)\n
  \ and `servant-server` (`Servant.Server.Generic`).\n\n0.14\n----\n\n- `Stream` takes
  a status code argument\n\n  ```diff\n  -Stream method        framing ctype a\n  +Stream
  method status framing ctype a\n  ```\n\n  ([#966](https://github.com/haskell-servant/servant/pull/966)\n
  \  [#972](https://github.com/haskell-servant/servant/pull/972))\n\n- `ToStreamGenerator`
  definition changed, so it's possible to write an instance\n  for conduits.\n\n  ```diff\n
  \ -class ToStreamGenerator f a where\n  -   toStreamGenerator :: f a -> StreamGenerator
  a\n  +class ToStreamGenerator a b | a -> b where\n  +   toStreamGenerator :: a ->
  StreamGenerator b\n  ```\n\n  ([#959](https://github.com/haskell-servant/servant/pull/959))\n\n-
  Added `NoFraming` streaming strategy\n  ([#959](https://github.com/haskell-servant/servant/pull/959))\n\n-
  *servant-client-core* Free `Client` implementation.\n  Useful for testing `HasClient`
  instances.\n  ([#920](https://github.com/haskell-servant/servant/pull/920))\n\n-
  *servant-client-core* Add `hoistClient` to `HasClient`.\n  Just like `hoistServer`
  allows us to change the monad in which request handlers\n  of a web application
  live in, we also have `hoistClient` for changing the monad\n  in which *client functions*
  live.\n  Read [tutorial section for more information](https://haskell-servant.readthedocs.io/en/release-0.14/tutorial/Client.html#changing-the-monad-the-client-functions-live-in).\n
  \ ([#936](https://github.com/haskell-servant/servant/pull/936))\n\n  iF you have
  own combinators, you'll need to define a new method of\n  `HasClient` class, for
  example:\n\n  ```haskell\n  type Client m (MyCombinator :> api) = MyValue :> Client
  m api\n  hoistClientMonad pm _ nt cl = hoistClientMonad pm (Proxy :: Proxy api)
  nt . cl\n  ```\n\n0.13.0.1\n--------\n\n- Support `base-compat-0.10`\n\n0.13\n----\n\n-
  Streaming endpoint support.\n  ([#836](https://github.com/haskell-servant/servant/pull/836))\n-
  *servant* Add `Servant.API.Modifiers`\n  ([#873](https://github.com/haskell-servant/servant/pull/873))\n\n0.12\n----\n\n-
  First version. Factored out of `servant-client` all the functionality that was\n
  \ independent of the `http-client` backend.\n"
basic-deps:
  exceptions: ! '>=0.10.0 && <0.11'
  free: ! '>=5.1 && <5.2'
  bytestring: ! '>=0.10.8.1 && <0.11'
  base: ! '>=4.9 && <4.13'
  base64-bytestring: ! '>=1.0.0.1 && <1.1'
  text: ! '>=1.2.3.0 && <1.3'
  servant: ! '>=0.15 && <0.16'
  containers: ! '>=0.5.7.1 && <0.7'
  base-compat: ! '>=0.10.5 && <0.11'
  network-uri: ! '>=2.6.1.0 && <2.7'
  transformers: ! '>=0.5.2.0 && <0.6'
  deepseq: ! '>=1.4.2.0 && <1.5'
  generics-sop: ! '>=0.4.0.1 && <0.5'
  http-types: ! '>=0.12.2 && <0.13'
  aeson: ! '>=1.4.1.0 && <1.5'
  template-haskell: ! '>=2.11.1.0 && <2.15'
  safe: ! '>=0.3.17 && <0.4'
  http-media: ! '>=0.7.1.3 && <0.8'
all-versions:
- '0.12'
- '0.13'
- 0.13.0.1
- '0.14'
- 0.14.1
- '0.15'
author: Servant Contributors
latest: '0.15'
description-type: markdown
description: ! "# servant-client-core\n\n![servant](https://raw.githubusercontent.com/haskell-servant/servant/master/servant.png)\n\nHTTP-client-agnostic
  client functions for servant APIs.\n\nThis library should mainly be of interest
  to backend- and combinator-writers.\n\n## For backend-writers\n\nIf you are creating
  a new backend, you'll need to:\n\n1. Define a `RunClient` instance for your datatype
  (call it `MyMonad`)\n2. Define a `ClientLike` instance. This will look like:\n\n```
  haskell\ninstance ClientLike (MyMonad a) (MyMonad a) where\n  mkClient = id\n```\n\n3.
  Re-export the module Servant.Client.Core.Reexport so that your end-users\n   can
  be blissfully unaware of 'servant-client-core', and so each\n   backend-package
  comes closer to the warm hearth of the drop-in-replacement\n   equivalence class.\n\n##
  For combinator-writers\n\nYou'll need to define a new `HasClient` instance for your
  combinator. There are\nplenty of examples to guide you in the\n[HasClient](src/Servant/Client/Core/Internal/HasClient.hs)
  module.\n"
license-name: BSD-3-Clause
