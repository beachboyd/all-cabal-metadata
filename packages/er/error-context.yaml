homepage: https://github.com/mtesseract/error-context#readme
changelog-type: markdown
hash: 3c86a533ea0c0fa9a0c0e051dc74a1ac7e6721c05d8af50c2e3a9695c7d0cbbd
test-bench-deps:
  exceptions: -any
  base: ! '>=4.7 && <5'
  text: -any
  safe-exceptions: -any
  unliftio-core: -any
  error-context: -any
  mtl: -any
  tasty-hunit: -any
  monad-logger: -any
  tasty: -any
  resourcet: -any
maintainer: mtesseract@silverratio.net
synopsis: Provides API for enriching errors with contexts
changelog: ! '# Changelog for error-context


  ## Unreleased changes

'
basic-deps:
  exceptions: -any
  base: ! '>=4.7 && <5'
  text: -any
  safe-exceptions: -any
  unliftio-core: -any
  mtl: -any
  monad-logger: -any
  resourcet: -any
all-versions:
- '0.1.0.0'
- '0.1.1.0'
- '0.1.2.0'
author: Moritz Clasmeier
latest: '0.1.2.0'
description-type: markdown
description: ! '# !! This is experimental work-in-progress !!


  Welcome to *error-context*! This is a library providing context-aware

  error and exception handling for Haskell.


  ## What problem does *error-context* attempt to solve?


  Good error handling is hard. In the case of failures it is important

  to keep as much context as necessary for a proper problem analysis.

  Call traces sometimes help, but the current solutions in Haskell-land

  for accessing call traces are rather limited.


  The *error-context* library allows you to easily attach call traces

  (''error contexts'') to errors, in particular to exceptions. Special

  `catch`- and `try`-functions are provided for accessing these

  contexts.


  ## How to use it?


  Add an `ErrorContextT` layer to your monad transformer stack by adding

  `runErrorContextT` to the transformer unwrapping code.


  The `ErrorContextT` transformer provides the context-enriching logic

  via special implementations of `MonadThrow`, `MonadCatch` and

  `MonadIO`.


  ## Examples


  See https://github.com/mtesseract/error-context/blob/master/test/Control/Error/Context/Test.hs.


  ## What about "pure" exceptions?


  The `ErrorContextT` transformer implements `MonadThrow` and `MonadIO`,

  therefore exceptions thrown by `throwM` and via `liftIO` are

  automatically context-enriched. On the other hand, exceptional values

  created via


  ```haskell

  throw :: Exception e => e -> a

  ```


  are not context-enriched per se. But there is a workaround for this

  use-case:


  ```haskell

  ensureExceptionContext :: (MonadCatch m, MonadErrorContext m) => m a -> m a

  ```


  This function provides context-aware enriching for any exceptions

  thrown within some monadic value, including those thrown by evaluating

  values created by `throw`.

'
license-name: BSD3
