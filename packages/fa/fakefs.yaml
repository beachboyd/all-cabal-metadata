homepage: https://gitlab.com/igrep/haskell-fakefs#readme
changelog-type: markdown
hash: 7e638ff3c0919dac34402de134a93e302dbf86773a3985cf45a8dcedcf17c2bf
test-bench-deps:
  exceptions: -any
  base: '>=4.7 && <5'
  hspec: -any
  containers: -any
  fakefs: -any
  QuickCheck: -any
maintainer: whosekiteneverfly@gmail.com
synopsis: Extensible fake file system for testing.
changelog: |
  # Changelog for fakefs

  ## 0.3.0.1 (2020-08-11)

  - :memo: Update README to follow the changes in 0.3.0.0.

  ## 0.3.0.0 (2020-08-11)

  - Redesign: Add ability to throw `IOException`s in a more composable manner.
      - By deleting `ExceptT` from `FileSystemT`, it's more `GeneralizedNewtypeDeriving`-friendly.
      - Generalize the monad of `readPath` and `writePath` etc. by the new constraint synonym `MonadFileSystem`.

  ## 0.2.0.1 (2019-07-16)

  - :memo: Update READE with an example.
  - :memo: Correct wrong repository URL in the cabal file.

  ## 0.2.0.0 (2019-03-30)

  - Simplify the monad stack and the file object.
  - Rename main APIs to express its generality.
      - `readFileT` -> `readPath`
      - `writeFileT` -> `writePath`
  - Add utility functions: `evalFileSystemT`, `execFileSystemT`, etc.

  ## 0.0.1.0 (2019-03-29)

  Initial Release
basic-deps:
  exceptions: -any
  base: '>=4.7 && <5'
  containers: -any
  mtl: -any
all-versions:
- 0.1.0.0
- 0.2.0.0
- 0.2.0.1
- 0.3.0.0
- 0.3.0.1
author: Yuji Yamamoto
latest: 0.3.0.1
description-type: markdown
description: "# fakefs\n\nExtensible fake file system for testing.\n\nProvides a simple
  Monad transformer `FileSystemT`, intended to make a fake file system.  \nAgainst
  its name, `FileSystemT` imitates *very limited* feature of a file system:  \nIt's
  essentially just a `newtype` of `StateT (Map FilePath contents) m a`,\nwhere the
  type variable `contents` can be any type suitable for your tests.  \nFor example:\n\n-
  If your tests have to handle only binary contents of a file, `contents` should be
  `ByteString`.\n- If your tests have to handle only text contents of a file, `contents`
  should be `Text`.\n- If your tests have to handle binary contents of a file with
  its permisson, `contents` should be `(Permission, ByteString)`.\n- etc.\n\n## Example\n\n```haskell\n--
  BEGINNING OF EXAMPLE\n\nimport Control.Monad\nimport Data.List\nimport qualified
  Data.Map.Strict as M\nimport Data.Maybe\nimport Test.Hspec\nimport Test.FileSystem.Fake\n\nimport
  Prelude hiding (readFile, appendFile)\n\ntype YourFsM = FileSystemM String\n\n--
  | Record of functions to stub IO actions\ndata FsActions m = FsActions\n    { readFile
  :: FilePath -> m String\n    , appendFile :: FilePath -> String -> m ()\n    }\n\nfsActionsForTesting
  :: FsActions YourFsM\nfsActionsForTesting = FsActions\n    { readFile = readPath\n
  \   , appendFile = \\path contents ->\n        modifyPath path (Just . (++ contents)
  . fromMaybe \"\")\n    }\n\n\n-- | The function you test.\ncollectMatchedPaths ::
  Monad m => FsActions m -> (String -> Bool) -> FilePath -> [FilePath] -> m ()\ncollectMatchedPaths
  acts p outPath = mapM_ $ \\path -> do\n    contents <- readFile acts path\n    when
  (p contents) $\n        appendFile acts outPath $ path ++ \"\\n\"\n\n\nmain :: IO
  ()\nmain = hspec $\n    describe \"collectMatchedPaths\" $\n        it \"collect
  paths whose content matches the given condition\" $ do\n            let initialFs
  = M.fromList\n                    [ (\"a.txt\", \"aaaaa\\n\")\n                    ,
  (\"b.hs\", \"main = undefined\\n\")\n                    , (\"c.c\", \"#include
  <stdio.h>\\n\")\n                    ]\n                outPath = \"result.txt\"\n
  \               args = M.keys initialFs\n                resultFs = execFileSystemM
  initialFs\n                    $ collectMatchedPaths fsActionsForTesting (isInfixOf
  \"in\") outPath args\n\n            resultFs M.! outPath `shouldBe` \"b.hs\\nc.c\\n\"\n\n--
  END\n```\n"
license-name: Apache-2.0
