homepage: https://github.com/wchresta/matrix-static#readme
changelog-type: markdown
hash: 219d8c5c4eeb0000db2577dec5d55d8973ad4c24234919d9b991af68a6243607
test-bench-deps:
  base: ! '>=4.9 && <5'
  matrix: ! '>=0.3.5 && <0.4'
  semigroups: -any
  matrix-static: -any
  ghc-typelits-knownnat: -any
  ghc-typelits-natnormalise: -any
  tasty-hunit: -any
  tasty: -any
  deepseq: -any
  vector: -any
maintainer: wanja.hs@chrummibei.ch
synopsis: Wrapper around matrix that adds matrix sizes to the type-level
changelog: ! '# Changelog for matrix-static


  ## Unreleased changes

'
basic-deps:
  base: ! '>=4.9 && <5'
  matrix: ! '>=0.3.5 && <0.4'
  semigroups: -any
  ghc-typelits-knownnat: -any
  ghc-typelits-natnormalise: -any
  deepseq: -any
  vector: -any
all-versions:
- '0.1'
author: Wanja Chresta
latest: '0.1'
description-type: markdown
description: ! "# matrix-static\n\nA static wrapper around the [https://hackage.haskell.org/package/matrix|matrix]
  library. It provides a data type `Matrix m n a` derived from `matrix`'s `Matrix
  a` with additional information about the matix dimension `m n` as type-level Nat's.\n\n(Almost)
  all functions provided by `Data.Matrix` are wrapped. These wrappers guarantee during
  compile time that the matrix dimension are correct. As such, runtime errors due
  to mismatching matrix dimensions are minimized. Also, some performance improvements
  are achieved by not having to do dimension checks during runtime.\n\nSome functions
  take indices `i` as parameters (e.g. `Matrix.Data.mapCol`).\n```haskell\nmapCol
  :: (Int -> a -> a) -> Int -> Matrix a -> Matrix a\n```\n\nFor these, a decision
  has to be made. Either the runtime index `i` is kept at the runtime level, or it
  is moved to the type-level. If it remains at the run-time level, it is kept as a
  parameter but the correctness of the index cannot be guaranteed by the compiler
  (e.g. there will be an error if the index is -1). If it is moved to the type-level
  as a type-parameter, the compiler can guarantee the correctnes of the index, but
  it is not dependent on any values during runtime:\n\nAs such, `Data.Matrix.Static.mapCol`
  chooses to go the safe route and provide `j` as a type level parameter:\n```haskell\nmapCol
  :: forall j m n a. (KnownNat j, KnownNat m, 1 <= j, j <= n)\n       => (Int -> a
  -> a) -> Matrix m n a -> Matrix m n a\n```\n\nSince it might be important to be
  able to provide mapCol with a run-time index, the following function is also provided:\n\n```haskell\nmapColUnsafe
  :: (Int -> a -> a) -> Int -> Matrix m n a -> Matrix m n a\n```\n\nOf course, it
  will cause an error if the given index does not match the matrix\ndimensions. In
  some cases, the result of a run-time variant of a function is wrapped\nin `Maybe`
  and thus becomes safe. In general, all functions in the library that do not guarantee
  that no error will be thrown have the postfix Unsafe.\n\n## Usage example\n\nNote,
  if you want to provide type-level paramters similar to run-time parameters, make
  sure to use the `DataKinds` and `TypeApplicatios` extensions. Then, you can give
  type-level parameters using `@` as demonstrated instead of giving the full type.\n\n```haskell\n>>>
  :set -XDataKinds -XTypeApplications\n>>> fromList [1..9] :: Maybe (Matrix 3 3 Int)\nJust
  ┌       ┐\n│ 1 2 3 │\n│ 4 5 6 │\n│ 7 8 9 │\n└       ┘\n>>> fromList [1..8] :: Maybe
  (Matrix 3 3 Int)\nNothing\n\n>>> fromJust $ fromList [1..8] :: Matrix 2 4 Int\n┌
  \    ┐\n│ 1 2 │\n│ 3 4 │\n│ 5 6 │\n│ 7 8 │\n└     ┘\n\n>>> a = fromListUnsafe @4
  @4 [1..16]\n>>> b = fromListUnsafe @4 @2 [4..12]\n>>> b .* a\n\n<interactive>:6:6:
  error:\n    * Couldn't match type `4' with `2'\n      Expected type: Matrix 2 4
  a\n        Actual type: Matrix 4 4 a\n    * In the second argument of `(.*)', namely
  `a'\n      In the expression: b .* a\n      In an equation for `it': it = b .* a\n>>>
  a .* b\n┌         ┐\n│  80  90 │\n│ 192 218 │\n│ 304 346 │\n│ 416 474 │\n└         ┘\n```\n"
license-name: BSD3
