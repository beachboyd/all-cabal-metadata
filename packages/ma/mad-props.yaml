homepage: https://github.com/ChrisPenner/mad-props#readme
changelog-type: markdown
hash: e962d8fa33b1fc460277eaecbb166a36a9a1b9f5c4c61eaefd19ae36c3cc8a1b
test-bench-deps: {}
maintainer: christopher.penner@gmail.com
synopsis: Monadic DSL for building constraint solvers using basic propagators.
changelog: |
  # Changelog for wave-function-collapse

  ## Unreleased changes
basic-deps:
  logict: -any
  MonadRandom: -any
  base: ! '>=4.7 && <5'
  mad-props: -any
  random-shuffle: -any
  containers: -any
  lens: -any
  raw-strings-qq: -any
  mtl: -any
  transformers: -any
  random: -any
  mono-traversable: -any
  psqueues: -any
all-versions:
- 0.1.0.0
author: Chris Penner
latest: 0.1.0.0
description-type: markdown
description: "# Mad Props\n\nMad props is a simple generalized propagator framework.
  This means it's pretty good at expressing and solving generalized [constraint satisfaction
  problems](https://en.wikipedia.org/wiki/Constraint_satisfaction_problem).\n\nThere
  are many other constraint solvers out there, probably most of them are faster than
  this one, but for those who like the comfort and type-safety of working in Haskell,
  I've gotcha covered.\n\nWith other constraint solvers it can be a bit of a pain
  to express your problem; you either need to compress your problem down to relations
  between boolean variables, or try to cram your problem into their particular format.
  Mad Props uses a Monadic DSL for expressing the variables in your problem and the
  relationships between them, meaning you can use normal Haskell to express your problem.\n\nIt's
  still unfinished and undergoing rapid iteration and experimentation, so I wouldn't
  base any major projects on it yet.\n\n## Example: Sudoku\n\nWe'll write a quick
  Sudoku solver using Propagators.\n\nHere's a problem which Telegraph has claimed
  to be [\"the world's hardest Sudoku\"](https://www.telegraph.co.uk/news/science/science-news/9359579/Worlds-hardest-sudoku-can-you-crack-it.html).
  Let's see if we can crack it.\n\n```haskell\nhardestProblem :: [String]\nhardestProblem
  = tail . lines $ [r|\n8........\n..36.....\n.7..9.2..\n.5...7...\n....457..\n...1...3.\n..1....68\n..85...1.\n.9....4..|]\n```\n\nA
  Sudoku is a constraint satisfaction problem, the \"constraints\" are that each of
  the numbers 1-9 are represented in each row, column and 3x3 grid. `Props` allows
  us to create `PVars` a.k.a. Propagator Variables. `PVars` represent a piece of information
  in our problem which is 'unknown' but has some relationship with other variables.
  To convert Sudoku into a propagator problem we can make a new `PVar` for each cell,
  the `PVar` will contain either all possible values from 1-9; or ONLY the value which
  is specified in the puzzle. We use a Set to indicate the possibilities, but you
  can really use almost any container you like inside a `PVar`.\n\n```haskell\ntxtToBoard
  :: [String] -> [[S.Set Int]]\ntxtToBoard = (fmap . fmap) possibilities\n  where\n
  \   possibilities :: Char -> S.Set Int\n    possibilities '.' = S.fromList [1..9]\n
  \   possibilities a = S.fromList [read [a]]\n\nhardestBoard :: [[S.Set Int]]\nhardestBoard
  = txtToBoard hardestProblem\n```\n\nThis function takes our problem and converts
  it into a nested grid of variables! Each variable 'contains' all the possibilities
  for that square. Now we need to 'constrain' the problem!\n\nWe can then introduce
  the constraints of Sudoku as relations between these `PVars`. The cells in each
  'quadrant' (i.e. square, row, or column) are each 'related' to one other in the
  sense that **their values must be disjoint**. No two cells in each quadrant can
  have the same value. We'll quickly write some shoddy functions to extract the lists
  of \"regions\" we need to worry about from our board. Getting the **rows** and **columns**
  is easy, getting the square **blocks** is a bit more tricky, the implementation
  here really doesn't matter.\n\n```haskell\nrowsOf, colsOf, blocksOf :: [[a]] ->
  [[a]]\nrowsOf = id\ncolsOf = transpose\nblocksOf = chunksOf 9 . concat . concat
  . fmap transpose . chunksOf 3 . transpose\n```\n\nNow we can worry about telling
  the system about our constraints. We'll map over each region relating every variable
  to every other one. This function assumes we've replaced the `Set a`'s in our board
  representation with the appropriate `PVar`'s, we'll actually do that soon, but for
  now you can look the other way.\n\n```haskell\n-- | Given a board of 'PVar's, link
  the appropriate cells with 'disjoint' constraints\nlinkBoardCells :: [[PVar (S.Set
  Int)]] -> Prop ()\nlinkBoardCells xs = do\n    let rows = rowsOf xs\n    let cols
  = colsOf xs\n    let blocks = blocksOf xs\n    for_ (rows <> cols <> blocks) $ \\region
  -> do\n        let uniquePairings = [(a, b) | a <- region, b <- region, a /= b]\n
  \       for_ uniquePairings $ \\(a, b) -> constrain a b disj\n  where\n    disj
  :: Ord a => a -> S.Set a -> S.Set a\n    disj x xs = S.delete x xs\n```\n\n\nNow
  every pair of `PVars` in each region is linked by the `disj` relation.\n\n`constrain`
  accepts two `PVar`s and a function, the function takes a 'choice' from the first
  variable and uses it to constrain the 'options' from the second. In this case, if
  the first variable is fixed to a specific value we 'propagate' by removing all matching
  values from the other variable's pool, you can see the implementation of the `disj`
  helper above. The information about the 'link' is stored inside the `Prop` monad.\n\nHere's
  the real signature in case you're curious: \n\n```haskell\nconstrain :: (Monad m,
  Typeable g, Typeable (Element f)) \n          => PVar f -> PVar g -> (Element f
  -> g -> g) \n          -> PropT m ()\n```\n\nSet disjunction is symmetric, propagators
  in general are not, so we'll need to 'constrain' in each direction. Luckily our
  loop will process each pair twice, so we'll run this once in each direction.\n\nNow
  we can link our parts together:\n\n```haskell\n-- | Given a sudoku board, apply
  the necessary constraints and return a result board of\n-- 'PVar's. We wrap the
  result in 'Compose' because 'solve' requires a Functor over 'PVar's\nconstrainBoard
  :: [[S.Set Int]]-> Prop (Compose [] [] (PVar (S.Set Int)))\nconstrainBoard board
  = do\n    vars <- (traverse . traverse) newPVar board\n    linkBoardCells vars\n
  \   return (Compose vars)\n```\n\nWe accept a sudoku \"board\", we replace each
  `Set Int` with a `PVar (S.Set Int)` using `newPVar` which creates a propagator from
  a set of possible values. This is a propagator variable which has a `Set` of Ints
  which the variable could take. We then link all the board's cells together using
  constraints, and lastly return a `Functor` full of `PVar`s; which will later be
  replaced with actual values. `Compose` converts a list of lists into a single functor
  over the nested elements.\n\n```haskell\nnewPVar :: (Monad m, MonoFoldable f, Typeable
  f, Typeable (Element f)) \n        => f -> PropT m (PVar f)\n```\n\nNow that we've
  got our problem set up we need to execute it!\n\n```haskell\n-- Solve a given sudoku
  board and print it to screen\nsolvePuzzle :: [[S.Set Int]] -> IO ()\nsolvePuzzle
  puz = do\n    -- We know it will succeed, but in general you should handle failure
  safely\n    let Just (Compose results) = solve $ constrainBoard puz\n    putStrLn
  $ boardToText results\n```\n\nWe run `solveGraph` to run the propagation solver.
  It accepts a puzzle, builds and constrains the cells, then calls `solve` which maps
  over the `Compose`'d board we created in `constrainBoard` and replaces all the `PVar`s
  with actual results! If all went well we'll have the solution of each cell! Then
  we'll print it out.\n\nHere are some types first, then we'll try it out:\n\n```haskell\nsolve
  :: (Functor f, Typeable (Element g)) \n      => Prop (f (PVar g)) -> Maybe (f (Element
  g))\n```\n\nWe can plug in our hardest sudoku and after a second or two we'll print
  out the answer!\n\n```haskell\n>>> solvePuzzle hardestBoard\n812753649\n943682175\n675491283\n154237896\n369845721\n287169534\n521974368\n438526917\n796318452\n```\n\nYou
  can double check it for me, but I'm pretty sure that's a valid solution!\n\n## Example:
  N-Queens\n\nJust for fun, here's the N-Queens problem\n\n```haskell\n{-# LANGUAGE
  ScopedTypeVariables #-}\n{-# LANGUAGE ViewPatterns #-}\nmodule Examples.NQueens
  where\n\nimport qualified Data.Set as S\nimport Props\nimport Data.Foldable\nimport
  Data.List\n\n-- | A board coordinate\ntype Coord = (Int, Int)\n\n-- | Given a number
  of queens, constrain them to not overlap\nconstrainQueens :: Int -> Prop [PVar (S.Set
  Coord)]\nconstrainQueens n = do\n    -- All possible grid locations\n    let locations
  = S.fromList [(x, y) | x <- [0..n - 1], y <- [0..n - 1]]\n    -- Each queen could
  initially be placed anywhere\n    let queens = replicate n locations\n    -- Make
  a PVar for each queen's location\n    queenVars <- traverse newPVar queens\n    --
  Each pair of queens must not overlap\n    let queenPairs = [(a, b) | a <- queenVars,
  b <- queenVars, a /= b]\n    for_ queenPairs $ \\(a, b) -> require (\\x y -> not
  $ overlapping x y) a b\n    return queenVars\n\n-- | Check whether two queens overlap
  with each other (i.e. could kill each other)\noverlapping :: Coord -> Coord -> Bool\noverlapping
  (x, y) (x', y')\n  -- Same Row\n  | x == x' = True\n  -- Same Column\n  | y == y'
  = True\n  -- Same Diagonal 1\n  | x - x' == y - y' = True\n  -- Same Diagonal 2\n
  \ | x + y == x' + y' = True\n  | otherwise = False\n\n-- | Print an nQueens puzzle
  to a string.\nshowSolution :: Int -> [Coord] -> String\nshowSolution n (S.fromList
  -> qs) =\n    let str = toChar . (`S.member` qs) <$> [(x, y) | x <- [0..n-1], y
  <- [0..n-1]]\n     in unlines . chunksOf n $ str\n  where\n    toChar :: Bool ->
  Char\n    toChar True = 'Q'\n    toChar False = '.'\n\n    chunksOf :: Int -> [a]
  -> [[a]]\n    chunksOf n = unfoldr go\n      where\n        go [] = Nothing\n        go
  xs = Just (take n xs, drop n xs)\n\n-- | Solve and print an N-Queens puzzle\nnQueens
  :: Int -> IO ()\nnQueens n = do\n    let Just results = solve (constrainQueens n)\n
  \   putStrLn $ showSolution n results\n\n-- | Solve and print all possible solutions
  of an N-Queens puzzle\n-- This will include duplicates.\nnQueensAll :: Int -> IO
  ()\nnQueensAll n = do\n    let results = solveAll (constrainQueens n)\n    traverse_
  (putStrLn . showSolution n) results\n```\n\n## Performance\n\nThis is a generalized
  solution, so performance suffers in relation to a tool built for the job (e.g. It's
  not as fast as dedicated Sudoku solvers); but it does \"pretty well\".\n"
license-name: BSD-3-Clause
