homepage: https://github.com/recursion-ninja/bv-little
changelog-type: markdown
hash: 398c62741421f2d0544d823b61e21c2da4dc8b6e6681d1099f4a450d3f0789bd
test-bench-deps:
  tasty-smallcheck: -any
  base: ! '>=4.5.1 && <5'
  text-show: -any
  criterion: -any
  smallcheck: ! '>=1.1.5'
  tasty-quickcheck: -any
  bv-little: -any
  hashable: -any
  tasty-hunit: -any
  mono-traversable-keys: -any
  tasty: -any
  deepseq: -any
  QuickCheck: -any
  mono-traversable: -any
maintainer: hackage@recursion.ninja
synopsis: Efficient little-endian bit vector library
changelog: |
  ### Unreleased Changes

    * None

  ### [v1.0.1][4]

    * Correcting Eq instance to test for value equality and not construction equality

    * Updated unit tests do not fail when the antecedent of logical implication cannot be satisfied


  ### [v1.0.0][3]

    * Added explicit recursion to monomorphic folds to improve time and space performance

    * Added the following instances:
      * `MonoAdjustable`
      * `MonoFoldableWithKey`
      * `MonoIndexable`
      * `MonoKeyed`
      * `MonoLookup`
      * `MonoTraversableWithKey`
      * `MonoZip`
      * `MonoZipWithKey`
      * `TextShow`

    * Updated the following functions to be constant time:
      * `omap`
      * `olength64`
      * `oall`
      * `oany`
      * `ofoldr1Ex`
      * `ofoldl1Ex`
      * `oelem`
      * `onotElem`
      * `ozipWith`


  ### [v0.1.2][2]

    * Updating to base bounds for GHC 8.6.1


  ### [v0.1.1][1]

    * Updated to well-typed internal representation

    * Corrected defect in rotate, rotateL, and rotateR

    * Improved performance by switching exponentiation with base 2 to bit shifting operations

    * Improved performance of clearBit by increasing strictness

    * Increased benchmark coverage

    * Increased test suite coverage


  ### [v0.1.0][0]

    * Created instances of applicable typeclass instances

    * Added numeric conversion functions

    * Added basic test suite

    * Added stub benchmark


  [0]: https://github.com/recursion-ninja/bv-little/tree/v0.1.0
  [1]: https://github.com/recursion-ninja/bv-little/tree/v0.1.1
  [2]: https://github.com/recursion-ninja/bv-little/tree/v0.1.2
  [3]: https://github.com/recursion-ninja/bv-little/tree/v1.0.0
  [4]: https://github.com/recursion-ninja/bv-little/tree/v1.0.1
basic-deps:
  base: ! '>=4.5.1 && <5'
  text-show: -any
  integer-gmp: -any
  keys: -any
  hashable: -any
  mono-traversable-keys: -any
  deepseq: -any
  QuickCheck: -any
  mono-traversable: -any
  primitive: -any
all-versions:
- 0.1.0.0
- 0.1.1
- 0.1.2
- 1.0.0
- 1.0.1
author: Alex Washburn
latest: 1.0.1
description-type: markdown
description: |
  ## Efficient little-endian bit vector Haskell library

  [![Build Status](https://travis-ci.org/recursion-ninja/bv-little.svg?branch=master)](https://travis-ci.org/recursion-ninja/bv-little)
  [![Coverage Status](https://coveralls.io/repos/github/recursion-ninja/bv-little/badge.svg?branch=master)](https://coveralls.io/github/recursion-ninja/bv-little?branch=master)
  [![License FreeBSD](https://img.shields.io/badge/license-FreeBSD-brightgreen.svg)](http://opensource.org/licenses/BSD-3-Clause)
  [![Hackage](https://img.shields.io/hackage/v/bv-little.svg?style=flat)](https://hackage.haskell.org/package/bv-little)
  [![Stackage Nightly](http://stackage.org/package/bv-little/badge/nightly)](http://stackage.org/nightly/package/bv-little)
  [![Stackage LTS](http://stackage.org/package/bv-little/badge/lts)](http://stackage.org/lts/package/bv-little)


  This package contains an efficient implementation of little-endian bit vectors. It implements most applicable typeclasses and also conversions to and from signed or unsigned numbers. Care has been taken to balance the number of transitive dependencies with respect to functionality provided.

  For an implementation of big-endian bit vectors, use the [`bv`](https://hackage.haskell.org/package/bv) package.

  #### Tests

  The test suite ensures that all typeclass instances are "lawful" and that data-structureâ€“specific functionality is well defined.

  The `TestSuite.hs` file contains the specification. It can be run by invoking any of the following commands:

    * `cabal new-test`

    * `cabal test`

    * `stack test`

  #### Benchmarks

  The benchmarks provide an empirical check for the asymptotic complexity of data structure operations and also provide easy metrics for detecting performance regressions.

  The `Benchmaks.hs` file contains these metrics. It can be run by invoking any of the following commands:

    * `cabal new-bench`

    * `cabal bench`

    * `stack bench`
license-name: BSD-3-Clause
