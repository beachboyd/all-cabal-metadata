homepage: http://community.moertel.com/ss/space/PXSL
changelog-type: ''
hash: a44a7248539c58d15a1cd880e2e7a6c50f1a982ca4549631b9fbcb59db5c8998
test-bench-deps: {}
maintainer: Tom Moertel <tom@moertel.com>
synopsis: Parsimonious XML Shorthand Language--to-XML compiler
changelog: ''
basic-deps:
  base: -any
  parsec: ! '>=2.0'
  containers: -any
  mtl: ! '>=1.0'
all-versions:
- 1.0.1
author: Tom Moertel <tom@moertel.com>
latest: 1.0.1
description-type: text
description: ! "\n                        ____  _  _  ___  __\n                       (
  \ _ \\( \\/ )/ __)(  )\n                        )___/ )  ( \\__ \\ )(__\n                       (__)
  \ (_/\\_)(___/(____)\n\n                 PARSIMONIOUS XML SHORTHAND LANGUAGE\n\n
  \                        Updated 2008-02-16\n\n\nPXSL (\"pixel\") is a convenient
  shorthand for writing markup-heavy XML\ndocuments.  The following document explains
  why PXSL is needed and\nshows you how to use it.  For additional information, such
  as the FAQ\nlist, visit the community site:\n\n    http://community.moertel.com/ss/space/pxsl\n\nYou'll
  get more out of this document if you read it from start to\nfinish, but you can
  stop anywhere after the \"Gentle Introduction to\nPXSL\" and be able to take advantage
  of PXSL in your documents.  The\nlater sections explain PXSL's advanced features.
  \ If you're willing to\ninvest some time in learning them, you will have at your
  disposal new\nand powerful ways to create and refactor XML documents.  The advanced\nfeatures
  are more complicated to master, but they can greatly reduce\nthe complexity of your
  documents.\n\n\n\n* Table of Contents\n\n  * Getting PXSL\n  * Getting help\n  *
  License\n  * Getting or building the PXSL tools\n  * Gentle Introduction to PXSL\n
  \   - Why PXSL ?\n    - A closer look at PXSL\n    - Using PXSL documents\n  * Advanced
  topics\n    - Element defaults provide convenient, customizable shortcuts\n        Using
  element defaults to create attribute shortcuts\n        Using element defaults to
  create virtual elements\n        Making and using your own element defaults\n        Built-in
  element defaults for XSLT stylesheets\n    - Advanced quoting with << >> and <{
  }>\n    - Macro facility\n    - Tip: store frequently used macros in reusable .pxsl
  files\n    - Advanced macros and passing parameters with the <( )> delimiters\n
  \   - More advanced macros and functional programming\n    - Automatic PXSL-to-XML
  conversion via Make\n  * Reference:  pxlscc\n  * Reference:  PXSL syntax\n  * Authors\n\n\n\n*
  Getting PXSL\n\nThe most-recent official version of the PXSL tools can always be
  found\nhere:\n\n    http://community.moertel.com/pxsl/\n\nThe PXSL tools have been
  also packaged for Debian (thanks Kari Pahula)\nand Red Hat / Fedora.\n\nBy the way,
  you pronounce PXSL like \"pixel\".\n\n\n* Getting help\n\nIf you need help with
  PXSL, there is a discussion site for PXSL\nusers and developers.  Feel free to ask
  questions and leave your\ncomments:\n\n    PXSL Community Forum\n    http://community.moertel.com/ss/space/pxsl\n\n
  \   PXSL FAQs\n    http://community.moertel.com/ss/space/PXSL+FAQs\n\n\n* LICENSE\n\nCopyright
  (C) 2003--2008 Thomas Moertel & Bill Hubauer.\n\nThe PXSL toolkit is free software;
  you can redistribute it and/or\nmodify it under the terms of the GNU General Public
  License as\npublished by the Free Software Foundation; either version 2 of\nthe
  License, or (at your option) any later version.\n\nThe text of the GNU GPL may be
  found in the LICENSE file,\nincluded with this software.\n\nThis program is distributed
  in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the
  implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU
  General Public License for more details.\n\nExcept as provided for under the terms
  of the GNU GPL, all rights\nare reserved worldwide.\n\n\n* Getting or building the
  PXSL tools\n\nIf you don't want to build the PXSL tools from source code, you can\ndownload
  one of the pre-built binary packages on the PXSL web site.\nThe PXSL tools have
  been also packaged for Debian (thanks Kari Pahula)\nand Red Hat / Fedora.  You might
  want to search your local package\nrepositories before building from source.\n\nIf
  a binary package isn't available for your computing platform of\nchoice, you can
  use the following procedure to build the PXSL tools\nfor your platform.\n\nIn order
  to build the tools you will need the following:\n\n  - A PXSL source tarball (typically
  named \"pxsl-tools-{version}.tar.gz\")\n    http://community.moertel.com/pxsl/sources/\n\n
  \ - A Haskell compiler supporting the Cabal build system.\n    I use GHC:  http://www.haskell.org/ghc/\n\nJust
  uncompress the tarball and build the project using the following\ncommands.  If
  you want to install a personal copy of pxslcc instead of\nthe doing the default,
  system-wide installation, uncomment the extra\ncommand-line flags on the third command.\n\n
  \   $ tar zxvf pxsl-tools-{version}.tar.gz\n    $ cd pxsl-tools-{version}\n    $
  runhaskell Setup.lhs configure # --user --prefix=$HOME\n    $ runhaskell Setup.lhs
  build\n    $ runhaskell Setup.lhs install\n\n(Replace {version} with the version
  of PXSL that you downloaded.)\n\nThat's it.  You should now have a fully functional
  version of pxslcc.\n\n** RPMs\n\nIf you are on a Red Hat or Fedora  Linux system
  (or a similar\nRPM-based distribution), you can probably find RPMS and SRPMS here:\n\n
  \   http://community.moertel.com/pxsl/RPMS/\n\nOtherwise, you can build custom RPMs
  using the cabal-rpm tool:\n\n    http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-rpm-0.3.2\n\n\n*
  Gentle Introduction to PXSL\n\nPXSL (\"pixel\") is a convenient shorthand for writing
  markup-heavy XML\ndocuments.  This introduction assumes that you are familiar with
  XML.\nIf you want a refresher, see the introductions on XML available here:\n\n
  \   http://xml.coverpages.org/xmlIntro.html\n\n** Why PXSL ?\n\nXML is a descendant
  of the markup language SGML and inherits its\nancestor's historical bias toward
  marking up textual documents.\nHowever, XML is becoming an increasingly popular
  medium for the\nrepresentation of non-textual information such as metadata (RSS,
  XSD,\nRELAX-NG), remote procedure calls (SOAP), and even information\nthat looks
  much like programming languages (XSLT, SVG, MathML).\nFor these uses, XML's text-centric
  syntax gets in the way.\n\nConsider, for example, this snippet of MathML:\n\n    MathML
  in XML\n\n    <declare type=\"fn\">\n      <ci> f </ci>\n      <lambda>\n        <bvar><ci>
  x </ci></bvar>\n        <apply>\n          <plus/>\n          <apply>\n            <power/>\n
  \           <ci> x </ci>\n            <cn> 2 </cn>\n          </apply>\n          <ci>
  x </ci>\n          <cn> 3 </cn>\n        </apply>\n      </lambda>\n    </declare>\n\nNotice
  something about MathML's structure: There is more markup than\ntext.  In fact, the
  only text in the snippet is \"f x x2 x3\"; the rest\nis markup.  As you can see
  above, XML's document-centric style of\nmarkup, in which the markup is delimited
  from the flow of surrounding\ntext, becomes a hindrance when markup is in the majority.\n\nPXSL,
  in contrast, was designed specifically to handle this case well.\nIt makes dense
  markup easy because it assumes that everything is\nmarkup to begin with.  You need
  only delimit the few portions of text\nthat are mixed into the flow of surrounding
  markup.\n\nIn other words, PXSL is what you get when you turn XML inside out:\n\n
  \   XML                             PXSL\n\n    <markup>text</markup>           markup
  <<text>>\n\nLet's see how this inside-out transformation simplifies our MathML\nexample
  from above:\n\n    MathML in XML                   MathML in PXSL\n\n    <declare
  type=\"fn\">             declare -type=fn\n      <ci> f </ci>                    ci
  << f >>\n      <lambda>                        lambda\n        <bvar><ci> x </ci></bvar>
  \      bvar\n        <apply>                           ci << x >>\n          <plus/>
  \                      apply\n          <apply>                         plus\n            <power/>
  \                     apply\n            <ci> x </ci>                    power\n
  \           <cn> 2 </cn>                    ci << x >>\n          </apply>                          cn
  << 2 >>\n          <ci> x </ci>                    ci << x >>\n          <cn> 3
  </cn>                    cn << 3 >>\n        </apply>\n      </lambda>\n    </declare>\n\nThere
  are two things to notice about the PXSL version in comparison\nto the XML version.
  \ First, the PXSL version is shorter.  Second, and\nmost important, PXSL is comparatively
  free of noisy characters like < >\n/ and \".  In PXSL, noise is the exception rather
  than the rule.\n\n\n** A closer look at PXSL\n\nWriting PXSL is simple.  If you
  know how to write XML, you can write\nPXSL.  In fact, PXSL is XML, just written
  in a different, inside-out\nsyntax.  Let's see how it works by way of comparison.\n\nFirst,
  every XML document and hence every PXSL document has a root\nelement.  Here is a
  tiny document that has a root element and nothing\nelse:\n\n    XML                             PXSL\n\n
  \   <doc/>                          doc\n\nIf the document contains other elements,
  they are simply placed\nunderneath the root element, but indented to indicate that
  the root\nelement contains them.  In XML this indenting is optional, but most\npeople
  do it anyway because it is an established practice that makes\ndocuments easier
  to understand.  In PXSL however, the indenting is\nmandatory because indentation
  determines which elements contain\nothers.  (This requirement is what enables PXSL
  to do away with the\nclosing tags that XML uses to determine containment.)\n\n    <doc>
  \                          doc\n      <title/>                        title\n      <body/>
  \                        body\n    </doc>\n\nIf an element has attributes, they
  are written in the form of\n-name=value in PXSL.\n\n    <doc>                           doc\n
  \     <title/>                        title\n      <body id=\"db13\"/>               body
  -id=db13\n    </doc>\n\nIf an attribute value contains whitespace, it must be quoted
  within\nthe literal delimiters << and >>.\n\n    <doc keywords=\"x y z\">          doc
  -keywords=<<x y z>>\n      <title/>                        title\n      <body id=\"db13\"/>
  \              body -id=db13\n    </doc>\n\nNow let's consider text.  If an element
  contains text, the text is\nquoted in << and >> delimiters and indented underneath
  the element\nthat owns the text.\n\n    <doc keywords=\"x y z\">          doc -keywords=<<x
  y z>>\n      <title/>                        title\n      <body id=\"db13\">                body
  -id=db13\n        This is text.                   <<This is text.>>\n      </body>\n
  \   </doc>\n\nThe << and >> delimiters are powerful.  The text within them,\nincluding
  all whitespace, is quoted verbatim.  The text can span\nmultiple lines and even
  stray outside of the outline-like indentation\nhierarchy.  If you place sections
  of quoted text next to one another\n<<like>> <<so>> they effectively become one
  section <<likeso>>.\n\n    <doc keywords=\"x y z\">          doc -keywords=<<x y
  z>>\n      <title>                         title\n        My title                        <<My
  title>>\n      </title>                        body -id=db13\n      <body id=\"db13\">
  \                 <<This is multi-\n        This is multi-                  line
  text.>>\n        line text.\n      </body>\n    </doc>\n\nIf you want to add an
  XML comment, introduce it with the -- delimiter.\nThe comment extends to the end
  of the line.\n\n    <!-- my document -->            -- my document\n    <doc keywords=\"x
  y z\">          doc -keywords=<<x y z>>\n      <title>                         title\n
  \       My title                        <<My title>>\n      </title>                        body
  -id=db13\n      <body id=\"db13\">                  <<This is multi-\n        This
  is multi-                  line text.>>\n        line text.\n      </body>\n    </doc>\n\nYou
  can also use the # delimiter, which creates a PXSL comment that is\ninvisible in
  XML:\n\n    <!-- my document -->            -- my document\n    <doc keywords=\"x
  y z\">          doc -keywords=<<x y z>>\n      <title>                         title\n
  \       My title                        <<My title>>\n      </title>                        body
  -id=db13\n      <body id=\"db13\">                  <<This is multi-\n        This
  is multi-                  line text.>>\n        line text.\n      </body>                       #
  hidden comment, for\n    </doc>                          # PXSL readers only\n\n\nThat's
  it.  You now know everything necessary to create PXSL\ndocuments.\n\nPXSL lets you
  do more, however, and if you want to take full advantage\nof it, read the Advanced
  Topics section.  For now, though, let's\nconsider how to use PXSL documents with
  your existing XML-based\nsoftware.\n\n\n** Using PXSL documents\n\nUsing PXSL documents
  is easy because they are really XML documents in\ndisguise.  (In fact, you may wish
  to consider PXSL as a convenient\nshorthand for writing XML.)  Any program that
  can read XML can handle\nPXSL.  All you need to do is remove the disguise first
  so that the\nprograms will recognize your documents for what they are.\n\nThe included
  tool pxlscc (short for PXSL conversion compiler) performs\nthis task.  Just feed
  it a PXSL document, and it returns the\nequivalent plain-old XML document:\n\n    $
  pxlscc document.pxsl > document.xml\n\nYou can then use the returned document in
  your XML-aware programs.\n\nIf you know how to use Make or Ant or similar tools,
  you can easily\nautomate this process so that your PXSL files are automagically\nconverted
  into XML when needed.\n\nNOTE:  The pxslcc program expects UTF-8 encoded input and
  emits UTF-8\nencoded output.\n\n\n* Advanced topics\n\nThe following sections describe
  the more advanced capabilities of PXSL\nthat can make your life easier.  The element
  defaults, in particular,\ncan significantly reduce markup burdens.\n\n\n** Element
  defaults provide convenient, customizable shortcuts\n\nMost XML documents conform
  to established vocabularies.  Once you\nbecome familiar with your documents' vocabularies,
  you'll probably\nfind that certain elements and attributes always or often occur\ntogether
  -- to the point where typing them becomes repetitive.  For\nexample, in XHTML, almost
  all img elements take the following form:\n\n    <img src=\"...\" alt=\"...\" [
  additional attributes here ] />\n\nOr, in PXSL:\n\n    img -src=... -alt=... [ additional
  attributes here ]\n\nSo, why should you have to type in the repetitive src=\"\"
  and alt=\"\"\nevery time you use an img element?  With PXSL's element defaults,\nyou
  don't need to.\n\n*** Using element defaults to create attribute shortcuts\n\nElement
  defaults are shortcuts that are defined in a separate file\nusing a simple syntax.
  \ (For the specifics of creating and loading\nthese files, see the Reference section
  on pxslcc.)  For example:\n\n    img = img src alt\n\nThis shortcut allows you optionally
  to leave off the -src= and -alt=\npart whenever you write the PXSL markup for an
  img element.  For\nexample, with this definition in place, all three of these PXSL\nstatements
  mean the exact same thing:\n\n    img -src=/images/logo.png -alt=Logo\n    img /images/logo.png
  -alt=Logo\n    img /images/logo.png Logo\n\nAll of them convert into the same XHTML:\n\n
  \   <img src=\"/images/logo.png\" alt=\"Logo\"/>\n    <img src=\"/images/logo.png\"
  alt=\"Logo\"/>\n    <img src=\"/images/logo.png\" alt=\"Logo\"/>\n\nIn other words,
  shortcuts let you pass attribute values by position\ninstead of by the -name=value
  syntax.  You provide only the values,\nand the shortcut provides the corresponding
  -name= parts behind the\nscenes.\n\nBut there are a couple of restrictions to keep
  in mind.  First,\nattribute values passed by position must come first, before any
  values\npassed using the -name=value syntax, and they must occur in the same\norder
  as declared in the shortcut definition.\n\nSecond, you can only pass values this
  way if they do not contain\nwhitespace.  If a value contains whitespace, you must
  use the\n-name=value syntax and quote the value: -name=<<my value>> (There is\nan
  advanced feature, the <( )> delimiters, that overcome this\nrestriction.  They are
  described in the section on advanced macros,\nlater in this document.)\n\n*** Using
  element defaults to create virtual elements\n\nYou can also use the element defaults
  to create your own virtual\nelements.  If you work in XHTML, you have probably noticed
  that the\n<a> element is used to create both hypertext links and anchors.  For\nexample:\n\n
  \  <a name=\"anchor-name\">Anchored text</a>\n   <a href=\"#anchor-name\">Link to
  anchored text</a>\n\nWhy not make these two uses more obviously distinct while cutting
  down\non markup at the same time?  Let's create virtual \"anchor\" and \"hlink\"\nelements
  that do just that:\n\n   anchor = a name\n   hlink = a href\n\nNow we can use these
  elements in PXSL to express the above XHTML more\nclearly:\n\n   anchor anchor-name
  <<Anchored text>>\n   hlink #anchor-name <<Link to anchored text>>\n\n(Notice that
  we used << and >> in an advanced way that lets us put\nquoted text on the same line
  as the element that contains it.  This is\ndiscussed further in the \"Advanced quoting\"
  section.)\n\nWhen we convert the above PXSL into XML, it results in exactly the\nsame
  XHTML that we discussed earlier:\n\n   <a name=\"anchor-name\">Anchored text</a>\n
  \  <a href=\"#anchor-name\">Link to anchored text</a>\n\n\n*** Making and using
  your own element defaults\n\nMaking your own shortcuts is easy.  Just create a file
  that contains\nlines of this form:\n\n    element-name = preferred-element-name
  opt-attr-1 opt-attr-2 ...\n\nIt's a good idea to extend the file's name with a suffix
  of \".edf\",\nwhich is short for \"element defaults,\" but feel free to ignore this\nconvention.
  \ (Note: element defaults are *not* PXSL macros.  If you\nwant to create a file
  that contains commonly used macros, just save\nthem in a regular .pxsl file and
  include it by mentioning it on the\ncommand line; the .edf suffix is for element
  defaults only.  See \"Tip:\nstore frequently used macros in separate .pxsl files\"
  for more.)\n\nFor example, we might create a \"xhtml-shortcuts.edf\" file to capture\nour
  shortcuts from above:\n\n    # File: xhtml-shortcuts.edf\n\n    anchor = a name\n
  \   hlink = a href\n\n(Notice that you can place comment lines in your .edf files
  by\nstarting them with a \"#\" character.)\n\nTo use the shortcuts, tell pxslcc
  to --add them to the set of active\nelement defaults that are used when processing
  your PXSL files:\n\n    $ pxslcc --add=xhtml-shortcuts.edf my-doc.pxsl > my-doc.xhtml\n\nYou
  can --add more than one set of defaults, and pxslcc will use them\nall.\n\n*** Built-in
  element defaults for XSLT stylesheets\n\nPXSL was originally created to reduce the
  verbosity of XSLT\nstylesheets.  As a result, pxslcc has a built-in set of element\ndefaults
  for XSLT that you can enable by passing the --xslt\nflag:\n\n    $ pxslcc --xslt
  stylesheet.pxsl > stylesheet.xsl\n\nThe built-in defaults provide two benefits:
  First, you can use element\nnames from within the XSLT namespace without having
  to use the xsl:\nprefix.  Second, you can pass common required attributes like \"select\"\nand
  \"match\" by position.\n\nTogether, these benefits result in massive markup reductions,
  making\nyour life as an XSLT author much easier.  Compare the following\nsnippet
  of XSLT in XML\n\n    <xsl:template match=\"/\">\n      <xsl:for-each select=\"//*/@src|//*/@href\">\n
  \       <xsl:value-of select=\".\"/>\n        <xsl:text>&#10;</xsl:text>\n      </xsl:for-each>\n
  \   </xsl:template>\n\nwith the same snippet rewritten in PXSL (using --xslt defaults):\n\n
  \   template /\n      for-each //*/@src|//*/@href\n        value-of .\n        text
  <<&#10;>>\n\nAmong the many XSLT shortcuts enabled by the --xslt flag, the above\nPXSL
  snippet uses the following:\n\n    template = xsl:template match name\n    for-each
  = xsl:for-each select xml:space\n    value-of = xsl:value-of select disable-output-escaping\n
  \   text     = xsl:text disable-output-escaping\n\nTo see the complete list of XSLT
  shortcuts, --export them:\n\n    $ pxslcc --xslt --export\n\n\n** Advanced quoting
  with the << >> and <{ }> delimiters\n\nPXSL has two kinds of quoting delimiters
  that can be used to quote\nmixed and text-only content.  Both are described in this
  section.\n\n*** XML quoting << >> delimiters\n\nThe << and >> delimiters not only
  let you insert text into your PXSL\ndocuments, but also let you insert raw, full-featured
  XML.  This works\ngreat for those times when it's just easier to write a bit of
  XML than\nits PXSL equivalent.  For example, if you're writing an XSLT\nstylesheet
  that generates XHTML output, you'll certainly want to use\nPXSL to express the markup-dense
  xsl:stylesheet directives.  But, if\nyou need to drop in some XHTML boilerplate
  that a designer gave you to\nuse in the page footer, just copy-and-paste it using
  << and >>:\n\n    <<\n       <div class=\"footer\">\n       Copyright (C) 2003 Blah,
  Blah, Blah, Inc.\n       <!--  lots more boilerplate ... -->\n       </div>\n    >>\n\nAnother
  great use for the << >> delimiters is to drop XML specials\nlike processing instructions
  into your code:\n\n    <<<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>>>\n\nThe
  above PXSL is equivalent to the following XML:\n\n    <?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n\nBecause
  the << >> delimiters quote XML, you must follow XML's\nsyntactical rules when using
  them.  That means that if you\nwant to include literal less-than \"<\" and ampersand
  \"&\"\ncharacters, you must use character entity references:\n\n    << less-than:
  &lt; >>\n    << ampersand: &amp; >>\n\n*** Verbatim text <{ }> delimiters (CDATA)\n\nWhen
  copy-and-pasting blocks of text from outside sources, you must be\ncareful to \"escape\"
  any literal \"<\" and \"&\" characters that may be\nwithin.  This can be annoying,
  especially for large blocks of text.\nAnother place where this requirement is burdensome
  is in mathematical\nexpressions that sometimes occur in XSLT markup:\n\n    xsl:test
  -when=<< $i &lt; 5 >>\n\nFor this reason, PXSL provides the verbatim-text delimiters
  <{ and }>\nthat perform the same function as XML's more verbose CDATA delimiters:\n\n
  \   XML                                   PXSL\n\n    <![CDATA[ toast & jelly ]]>
  \          <{ toast & jelly }>\n\nAny characters that you place inside of <{ }>
  will come out as a\ncharacter literals.  PXSL will take care of any escaping that
  is\nnecessary to prevent XML from misinterpreting your text as markup.\nFor example,
  we can rewrite the above XSLT snippet more clearly\nusing the verbatim-text delimiters:\n\n
  \   xsl:test -when=<{ $i < 5 }>\n\nThese delimiters are especially handy for including
  examples of XML\nmarkup in your documents.  Like << >>, <{ }> can handle large blocks\nof
  multi-line text and preserves whitespace and indentation.\n\n*** Text-content shortcut\n\nAs
  you may have noticed from the MathML example at the beginning of\nthis document,
  if an element contains text, you can declare the\ntext on the same line as the element.
  \ This saves space and often\nreads more easily:\n\n    NORMAL                         SHORTCUT\n\n
  \   h1                             h1 <<Chapter 1>>\n      <<Chapter 1>>                h2
  <{Sections 1 & 2}>\n    h2\n      <{Sections 1 & 2}>\n\n\n** Macro facility\n\nPXSL
  has a simple macro facility that you can use to reorganize your\nmarkup and \"factor
  out\" boilerplate.  A macro is defined with a\nleading comma and a trailing equals
  sign, like so:\n\n    ,name =\n        body-of-the-macro\n\nwhere \"name\" is the
  name of the macro and \"body-of-the-macro\" can be\nany series of elements and text.
  \ Macros can be defined at any level\nof nesting within a PXSL document, but they
  are only visible (i.e.,\navailable for use) at the level where they were defined
  and at levels\nnested underneath.  (If two macros with the same name are visible
  at\nthe same time, the deepest one will hide the other, or if both are on\nthe same
  level, the one defined latest in the document will hide the\nearlier.  In other
  words, the policy is \"the last, deepest one wins.\")\n\n*** Using macros (i.e.,
  macro expansion)\n\nTo use a macro, simply refer to it by name anywhere that an
  element\ncan be used:\n\n    ,hello =\n      <<Hello!>>\n\n    html\n      head\n
  \       title\n          ,hello\n      body\n        <<Hello! Again!>>\n\nWhen processed
  with pxslcc (using the --indent flag), this is the\nresult:\n\n    <html>\n      <head>\n
  \       <title>Hello!</title>\n      </head>\n      <body>Hello! Again!</body>\n
  \   </html>\n\nNote that the macro definition has been removed and that the reference\nto
  the macro inside of the \"title\" element has been replaced by the\nmacro's body.
  \ This is called macro expansion.\n\nMacros don't need to be defined before they
  are expanded, as long as\nthey are visible from the sites (locations) where they
  are expanded.\nAlso, macros can call other macros:\n\n    ,hello =\n      <<Hello!>>\n\n
  \   html\n      ,head\n      ,body\n\n      ,head =\n         head\n          title\n
  \           ,hello\n\n      ,body =\n        body <<Hello! Again!>>\n\nThis snippet
  results in exactly the same XML as the one above.\nNevertheless, we have made a
  number of organizational changes.\nThe \"head\" and \"body\" within the \"html\"
  element have been\nfactored out into the macros ,head and ,body and relocated within\nthe
  document.  These macros are defined within the \"html\"\nelement, after the sites
  where they are expanded.  Note that the\n,head macro calls upon the ,hello macro
  that we defined earlier.\n\nAlthough contrived in this small example, factoring
  out blocks of\nmarkup makes the structure of large documents easier to understand
  and\nmanage because you are free to move them around, subdivide them\nfurther, and
  reuse them in many locations.\n\n*** Tip: store frequently used macros in reusable
  .pxsl files\n\nIf you use certain macros frequently in your PXSL documents, you
  might\nbenefit from placing the macros into a separate .pxsl file that you\ncan
  reuse.  For example, you could place your macros into a file\nmacros.pxsl and then
  use them when processing several documents:\n\n    $ pxslcc macros.pxsl doc1.pxsl
  > doc1.xml\n    $ pxslcc macros.pxsl doc2.pxsl > doc2.xml\n    $ pxslcc macros.pxsl
  doc3.pxsl > doc3.xml\n\n\n*** Parameterized macros\n\nMacros can take any number
  of parameters, which allows you to customize\ntheir definitions.\n\n**** Using named
  parameters\n\nFor example, we could customize the definition of the ,head macro
  that\nwe used above to accept the title as a parameter:\n\n    ,make-head my-title
  =\n       head\n        title\n          ,my-title\n\nNow we can use it to create
  a head element that contains any title\nthat we want:\n\n    ,make-head -my-title=<<This
  is my title.>>\n\nNote that we pass parameters to a macro just like we pass attributes\nto
  an element definition.\n\n**** Using the magic, implicit BODY parameter\n\nBut what
  if we want to pass more than strings?  What if we want to\npass large sections of
  documents as parameters?  We can do this using\nthe special BODY parameter that
  all macros have implicitly:\n\n    ,make-section title =\n      section\n        --
  start of section\n        title\n          ,title\n        ,BODY\n        -- end
  of section\n\n(Note that the BODY parameter must be spelled exactly \"BODY\" and
  in\nall caps.)  The BODY parameter accepts any content defined underneath\nthe macro-expansion
  site (i.e., the body of the macro-expansion\ninvocation):\n\n    ,make-section -title=<<This
  is my title>>\n      p <<This is a paragraph.>>\n      p <<And another.>>\n      p
  <<And so on.>>\n\nThe result of calling this macro is the following XML:\n\n    <section>\n
  \     <!-- start of section -->\n      <title>This is my title</title>\n      <p>This
  is a paragraph.</p>\n      <p>And another.</p>\n      <p>And so on.</p>\n      <!--
  end of section -->\n    </section>\n\n*** Advanced macros and passing parameters
  with the <( )> delimiters\n\nAs we showed earlier, one way of passing document fragments
  to macros\nis via the implicit BODY parameter that all macros have.  Another is\nto
  pass them as normal arguments using the <( )> delimiters, which let\nyou group PXSL
  document fragments into chunks that you can pass as\narguments.\n\nFor example,
  let's redefine the make-section macro we defined above to\naccept the body of the
  section as a normal parameter:\n\n    ,make-section title body =\n      section\n
  \       -- start of section\n        title\n          ,title\n        body\n          ,body\n
  \       -- end of section\n\nNow we can call it like so:\n\n    ,make-section -title=<<This
  is my title>> \\\n      -body=<(\n        p <<This is a paragraph.>>\n        p
  <<And another.>>\n        p <<And so on.>>\n      )>\n\n(Note the use of the backslash
  in between parameters to continue the\nparameter list to the next line.  This useful
  trick also works to\ncontinue attribute lists when you are creating elements.)\n\nBecause
  the <( )> delimiters can be used only to pass arguments, you\ncan use them to \"quote\"
  arguments that otherwise could not be passed\nvia position, e.g., a fragment of
  text that contains whitespace:\n\n    ,make-section <( <<This is my title>> )> \\\n
  \     <(\n        p <<This is a paragraph.>>\n        p <<And another.>>\n        p
  <<And so on.>>\n      )>\n\nYou can even use the <( )> delimiters to pass the results
  of macro\ncalls to elements and other macros:\n\n    ,h1 x =\n      -- level one
  heading\n      h1\n        ,x\n\n    ,bang x =\n      ,x\n      <<!>>\n\n    ,h1
  <( <<Hello, >>\n           ,bang World )>\n\nThe above produces the following XML:\n\n
  \   <!-- level one heading -->\n    <h1>Hello, World!</h1>\n\n\n*** More advanced
  macros and functional programming\n\nLike functions in functional programming languages,
  macros in PXSL are\nfirst-class values that can be created, bound to parameters,
  and\npassed to other macros.  While this might initially seem like a\nprogramming-language
  curiosity, it is actually a simple yet immensely\npowerful tool that you can use
  to reduce the size and complexity of\nyour XML documents.  In particular, this tool
  lets you \"factor out\"\nand reuse common, boilerplate portions of your documents.\n\nTo
  see how this works, consider the following XML document that\nrepresents an address
  book:\n\n    <address-book>\n      <person>\n        <first>Joe</first>\n        <last>Smith</last>\n
  \       <preferred>Joe Smith</preferred>\n      </person>\n      <person>\n        <first>John</first>\n
  \       <last>Doe</last>\n        <preferred>John Doe</preferred>\n      </person>\n
  \     <!-- ... more persons ... -->\n    </address-book>\n\nThe address book contains
  a long list of persons, each of which has a\nfirst and last name and a \"preferred
  name\" that is usually the first\nand last named joined together (but might be something
  else).\n\nWe might write the address book in PXSL like this:\n\n    address-book\n
  \     person\n        first <<Joe>>\n        last <<Smith>>\n        preferred <<Joe
  Smith>>\n      person\n        first <<John>\n        last <<Doe>>\n        preferred
  <<John Doe>>\n      -- ... more persons ...\n\nBut, seeing how repetitive that is,
  we might create a ,person macro\nto make our lives easier:\n\n    ,person first
  last =\n      person\n        first\n          ,first\n        last\n          ,last\n
  \       preferred\n          ,first\n          << >>\n          ,last\n\nNow, with
  our new macro, we can simply write\n\n    address-book\n      ,person Joe Smith\n
  \     ,person John Doe\n      -- ... more persons ...\n\nAnd, indeed, running the
  above PXSL code through pxslcc, yields the\nidentical XML:\n\n    <address-book>\n
  \     <person>\n        <first>Joe</first>\n        <last>Smith</last>\n        <preferred>Joe
  Smith</preferred>\n      </person>\n      <person>\n        <first>John</first>\n
  \       <last>Doe</last>\n        <preferred>John Doe</preferred>\n      </person>\n
  \     <!-- ... more persons ... -->\n    </address-book>\n\nAlready, we have saved
  a great deal of work, but let's say that the\nsituation is a little more complicated.
  \ Let's say that in addition\nto the address-book, we also need to make a roster
  of persons:\n\n    <roster>\n      <formal>Smith, Joe</formal>\n      <formal>Doe,
  John</formal>\n      <!-- ... more persons ... -->\n    </roster>\n\nand, most important,
  we need to keep the address-book and roster\nsynchronized.  In other words, we have
  one list of names and we\nmust use it in two places.\n\nAt this point, we might
  be tempted to put the list of names in a\nseparate XML document and write a small
  external program or a couple\nof XSLT stylesheets to transform the document into
  the address-book\nand roster.  After all, we don't want to have to keep the address-book\nand
  roster synchronized by hand.\n\nBut we can do this without leaving PXSL.  All we
  have to do is create\na macro that builds things out of our list of people:\n\n
  \   ,build-from-people builder-macro =\n        ,builder-macro Joe Smith\n        ,builder-macro
  John Doe\n        -- ... more persons ...\n\nThe interesting thing is that our ,build-from-people
  macro takes\nanother macro as a parameter and binds it to the name \"builder-macro\",\njust
  like it would any other kind of parameter.  It uses this macro to\ntransform a first
  and last name into something else.  What that\nsomething else is, is up to us: We
  simply tailor the ,builder-macro to\nsuit our purpose.\n\nFor example, to build
  an address book:\n\n    address-book\n      ,build-from-people <( , first last =\n
  \                             ,person <(,first)> <(,last)> )>\n\nor, to build a
  roster:\n\n    roster\n      ,build-from-people <( , first last =\n                              formal\n
  \                               ,last\n                                <<, >>\n
  \                               ,first  )>\n\nThat's it.  We have just built an
  address book and a roster from our\nlist of people.\n\nNow, you may have noticed
  something new in the above two snippets of\nPXSL.  In each snippet, inside of the
  outer-most <( )> delimiters, we\ncreated a macro on the fly -- an anonymous macro,
  so called because we\ndidn't give it a name.  (It doesn't need a name because we're
  using it\njust this one time; nobody else will ever call it.)  We simply created\nit
  right when we needed it and passed it to the ,build-from-people\nmacro, where it
  was bound to the name \"builder-macro.\" Then\n,build-from-people used it to construct
  \"person\" or \"formal\" elements\n(depending on how we defined the anonymous macro).
  \ It's a pretty neat\ntrick.\n\nYou can create anonymous macros using the familiar
  comma syntax --\njust don't provide a name.  Note the space between the comma and
  the\nstart of the argument list:\n\n    , arg1 arg2... =\n      body\n\nTo call
  an anonymous macro, of course, you'll first have to bind it to\na name.  The way
  you do this is to pass the anonymous macro to another\nmacro, just like we did earlier,
  causing the anonymous macro to be\nbound to one of the other macro's parameters:\n\n
  \   ,some-other-macro <( , arg1 arg2... =\n                           body  )>\n\nThen
  that other macro can call it via the parameter's name:\n\n    ,some-other-macro
  marco-arg =\n      ,macro-arg -arg1=... -arg2=...\n\nHere's another example, less
  practical but illustrative.  See if you\ncan figure out how the code works before
  reading the explanation\nthat follows.\n\n    ,double str =\n       <{\"}>\n       ,str\n
  \      <{\"}>\n    ,single str =\n       <{'}>\n       ,str\n       <{'}>\n    ,add-quotes
  quote-fn str =\n       ,quote-fn <( ,str )>\n\n    -- let's quote a couple of strings\n\n
  \   ,add-quotes <( , x = ,double <(,x)> )> -str=<<Quote Me>>\n    << >>\n    ,add-quotes
  <( , x = ,single <(,x)> )> Please!\n\nPxslcc compiles the above into the following
  output:\n\n    <!-- let's quote a couple of strings -->\n\n    \"Quote Me\" 'Please!'\n\nIn
  this example, the two calls to the ,add-quotes macro each pass in\nan anonymous
  macro that performs the desired quoting operation.  The\nanonymous macro is bound
  to \"quote-fn\" when the ,add-quotes macro is\ncalled and expanded.  Thus, when
  ,add-quotes calls ,quote-fn, it is\nreally calling the anonymous macro that we passed
  to it.  This lets us\ncustomize the behavior of ,add-quotes without having to rewrite
  it.\n\n*** Real-world example\n\nThe examples above are contrived and don't do justice
  to the\nusefulness of this tool.  This type of refactoring shines when dealing\nwith
  large, complicated, and repetitive data structures, but such\nexamples are too unwieldy
  to include in an introduction like this.\nFor this reason, I urge you to take a
  look at the\n\"xsl-menus-w-macros.pxsl\" example, in examples directory.  It shows\none
  way that you can use anonymous macros to factor out common code in\nproduction XSLT
  stylesheets.\n\n    http://community.moertel.com/pxsl/examples/xsl-menus-w-macros.pxsl\n\n**
  Automatic PXSL-to-XML conversion via Make\n\nMost Make utilities allow you to define
  pattern rules that are then\nused automatically to convert one class of documents
  into another.\nPattern rules can be used to automate the conversion of PXSL documents\ninto
  their XML counterparts.  For example, if you place the following\nrule into a makefile
  (this is for GNU make),\n\n    %.xml: %.pxsl\n            pxlscc --indent=2 --header
  $< > $@\n\nMake will automatically generate .xml documents from the\ncorresponding
  .pxsl documents whenever they are needed.  This\nfrees you to substitute .pxsl documents
  anywhere that your\nproject calls for .xml documents, knowing that make will keep
  all\nof the .xml documents up to date, regenerating them as needed\nwhen you update
  your .pxsl documents.\n\n\n* Reference:  pxlscc\n\n  Usage: pxslcc [OPTION...] [file...]\n
  \ -i[NUM]  --indent[=NUM]  Re-indent XML using NUM spaces per nesting level\n  -h
  \      --header        Insert edit-the-PXSL-instead header into output XML\n  -x
  \      --xslt          Add XSLT defaults\n  -a FILE  --add=FILE      Add the given
  defaults file\n           --export        Export (print) all of the active defaults\n
  \          --dump          Dump internal parse format (for debugging)\n\nWhen you
  list more than one PXSL file on the command line, pxslcc will\njoin the files, in
  order, into one big PXSL document and process that\ndocument.  You can use this
  feature to incorporate commonly used\nmacros into your documents:\n\n    $ pxslcc
  macros1.pxsl macros2.pxsl doc.pxsl > doc.xml\n\nIn the example above, doc.pxsl can
  use the macros defined in\nmacros1.pxsl and macros2.pxsl.\n\nThe --header option
  requires some explanation.  It inserts the following\nheader comment into the output
  XML:\n\n    <!--\n\n    NOTICE:  This XML document was generated from PXSL source.\n
  \            If you want to edit this file, you should probably\n             edit
  the original PXSL source file instead.\n\n    -->\n\nIt's a good idea to use the
  --header option all of the time.  This\nprevents you (or somebody else) from accidentally
  editing an XML file\nwhen you really ought to be editing the PXSL file from which
  the\nXML file is generated.\n\n\n[TODO: Expand this section]\n\n\n* Reference:  PXSL
  syntax\n\nThe PXSL grammar, in EBNF-like notation:\n\n    pxsl-document       ::=
  statement*, EOF\n\n    statement           ::= pxsl-comment\n                          |
  xml-comment\n                          | literal-constructor\n                          |
  element-constructor\n                          | macro-def\n                          |
  macro-app\n\n    pxsl-comment        ::= '#',  all-text-until-newline, NEWLINE\n
  \   xml-comment         ::= \"--\", all-text-until-newline, NEWLINE\n    literal-constructor
  ::= mixed-literal | cdata-literal\n    element-constructor ::= xml-name, posn-args,
  nv-args, children\n    macro-def           ::= ',', xml-name?, param-names, '=',
  macro-body\n    macro-app           ::= ',', xml-name, posn-args, nv-args, children\n\n
  \   xml-name            ::= ( LETTER | '_' | ':' ),\n                            (
  LETTER | DIGIT | '_' | ':' | '.' | '-' )*\n    posn-args           ::= expr-list\n
  \   nv-args             ::= ( line-continuation?, name-value-pair )*\n    name-value-pair
  \    ::= '-', xml-name, '=', expr\n    children            ::= statement*     /*
  must be indented */\n    macro-body          ::= children\n    param-names         ::=
  ( line-continuation?, xml-name )*\n\n    line-continuation   ::= '\\', newline\n\n
  \   expr-list           ::= ( line-continuation?, arg-expr )*\n    arg-expr            ::=
  expr    /* cannot start with '-' */\n    expr                ::= expr-single | NON-WHITESPACE+\n
  \   expr-single         ::= mixed-literal | cdata-literal | pxsl-fragment\n    mixed-literal
  \      ::= \"<<\", all-text-until->>-delimiter, \">>\"\n    cdata-literal       ::=
  \"<{\", all-text-until-}>-delimiter, \"}>\"\n    pxsl-fragment       ::= \"<(\",
  statement*, \")>\"\n\n\n* Authors\n\nTom Moertel <tom@moertel.com> http://blog.moertel.com/\n\nBill
  Hubauer <bill@hubauer.com>\n\n* (For Emacs)\n\n  Local Variables:\n  mode:outline\n
  \ End:\n"
license-name: LicenseRef-GPL
