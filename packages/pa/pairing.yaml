homepage: https://github.com/adjoint-io/pairing#readme
changelog-type: markdown
hash: 83803b26104bdce95bda7910d6c1c88d808ba3e3952c6dc1badf1c190e6ebed2
test-bench-deps:
  bytestring: -any
  base: ! '>=4.7 && <5'
  tasty-discover: -any
  criterion: -any
  protolude: ! '>=0.2'
  memory: -any
  wl-pprint-text: -any
  pairing: -any
  cryptonite: -any
  tasty-quickcheck: -any
  tasty-hunit: -any
  random: -any
  tasty: -any
  QuickCheck: -any
maintainer: Adjoint Inc (info@adjoint.io)
synopsis: Optimal ate pairing over Barreto-Naehrig curves
changelog: ! '# Changelog for pairing


  ## 0.1


  * Initial release.

'
basic-deps:
  bytestring: -any
  base: ! '>=4.7 && <5'
  protolude: ! '>=0.2'
  memory: -any
  wl-pprint-text: -any
  cryptonite: -any
  random: -any
  QuickCheck: -any
all-versions:
- '0.1.0'
- '0.1.1'
- '0.1.2'
author: ''
latest: '0.1.2'
description-type: markdown
description: ! "<p align=\"center\">\n  <a href=\"http://www.adjoint.io\"><img src=\"https://www.adjoint.io/assets/img/adjoint-logo@2x.png\"
  width=\"250\"/></a>\n</p>\n\n[![CircleCI](https://circleci.com/gh/adjoint-io/pairing.svg?style=svg&circle-token=ac95d02ba07e02b88585397f91cfe92a8c833343)](https://circleci.com/gh/adjoint-io/pairing)\n[![Hackage](https://img.shields.io/hackage/v/pairing.svg)](https://hackage.haskell.org/package/pairing)\n\nImplementation
  of the Barreto-Naehrig (BN) curve construction from\n[[BCTV2015]](https://eprint.iacr.org/2013/879.pdf)
  to provide two cyclic groups\n**G<sub>1</sub>** and **G<sub>2</sub>**, with an efficient
  bilinear pairing:\n\n*e: G<sub>1</sub> × G<sub>2</sub> → G<sub>T</sub>*\n\n# Pairing\n\nLet
  G<sub>1</sub>, G<sub>2</sub> and G<sub>T</sub> be abelian groups of prime order
  `q` and let `g` and `h` elements of G<sub>1</sub> and G<sub>2</sub> respectively
  . A pairing is a non-degenerate bilinear map e: G<sub>1</sub> × G<sub>2</sub> →
  G<sub>T</sub>.\n\nThis bilinearity property is what makes pairings such a powerful
  primitive in cryptography. It satisfies:\n- e(g<sub>1</sub> + g<sub>2</sub>, h)
  = e(g<sub>1</sub>, h) e(g<sub>2</sub>, h)\n- e(g, h<sub>1</sub> + h<sub>2</sub>)
  = e(g, h<sub>1</sub>) e(g, h<sub>2</sub>)\n\n\nThe non-degeneracy property guarantees
  non-trivial pairings for non-trivial arguments. In other words, being non-degenerate
  means that:\n- ∀ g ≠ 1, ∃ h<sub>i</sub> ∈ G<sub>2</sub> such that e(g, h<sub>i</sub>)
  ≠ 1\n- ∀ h ≠ 1, ∃ g<sub>i</sub> ∈ G<sub>1</sub> such that e(g<sub>i</sub>, h) ≠
  1\n\nAn example of a pairing would be the scalar product on euclidean space <.>
  : R<sup>n</sup> × R<sup>n</sup> → R\n\n## Example Usage\n\nA simple example of calculating
  the optimal ate pairing given two points in G<sub>1</sub> and G<sub>2</sub>.\n\n```haskell\nimport
  Protolude\n\nimport Pairing.Group\nimport Pairing.Pairing\nimport Pairing.Point\nimport
  Pairing.Fq (Fq(..))\nimport Pairing.Fq2 (Fq2(..))\n\ne1 :: G1\ne1 = Point\n        (Fq
  1368015179489954701390400359078579693043519447331113978918064868415326638035)\n
  \       (Fq 9918110051302171585080402603319702774565515993150576347155970296011118125764)\n\n\ne2
  :: G2\ne2 = Point\n        (Fq2\n         (Fq 2725019753478801796453339367788033689375851816420509565303521482350756874229)\n
  \        (Fq 7273165102799931111715871471550377909735733521218303035754523677688038059653)\n
  \       )\n        (Fq2\n         (Fq 2512659008974376214222774206987427162027254181373325676825515531566330959255)\n
  \        (Fq 957874124722006818841961785324909313781880061366718538693995380805373202866)\n
  \       )\n\n\nmain :: IO ()\nmain  = do\n  putText \"Ate pairing:\"\n  print (atePairing
  e1 e2)\n  let \n    lhs = reducedPairing (gMul e1 2) (gMul e2 3)\n    rhs = (reducedPairing
  e1 e2)^(2 * 3)\n  putText \"Is bilinear:\" \n  print (lhs == rhs)\n```\n\n## Pairings
  in cryptography\n\nPairings are used in encryption algorithms, such as identity-based
  encryption (IBE), attribute-based encryption (ABE), (inner-product) predicate encryption,
  short broadcast encryption and searchable encryption, among others. It allows strong
  encryption with small signature sizes.\n\n## Admissible Pairings\n\nA pairing `e`
  is called admissible pairing if it is efficiently computable. The only admissible
  pairings that are suitable for cryptography are the Weil and Tate pairings on algebraic
  curves and their variants. Let `r` be the order of a group and E[r] be the entire
  group of points of order `r` on E(F<sub>q</sub>). E[r] is called the r-torsion and
  is defined as E[r] = { P ∈ E(F<sub>q</sub>) | rP = O }. Both Weil and Tate pairings
  require that `P` and `Q` come from disjoint cyclic subgroups of the same prime order
  `r`. Lagrange's theorem states that for any finite group `G`, the order (number
  of elements) of every subgroup `H` of `G` divides the order of `G`. Therefore, r
  | #E(F<sub>q</sub>).\n\nG<sub>1</sub> and G<sub>2</sub> are subgroups of a group
  defined in an elliptic curve over an extension of a finite field F<sub>q</sub>,
  namely E(F<sub>q<sup>k</sup></sub>), where `q` is the characteristic of the field
  and `k` is a positive integer called embedding degree.\n\nThe embedding degree `k`
  plays a crucial role in pairing cryptography:\n- It's the value that makes  F<sub>q<sup>k</sup></sub>
  be the smallest extension of F<sub>q</sub> such that E(F<sub>q<sup>k</sup></sub>)
  captures more points of order `r`.\n- It's the minimal value that holds r | (q<sup>k</sup>
  - 1).\n- It's the smallest positive integer such that E[r] ⊂ E(F<sub>q<sup>k</sup></sub>)\n\nThere
  are subtle but relevant differences in G<sub>1</sub> and G<sub>2</sub> subgroups
  depending on the type of pairing. Nowadays, all of the state-of-the-art implementations
  of pairings take place on ordinary curves and assume a type of pairing (Type 3)
  where G<sub>1</sub> = E[r] ∩ Ker(π - [1]) and G<sub>2</sub> = E[r] ∩ Ker(π - [q])
  and there is no non-trivial map φ: G<sub>2</sub> → G<sub>1</sub>.\n\n## Tate Pairing\n\nThe
  Tate pairing is a map:\n\ntr : E(F<sub>q<sup>k</sup></sub>)[r] × E(F<sub>q<sup>k</sup></sub>)
  / rE(F<sub>q<sup>k</sup></sub>) → F<sup>&ast;</sup><sub>q<sup>k</sup></sub> / (F<sup>&ast;</sup><sub>q<sup>k</sup></sub>)<sup>r</sup>\n\ndefined
  as:\n\ntr(P, Q) = f(Q)\n\nwhere P ∈ E(F<sub>q<sup>k</sup></sub>)[r], Q is any representative
  in a equivalence class in E(F<sub>q<sup>k</sup></sub>) / rE(F<sub>q<sup>k</sup></sub>)
  and F<sup>&ast;</sup><sub>q<sup>k</sup></sub> / (F<sup>&ast;</sup><sub>q<sup>k</sup></sub>)<sup>r</sup>
  is the set of equivalence classes of F<sup>&ast;</sup><sub>q<sup>k</sup></sub> under
  the equivalence relation a ≡ b iff a / b ∈ (F<sup>&ast;</sup><sub>q<sup>k</sup></sub>)<sup>r</sup>.
  The equivalence relation in the output of the Tate pairing is unfortunate. In cryptography,
  different parties must compute the same value under the bilinearity property.\n\nThe
  reduced Tate pairing solves this undesirable property by exponentiating elements
  in F<sup>&ast;</sup><sub>q<sup>k</sup></sub> / (F<sup>&ast;</sup><sub>q<sup>k</sup></sub>)<sup>r</sup>
  to the power of (q<sup>k</sup> - 1) / r. It maps all elements in an equivalence
  class to the same value. It is defined as:\n\nTr(P, Q) = t<sub>r</sub>(P, Q)<sup>#F<sub>q<sup>k</sup></sub>
  / r</sup> = f<sub>r</sub>,P(Q)<sup>(q<sup>k</sup> - 1) / r</sup>.\n\nWhen we say
  Tate pairing, we normally mean the reduced Tate pairing.\n\n## Pairing optimization\n\nTate
  pairings use Miller's algorithm, which is essentially the double-and-add algorithm
  for elliptic curve point multiplication combined with evaluation of the functions
  used in the addition process. Miller's algorithm remains the fastest algorithm for
  computing pairings to date.\n\nBoth G<sub>1</sub> and G<sub>2</sub> are elliptic
  curve groups. G<sub>T</sub> is a multiplicative subgroup of a finite field. The
  security an elliptic curve group offers per bit is considerably greater than the
  security a finite field does. In order to achieve security comparable to 128-bit
  security (AES-128), an elliptic curve of 256 bits will suffice, while we need a
  finite field of 3248 bits. The aim of a cryptographic protocol is to achieve the
  highest security degree with the smallest signature size, which normally leads to
  a more efficient computation. In pairing cryptography, significant improvements
  can be made by keeping all three group sizes the same. It is possible to find elliptic
  curves over a field F<sub>q</sub> whose largest prime order subgroup `r` has the
  same bit-size as the characteristic of the field `q`. The ratio between the field
  size `q` and the large prime group order `r` is called the φ-value. It is an important
  value that indicates how much (ECDLP) security a curve offers for its field size.
  φ=1 is the optimal value. The Barreto-Naehrig (BN) family of curves all have φ=1
  and k=12. They are perfectly suited to the 128-bit security level.\n\nMost operations
  in pairings happen in the extension field F<sub>q<sup>k</sup></sub>. The larger
  k gets, the more complex F<sub>q<sup>k</sup></sub> becomes and the more computationally
  expensive the pairing becomes. The complexity of Miller's algorithm heavily depends
  on the complexity of the associated F<sub>q<sup>k</sup></sub>-arithmetic. Therefore,
  the aim is to minimize the cost of arithmetic in F<sub>q<sup>k</sup></sub>.\n\nIt
  is possible to construct an extension of a field F<sub>q<sup>k</sup></sub> by successively
  towering up intermediate fields F<sub>q<sup>a</sup></sub> and F<sub>q<sup>b</sup></sub>
  such that k = a^i b^j, where a and b are usually 2 and 3. One of the reasons tower
  extensions work is that quadratic and cubic extensions (F<sub>q<sup>2</sup></sub>
  and F<sub>q<sup>3</sup></sub>) offer methods of performing arithmetic more efficiently.\n\nMiller's
  algorithm in the Tate pairing iterates as far as the prime group order `r`, which
  is a large number in cryptography. The ate pairing comes up as an optimization of
  the Tate pairing by shortening Miller's loop. It achieves a much shorter loop of
  length T = t - 1 on an ordinary curve, where t is the trace of the Frobenius endomorphism.
  The ate pairing is defined as:\n\nat(Q,P) = f<sub>r,Q</sub>(P)<sup>(q<sup>k</sup>
  - 1) / r</sup>\n\n## Implementation\n\nWe have implemented the optimal Ate pairing
  over the BN128 curve, i.e. we define `q` and `r` as\n\n * q = 36t<sup>4</sup> +
  36t<sup>3</sup> + 24t<sup>2</sup> + 6t + 1\n * r = 36t<sup>4</sup> + 36t<sup>3</sup>
  + 18t<sup>2</sup> + 6t + 1\n * t = 4965661367192848881\n\nThe tower of finite fields
  we work with is defined as follows:\n\n * F<sub>q</sub> is the prime field with
  characteristic `q`\n * F<sub>q<sup>2</sup></sub> := F<sub>q</sub>[u]/u<sup>2</sup>
  + 1\n * F<sub>q<sup>6</sup></sub> := F<sub>q<sup></sub>2</sup>[v]/v<sup>3</sup>
  - (9 + u)\n * F<sub>q<sup>12</sup></sub> := F<sub>q<sup>6</sup></sub>[w]/w<sup>2</sup>
  - v\n\nThe groups' definitions are:\n\n * G<sub>1</sub> := E(F<sub>q</sub>), with
  equation y<sup>2</sup> = x<sup>3</sup> + 3\n * G<sub>2</sub> := E'(F<sub>q<sup>2</sup></sub>),
  with equation y<sup>2</sup> = x<sup>3</sup> + 3 / (9 + u)\n * G<sub>T</sub> := μ<sub>r</sub>,
  i.e. the `r`-th roots of unity subgroup of the multiplicative group of F<sub>q<sup>12</sup></sub>\n\nLicense\n-------\n\n```\nCopyright
  (c) 2018-2019 Adjoint Inc.\n\nPermission is hereby granted, free of charge, to any
  person obtaining a copy\nof this software and associated documentation files (the
  \"Software\"), to deal\nin the Software without restriction, including without limitation
  the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or
  sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished
  to do so, subject to the following conditions:\n\nThe above copyright notice and
  this permission notice shall be included in all\ncopies or substantial portions
  of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY
  KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS
  OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\nDAMAGES OR OTHER LIABILITY, WHETHER
  IN AN ACTION OF CONTRACT, TORT OR\nOTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
  WITH THE SOFTWARE OR THE USE\nOR OTHER DEALINGS IN THE SOFTWARE.\n```\n\n"
license-name: MIT
