homepage: http://github.com/bennofs/dynamic-cabal/
changelog-type: ''
hash: 71313c48befed3fe358f6911ca7336138d5b6faf0fbda437866ef0b07f5dc393
test-bench-deps:
  ghc: -any
  tasty-th: -any
  base: -any
  filepath: -any
  doctest: ! '>=0.9.1'
  HUnit: -any
  containers: -any
  dynamic-cabal: -any
  tasty-hunit: -any
  tasty: -any
  directory: ! '>=1.0'
maintainer: Benno F端nfst端ck <benno.fuenfstueck@gmail.com>
synopsis: Access the functions from the Cabal library without depending on it
changelog: ''
basic-deps:
  void: -any
  ghc: -any
  haskell-generate: -any
  base: ! '>=4.4 && <5'
  time: -any
  filepath: -any
  data-default: -any
  containers: -any
  haskell-src-exts: -any
  ghc-paths: -any
  directory: -any
all-versions:
- '0.1'
- '0.2'
- '0.3'
- 0.3.1
- 0.3.2
- 0.3.3
- 0.3.4
- 0.3.5
author: Benno F端nfst端ck
latest: 0.3.5
description-type: markdown
description: ! "dynamic-cabal\n=============\n\n[![Build Status](https://secure.travis-ci.org/bennofs/dynamic-cabal.png?branch=master)](http://travis-ci.org/bennofs/dynamic-cabal)\n\n*Note*:
  The problem this library solves no longer exists starting with GHC 7.10, since versions
  later than that do not depend on the Cabal library. You only need this library if
  you like to support older GHC versions.\n\nIf you've ever used Cabal together with
  the GHC-API, you know the problem. Because GHC depends on a version of Cabal, which
  is often outdated, there is no way to parse the setup-config file generated by newer
  cabal versions. This library attemps to solve the problem by dynamically generating
  code that performs the action you want, and then compiling and loading that with
  GHC. With this method, you don't need to depend on Cabal at compile time and so
  you can use any version of Cabal.\n\n## Usage\n\nCurrently, the library only allows
  two queries: Getting the targets (along with their dependencies, ghc options, etc)
  and the package databases. The first is easily achieved using the `targets` query
  provided by the library. To run the query, you can use the `runQuery` function,
  which takes the path to the setup-config file as an argument. For example, the following
  little program prints out the names of all test suites, when run in a configured
  cabal project root directory:\n\n```haskell\nimport Distribution.Client.Dynamic\n\nmain
  :: IO ()\nmain = do\n  tgs <- runQuery (on localPkgDesc targets) \"dist/setup-config\"\n
  \ mapM_ putStrLn [ n | TestSuite n <- map name tgs ]\n```\n\nBecause `targets` works
  on a PackageDescription, `on localPkgDesc` is used to get the current PackageDescription.\n\n##
  Contributing\n\nAt the moment, I only implemented the functions I need myself. If
  you have more functions you want to implement, just send a pull request or open
  an issue.\n"
license-name: BSD-3-Clause
