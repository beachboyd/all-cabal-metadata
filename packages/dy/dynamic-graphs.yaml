homepage: ''
changelog-type: markdown
hash: 4d5314331aa13a31f9da29162e40a14ffcfef9cbdd2dffc999c4504db77bd42b
test-bench-deps:
  bytestring: -any
  dynamic-graphs: -any
  mwc-random: -any
  test-framework: -any
  base: -any
  unordered-containers: -any
  text: -any
  test-framework-quickcheck2: -any
  criterion: -any
  test-framework-th: -any
  containers: -any
  hashable: -any
  deepseq: -any
  QuickCheck: -any
  aeson: -any
  primitive: -any
maintainer: me@alang.ca
synopsis: Dynamic graph algorithms
changelog: |
  # CHANGELOG

  - 0.1.0.1 (2019-01-11)
      * Restrict dependency versions somewhat

  - 0.1.0.0 (2019-01-11)
      * First version.  Basic versions of dynamic connectivity.  This blogpost has
        some more information:
        <https://jaspervdj.be/posts/2019-01-11-dynamic-graphs.html>
basic-deps:
  dynamic-graphs: -any
  mwc-random: ! '>=0.12 && <0.14'
  base: ! '>=4.9 && <4.12'
  unordered-containers: ==0.2.*
  text: -any
  criterion: -any
  containers: ! '>=0.3 && <0.7'
  hashtables: ! '>=1.2 && <1.3'
  hashable: ! '>=1.0 && <1.3'
  deepseq: -any
  QuickCheck: -any
  primitive: ! '>=0.5 && <0.7'
  vector: ! '>=0.10 && <0.13'
all-versions:
- 0.1.0.1
author: Alex Lang, Jasper Van der Jeugt
latest: 0.1.0.1
description-type: markdown
description: |
  # dynamic-graphs

  ## Summary

  A Haskell library for dealing with the _dynamic connectivity_ problem.  Consider
  an undirected graph, where edges may be added and removed.  This library allows
  you to answer the question "are the nodes X and Y connected" at any point in
  time.

  This blogpost has some more information about this library:
  <https://jaspervdj.be/posts/2019-01-11-dynamic-graphs.html>.

  ## Installation

  `dynamic-graphs` is available on
  [hackage](https://hackage.haskell.org/package/dynamic-graphs).  You can install
  it using Stack, Cabal, Nix, or whichever tool you prefer.

  ## Example

  ```haskell
  import qualified Data.Graph.Dynamic.Levels as GD
  import qualified Data.Tree as T

  main :: IO ()
  main = do
      graph <- GD.empty'
      mapM_ (GD.insert_ graph) ["Akanu", "Kanoa", "Kekoa", "Kaiwi", "Onakea"]
      GD.link_ graph "Akanu" "Kanoa"
      GD.link_ graph "Akanu" "Kaiwi"
      GD.link_ graph "Akanu" "Onakea"
      GD.link_ graph "Kaiwi" "Onakea"
      GD.link_ graph "Onakea" "Kanoa"
      GD.link_ graph "Kanoa" "Kekoa"

      GD.connected graph "Kaiwi" "Kekoa" >>= print
      GD.cut_ graph "Kaiwi" "Akanu"
      GD.cut_ graph "Onakea" "Akanu"
      GD.cut_ graph "Onakea" "Kanoa"
      GD.connected graph "Kaiwi" "Kekoa" >>= print
      GD.link_ graph "Akanu" "Kaiwi"
      GD.connected graph "Kaiwi" "Kekoa" >>= print
  ```
license-name: BSD-3-Clause
