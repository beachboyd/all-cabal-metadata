homepage: https://github.com/ChrisPenner/grids#readme
changelog-type: markdown
hash: 16aa6b36dd5bae5a4852c292745028d3870a1ecfd2923a4d27b42f999694b28c
test-bench-deps: {}
maintainer: christopher.penner@gmail.com
synopsis: ''
changelog: ! '# Changelog for grids


  ## Unreleased changes

'
basic-deps:
  base: ! '>=4.7 && <5'
  adjunctions: -any
  distributive: -any
  lens: -any
  finite-typelits: -any
  vector: -any
all-versions:
- 0.1.0.0
- 0.1.1.0
author: Chris Penner
latest: 0.1.1.0
description-type: markdown
description: ! "# Grids\n\nGrids can have an arbitrary amount of dimensions, specified
  by a type-level\nlist of `Nat`s. They're backed by a single contiguous Vector and
  gain the associated performance benefits. Currently\nonly boxed immutable vectors
  are supported, but let me know if you need other variants.\n\nHere's how we might
  represent a Tic-Tac-Toe board:\n\n```haskell\ndata Piece = X | O deriving Show\ntoPiece
  n = if even n then X\n                      else O\n\nticTacToe :: Grid [3, 3] Piece\nticTacToe
  = generate toPiece\n```\n\nYou can collapse the grid down to nested lists! The output
  type of `toNestedLists` depends on your dimensions, e.g.:\n\n- `Grid [3, 3] Piece`
  will generate: `[[Piece]]`\n- `Grid [2, 2, 2] Char` will generate: `[[[Char]]]`\n-
  ...etc\n\n```haskell\nλ> toNestedLists ticTacToe\n[ [X,O,X]\n, [O,X,O]\n, [X,O,X]]\n```\n\nYou
  can even create a grid from nested lists! `fromNestedLists` returns a grid\nif possible,
  or `Nothing` if the provided lists don't match the structure of\nthe grid you specify:\n\n```haskell\nλ>
  fromNestedLists [[1, 2], [3, 4]] :: Maybe (Grid '[2, 2] Int)\nJust (Grid [[1,2]\n
  \          ,[3,4]])\nλ> fromNestedLists [[1], [2]] :: Maybe (Grid '[2, 2] Int)\nNothing\n```\n\nGrids
  are Representable Functors, Applicatives, Foldable, and are Traversable!\n\nYou
  can do things like piecewise addition using their applicative instance:\n\n```haskell\nλ>
  let g = generate id :: Grid '[2, 3] Int\nλ> g\n(Grid [[0,1,2]\n      ,[3,4,5]])\nλ>
  liftA2 (+) g g\n(Grid [[0,2,4]\n      ,[6,8,10]])\nλ> liftA2 (*) g g\n(Grid [[0,1,4]\n
  \     ,[9,16,25]])\n```\n\n## Indexing\n\nYou can index into a grid using the `Coord`
  type family. The number of\ncoordinates you need depends on the shape of the grid.
  The Coord is stitched\ntogether using the `:#` constructor from 1 or more `Finite`
  values. Each Finite\nvalue is scoped to the size of its dimension, so you'll need
  to prove that each\nindex is within range (or just use `finite` to wrap an `Integer`
  and the\ncompiler will trust you). Here's the type of Coord for a few different
  Grids:\n\n```haskell\nCoord '[1] == Finite 1\nCoord '[1, 2] == Finite 1 :# Finite
  2\nCoord '[1, 2, 3] == Finite 1 :# Finite 2 :# Finite 3\n```\n\nYou can get a value
  at an index out using `index` from `Data.Functor.Rep`:\n\n```haskell\nλ> let g =
  generate id :: Grid '[2, 3] Int\nλ> g\n(Grid [[0,1,2]\n      ,[3,4,5]])\nλ> g `index`
  (1 :# 1)\n4\nλ> g `index` (1 :# 0)\n3\nλ> g `index` (0 :# 2)\n2\n```\n\nYou can
  also use the `cell` Lens from `Data.Grid.Lens` to access and mutate\nindices:\n\n```haskell\nλ>
  g ^. cell (0 :# 1)\n1\nλ> g & cell (0 :# 1) *~ 1000\n(Grid [[0,1000,2],[3,4,5]])\n```\n\n##
  Creation\n\nYou can generate a grid by providing a function over the integer position
  in the grid (`generate`) or by providing\na function over the coordinate position
  of the cell (`tabulate`).\n\nYou can also use the `fromList` and `fromNestedLists`
  functions which return a\n`Maybe (Grid dims a)` depending on whether the input list
  is well formed.\n\n- `fromList :: [a] -> Maybe (Grid dims a)`\n- `fromNestedLists
  :: NestedLists dims a -> Maybe (Grid dims a)`\n- `generate :: (Int -> a) -> Grid
  dims a`\n- `tabulate :: (Coord dims -> a) -> Grid dims a`\n- `pure :: a -> Grid
  dims a`\n\n## Updating\n\nUse either the `cell` lens, or fmap, applicative, traversable.\nFor
  batch updates using the underlying Vector implementation use `(//)`\n\n- `(//) ::
  Grid dims a -> [(Coord dims, a)] -> Grid dims a`\n"
license-name: BSD-3-Clause
