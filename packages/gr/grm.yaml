homepage: ''
changelog-type: ''
hash: 6eafc90eea6d4db542206aa8da7b0f2ccbba26bc3f7537588d7b7bc5c8595700
test-bench-deps: {}
maintainer: Brett Letner <brettletner@gmail.com>
synopsis: grm grammar converter
changelog: ''
basic-deps:
  wl-pprint: -any
  Cabal: -any
  base: <5
  syb: ! '>=0.3'
  filepath: -any
  process: -any
  parsec: -any
  cmdargs: -any
  directory: -any
all-versions:
- 0.1.0
- 0.1.1
author: Brett Letner <brettletner@gmail.com>
latest: 0.1.1
description-type: text
description: ! "Introducing the grm compiler construction tool.  Grm takes a grammar\nspecification
  and generates Haskell bindings.  Grm is essentially a\nsimplified bnfc which only
  generates Haskell (bnfc\nhttp://www.cse.chalmers.se/research/group/Language-technology/BNFC/).\n\nGiven
  a grammar the tool produces:\n  - an abstract syntax implementation\n  - a Happy
  parser generator file\n  - a pretty-printer\n\nGrm also has some library code for
  lexing and misc. language\ndevelopment tasks (e.g. unique identifiers).\n\nI use
  grm heavily in my pec language\ncompiler. (git@github.com:stevezhee/pec.git and
  on hackage).  You can\ncheck out pec for example grm usage.\n\nBuilding\n  - type
  'make'\n  - resolve all hackage dependencies\n  - type 'make' again\n\nYou can download
  and install grm via cabal or access the git\nrepository on github (git@github.com:stevezhee/grm.git).\n\nAny
  feedback on the design and/or implementation of grm would be\ngreatly appreciated
  :)\n\nThanks,\nBrett\nbrettletner at gmail dot com\n"
license-name: BSD-3-Clause
