homepage: https://github.com/thautwarm/Rsolver#readme
changelog-type: ''
hash: 229a850d42cd53cbb9a59dfd3c739569189e1c624c38640faf66e13593f8fd9e
test-bench-deps: {}
maintainer: twshere@outlook.com
synopsis: A general solver for equations
changelog: ''
basic-deps:
  base: ==4.*
  containers: -any
  RSolve: -any
all-versions:
- 0.1.0.0
author: thautwarm
latest: 0.1.0.0
description-type: markdown
description: ! "# RSolve\n\nA general solver for type checkers of programming languages
  and real world puzzles with complex constraints. \n\n\n## Preview\n\nHere are 2
  special cases presented in the following sections to show how powerful `RSolve`
  is.\n\n### The Most Graceful Hindley-Milner Unification\n\nCheck `RSolve.HM.Core`
  and `RSolve.HM.Example`.  \n\nUncomment the code in `Main.hs` could reproduce following
  program:\n\n```haskell\ncheck = do\n    let i = Prim Int\n    let f = Prim Float\n
  \   let arrow = Op Arrow i f\n    -- u means undecided\n    u1 <- new\n    u2 <-
  new\n    u3 <- new\n    u4 <- new\n    -- u1 -> u2 where u1, u2 is not generic \n
  \   let arrow_var = Op Arrow (Var u1) (Var u2)    \n    -- int -> int\n    let arrow_inst1
  = Op Arrow i i\n    -- float -> float\n    let arrow_inst2 = Op Arrow f f\n    --
  a generic function\n    let arrow_generic = Forall [u3] $ Op Arrow (Var u3) (Var
  u3)\n\n    let arrow_match = Op Arrow (Var u4) (Var u4)\n\n    _ <- solve $ Unify
  arrow arrow_var\n    _ <- solve $ Unify arrow_inst1 arrow_match\n    _ <- solve
  $ Unify arrow_generic arrow_inst1\n    _ <- solve $ Unify arrow_generic arrow_inst2\n
  \   _ <- solveNeg\n\n    mapM require [Var u1, Var u2, arrow_inst1, arrow_inst2,
  arrow_generic, arrow_match]\n  \n```\n\noutput:\n\n```\nu1 : Int\nu2 : Float\narrow_inst1
  : (Int -> Int)\narrow_inst2 : (Float -> Float)\narrow_generic : forall  a2.(a2 ->
  a2)\narrow_match : (Int -> Int)\n```\n\n### N-Option Puzzles\n\nThis implememtation
  is presented at `RSolve.Options`,  which provides the abstractions to solve all
  kinds of puzzles described with options.\n\nA Hello World program could be found
  at `src/Main.hs` which solves a complex problem described with following link:\n\nhttps://www.zhihu.com/question/68411978/answer/558913247.\n\n\nHowever,
  the much easier cases taking the same background as above problem (logic constraints
  described with four options `A, B, C, D`) could be enjoyale:\n\n```haskell\ntest2
  = do\n  a <- store $ sol [A, B, C]\n  b <- store $ sol [B, C, D]\n  c <- store $
  sol [C]\n  _ <- solve $ a `eq`  b\n  _ <- solve $ b `neq` c\n  _ <- solveNeg  --
  `Not` condition requires this\n  _ <- solvePred -- unnecessary\n  mapM require [a,
  b, c] \n  \nmain = do\n    format [\"a\", \"b\", \"c\"] . nub . L.map fst\n    $
  runBr test2 emptyLState\n```\n\noutput:\n\n```\nÎ» stack exec RSolve\n====\n\"a\"
  : Sol (fromList [B])\n\"b\" : Sol (fromList [B])\n\"c\" : Sol (fromList [C])\n```\n"
license-name: MIT
