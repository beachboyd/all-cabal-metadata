homepage: https://github.com/mstksg/type-combinators-singletons
changelog-type: markdown
hash: da8d13f04bf3ba2179afcc19900a839db883018430664b05d3d8ee31c80e29a5
test-bench-deps: {}
maintainer: justin@jle.im
synopsis: Interop between /type-combinators/ and /singletons/.
changelog: ! "Changelog\n=========\n\nVersion 0.2.0.0\n---------------\n\n*Jan 16,
  2018*\n\n<https://github.com/mstksg/type-combinators-singletons/releases/tag/v0.2.0.0>\n\n*
  \  Gathered together the many two-way conversion functions into a typeclass,\n    `TC`.\n\nVersion
  0.1.0.0\n---------------\n\n*Sep 1, 2017*\n\n<https://github.com/mstksg/type-combinators-singletons/releases/tag/v0.1.0.0>\n\n*
  \  Initial release.\n\n"
basic-deps:
  type-combinators: -any
  base: ! '>=4.9 && <5'
  singletons: -any
all-versions:
- '0.1.0.0'
- '0.2.0.0'
author: Justin Le
latest: '0.2.0.0'
description-type: markdown
description: ! 'type-combinator-singletons

  ==========================


  Conversions between data-types in *[type-combinators][]* and singletons from

  *[singletons][]* and orphan instances.


  [type-combinators]: https://hackage.haskell.org/package/type-combinators

  [singletons]: https://hackage.haskell.org/package/singletons


  There''s a lot of overlap in functionality between the two libraries.  I often

  use both of them together side-by-side to do different things, but there is

  some friction the process of converting between the identical data types that

  both libraries have, and between similar typeclasses.  This library attempts to

  ease that friction by providing conversion functions between identical data

  types and also many of the appropriate orphan typeclass instances.

'
license-name: BSD3
