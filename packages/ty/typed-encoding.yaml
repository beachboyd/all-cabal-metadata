homepage: https://github.com/rpeszek/typed-encoding#readme
changelog-type: markdown
hash: 3fecba1e2ff377720d631bd85084e11c5e3d608cf64cae3fb1f51973fce20c71
test-bench-deps:
  bytestring: ==0.10.*
  base: '>=4.10 && <5'
  symbols: '>=0.3 && <0.3.1'
  base64-bytestring: ==1.0.*
  hspec: -any
  text: ==1.2.*
  doctest: '>=0.16 && <0.17'
  quickcheck-instances: '>=0.3.20 && <0.4'
  typed-encoding: -any
  doctest-discover: '>=0.2 && <0.3'
  QuickCheck: '>=2.13.1 && <2.14'
maintainer: robpeszek@gmail.com
synopsis: Type safe string transformations
changelog: "# Changelog for typed-encoding\n\n## Unreleased changes\n\n## Anticipated
  future breaking changes\n\n- `Data.TypedEncoding.Internal.Class.IsStringR` expected
  to be be changed / replaced\n\n## 0.2.1.0\n\n- new functionality:\n  - bounded alpha-numeric
  restriction encodings (`r-ban`)\n  - boolean algebra of encodings \n- minor improvements\n
  \ - dropped IsString contraint from instances in `Data.TypedEncoding.Instances.Restriction.Common`\n
  \ - added forall annotation to ecodeAll and decodeAll\n\n## 0.2.0.0\n\n- breaking:\n
  \ - Data.TypedEncoding.Instances modules reorganized\n  - Data.TypedEncoding.Internal.Class
  modules reorganized\n  - Data.TypedEncoding.Internal.Utils module renamed\n  - Several
  TypeAnnotations friendly changes:\n      * Removed polymorphic kinds in most places\n
  \     * Changed typeclass name from `Subset` to `Superset`\n      * flipped type
  parameters on FlattenAs, HasA typeclass functions\n      * Removed Proxy parameters
  from several methods (few methods have a '_' backward compatible version which still
  has them)\n- new functionality:\n  - `ToEncString` - class allowing to convert types
  to `Enc` encoded strings\n  - `FromEncString` - class reverses ToEncString\n  -
  `CheckedEnc` untyped version of `Enc` containing valid encoding\n  - `SomeEnc` existentially
  quantified version of `Enc` \n  - `UncheckedEnc` for working with not validated
  encoding\n  - `RecreateExUnkStep` constructor added to RecreateEx\n  -  utility
  `IsStringR` - reverse to `IsString` class\n  -  utility `SymbolList` class\n- docs:
  \n  - ToEncString example\n\n\n## 0.1.0.0\n\n- initial release\n \n"
basic-deps:
  bytestring: '>=0.10 && <0.11'
  base: '>=4.10 && <5'
  symbols: '>=0.3 && <0.3.1'
  base64-bytestring: '>=1.0 && <1.1'
  text: '>=1.2 && <1.3'
all-versions:
- 0.1.0.0
- 0.2.0.0
- 0.2.1.0
author: Robert Peszek
latest: 0.2.1.0
description-type: markdown
description: "# typed-encoding\nType level annotations, string transformations, and
  other goodies that make programming strings safer.\n\n## Motivation\nI have recently
  spent a lot of time troubleshooting various `Base64`, `quoted-printable`, and `UTF-8`
  encoding issues.  \nI decided to write a library that will help avoiding issues
  like these.\n\nThis library allows to specify and work with types like\n\n```Haskell\n--
  some data encoded in base 64\nmydata :: Enc '[\"enc-B64\"] ByteString\n\n-- some
  text (utf8) data encoded in base 64 \nmyData :: Enc '[\"enc-B64\", \"r-UTF8\"] ByteString\n```\n\nIt
  allows to define precise string content annotations like:\n\n```Haskell\nipaddr
  :: Enc '[\"r-IpV4\"] Text\n```\n\nand provides ways for \n   - encoding\n   - decoding\n
  \  - recreation (encoding validation)\n   - type conversions\n   - converting types
  to encoded strings\n   - typesafe conversion of encoded strings to types\n\n...
  but this approach seems to be a bit more...\n\n```Haskell\n-- upper cased text encoded
  as base64\nexample :: Enc '[\"enc-B64\", \"do-UPPER\"] () T.Text\nexample = encodeAll
  . toEncoding () $ \"some text goes here\"\n```\n\nIt becomes a type directed, declarative
  approach to string transformations.\n\nTransformations can be\n   - used with parameters\n
  \  - applied or undone partially (if encoding is reversible)\n\nOne of more intersting
  uses of this library are encoding restrictions.   \n(Arbitrary) bounded alpha-numeric
  (`r-ban`) restrictions \nand a simple annotation boolean algebra are both provided.\n\n```Haskell\nphone
  :: Enc '[\"r-ban:999-999-9999\"] () T.Text\nphone = ...\n\n-- simple boolean algebra:\nphone'
  :: Enc '[\"boolOr:(r-ban:999-999-9999)(r-ban:(999) 999-9999)\"] () T.Text\nphone'
  = ...\n```\n\n\n\n## Examples \n\nPlease see `Examples.TypedEncoding` it the module
  list.\n\n## Dependencies on other encoding libs\n\nCurrently it uses\n   - `base64-bytestring`
  because it was my driving example\n   - I will try to separate other deps like `servant`,
  specific encoding libraries, etc into separate libs if there is interest. I consider
  orphan instances to be OK in this context. (GHC will classify them as such despite
  use of unique symbols.)\n\n## Plans, some TODOs\n   - lensifying conversions \n
  \  - better implementation type safety\n\n## Tested with\n   - stack (1.9.3) lts-14.27
  (ghc-8.6.5)\n   - needs ghc >= 8.2.2, base >=4.10 for GHC.TypeLits support\n\n##
  Known issues\n   - running test suite: cabal has problems with doctest, use stack
  \ \n   https://github.com/haskell/cabal/issues/6087   \n"
license-name: BSD-3-Clause
