homepage: ''
changelog-type: ''
hash: ed33aec0a6f80d45e9cc91e48bfa06cdb1b54b98b460338f3a622da76ecd7451
test-bench-deps:
  base: ! '>=4.12 && <5'
  kind-generics: ! '>=0.2.1'
  kind-generics-th: -any
maintainer: trupill@gmail.com
synopsis: Template Haskell support for generating `GenericK` instances
changelog: ''
basic-deps:
  base: ! '>=4.12 && <5'
  th-abstraction: ! '>=0.2.8 && <0.3'
  kind-generics: ! '>=0.3'
  template-haskell: ! '>=2.14 && <2.15'
all-versions:
- '0.1.0.0'
author: Alejandro Serrano
latest: '0.1.0.0'
description-type: markdown
description: ! "# `kind-generics-th`: Template Haskell support for generating `GenericK`
  instances\n\nThis package provides Template Haskell functionality to automatically
  derive\n`GenericK` instances. Currently, this only supports the version of `GenericK`\nas
  found in the `kind-generics` library. (The `GenericK` class found in\n`kind-generics-sop`
  is not supported at the moment.)\n\n## How to use this library\n\nTo derive instances
  of `GenericK` for a data type, simply pass the Template\nHaskellâ€“quoted `Name` of
  the type to the `deriveGenericK` function, as in the\nfollowing example:\n\n```haskell\n$(deriveGenericK
  ''Either)\n```\n\nIf you wish to pass a data family instance, one can pass the name
  of a\nconstructor belonging to the particular family instance, such as in the\nfollowing
  example:\n\n```haskell\ndata family Foo a b\ndata instance Foo Int b = MkFooInt
  b\n\n$(deriveGenericK 'MkFooInt)\n```\n\nYou will likely need to enable most of
  these language extensions in order for\nGHC to accept the generated code:\n\n* `DataKinds`\n*
  `EmptyCase` (if using an empty data type)\n* `FlexibleInstances`\n* `MultiParamTypeClasses`\n*
  `PolyKinds` (if using a poly-kinded data type)\n* `TemplateHaskell`\n* `TypeFamilies`\n\n##
  How many `GenericK` instances are generated\n\n`deriveGenericK` typically generates
  multiple `GenericK` instances per data\ntype, as there is one `GenericK` instance
  per partial application of a data\ntype constructor. For instance, `$(deriveGenericK
  ''Either)` will generate\nthree `GenericK` instances:\n\n```haskell\ninstance GenericK
  (Either a b) LoT0 where ...\ninstance GenericK (Either a)   (b :&&: LoT0) where
  ...\ninstance GenericK Either       (a :&&: b :&&: LoT0) where ...\n```\n\nNot every
  data type can be partially applied all the way in this fashion,\nhowever. Some notable
  counterexamples are:\n\n1. Data family instances. In the following example:\n\n
  \  ```haskell\n   data family Bar a b\n   data instance Bar a a = MkBar a\n   ```\n\n
  \  One cannot partially apply to `Bar a a` to simply `Bar a`, so\n   `$(deriveGenericK
  'MkBar)` will only generate a single instance for\n   `GenericK (Bar a a) LoT0`.\n2.
  Dependent kinds. `kind-generics` is not currently capable of representing\n   data
  types such as the following in their full generality:\n\n   ```haskell\n   data
  Baz k (a :: k)\n   ```\n\n   Because the `k` type variable is used in the kind of
  `a` (i.e., it is used\n   in a visible, dependent fashion). As a consequence,\n
  \  `$(deriveGenericK ''Baz)` will only generate the following instances:\n\n   *
  `instance GenericK (Baz k a) LoT0`\n   * `instance GenericK (Baz k)   (a :&&: LoT0)`\n3.
  Data types with type family applications. In the following example:\n\n   ```haskell\n
  \  type family Fam a\n   newtype WrappedFam a = WrapFam (Fam a)\n   ```\n\n   It
  is impossible to write a `GenericK` instance for a partial application\n   of `WrappedFam`,
  since the representation type would necessarily need to\n   partially apply `Fam`,
  which GHC does not permit. Therefore,\n   `$(deriveGenericK ''WrappedFam)` will
  only generate a single instance for\n   `GenericK (WrappedFam a) LoT0`.\n\n   There
  are some uses of type families that are not supported altogether.\n   For instance,
  if a type family is applied to an _existentially_ quantified\n   type variable,
  as in the following example:\n\n   ```haskell\n   data ExFam where\n     MkExFam
  :: forall a. Fam a -> ExFam\n   ```\n\n   Representing `ExFam` would fundamentally
  require a partial application of\n   `Fam`, as `type RepK ExFam = Exists * (Field
  (Fam :$: Var0))`. As a result,\n   it is impossible to give `ExFam` a `GenericK`
  instance.\n\n   Note that not all type families are problematic. For instance:\n\n
  \  ```haskell\n   type family Fam2 :: * -> *\n   newtype WrappedFam2 a = WrapFam2
  (Fam2 a)\n   ```\n\n   In this example, `Fam2` is perfectly fine to partially apply,
  so\n   `$(deriveGenericK ''WrappedFam2)` will generate two instances (as opposed\n
  \  to just one, as was the case for `WrappedFam`).\n\n## Limitations\n\n`kind-generics`
  is capable of representing a wide variety of data types. The\nTemplate Haskell machinery
  in this library makes a best-effort attempt to\nautomate the creation of most of
  these instances, but there are a handful of\ncorner cases that it does not handle
  well. This section documents all of the\nknown limitations of `deriveGenericK`:\n\n1.
  Data constructors with rank-_n_ field types (e.g., `(forall a. a -> a)`)\n   are
  currently not supported.\n2. Data constructors with unlifted field types (e.g.,
  `Int#` or `(# Bool #)`)\n   are unlikely to work.\n3. GADTs that make use of certain
  forms of kind equalities are currently not\n   supported. For example:\n\n   ```haskell\n
  \  data Quux (a :: k) where\n     MkQuux :: forall (a :: *). Maybe a -> Quux a\n
  \  ```\n\n   If one were to rewrite `Quux` to make the existential quantification\n
  \  explicit, it would look like this:\n\n   ```haskell\n   data Quux (a :: k) =\n
  \    forall (a' :: *). (k ~ Type, a' ~~ a) => MkQuux (Maybe a')\n   ```\n\n   Therefore,
  we ought to get a `GenericK` instance like this:\n\n   ```haskell\n   instance GenericK
  (Quux :: k -> *) (a :&&: LoT0) where\n     type RepK (Quux :: k -> *) =\n       Exists
  *\n         ((Kon (k ~ Type) :&: (Var0 :~~: Var1)) :=>: Field (Maybe :$: Var0))\n
  \    ...\n   ```\n\n   Devising an algorithm that converts the original GADT definition
  of `Quux`\n   into the explicitly existential form is not straightforward, however.
  In\n   particular, `deriveGenericK` only detects the `k ~ *` part correctly at the\n
  \  moment, so it will generate an ill kinded instance for `Quux`.\n"
license-name: BSD3
