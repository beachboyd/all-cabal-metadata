homepage: https://github.com/morphismtech/squeal
changelog-type: ''
hash: 6e092a44936ff2e89e72b96903082e41d24df9961cff9d4b96dfaeecdeacd1b8
test-bench-deps:
  base: ! '>=4.10.0.0'
  doctest: ! '>=0.11.4'
maintainer: eitan.chatav@gmail.com
synopsis: Squeal PostgreSQL Library
changelog: ''
basic-deps:
  bytestring: ! '>=0.10.8.2'
  base: ! '>=4.10.1.0 && <5'
  time: ! '>=1.8.0.2'
  postgresql-libpq: ! '>=0.9.4.1'
  text: ! '>=1.2.3.0'
  monad-control: ! '>=1.0.2.3'
  resource-pool: ! '>=0.2.3.2'
  lifted-base: ! '>=0.2.3.12'
  postgresql-binary: ! '>=0.12.1'
  squeal-postgresql: -any
  network-ip: ! '>=0.3.0.2'
  mtl: ! '>=2.2.2'
  mmorph: ! '>=1.1.1'
  transformers-base: ! '>=0.4.4'
  transformers: ! '>=0.5.2.0'
  deepseq: ! '>=1.4.3.0'
  uuid-types: ! '>=1.0.3'
  scientific: ! '>=0.3.5.3'
  generics-sop: ! '>=0.3.2.0'
  aeson: ! '>=1.2.4.0'
  vector: ! '>=0.12.0.1'
all-versions:
- '0.1.0.0'
- '0.1.1.0'
- '0.1.1.1'
- '0.1.1.2'
- '0.1.1.3'
- '0.1.1.4'
- '0.2'
author: Eitan Chatav
latest: '0.2'
description-type: markdown
description: ! "# squeal\n\n![squeal-icon](http://www.emoticonswallpapers.com/emotion/cute-big-pig/cute-pig-smiley-046.gif)\n\n[![CircleCI](https://circleci.com/gh/echatav/squeal.svg?style=svg&circle-token=a699a654ef50db2c3744fb039cf2087c484d1226)](https://circleci.com/gh/morphismtech/squeal)\n\n[Github](https://github.com/morphismtech/squeal)\n\n[Hackage](https://hackage.haskell.org/package/squeal-postgresql)\n\n[Stackage](https://www.stackage.org/package/squeal-postgresql)\n\n##
  installation\n\n`stack install squeal-postgresql`\n\n## usage\n\nSqueal is a deep
  embedding of PostgreSQL in Haskell. Let's see an example!\nFirst, we need some language
  extensions because Squeal uses modern GHC\nfeatures.\n```haskell\n>>> :set -XDataKinds
  -XDeriveGeneric -XOverloadedLabels\n>>> :set -XOverloadedStrings -XTypeApplications
  -XTypeOperators\n```\n\nWe'll need some imports.\n\n```haskell\n>>> import Control.Monad
  (void)\n>>> import Control.Monad.Base (liftBase)\n>>> import Data.Int (Int32)\n>>>
  import Data.Text (Text)\n>>> import Squeal.PostgreSQL\n```\n\nWe'll use generics
  to easily convert between Haskell and PostgreSQL values.\n\n```haskell\n>>> import
  qualified Generics.SOP as SOP\n>>> import qualified GHC.Generics as GHC\n```\n\nThe
  first step is to define the schema of our database. This is where\nwe use `DataKinds`
  and `TypeOperators`. The schema consists of a type-level\nlist of tables, a `:::`
  pairing of a type level string or\n`Symbol` and a list a columns, itself a `:::`
  pairing of a\n`Symbol` and a `ColumnType`. The `ColumnType` describes the\nPostgreSQL
  type of the column as well as whether or not it may contain\n`NULL` and whether
  or not inserts and updates can use a `DEFAULT`. For our\nschema, we'll define two
  tables, a users table and an emails table.\n\n```haskell\n>>> :{\ntype Schema =\n
  \ '[ \"users\" :::\n       '[ \"pk_users\" ::: 'PrimaryKey '[\"id\"] ] :=>\n       '[
  \"id\" ::: 'Def :=> 'NotNull 'PGint4\n        , \"name\" ::: 'NoDef :=> 'NotNull
  'PGtext\n        ]\n   , \"emails\" :::\n       '[  \"pk_emails\" ::: 'PrimaryKey
  '[\"id\"]\n        , \"fk_user_id\" ::: 'ForeignKey '[\"user_id\"] \"users\" '[\"id\"]\n
  \       ] :=>\n       '[ \"id\" ::: 'Def :=> 'NotNull 'PGint4\n        , \"user_id\"
  ::: 'NoDef :=> 'NotNull 'PGint4\n        , \"email\" ::: 'NoDef :=> 'Null 'PGtext\n
  \       ]\n   ]\n:}\n```\n\nNext, we'll write `Definition`s to set up and tear down
  the schema. In\nSqueal, a `Definition` is a `createTable`, `alterTable` or `dropTable`\ncommand
  and has two type parameters, corresponding to the schema\nbefore being run and the
  schema after. We can compose definitions using\n`>>>`. Here and in the rest of our
  commands we make use of overloaded\nlabels to refer to named tables and columns
  in our schema.\n\n```haskell\n>>> :{\nlet\n  setup :: Definition '[] Schema\n  setup
  = \n   createTable #users\n     ( serial `As` #id :*\n       (text & notNull) `As`
  #name :* Nil )\n     ( primaryKey (Column #id :* Nil) `As` #pk_users :* Nil ) >>>\n
  \  createTable #emails\n     ( serial `As` #id :*\n       (int & notNull) `As` #user_id
  :*\n       text `As` #email :* Nil )\n     ( primaryKey (Column #id :* Nil) `As`
  #pk_emails :*\n       foreignKey (Column #user_id :* Nil) #users (Column #id :*
  Nil)\n         OnDeleteCascade OnUpdateCascade `As` #fk_user_id :* Nil )\n:}\n```\n\nWe
  can easily see the generated SQL is unsuprising looking.\n\n```haskell\n>>> renderDefinition
  setup\n\"CREATE TABLE users (id serial, name text NOT NULL, CONSTRAINT pk_users
  PRIMARY KEY (id)); CREATE TABLE emails (id serial, user_id int NOT NULL, email text,
  CONSTRAINT pk_emails PRIMARY KEY (id), CONSTRAINT fk_user_id FOREIGN KEY (user_id)
  REFERENCES rs (id) ON DELETE CASCADE ON UPDATE CASCADE);\"\n```\n\nNotice that `setup`
  starts with an empty schema `'[]` and produces `Schema`.\nIn our `createTable` commands
  we included `TableConstraint`s to define\nprimary and foreign keys, making them
  somewhat complex. Our tear down\n`Definition` is simpler.\n\n```haskell\n>>> :{\nlet\n
  \ teardown :: Definition Schema '[]\n  teardown = dropTable #emails >>> dropTable
  #users\n:}\n>>> renderDefinition teardown\n\"DROP TABLE emails; DROP TABLE users;\"\n```\n\nNext,
  we'll write `Manipulation`s to insert data into our two tables.\nA `Manipulation`
  is a `insertInto`, `update` or `deleteFrom` command and\nhas three type parameters,
  the schema it refers to, a list of parameters\nit can take as input, and a list
  of columns it produces as output. When\nwe insert into the users table, we will
  need a parameter for the `name`\nfield but not for the `id` field. Since it's optional,
  we can use a default\nvalue. However, since the emails table refers to the users
  table, we will\nneed to retrieve the user id that the insert generates and insert
  it into\nthe emails table. Take a careful look at the type and definition of both\nof
  our inserts.\n\n```haskell\n>>> :{\nlet\n  insertUser :: Manipulation Schema '[
  'NotNull 'PGtext ]\n    '[ \"fromOnly\" ::: 'NotNull 'PGint4 ]\n  insertUser = insertRow
  #users\n    (Default `As` #id :* Set (param `1) `As` #name :* Nil)\n    OnConflictDoNothing
  (Returning (#id `As` #fromOnly :* Nil))\n:}\n>>> :{\nlet\n  insertEmail :: Manipulation
  Schema '[ 'NotNull 'PGint4, 'Null 'PGtext] '[]\n  insertEmail = insertRow #emails\n
  \   ( Default `As` #id :*\n      Set (param `1) `As` #user_id :*\n      Set (param
  `2) `As` #email :* Nil )\n    OnConflictDoNothing (Returning Nil)\n:}\n>>> renderManipulation
  insertUser\n\"INSERT INTO users (id, name) VALUES (DEFAULT, ($1 :: text)) ON CONFLICT
  DO NOTHING URNING id AS fromOnly;\"\n>>> renderManipulation insertEmail\n\"INSERT
  INTO emails (id, user_id, email) VALUES (DEFAULT, ($1 :: int4), ($2 :: text)N CONFLICT
  DO NOTHING;\"\n```\n\nNext we write a `Query` to retrieve users from the database.
  We're not\ninterested in the ids here, just the usernames and email addresses. We\nneed
  to use an inner join to get the right result. A `Query` is like a\n`Manipulation`
  with the same kind of type parameters.\n\n```haskell\n>>> :{\nlet\n  getUsers ::
  Query Schema '[]\n    '[ \"userName\" ::: 'NotNull 'PGtext\n     , \"userEmail\"
  ::: 'Null 'PGtext ]\n  getUsers = select\n    (#u ! #name `As` #userName :* #e !
  #email `As` #userEmail :* Nil)\n    ( from (table (#users `As` #u)\n      & innerJoin
  (table (#emails `As` #e))\n        (#u ! #id .== #e ! #user_id)) )\n:}\n>>> renderQuery
  getUsers\n\"SELECT u.name AS userName, e.email AS userEmail FROM users AS u INNER
  JOIN emails e ON (u.id = e.user_id)\"\n```\nNow that we've defined the SQL side
  of things, we'll need a Haskell type\nfor users. We give the type `Generics.SOP.Generic`
  and\n`Generics.SOP.HasDatatypeInfo` instances so that we can decode the rows\nwe
  receive when we run `getUsers`. Notice that the record fields of the\n`User` type
  match the column names of `getUsers`.\n\n```haskell\n>>> data User = User { userName
  :: Text, userEmail :: Maybe Text } deriving (Show, .Generic)\n>>> instance SOP.Generic
  User\n>>> instance SOP.HasDatatypeInfo User\n```\n\nLet's also create some users
  to add to the database.\n\n```haskell\n>>> :{\nlet\n  users :: [User]\n  users =
  \n    [ User \"Alice\" (Just \"alice`gmail.com\")\n    , User \"Bob\" Nothing\n
  \   , User \"Carole\" (Just \"carole`hotmail.com\")\n    ]\n:}\n```\n\nNow we can
  put together all the pieces into a program. The program\nconnects to the database,
  sets up the schema, inserts the user data\n(using prepared statements as an optimization),
  queries the user\ndata and prints it out and finally closes the connection. We can
  thread\nthe changing schema information through by using the indexed `PQ` monad\ntransformer
  and when the schema doesn't change we can use `Monad` and\n`MonadPQ` functionality.\n\n```haskell\n>>>
  :{\nlet\n  session :: PQ Schema Schema IO ()\n  session = do\n    idResults <- traversePrepared
  insertUser (Only . userName <$> users)\n    ids <- traverse (fmap fromOnly . getRow
  (RowNumber 0)) idResults\n    traversePrepared_ insertEmail (zip (ids :: [Int32])
  (userEmail <$> users))\n    usersResult <- runQuery getUsers\n    usersRows <- getRows
  usersResult\n    liftBase $ print (usersRows :: [User])\n:}\n>>> :{\nvoid . withConnection
  \"host=localhost port=5432 dbname=exampledb\" $\n  define setup\n  & pqThen session\n
  \ & thenDefine teardown\n:}\n[User {userName = \"Alice\", userEmail = Just \"alice`gmail.com\"},User
  {userName = \"Bob\", userEmail = Nothing},User {userName = \"Carole\", userEmail
  = Just role`hotmail.com\"}]\n```\n"
license-name: BSD3
