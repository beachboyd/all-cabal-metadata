homepage: https://github.com/ag-eitilt/data-standards
changelog-type: markdown
hash: 0774ed1aa58ed4af471914bf56ae143a4d2badd2caf05114fc244e3dbfa7903c
test-bench-deps: {}
maintainer: ag.eitilt@gmail.com
synopsis: A collection of standards representable by simple data types.
changelog: ! "# Revision history for data-standards\n\n## 0.1.0.0  -- 2018-07-06\n\n*
  ISO 3166-1, in all three variants (alpha-2, alpha-3, and numeric)\n  * Methods of
  converting between all three\n  * Historic or otherwise discouraged codes marked
  as such\n"
basic-deps:
  base: ! '>=4.9 && <4.12'
  unordered-containers: <0.3
  hashable: ! '>=1.2 && <1.3'
all-versions:
- '0.1.0.0'
author: Samuel May
latest: '0.1.0.0'
description-type: markdown
description: ! "A number of the ISO standards are particularly attractive to being
  implemented\nas static data libraries: they describe short strings that are prone
  to error\nif left as 'Text', but are large enough to strongly discourage rewriting
  them\nfor each project.  It is no surprise, therefore, that this package is the\nfourth
  on Hackage to implement ISO 3166-1:\n\n* \"Data.ISO3166\\_CountryCodes\" from\n
  \ [iso3166-country-codes](https://hackage.haskell.org/package/iso3166-country-codes)\n*
  \"Data.CountryCodes\" from\n  [country-codes](https://hackage.haskell.org/package/country-codes)\n*
  \"Country\" from [country](https://hackage.haskell.org/package/country)\n\nHowever,
  none of those options truly seemed to provide an ideal, /complete/\nexperience.
  \ Only one (`country`) provides all three code encodings, but it\ndoesn't expose
  constructors for pattern matching.  None of them implement the\nother two parts
  of ISO 3166 (region codes, and historic countries), and the\nonly package that makes
  an effort to do so (\"Data.StateCodes\" from\n[state-codes](https://hackage.haskell.org/package/state-codes))
  doesn't cover\nanything beyond the US.  Someone who only needs the alpha-2 codes
  (\"CA\") may\nindeed find one of the existing packages sufficient, but for anyone
  who does\nneed the full power of ISO 3166-2, none of them would serve.\n\nThe lack
  of people who would actually find this useful is another matter.\n(Eight packages
  using the simple alpha-2 codes from one or another of the\nabove, as of writing.)\n\nThis
  package is an attempt to package that standard -- and, eventually, others\nlike
  it -- in a consistent API based in standard Haskell; `fromEnum` rather\nthan `encodeNumeric`,
  for example.\n\nThe following standards are implemented:\n\n* ISO 3166-1 (`Data.Standards.ISO.Country.Primary`)\n\n
  \   * alpha-2 (`Data.Standards.ISO.Country.Primary.Alpha2`)\n    * alpha-3 (`Data.Standards.ISO.Country.Primary.Alpha3`)\n
  \   * numeric (`Data.Standards.ISO.Country.Primary.Numeric`)\n"
license-name: MPL-2.0
