homepage: https://github.com/tek/cornea#readme
changelog-type: ''
hash: 519e584c62f750345e9cd12dee7524eef5242463233286cef6c5d0db6a516235
test-bench-deps:
  HTF: ! '>=0.13.2.5 && <0.14'
  base: ! '>=4.7 && <5'
  th-abstraction: ! '>=0.2.10.0 && <0.3'
  cornea: -any
  lens: ! '>=4.16.1 && <4.17'
  mtl: ! '>=2.2.2 && <2.3'
  transformers: ! '>=0.5.5.0 && <0.6'
  template-haskell: ! '>=2.13.0.0 && <2.14'
maintainer: tek@tryp.io
synopsis: classy optical monadic state
changelog: ''
basic-deps:
  base: ! '>=4.7 && <5'
  th-abstraction: ! '>=0.2.10.0 && <0.3'
  lens: ! '>=4.16.1 && <4.17'
  mtl: ! '>=2.2.2 && <2.3'
  transformers: ! '>=0.5.5.0 && <0.6'
  template-haskell: ! '>=2.13.0.0 && <2.14'
all-versions:
- 0.2.0.0
- 0.2.1.0
- 0.2.2.0
author: Torsten Schmits
latest: 0.2.2.0
description-type: markdown
description: |
  # Intro

  Classes for accessing and mutating nested data types with corresponding adapter classes for `MonadState` and `MonadError`.
  Inspired by the [next level mtl with classy optics] talk.

  [Hackage]

  # Internals

  Lenses and Prisms from [lens] are autogenerated with [TH] by splicing with `deepPrisms` and `deepLenses`.
  The generator recurses into single-field constructors and record fields if there are instances of `DeepPrisms` or `DeepLenses` for their parameter types.

  # Example

  For `MonadError`:

  ```haskell
  {-# LANGUAGE TemplateHaskell #-}

  import Control.Monad.DeepError (MonadDeepError(throwHoist))
  import Control.Monad.Trans.Except (runExceptT)
  import Data.DeepPrisms (deepPrisms)

  newtype Error = Error String

  newtype Inner = Inner Error
  deepPrisms ''Inner

  data Mid = Mid Inner
  deepPrisms ''Mid

  newtype Outer = Outer Mid
  deepPrisms ''Outer

  throwDeep :: MonadDeepError e Inner m => m ()
  throwDeep = throwHoist (Inner (Error "boom"))

  main :: IO (Either Outer ())
  main = runExceptT throwDeep
  ```

  In `main`, `MonadError Outer IO` and `DeepPrisms Outer Inner` are summoned.

  Analogously for `MonadState`:

  ```haskell
  {-# LANGUAGE TemplateHaskell #-}

  import Control.Monad.DeepState (MonadDeepState(get, gets, put))
  import Control.Monad.Trans.State (execStateT)
  import Data.DeepLenses (deepLenses)

  newtype S = S Int

  newtype Inner = Inner { _innerS :: S }
  deepLenses ''Inner

  data Mid = Mid { _midInner :: Inner }
  deepLenses ''Mid

  newtype Outer = Outer { _outerMid :: Mid }
  deepLenses ''Outer

  stateDeep :: MonadDeepState s Inner m => m ()
  stateDeep = do
    (Inner (S a)) <- get
    b <- gets $ \(Inner (S b)) -> b
    put (Inner (S (a + b + 3)))

  main :: IO Outer
  main = do
    execStateT stateDeep (Outer (Mid (Inner (S 5))))
  ```

  [lens]: https://hackage.haskell.org/package/lens
  [TH]: https://hackage.haskell.org/package/template-haskell
  [next level mtl with classy optics]: https://github.com/gwils/next-level-mtl-with-classy-optics
  [Hackage]: https://hackage.haskell.org/package/cornea
license-name: LicenseRef-OtherLicense
