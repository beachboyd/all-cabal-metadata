homepage: https://github.com/tek/cornea#readme
changelog-type: ''
hash: 3824ce9d53d96875c68c2423437ebf36cf80bc6c0d4addbf3c7051645c439209
test-bench-deps:
  HTF: ! '>=0.13.2.5 && <0.14'
  base: ! '>=4.7 && <5'
  th-abstraction: ! '>=0.2.10.0 && <0.3'
  cornea: -any
  lens: ! '>=4.16.1 && <4.17'
  mtl: ! '>=2.2.2 && <2.3'
  transformers: ! '>=0.5.5.0 && <0.6'
  template-haskell: ! '>=2.13.0.0 && <2.14'
maintainer: tek@tryp.io
synopsis: classy optical monadic state
changelog: ''
basic-deps:
  base: ! '>=4.7 && <5'
  th-abstraction: ! '>=0.2.10.0 && <0.3'
  lens: ! '>=4.16.1 && <4.17'
  mtl: ! '>=2.2.2 && <2.3'
  transformers: ! '>=0.5.5.0 && <0.6'
  template-haskell: ! '>=2.13.0.0 && <2.14'
all-versions:
- 0.2.0.0
author: Torsten Schmits
latest: 0.2.0.0
description-type: markdown
description: |
  # Intro

  Classes for accessing and mutating nested data types with corresponding adapter classes for `MonadState` and `MonadError`.

  # Example

  For `MonadError`:

  ```haskell
  {-# LANGUAGE TemplateHaskell #-}

  import Control.Monad.DeepError (MonadDeepError(throwHoist))
  import Control.Monad.Trans.Except (runExceptT)
  import Data.DeepPrisms (deepPrisms)

  newtype Error = Error String

  newtype Inner = Inner Error
  deepPrisms ''Inner

  data Mid = Mid Inner
  deepPrisms ''Mid

  newtype Outer = Outer Mid
  deepPrisms ''Outer

  throwDeep :: MonadDeepError e Inner m => m ()
  throwDeep = throwHoist (Inner (Error "boom"))

  main :: IO (Either Outer ())
  main = runExceptT throwDeep
  ```

  In `main`, `MonadError Outer IO` and `DeepPrisms Outer Inner` is summoned.

  Analogously for `MonadState`:

  ```haskell
  {-# LANGUAGE TemplateHaskell #-}

  import Control.Monad.DeepState (MonadDeepState(get, gets, put))
  import Control.Monad.Trans.State (execStateT)
  import Data.DeepLenses (deepLenses)

  newtype S = S Int

  newtype Inner = Inner { innerS :: S }
  deepLenses ''Inner

  data Mid = Mid { _midInner :: Inner }
  deepLenses ''Mid

  newtype Outer = Outer { _outerMid :: Mid }
  deepLenses ''Outer

  stateDeep :: MonadDeepState s Inner m => m ()
  stateDeep = do
    (Inner (S a)) <- get
    b <- gets $ \(Inner (S b)) -> b
    put (Inner (S (a + b + 3)))

  main :: IO Outer
  main = do
    execStateT stateDeep (Outer (Mid (Inner (S 5))))
  ```
license-name: LicenseRef-OtherLicense
