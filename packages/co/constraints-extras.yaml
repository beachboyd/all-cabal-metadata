homepage: ''
changelog-type: markdown
hash: 62cfa1f9d02c6db2c506690d8da068518f494818d9861d325071e8426438b0e5
test-bench-deps: {}
maintainer: maintainer@obsidian.systems
synopsis: Utility package for constraints
changelog: |
  # Revision history for constraints-extras

  ## 0.2.3.5 - 2019-05-04

  * Bumped version bounds on base and template-haskell to admit the versions from GHC 8.6.x

  ## 0.2.3.4 - 2019-03-22

  * Added ChangeLog.md
  * Replaced some occurrences of <> in Data.Constraint.Extras.TH with ++ so that the module will hopefully build with GHC 8.0.2 and 8.2.2 without needing to import Data.Semigroup.
basic-deps:
  constraints-extras: -any
  base: ! '>=4.9 && <4.13'
  constraints: ! '>=0.9 && <0.11'
  aeson: -any
  template-haskell: ! '>=2.11 && <2.15'
all-versions:
- 0.1.0.0
- 0.1.0.1
- 0.2.0.0
- 0.2.1.0
- 0.2.2.0
- 0.2.2.1
- 0.2.3.0
- 0.2.3.1
- 0.2.3.2
- 0.2.3.3
- 0.2.3.4
- 0.2.3.5
author: Cale Gibbard, Ali Abrar
latest: 0.2.3.5
description-type: text
description: |
  # constraints-extras

  ## Example usage:

  NB: This example can be built with `-pgmL markdown-unlit`.

  ```haskell
  {-# LANGUAGE GADTs #-}
  {-# LANGUAGE KindSignatures #-}
  {-# LANGUAGE PolyKinds #-}
  {-# LANGUAGE ScopedTypeVariables #-}
  {-# LANGUAGE TemplateHaskell #-}
  {-# LANGUAGE TypeApplications  #-}
  {-# LANGUAGE TypeFamilies #-}
  {-# LANGUAGE UndecidableInstances #-}
  {-# LANGUAGE ExistentialQuantification #-}

  import Data.Aeson
  import Data.Constraint.Forall
  import Data.Constraint.Extras
  import Data.Constraint.Extras.TH

  data A :: * -> * where
    A_a :: A Int
    A_b :: Int -> A ()

  data B :: * -> * where
    B_a :: A a -> A a -> B a
    B_x :: Int -> B Int

  data V :: (* -> *) -> * where
    V_a :: A Int -> V A

  deriveArgDict ''A
  deriveArgDict ''B
  deriveArgDict ''V

  data DSum k f = forall a. DSum (k a) (f a)

  -- Derive a ToJSON instance for our 'DSum'
  instance forall k f.
    ( Has' ToJSON k f -- Given a value of type (k a), we can obtain an instance (ToJSON (f a))
    , ForallF ToJSON k -- For any (a), we have an instance (ToJSON (k a))
    ) => ToJSON (DSum k f) where
    toJSON (DSum (k :: k a) f) = toJSON
      ( whichever @ToJSON @k @a $ toJSON k -- Use the (ForallF ToJSON k) constraint to obtain the (ToJSON (k a)) instance
      , has' @ToJSON @f k $ toJSON f -- Use the (Has' ToJSON k f) constraint to obtain the (ToJSON (f a)) instance
      )

  data Some k = forall a. Some (k a)

  -- Derive a FromJSON instance for our 'DSum'
  instance (FromJSON (Some f), Has' FromJSON f g) => FromJSON (DSum f g) where
    parseJSON x = do
      (jf, jg) <- parseJSON x
      Some (f :: f a) <- parseJSON jf
      g <- has' @FromJSON @g f (parseJSON jg)
      return $ DSum f g

  main :: IO ()
  main = return ()
  ```
license-name: BSD-3-Clause
