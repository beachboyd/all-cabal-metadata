homepage: https://github.com/SamuelSchlesinger/commander-cli
changelog-type: markdown
hash: ca190ea5ba1311585cee18c75049aff4025edc694932a183f1155d22fd60a96a
test-bench-deps:
  base: '>=4.12 && <5'
  unordered-containers: '>=0.2 && <1'
  text: '>=1.2 && <2'
  commander-cli: -any
maintainer: sgschlesinger@gmail.com
synopsis: A command line argument/option parser library built around a monadic metaphor
changelog: |
  # Revision history for commander-cli

  ## 0.1.0.0 -- 2020-01-12

  * Ported this to a cabal project after having built it in a larger repository
  accompanied by scripts written with it. (Samuel Schlesinger)
basic-deps:
  bytestring: '>=0.8 && <1'
  base: '>=4.12 && <5'
  unordered-containers: '>=0.2 && <1'
  text: '>=1.2 && <2'
  commander-cli: -any
  process: '>=1.6 && <2'
  mtl: '>=2.2 && <3'
  directory: '>=1.3 && <2'
all-versions:
- 0.1.0.0
- 0.2.0.0
- 0.2.0.1
- 0.3.0.0
- 0.4.0.0
- 0.4.0.1
- 0.4.1.1
- 0.4.1.2
- 0.5.0.0
author: Samuel Schlesinger
latest: 0.5.0.0
description-type: markdown
description: "# Commander CLI\n\n[![Hackage](https://img.shields.io/hackage/v/commander-cli.svg)](https://hackage.haskell.org/package/commander-cli)\n[![Build
  Status](https://travis-ci.org/SamuelSchlesinger/commander-cli.svg?branch=master)](https://travis-ci.org/SamuelSchlesinger/commander-cli)\n\nThis
  library is meant to allow Haskell programs to quickly and easily construct\ncommand
  line interfaces which are easy to use, especially as a Haskell user. To\nbegin,
  I suggest viewing/playing with the task-manager application which\ncomes with this
  repository. Its usage info is generated as:\n\n```bash\nusage:\ntask-manager help
  \ntask-manager -d <task-directory :: [Char]> edit <task-name :: [Char]> \ntask-manager
  -d <task-directory :: [Char]> open <task-name :: [Char]> \ntask-manager -d <task-directory
  :: [Char]> close <task-name :: [Char]> \ntask-manager -d <task-directory :: [Char]>
  tasks \ntask-manager -d <task-directory :: [Char]> priorities \ntask-manager -d
  <task-directory :: [Char]> \n```\n\n\nThe library is based around the following
  classes:\n\n```haskell\nclass Unrender r where\n  unrender :: Text -> Maybe r\n```\n\nThis
  class is what you will use to define the parsing of a type from text and\ncan use
  any parsing library or whatever you want. Next, we have the class\n\n```haskell\nclass
  HasProgram p where\n  data ProgramT p m a\n  run :: ProgramT p IO a -> CommanderT
  State IO a\n  hoist :: (forall x. m x -> n x) -> ProgramT p m a -> ProgramT p n
  a\n  invocations :: [Text]\n```\n\nInstances of this class will define a syntactic
  element, a new instance of the\ndata family ProgramT, as well as its semantics in
  terms of the CommanderT monad,\nwhich is a backtracking monad based on a metaphor
  to military commanders which\nretreats upon defeat.\n"
license-name: MIT
