homepage: https://github.com/SamuelSchlesinger/commander-cli
changelog-type: markdown
hash: e0f7e210a1b5b09a31baa420cd32728efbc95e6a7bdf6b535eb4b55b085c5247
test-bench-deps: {}
maintainer: sgschlesinger@gmail.com
synopsis: A command line argument/option parser library built around a monadic metaphor
changelog: |
  # Revision history for commander-cli

  ## 0.1.0.0 -- 2020-01-12

  * Ported this to a cabal project after having built it in a larger repository
  accompanied by scripts written with it. (Samuel Schlesinger)
basic-deps:
  base: ! '>=4.13.0.0 && <4.14'
  unordered-containers: ^>=0.2.10.0
  text: ! '>=1.2.4.0 && <1.3'
  commander-cli: ^>=0.1
  mtl: ! '>=2.2.2 && <2.3'
all-versions:
- 0.1.0.0
author: Samuel Schlesinger
latest: 0.1.0.0
description-type: markdown
description: "# Commander\n\nThe commander package contains two DSLs for describing
  command line programs, \none at the type level and one at the term level. The one
  at the type level looks \nlike this:\n\n```haskell\ntype File = \"writer\" & Arg
  \"file\" FilePath & Arg \"contents\" FilePath Raw\n          + \"reader\" & Arg
  \"file\" FilePath & Raw\n```\n\nThis is a type which encodes information about an
  command line program we want to write. We can\ninstantiate a term of this type by
  writing\n\n```haskell\nfile :: ProgramT File IO\nfile = sub (arg \\file -> arg \\contents
  -> raw $ writeFile file contents) \n   :+: sub (arg \\file -> raw $ readFile file
  >>= putStrLn)\n```\n\nI can write a term of this type without specifying the File
  type by using the\nTypeApplications extension.\n\n```haskell\nfile = sub @\"writer\"
  (arg @\"file\" \\file -> arg @\"contents\" \\contents -> raw $ writeFile file contents)\n
  \  :+: sub @\"reader\" (arg @\"file\" \\file -> raw $ readFile file >>= putStrLn)\n```\n\nThe
  library consists of a few basic types which are important for understanding\nhow
  to use it. The first thing is the class\n\n```haskell\nclass Unrender r where\n
  \ unrender :: Text -> Maybe r\n```\n\nThis class is what you will use to define
  the parsing of a type from text and\ncan use any parsing library or whatever you
  want. Next, we have the class\n\n```haskell\nclass HasProgram p where\n  data ProgramT
  p m a\n  run :: ProgramT p IO a -> CommanderT State IO a\n  hoist :: (forall x.
  m x -> n x) -> ProgramT p m a -> ProgramT p n a\n  invocations :: [Text]\n```\n\nInstances
  of this class will define a syntactic element, a new instance of the\ndata family
  ProgramT, as well as its semantics in terms of the CommanderT monad,\nwhich is a
  backtracking monad based on a metaphor to military commanders which\nretreats upon
  defeat.\n"
license-name: MIT
