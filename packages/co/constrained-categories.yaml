homepage: https://github.com/leftaroundabout/constrained-categories
changelog-type: ''
hash: 1f093ab55ac17f087345fa87cb1002ccf7ee23f2b3dd7d16733a4175725ae950
test-bench-deps: {}
maintainer: (@) sagemueller $ geo.uni-koeln.de
synopsis: Constrained clones of the category-theory type classes, using ConstraintKinds.
changelog: ''
basic-deps:
  void: -any
  base: ! '>=4.7 && <5'
  tagged: -any
all-versions:
- '0.1.0.0'
- '0.2.0.0'
- '0.2.1.0'
- '0.2.1.1'
- '0.2.5.1'
- '0.3.0.0'
- '0.3.0.1'
- '0.3.1.0'
author: Justus Sagemüller
latest: '0.3.1.0'
description-type: haddock
description: ! 'Haskell has, and makes great use of, powerful facilities from category

  theory – basically various variants of functors.


  However, all those are just endofunctors in Hask, the category of

  all Haskell types with functions as morphisms. Which is sufficient

  for container / control structures that you want to be able to handle

  any type of data, but otherwise it''s a bit limiting, seeing as

  there are (in maths, science etc.) many categories that cannot properly

  be represented this way. Commonly used libraries such as

  <http://hackage.haskell.org/package/vector-space> thus make

  little notion of the fact that the objects they deal with actually

  form a category, instead defining just specialised versions of

  the operations.


  This library generalises functors etc. to a much wider class of

  categories, by allowing for constraints on objects (so these can have

  extra properties required). At the same time, we try to keep as close

  as possible to the well-known Haskell type class hierarchies rather

  than exactly adopting the mathematicians'' notions.


  Consider the README file, the examples, and/or the documentation to

  "Control.Category.Constrained" for how to make use of this.'
license-name: GPL-3
