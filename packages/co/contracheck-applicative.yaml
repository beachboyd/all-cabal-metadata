homepage: ''
changelog-type: markdown
hash: fc77f93c71427c0fffaf73123a88fc7fa5630e25d2eae85849029461bec19afa
test-bench-deps: {}
maintainer: 99fabianb@sis.gl
synopsis: Validation types/typeclass based on the contravariance.
changelog: |
  # Changelog for contracheck-applicative

  ## Unreleased changes
basic-deps:
  bytestring: '>=0.10.10 && <0.11'
  base: '>=4.7 && <5'
  text: '>=1.2.4 && <1.3'
  containers: '>=0.6.2 && <0.7'
  contravariant: '>=1.5.2 && <1.6'
  mmorph: '>=1.1.3 && <1.2'
all-versions:
- 0.1.0.0
author: Fabian Birkmann
latest: 0.1.0.0
description-type: markdown
description: "contracheck-applicative\n=======================\n\nThis package provides
  some simple yet useful types and functions to dynamically check properties of your
  data.\n\nWhy use this library?\n---------------------\n\nRuntime-checking for properties
  of data is the poor mans parsing. Nonetheless, sometimes it has do be done, and
  most of the time is not really pretty.\n\nMost validation libraries define validations
  to be a type like `a -> Either Text a`, which makes sense as it captures the essence
  of validations: Put something in, and you either get it back and know your data
  is alright, or you have an error to work with. But the type `a -> Either Text a`
  does not behave nicely:\n* On the type level it does not distinguish between unvalidated
  and validated values.\n* Validations are not combinable: There is not canonical
  monoid instance\n* Validations are not reusable:   It is invariant in that is neither
  co- nor contravarian.\n* Validations are not composable: There is no canonical way
  to combine a pair of validations `(a -> Either Text a, b -> Either Text b)` to a
  validation `(a, b) -> Either Text (a, b)`\n\nThis library attempts to fix these
  issues.\n\nQuickstart\n----------\n\n\n\nA `Check` is a function that takes an `Unvalidated`
  value and returns the result, possibly with a context: If the inpu has `Passed`
  the check or `Failed` it with a number of possible errors.\n```haskell\nnewtype
  Unvalidated a = Unvalidated { unsafeValidate :: a } \n\ndata CheckResult \n\t= Passed\n\t|
  Failed (Seq a)\n\t\nnewtype Check  e m a = Check { runCheck :: Unvalidated a ->
  m (CheckResult e) }\ntype    Check' e = Check e Identity\n```\n\n\nUnvalidated\n-----------\nThe
  `Unvalidated` newtype is to make a distinction between validated and unvalidated
  values on the type level. It is often convient to give an orphan instance for the
  typeclass of your choice via `-XStandaloneDeriving` so unvalidated data cannot get
  into your system, e.g.\n```haskell\n{-# language StandaloneDeriving, GeneralizedNewtypeDeriving,
  DerivingStrategies #-}\nimport Data.Aeson(FromJSON)\nderiving newtype instance (FromJSON
  a) => FromJSON (Unvalidated a)\n```\n\nCheckResult\n-----------\nIt has a monoid
  instance so it collects all possible errors, that is, it is not lazy in its failure
  component.\n\n\nBasically all this library does is provide convenient instances
  for these types.\n\n\nCheck\n-----\n\nTo start off lets give some simple examples.
  We construct `Check`s using the auxiliary combinators\n* `failsWith :: e -> CheckResult
  e`\n* `failsNoMsg :: CheckResult e`\n* `checking' :: (a -> CheckResult e) -> Check'
  e a`\n* `test' :: Applicative m => (a -> Bool) -> (a -> e) -> Check e m a`\n\n```haskell\nimport
  Data.Char(isAlpha)\n\ncheckEven :: Check' String Int\ncheckEven = test \n\t          ((==
  0) . (`mod` 2)) \n\t\t\t  (mappend \"Number not even: \" . show)\n\t\t\t  \ntype
  Age = Int\ncheckAge = test' (< 18) failsNoMsg\n\ntype Name = String\ncheckName =
  test $ \\name -> \n\tlet invalidChars = filter (not . isAlpha) name\n\tin if null
  invalidChars\n\t\t then Passed\n\t\t else failsWith invalidChars\n```\nThere are
  some other combinators to construct checks in various flavours.\nYou can run the
  checks using `validateBy'` if you want to use the validated result or just by `runCheck`
  if you just want to know if your input passed the check (or which errors occured).\n\nComposition\n-----------\n\nThe
  `Check` type is contravariant in the parameter to be checked (in fact, the whole
  library is merely a big wrapper around the instancess for the type classes from
  the package [contravariant](https://www.stackage.org/package/contravariant)). This
  tells us that we can \"pull back\" checks to other types:\n\n```haskell\ncheckOdd
  = contramap (+1) checkEven\n```\n\nSo if we have a `Check` for an `a` and know how
  to convert a `b` into an `a` that preserves the property to be checked, we get a
  `Check` for our `b` for free. You can also pull back a pair of checks to a product/sum
  of types (`(,)/Either`) using `divide/choose` from the type classes `Divisible/Decidable`
  (also defined in the package [contravariant](https://www.stackage.org/package/contravariant)).
  We show how to use them by lifting a `Check` for an `a` to a `Check` for a list
  of `a`s:\n\n```haskell\ncheckListBy :: Check' e a -> Check' e [a]\ncheckListBy checkA
  =\n  choose split checkNil checkCons\n  where\n    splitSum [] = Left ()\n    splitSum
  (x:xs) = Right (x, xs)\n\tcheckNil = mempty\n\tcheckCons = divide id checkA (checkListBy
  checkA)\n```\t\nTo check a `[a]` we have to distinguish two cases (`split`); either
  it is empty (`Left ()`), then we apply the trivial check `checkNil` or it is a cons,
  then we apply the check to the head and check the rest of the list.\n\nTo summarize,
  from _contravariant_ we use (with Types specialized to `Check`):\n* `contramap`
  (≡ `>$<`): `(b -> a) -> Check e m a -> Check e m b`\n* `divide :: (a -> (b, c))
  -> Check e m b -> Check e m c -> Check e m a`\n* `choose :: (a -> Either b c) ->
  Check e m b -> Check e m c -> Check e m a`\n\nCombination\n-----------\n\nBut now
  you want to combine your checks, e.g. to check a registration form. A first attempt
  might be to use the monoid instance of `CheckResult`. Note that it collects all
  errors and does not short-circuit if a `Check` fails (as you do not want to be that
  guy that sends the registration form back twenty times with different errors). But
  fortunately the `Monoid`-instance of `CheckResult` lifts to `Checks`! That means
  we can use the `Semigroup/Monoid` operations on `Checks`, (`mempty` being the trivial
  `Check` that always succeeds).\n```haskell\ndata Registration = Registration \n\t{
  registrationAge :: Age\n\t, registrationName :: Name\n\t, registrationEmail :: String
  \n\t} \ncheckRegistration \n\t=  contramap registrationAge   checkAge \n\t<> contramap
  registrationName  checkName\n\t<> contramap registrationEmail mempty -- of course
  unneccessary as it does nothing, but here for completeness\n```\n\nAdditional Context\n------------------\n\nSometimes
  you need to check properties, but the check itself has a sideeffict e.g. making
  a HTTP request or reading from a database. This is no problem, as \n1. `Check`s
  may have a context (remember that `Check' e a ≡ Check e Identity a`, a `Check` with
  a trivial context).\n2. We can easily convert our checks between context as `Check`s
  are an instance of `MFunctor` from the package [mmorph](https://www.stackage.org/package/mmorph).\n3.
  We are all good as long as the context is an `Applicative` as then the monoid instance
  of `CheckResult e` lifts to `m CheckResult e`.\n\nLet's give an example. Say you
  let users store URLs in a database, but for their convience you do not accept broken
  links.\n\n```haskell\nimport Network.HTTP.Client\nimport Network.HTTP.Types.Status(Status,
  statusCode)\nimport Network.HTTP.Client.TLS(newTlsManager)\nimport Control.Concurrent.Async(concurrently)\nimport
  Control.Validation.Check\nimport Control.Monad.Morph(MFunctor(..), generalize)\n\nnewtype
  Url = Url { getUrl ∷  String  }\n        deriving (Show, Eq, IsString)\n\ncheckUrlNo4xx
  ∷ Check Status IO Url                 \ncheckUrlNo4xx = checking $ \\url →  do\n
  \ m ← newTlsManager\n  req ← parseRequest . getUrl $ url\n  res ← httpLbs req m\n
  \ let stat =  (responseStatus res) ∷Status\n\t  code = statusCode stat\n  pure $
  if code < 400 || code >= 500\n     then  Passed\n     else  failsWith stat\n```\n\nBut
  now you allow your users to store several links, Facbook LinkedIn, Twitter and whatnot.
  With `foldWithCheck`/`traverseWithCheck` you can lift checks to arbitary instances
  of `Foldable` or `Traversable`:\nfoldWithCheck :: (Foldable f, Applicative m) =>
  Check e m a -> Check e m (f a)\ntraverseWithCheck :: (Traversable t, Applicative
  m) => Check e m a -> Check e m (t a)\n\n```haskell\ntype UrlList =  [ Url ] \ncheckUrlList
  :: Check Status IO [Url]\ncheckUrlList = traverseWithCheck checkUrlNo4xx \n```\nThats
  all there is. Since it is that easy to generalize, `Check`s for foldables/traversable
  are ommited.\n\nWell, its not really performant, as the `Url`s are checked in sequence;
  so to check 10 `Url`s you need about 10 seconds. We can fix that by giving `IO`
  a \"parallel\" `Applicative` instance that performs all chained `(<*>)` in parallel:\n```haskell\nnewtype
  ParIO a = ParIO { runParIO :: IO a } deriving Functor\n\ninstance Applicative ParIO
  where\n    pure = ParIO . pure\n    ParIO iof <*> ParIO iox = ParIO $ (\\(f, x)
  -> f x) <$> concurrently iof iox\n```\nAs we do not want to change the implementation
  of `checkUrlNo4xx` since it is fine, we can use `hoist`  to lift the check to a
  context that is executed in parallel:\n```haskell \n-- hoist :: Monad m => (forall
  a. m a -> n a) -> Check e m a -> Check e n a\n-- ParIO :: forall a. IO a -> ParIO
  a\ncheckUrlListPar :: Check Status ParIO [Url]\ncheckUrlListPar = traverseWithCheck
  (hoist ParIO checkUrlNo4xx)\n```\n_Warning_: \n```haskell\ncheckUrlListParWrong
  = hoist ParIO checkUrlList\n```\ndoes *NOT* work as here you lift into the parallel
  context after all the checks have been performed.\n\nThats about it. \n\nCheckable
  typeclass\n------------------\nThere is also a typeclass in Control.Validation.Class,
  but it has to be used with care as it does not perform any Checks on primitive types
  and this is often not what you want. You should probably use it only on nested structures
  made up solely from custom data types.\n\n\n\n\n\n"
license-name: BSD-3-Clause
