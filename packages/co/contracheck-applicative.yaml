homepage: ''
changelog-type: markdown
hash: 0fbc1418eec284760f8d169da46fbefa93e4df97f5d48d7fa2e8d0b5b236d9a7
test-bench-deps: {}
maintainer: 99fabianb@sis.gl
synopsis: Validation types/typeclass based on the contravariance.
changelog: |
  # Changelog for contracheck-applicative

  ## 0.1.1.1 Update documentation

  ## 0.1.1.0 Drop Checkable instances for Text and ByteString
basic-deps:
  base: '>=4.7 && <5'
  containers: '>=0.4 && <0.7'
  contravariant: '>=1.0.0 && <1.6'
  mmorph: '>=1.0.0 && <1.2'
all-versions:
- 0.1.0.0
- 0.1.0.1
- 0.1.1.0
- 0.1.2
author: Fabian Birkmann
latest: 0.1.2
description-type: markdown
description: "contracheck-applicative\n=======================\n\nThis package provides
  some simple yet useful types and functions to dynamically check properties of your
  data.\n\n# Table of contents\n1. [Why use this library](#why)\n2. [Quickstart](#quickstart)\n
  \   1. [Types](#Types)\n\t   * [`Unvalidated`](#Unvalidated)\n\t   * [`CheckResult`](#CheckResult)\n\t
  \  * [`Check`](#Check)\n    2. [Composition of `Check`'s](#composition)\n\t3. [Combination
  of `Check`'s](#combination)\n\t4. [Dealing with additional context](#context)\n\t5.
  [`Checkable` Typeclass](#typeclass)\n\n# Why use this library? <a name=\"why\"></a>\n\nRuntime-checking
  for properties of data is the poor man's parsing. Nonetheless, sometimes it has
  do be done, and most of the time is not really pretty.\n\nMost validation libraries
  define validations to be a type like `a -> Either Text a`, which makes sense as
  it captures the essence of validations: Put something in, and you either get it
  back and know your data is alright, or you have an error to work with. But the type
  `a -> Either Text a` does not behave nicely:\n* On the type level it does not distinguish
  between unvalidated and validated values.\n* Validations are not combinable: There
  is no canonical monoid instance\n* Validations are not reusable:   It is invariant;
  so it is neither co- nor contravariant.\n* Validations are not composable: There
  is no canonical way to combine a pair of validations `(a -> Either Text a, b ->
  Either Text b)` to a validation `(a, b) -> Either Text (a, b)`\n\nThis library attempts
  to fix these issues.\n\n# Quickstart <a name=\"quickstart\"></a>\n\n\nA `Check`
  is a function that takes an `Unvalidated` value and returns the result, possibly
  with a context: If the input has `Passed` the check or `Failed` it with a number
  of possible errors.\n```haskell\nnewtype Unvalidated a = Unvalidated { unsafeValidate
  :: a } \n\ndata CheckResult \n\t= Passed\n\t| Failed (Seq a)\n\t\nnewtype Check
  \ e m a = Check { runCheck :: Unvalidated a -> m (CheckResult e) }\ntype    Check'
  e = Check e Identity\n```\n\n## Types <a name=\"types\"></a>\nBasically all this
  library does is provide convenient instances for the following types.\n\n### `Unvalidated`
  <a name=\"unvalidated\"></a>\n\n```haskell\nnewtype Unvalidated a = Unvalidated
  { unsafeValidate :: a } \n```\n\nThe `Unvalidated` newtype is to make a distinction
  between validated and unvalidated values on the type level. It is often convient
  to give an orphan instance for the typeclass of your choice via `-XStandaloneDeriving`
  so unvalidated data cannot sneak into your system, e.g.\n```haskell\n{-# language
  StandaloneDeriving, GeneralizedNewtypeDeriving, DerivingStrategies #-}\nimport Data.Aeson(FromJSON)\nderiving
  newtype instance (FromJSON a) => FromJSON (Unvalidated a)\n```\n\n### `CheckResult`
  <a name=\"CheckResult\"></a>\n```haskell\ndata CheckResult \n\t= Passed\n\t| Failed
  (Seq a)\n\t\ninstance Monoid CheckResult\ninstance Functor CheckResult\n```\n\nIt
  has a monoid instance that collects all possible errors, that is, it is not lazy
  in its failure component.\n\n### Check <a name=\"Check\"></a>\n\n```haskell\nnewtype
  Check  e m a = Check { runCheck :: Unvalidated a -> m (CheckResult e) }\ntype    Check'
  e = Check e Identity\n```\n\nTo start off lets give some simple examples. We construct
  `Check`s using the auxiliary combinators\n* `failsWith :: e -> CheckResult e`\n*
  `failsNoMsg :: CheckResult e`\n* `checking' :: (a -> CheckResult e) -> Check' e
  a`\n* `test' :: Applicative m => (a -> Bool) -> (a -> e) -> Check e m a`\n\n```haskell\nimport
  Data.Char(isAlpha)\n\ncheckEven :: Check' String Int\ncheckEven = test \n\t          ((==
  0) . (`mod` 2)) \n\t\t\t  (mappend \"Number not even: \" . show)\n\t\t\t  \ntype
  Age = Int\ncheckAge = test' (< 18) failsNoMsg\n\ntype Name = String\ncheckName =
  test $ \\name -> \n\tlet invalidChars = filter (not . isAlpha) name\n\tin if null
  invalidChars\n\t\t then Passed\n\t\t else failsWith invalidChars\n```\n\nThere are
  some other combinators to construct checks in various flavours, notably the `test/(?>)`
  family.\nYou can run the checks using `validateBy'` if you want to use the validated
  result or just by `runCheck` if you just want to know if your input passed the check
  (though this is slower than it needs to be as the check collects all possible errors).\n\n##
  Composition of `Check`s <a name=\"composition\"></a>\n\n\nThe `Check` type is contravariant
  in the parameter to be checked (in fact, the whole library is merely a big wrapper
  around the instances for the type classes from the package [contravariant](https://www.stackage.org/package/contravariant)).
  This tells us that we can \"pull back\" checks to other types:\n\n```haskell\ncheckOdd
  = contramap (+1) checkEven\n```\n\nSo if we have a `Check` for an `a` and know how
  to convert a `b` into an `a` that preserves the property to be checked, we get a
  `Check` for our `b` for free. You can also pull back a pair of checks to a product/sum
  of types (`(,)/Either`) using `divide/choose` from the type classes `Divisible/Decidable`
  (also defined in the package [contravariant](https://www.stackage.org/package/contravariant)).
  We show how to use them by lifting a `Check` for an `a` to a `Check` for a list
  of `a`s:\n\n```haskell\ncheckListBy :: Check' e a -> Check' e [a]\ncheckListBy checkA
  =\n  choose split checkNil checkCons\n  where\n    splitSum [] = Left ()\n    splitSum
  (x:xs) = Right (x, xs)\n\tcheckNil = mempty\n\tcheckCons = divide id checkA (checkListBy
  checkA)\n```\t\nTo check a list `[a]` we have to distinguish two cases (`split`);
  either it is empty (`Left ()`), then we apply the trivial check `checkNil` or it
  is a cons, then we apply the check to the head and check the rest of the list.\n\nTo
  summarize, we can use (with Types specialized to `Check`):\n* `contramap` (≡ `>$<`):
  `(b -> a) -> Check e m a -> Check e m b`\n* `divide :: (a -> (b, c)) -> Check e
  m b -> Check e m c -> Check e m a`\n* `choose :: (a -> Either b c) -> Check e m
  b -> Check e m c -> Check e m a`\n\n## Combination of `Check`'s <a name=\"combination\"></a>\n\nBut
  now you want to combine your checks, e.g. to check a registration form. A first
  attempt might be to use the monoid instance of `CheckResult`. Note that it collects
  all errors and does not short-circuit if a `Check` fails (as you do not want to
  be _that_ guy that sends the registration form back twenty times with different
  errors). But fortunately the `Monoid`-instance of `CheckResult` lifts to `Checks`!
  That means we can use the `Semigroup/Monoid` operations on `Checks`, (`mempty` being
  the trivial `Check` that always succeeds).\n```haskell\ndata Registration = Registration
  \n\t{ registrationAge :: Age\n\t, registrationName :: Name\n\t, registrationEmail
  :: String \n\t} \ncheckRegistration \n\t=  contramap registrationAge   checkAge
  \n\t<> contramap registrationName  checkName\n\t<> contramap registrationEmail mempty
  -- of course unneccessary as it does nothing, but here for completeness\n```\n\n##
  Dealing with additional Context <a name=\"context\"></a>\n\nSometimes you need to
  check properties, but the check itself has a sideeffect e.g. making a HTTP request
  or reading from a database. This is no problem, as \n1. `Check`s may have a context
  (remember that `Check' e a ≡ Check e Identity a`, a `Check` with a trivial context).\n2.
  we can easily convert our checks between context as `Check`s are an instance of
  `MFunctor` from the package [mmorph](https://www.stackage.org/package/mmorph).\n3.
  we are all good as long as the context is an `Applicative` as then the monoid instance
  of `CheckResult e` lifts to `m CheckResult e`.\n\nLet's give an example. Say you
  let users store URLs in a database, but for their convience you do not accept broken
  links.\n\n```haskell\nimport Network.HTTP.Client\nimport Network.HTTP.Types.Status(Status,
  statusCode)\nimport Network.HTTP.Client.TLS(newTlsManager)\nimport Control.Concurrent.Async(concurrently)\nimport
  Control.Validation.Check\nimport Control.Monad.Morph(MFunctor(..), generalize)\n\nnewtype
  Url = Url { getUrl ∷  String  }\n        deriving (Show, Eq, IsString)\n\ncheckUrlNo4xx
  ∷ Check Status IO Url                 \ncheckUrlNo4xx = checking $ \\url →  do\n
  \ m ← newTlsManager\n  req ← parseRequest . getUrl $ url\n  res ← httpLbs req m\n
  \ let stat =  (responseStatus res) ∷Status\n\t  code = statusCode stat\n  pure $
  if code < 400 || code >= 500\n     then  Passed\n     else  failsWith stat\n```\n\nBut
  now you allow your users to store several links, Facbook, LinkedIn, Twitter and
  whatnot. With `foldWithCheck`/`traverseWithCheck` you can lift checks to arbitary
  instances of `Foldable` or `Traversable`:\nfoldWithCheck :: (Foldable f, Applicative
  m) => Check e m a -> Check e m (f a)\ntraverseWithCheck :: (Traversable t, Applicative
  m) => Check e m a -> Check e m (t a)\n\n```haskell\ntype UrlList =  [ Url ] \ncheckUrlList
  :: Check Status IO [Url]\ncheckUrlList = traverseWithCheck checkUrlNo4xx \n```\nThats
  all there is. Since it is that easy to generalize, `Check`s for foldables/traversable
  are ommited.\n\nWell, its not really performant, as the `Url`s are checked in sequence.
  We can fix that by giving `IO` a \"parallel\" `Applicative` instance that performs
  all chained `(<*>)` in concurrently:\n```haskell\nnewtype ParIO a = ParIO { runParIO
  :: IO a } deriving Functor\n\ninstance Applicative ParIO where\n    pure = ParIO
  . pure\n    ParIO iof <*> ParIO iox = ParIO $ (\\(f, x) -> f x) <$> concurrently
  iof iox\n```\nAs we do not want to change the implementation of `checkUrlNo4xx`
  as it is fine on its own, but we can use `hoist`  to lift the check to a context
  that is executed concurrently:\n```haskell \n-- hoist :: Monad m => (forall a. m
  a -> n a) -> Check e m a -> Check e n a\n-- ParIO :: forall a. IO a -> ParIO a\ncheckUrlListPar
  :: Check Status ParIO [Url]\ncheckUrlListPar = traverseWithCheck (hoist ParIO checkUrlNo4xx)\n```\n_Warning_:
  \n```haskell\ncheckUrlListParWrong = hoist ParIO checkUrlList\n```\ndoes *NOT* work
  as here you lift into the parallel context after all the checks have been performed.\n\nThats
  about it. \n\n## `Checkable` typeclass <a name=\"typeclass\"></a>\n\nThere is also
  a typeclass in the module Control.Validation.Class, but it has to be used with care
  as it does not perform any Checks on primitive types and this is often not what
  you want. You should probably use it _only_ on nested structures made up solely
  from custom data types, and otherwise define the checks explicitly.\n\n\n\n\n\n"
license-name: BSD-3-Clause
