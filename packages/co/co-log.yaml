homepage: https://github.com/kowainik/co-log
changelog-type: markdown
hash: 3a57264ada352996d831920c9d233e7f96bf5414352e7937358d6e5ee90d6acd
test-bench-deps: {}
maintainer: xrom.xkov@gmail.com
synopsis: Composable Contravariant Comonadic Logging Library
changelog: ! "# Change log\n\n`co-log` uses [PVP Versioning][1].\nThe change log is
  available [on GitHub][2].\n\n## 0.2.0 â€” Nov 15, 2018\n\n* [#45](https://github.com/kowainik/co-log/issues/45):\n
  \ Introduce approach for concurrent log writing.\n* [#46](https://github.com/kowainik/co-log/issues/46):\n
  \ Moves `logStringStdout`, `logStringStderr`, `logStringHandle`,\n  `withLogStringFile`
  from `Colog.Actions` to `Colog.Core.IO`\n* [#77](https://github.com/kowainik/co-log/issues/77):\n
  \ Remove `relude` from dependencies.\n  Add HLint check to Travis CI.\n* [#64](https://github.com/kowainik/co-log/issues/64):\n
  \ Introduce basic benchmarks.\n* [#20](https://github.com/kowainik/co-log/issues/20):\n
  \ Add experimental support for logger rotation (see `Colog.Rotation` module).\n*
  [#39](https://github.com/kowainik/co-log/issues/39):\n  Support GHC-8.2.2 and GHC-8.6.2.\n\n##
  0.1.0\n\n* [#37](https://github.com/kowainik/co-log/issues/37):\n  Add bounds to
  all dependencies. Move `Prelude` to the\n  `other-modules` section.\n\n## 0.0.0\n\n*
  Initially created.\n\n[1]: https://pvp.haskell.org\n[2]: https://github.com/kowainik/co-log/releases\n"
basic-deps:
  bytestring: ^>=0.10.8
  stm: ! '>=2.4 && <2.6'
  base: ! '>=4.10 && <4.13'
  time: ! '>=1.8 && <1.10'
  co-log: -any
  text: ! '>=1.2.3 && <1.3'
  co-log-core: ^>=0.1.1
  filepath: ^>=1.4.1
  containers: ! '>=0.5.7 && <0.7'
  ansi-terminal: ^>=0.8
  contravariant: ^>=1.5
  mtl: ^>=2.2.2
  transformers: ^>=0.5
  typerep-map: ! '>=0.3.0 && <0.4'
  directory: ^>=1.3.0
all-versions:
- 0.0.0
- 0.1.0
- 0.2.0
author: Kowainik, Alexander Vershilov
latest: 0.2.0
description-type: text
description: ! "# co-log\n\n[![Hackage](https://img.shields.io/hackage/v/co-log.svg)](https://hackage.haskell.org/package/co-log)\n[![MPL-2.0
  license](https://img.shields.io/badge/license-MPL--2.0-blue.svg)](https://github.com/kowainik/co-log/blob/master/LICENSE)\n[![Build
  status](https://secure.travis-ci.org/kowainik/co-log.svg)](https://travis-ci.org/kowainik/co-log)\n\n\nLogging
  library based on [`co-log-core`](../co-log-core) package. Provides\nready-to-go
  implementation of logging. This README contains _How to_ tutorial on\nusing this
  library. This tutorial explains step by step how to integrate\n`co-log` into small
  basic project, specifically how to replace `putStrLn` used\nfor logging with library
  provided logging.\n\nAll code below can be compiled and run with the following commands:\n\n```shell\n$
  cabal new-build co-log\n$ cabal new-exec readme\n```\n\n## Preamble: imports and
  language extensions\n\nSince this is a literate haskell file, we need to specify
  all our language\nextensions and imports up front.\n\n```haskell\n{-# LANGUAGE FlexibleContexts
  \ #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nimport Colog (Message, WithLog, cmap,
  fmtMessage, logDebug, logInfo, logTextStdout, logWarning,\n              usingLoggerT)\nimport
  Control.Monad.IO.Class (MonadIO, liftIO)\n\nimport Data.Semigroup ((<>))\nimport
  qualified Data.Text as Text\nimport qualified Data.Text.IO as TextIO\n\n```\n\n##
  Simple IO function example\n\nConsider the following function that reads lines from
  `stdin` and outputs\ndifferent feedback depending on the line size.\n\n```haskell\nprocessLinesBasic
  :: IO ()\nprocessLinesBasic = do\n    line <- TextIO.getLine\n    case Text.length
  line of\n        0 -> do\n            -- here goes logging\n            TextIO.putStrLn
  \">>>> Empty input\"\n            processLinesBasic\n        n -> do\n            TextIO.putStrLn
  \">>>> Correct input\"\n            TextIO.putStrLn $ \"Line length: \" <> Text.pack
  (show n)\n```\n\nThis code mixes application logic with logging of the steps. It's
  convenient to\nhave logging to observe behavior of the application. But `putStrLn`
  is very\nsimple and primitive way to log things.\n\n## Using `co-log` library\n\nIn
  order to use `co-log` library, we need to refactor `processLinesBasic`\nfunction
  in the following way:\n\n```haskell\nprocessLinesLog :: (WithLog env Message m,
  MonadIO m) => m ()\nprocessLinesLog = do\n    line <- liftIO TextIO.getLine\n    case
  Text.length line of\n        0 -> do\n            -- here goes logging\n            logWarning
  \"Empty input\"\n            processLinesLog\n        n -> do\n            logDebug
  \"Correct line\"\n            logInfo $ \"Line length: \" <> Text.pack (show n)\n```\n\nLet's
  summarize required changes:\n\n1. Make type more polymorphic: `(WithLog env Message
  m, MonadIO m) => m ()`\n2. Add `liftIO` to all `IO` functions.\n3. Replace `putStrLn`
  with proper `log*` function.\n\n## Running actions\n\nLet's run both functions:\n\n```haskell\nmain
  :: IO ()\nmain = do\n    processLinesBasic\n\n    let action = cmap fmtMessage logTextStdout\n
  \   usingLoggerT action processLinesLog\n```\n\nAnd here is how output looks like:\n\n![screenshot
  from 2018-09-17 20-52-01](https://user-images.githubusercontent.com/4276606/45623973-8bafb900-babb-11e8-9e20-4369a5a8e5ff.png)\n"
license-name: MPL-2.0
