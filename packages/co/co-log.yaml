homepage: https://github.com/kowainik/co-log
changelog-type: markdown
hash: 369d0603ab0f322ab2d32c346aa229efc1a2cafc2922c3bc7f072d651838f861
test-bench-deps: {}
maintainer: xrom.xkov@gmail.com
synopsis: Logging library
changelog: ! "Change log\n==========\n\n`co-log uses` [PVP Versioning][1].\nThe change
  log is available [on GitHub][2].\n\n0.1.0\n=====\n\n* [#37](https://github.com/kowainik/co-log/issues/37):\n
  \ Add bounds to all dependencies. Move `Prelude` to the\n  `other-modules` section.\n\n0.0.0\n=====\n*
  Initially created.\n\n[1]: https://pvp.haskell.org\n[2]: https://github.com/kowainik/co-log/releases\n"
basic-deps:
  bytestring: ^>=0.10.8
  base: ! '>=4.9 && <5'
  time: ^>=1.9.2
  co-log: -any
  text: ! '>=1.2.3 && <1.3'
  co-log-core: ^>=0.1.0
  base-noprelude: ! '>=4.11 && <5'
  containers: ! '>=0.5.7 && <0.7'
  ansi-terminal: ^>=0.8
  relude: ! '>=0.3.0 && <0.4'
  contravariant: ^>=1.5
  mtl: ^>=2.2.2
  transformers: ^>=0.5
  typerep-map: ! '>=0.3.0 && <0.4'
all-versions:
- '0.0.0'
- '0.1.0'
author: Kowainik
latest: '0.1.0'
description-type: text
description: ! "# co-log\n\n[![Hackage](https://img.shields.io/hackage/v/co-log.svg)](https://hackage.haskell.org/package/co-log)\n[![MPL-2.0
  license](https://img.shields.io/badge/license-MPL--2.0-blue.svg)](https://github.com/kowainik/co-log/blob/master/LICENSE)\n[![Build
  status](https://secure.travis-ci.org/kowainik/co-log.svg)](https://travis-ci.org/kowainik/co-log)\n\n\nLogging
  library based on [`co-log-core`](../co-log-core) package. Provides\nready-to-go
  implementation of logging. This README contains _How to_ tutorial on\nusing this
  library. This tutorial explains step by step how to integrate\n`co-log` into small
  basic project, specifically how to replace `putStrLn` used\nfor logging with library
  provided logging.\n\nAll code below can be compiled and run with the following commands:\n\n```shell\n$
  cabal new-build co-log\n$ cabal new-exec readme\n```\n\n## Preamble: imports and
  language extensions\n\nSince this is a literate haskell file, we need to specify
  all our language\nextensions and imports up front.\n\n```haskell\n{-# LANGUAGE FlexibleContexts
  \ #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nimport Colog (Message, WithLog, cmap,
  fmtMessage, logDebug, logInfo, logTextStdout, logWarning,\n              usingLoggerT)\nimport
  Control.Monad.IO.Class (MonadIO, liftIO)\n\nimport qualified Data.Text as Text\nimport
  qualified Data.Text.IO as TextIO\n```\n\n## Simple IO function example\n\nConsider
  the following function that reads lines from `stdin` and outputs\ndifferent feedback
  depending on the line size.\n\n```haskell\nprocessLinesBasic :: IO ()\nprocessLinesBasic
  = do\n    line <- TextIO.getLine\n    case Text.length line of\n        0 -> do\n
  \           -- here goes logging\n            TextIO.putStrLn \">>>> Empty input\"\n
  \           processLinesBasic\n        n -> do\n            TextIO.putStrLn \">>>>
  Correct input\"\n            TextIO.putStrLn $ \"Line length: \" <> Text.pack (show
  n)\n```\n\nThis code mixes application logic with logging of the steps. It's convenient
  to\nhave logging to observe behavior of the application. But `putStrLn` is very\nsimple
  and primitive way to log things.\n\n## Using `co-log` library\n\nIn order to use
  `co-log` library, we need to refactor `processLinesBasic`\nfunction in the following
  way:\n\n```haskell\nprocessLinesLog :: (WithLog env Message m, MonadIO m) => m ()\nprocessLinesLog
  = do\n    line <- liftIO TextIO.getLine\n    case Text.length line of\n        0
  -> do\n            -- here goes logging\n            logWarning \"Empty input\"\n
  \           processLinesLog\n        n -> do\n            logDebug \"Correct line\"\n
  \           logInfo $ \"Line length: \" <> Text.pack (show n)\n```\n\nLet's summarize
  required changes:\n\n1. Make type more polymorphic: `(WithLog env Message m, MonadIO
  m) => m ()`\n2. Add `liftIO` to all `IO` functions.\n3. Replace `putStrLn` with
  proper `log*` function.\n\n## Running actions\n\nLet's run both functions:\n\n```haskell\nmain
  :: IO ()\nmain = do\n    processLinesBasic\n\n    let action = cmap fmtMessage logTextStdout\n
  \   usingLoggerT action processLinesLog\n```\n\nAnd here is how output looks like:\n\n![screenshot
  from 2018-09-17 20-52-01](https://user-images.githubusercontent.com/4276606/45623973-8bafb900-babb-11e8-9e20-4369a5a8e5ff.png)\n"
license-name: MPL-2.0
