homepage: https://github.com/achirkin/constraints-deriving#readme
changelog-type: ''
hash: fecf24cd790704eddb297a04710c8cde40bf273e27573dd270fa720d5456614d
test-bench-deps:
  ghc: -any
  bytestring: -any
  path: -any
  base: ! '>=4.9 && <5'
  filepath: -any
  ghc-paths: -any
  constraints-deriving: -any
  path-io: -any
maintainer: achirkin@users.noreply.github.com
synopsis: Manipulating constraints and deriving class instances programmatically.
changelog: ''
basic-deps:
  ghc: ! '>=8.0.1'
  base: ! '>=4.9 && <5'
  constraints-deriving: -any
all-versions:
- 1.0.0.0
- 1.0.1.0
- 1.0.1.1
- 1.0.1.2
- 1.0.2.0
- 1.0.3.0
author: Artem Chirkin
latest: 1.0.3.0
description-type: markdown
description: "[![Hackage](https://img.shields.io/hackage/v/constraints-deriving.svg)](https://hackage.haskell.org/package/constraints-deriving)\r\n[![Build
  Status](https://secure.travis-ci.org/achirkin/constraints-deriving.svg)](http://travis-ci.org/achirkin/constraints-deriving)\r\n#
  constraints-deriving\r\n\r\nThis project is based on the [constraints](http://hackage.haskell.org/package/constraints)
  library.\r\nModule `Data.Constraint.Deriving` provides a GHC Core compiler plugin
  that generates class instances.\r\n\r\nThe main goal of this project is to make
  possible a sort of ad-hoc polymorphism that I wanted to\r\nimplement in [easytensor](http://hackage.haskell.org/package/easytensor)
  for performance reasons:\r\nan umbrella type unifies multiple specialized type family
  backend instances;\r\nif the type instance is known, GHC picks a specialized (overlapping)
  class instance for a required function;\r\notherwise, GHC resorts to a unified (overlappable)
  instance that is defined for the whole type family.\r\n\r\nTo use the plugin, add\r\n```Haskell\r\n{-#
  OPTIONS_GHC -fplugin Data.Constraint.Deriving #-}\r\n```\r\nto the header of your
  module.\r\nFor debugging, add a plugin option `dump-instances`:\r\n```Haskell\r\n{-#
  OPTIONS_GHC -fplugin-opt Data.Constraint.Deriving:dump-instances #-}\r\n```\r\nto
  the header of your file; it will print all instances declared in the module (hand-written
  and auto-generated).\r\nTo enable much more verbose debug output, use library flag
  `dev` (for debugging the plugin itself).\r\n\r\nCheck out `example` folder for a
  motivating use case (enabled with flag `examples`).\r\n\r\nThe plugin is controlled
  via GHC annotations; there are two types of annotations corresponding to two plugin
  passes.\r\nBoth passes are core-to-core, which means the plugin runs after typechecker,\r\nwhich
  in turn means **the generated class instances are available only outside of the
  module**.\r\nA sort of inconvenience you may have experienced with template haskell
  \U0001F609.\r\n\r\n### DeriveAll\r\n\r\n`DeriveAll` plugin pass inspects a newtype
  declaration.\r\nTo enable `DeriveAll` for a newtype `Foo`, add an annotation as
  follows:\r\n```Haskell\r\ndata Bar a = ...\r\n{-# ANN type Foo DeriveAll #-}\r\nnewtype
  Foo a = Foo (Bar a)\r\n\r\n-- the result is that Foo has the same set of instances
  as Bar\r\n```\r\ncheck out [`test/Spec/`](https://github.com/achirkin/constraints-deriving/tree/master/test/Spec)
  for [more examples](https://github.com/achirkin/constraints-deriving/blob/master/test/Spec/DeriveAll04.hs#L19-L20).\r\n\r\n`DeriveAll`
  plugin pass looks through all possible type instances (in the presence of type families)
  of the base type,\r\nand copies all class instances for the newtype wrapper.\r\n\r\nSometimes,
  you may need to refine the relation between the base type and the newtype;\r\nyou
  can do this via a special `type family DeriveContext newtype :: Constraint`.\r\nBy
  adding equality constraints, you can specify custom dependencies between type variables
  present in the newtype declaration\r\n(e.g. [`test/Spec/DeriveAll01.hs`](https://github.com/achirkin/constraints-deriving/blob/master/test/Spec/DeriveAll01.hs#L24)).\r\nBy
  adding class constraints, you force these class constraints for all generated class
  instances\r\n(e.g. in [`test/Spec/DeriveAll02.hs`](https://github.com/achirkin/constraints-deriving/blob/master/test/Spec/DeriveAll02.hs#L37)\r\n
  all class instances of `BazTy a b c d e f` have an additional constraint `Show e`).\r\n\r\n\r\nNote,
  the internal machinery is different from `GeneralizedNewtypeDeriving` approach:\r\nrather
  than coercing every function in the instance definition from the base type to the
  newtype,\r\nit coerces the whole instance dictionary.\r\n\r\n#### Blacklisting instances
  from being DeriveAll-ed\r\n\r\nSometimes you may want to avoid deriving a number
  of instances for your newtype.\r\nUse `DeriveAllBut [String]` constructor in the
  annotation and specify names of type classes you don't want to derive.\r\n```Haskell\r\n{-#
  ANN type CHF (DeriveAllBut [\"Show\"]) #-}\r\nnewtype CHF = CHF Double deriving
  Show\r\n\r\n-- the result is a normal `Show CHF` instance and the rest of `Double`'s
  instances are DeriveAll-ed\r\n```\r\nFor your safety,\r\nthe plugin is hardcoded
  to **not** generate instances for any classes and types in\r\n`GHC.Generics`, `Data.Data`,
  `Data.Typeable`, `Language.Haskell.TH`.\r\n\r\n#### Overlapping instances\r\n\r\nBy
  default `DeriveAll` marks all instances as `NoOverlap` if there are no overlapping\r\nclosed
  type families involved.\r\nOtherwise, it marks overlapped type instances as `Incoherent`.\r\nIf
  this logic does not suit you, you can enforce `OverlapMode` using `DeriveAll'` data
  constructor.\r\n\r\n### ToInstance\r\n\r\n`ToInstance` plugin pass converts a top-level
  `Ctx => Dict (Class t1..tn)` value declaration into\r\nan instance of the form `instance
  Ctx => Class t1..tn`.\r\nThus, one can write arbitrary Haskell code (returning a
  class dictionary) to be executed every time\r\nan instance is looked up by the GHC
  machinery.\r\nTo derive an instance this way, use  `ToInstance (x :: OverlapMode)`
  for a declaration, e.g. as follows:\r\n```Haskell\r\nnewtype Foo t = Foo t\r\n\r\n{-#
  ANN deriveEq (ToInstance NoOverlap) #-}\r\nderiveEq :: Eq t => Dict (Eq (Foo t))\r\nderiveEq
  = mapDict (unsafeDerive Foo) Dict\r\n\r\n-- the result of the above is equal to\r\n--
  deriving instance Eq t => Eq (Foo t)\r\n```\r\nYou can find a more meaningful example
  in [`test/Spec/ToInstance01.hs`](https://github.com/achirkin/constraints-deriving/blob/master/test/Spec/ToInstance01.hs#L45-L47)
  or\r\n[`example/Lib/VecBackend.hs`](https://github.com/achirkin/constraints-deriving/blob/master/example/Lib/VecBackend.hs).\r\n\r\n**Danger**:
  `ToInstance` removes duplicate instances;\r\nif you have defined an instance with
  the same head using vanilla Haskell and the plugin,\r\nthe latter will try to replace
  the former in place.\r\nBehavior of the instance in the same module is undefined
  in this case\r\n(the other modules should be fine seeing the plugin version).\r\n*I
  used this trick to convince `.hs-boot` to see the instances generated by the plugin.*\r\n\r\n##
  Further work\r\n\r\n`DeriveAll` derivation mechanics currently may break functional
  dependencies (untested).\r\n"
license-name: BSD-3-Clause
