homepage: https://github.com/achirkin/constraints-deriving#readme
changelog-type: ''
hash: 620cf6cc0fc093444bb8d7a20b974d35c45a8238d3eb022bd9455119c84adee8
test-bench-deps:
  ghc: -any
  bytestring: -any
  path: -any
  base: ! '>=4.9 && <5'
  filepath: -any
  ghc-paths: -any
  constraints-deriving: -any
  path-io: -any
maintainer: achirkin@users.noreply.github.com
synopsis: Manipulating constraints and deriving class instances programmatically.
changelog: ''
basic-deps:
  ghc: ! '>=8.0.1'
  base: ! '>=4.9 && <5'
  constraints-deriving: -any
all-versions:
- 1.0.0.0
author: Artem Chirkin
latest: 1.0.0.0
description-type: markdown
description: "constraints-deriving\r\n==================================\r\n[![Build
  Status](https://secure.travis-ci.org/achirkin/constraints-deriving.svg)](http://travis-ci.org/achirkin/constraints-deriving)\r\n\r\nThis
  project is based on the [constraints](http://hackage.haskell.org/package/constraints)
  library.\r\nModule `Data.Constraint.Deriving` provides a GHC Core compiler plugin
  that generates class instances.\r\n\r\nThe main goal of this project is to make
  possible a sort of ad-hoc polymorphism that I wanted to\r\nimplement in [easytensor](http://hackage.haskell.org/package/easytensor)
  for performance reasons:\r\nan umbrella type unifies multiple specialized type family
  backend instances;\r\nif the type instance is known, GHC picks a specialized (overlapping)
  class instance for a required function;\r\notherwise, GHC resorts to a unified (overlappable)
  instance that is defined for the whole type family.\r\n\r\nTo use the plugin, add\r\n```Haskell\r\n{-#
  OPTIONS_GHC -fplugin Data.Constraint.Deriving #-}\r\n```\r\nto the header of your
  module.\r\nFor debugging, add a plugin option `dump-instances`:\r\n```Haskell\r\n{-#
  OPTIONS_GHC -fplugin-opt Data.Constraint.Deriving:dump-instances #-}\r\n```\r\nto
  the header of your file; it will print all instances declared in the module (hand-written
  and auto-generated).\r\nTo enable much more verbose debug output, use library flag
  `dev` (for debugging the plugin itself).\r\n\r\nCheck out `example` folder for a
  motivating use case (enabled with flag `examples`).\r\n\r\nThe plugin is controlled
  via GHC annotations; there are two types of annotations corresponding to two plugin
  passes.\r\nBoth passes are core-to-core, which means the plugin runs after typechecker,\r\nwhich
  in turn means **the generated class instances are available only outside of the
  module**.\r\nA sort of inconvenience you may have experienced with template haskell
  \U0001F609.\r\n\r\n### DeriveAll\r\n\r\n`DeriveAll` plugin pass inspects a newtype
  declaration.\r\nTo enable `DeriveAll` for a newtype `Foo`, add an annotation as
  follows:\r\n```Haskell\r\n{-# ANN type Foo DeriveAll #-}\r\nnewtype Foo a = ...\r\n```\r\ncheck
  out [`test/Spec/`](https://github.com/achirkin/constraints-deriving/tree/master/test/Spec)
  for [more examples](https://github.com/achirkin/constraints-deriving/blob/master/test/Spec/DeriveAll04.hs#L19-L20).\r\n\r\n`DeriveAll`
  plugin pass looks through all possible type instances (in the presence of type families)
  of the base type,\r\nand copies all class instances for the newtype wrapper.\r\n\r\nSometimes,
  you may need to refine the relation between the base type and the newtype;\r\nyou
  can do this via a special `type family DeriveContext newtype :: Constraint`.\r\nBy
  adding equality constraints, you can specify custom dependencies between type variables
  present in the newtype declaration\r\n(e.g. [`test/Spec/DeriveAll01.hs`](https://github.com/achirkin/constraints-deriving/blob/master/test/Spec/DeriveAll01.hs#L24)).\r\nBy
  adding class constraints, you force these class constraints for all generated class
  instances\r\n(e.g. in [`test/Spec/DeriveAll02.hs`](https://github.com/achirkin/constraints-deriving/blob/master/test/Spec/DeriveAll02.hs#L37)\r\n
  all class instances of `BazTy a b c d e f` have an additional constraint `Show e`).\r\n\r\n\r\nNote,
  the internal machinery is different from `GeneralizedNewtypeDeriving` approach:\r\nrather
  than coercing every function in the instance definition from the base type to the
  newtype,\r\nit coerces the whole instance dictionary.\r\n\r\n\r\n### ToInstance\r\n\r\n`ToInstance`
  plugin pass converts a top-level `Ctx => Dict (Class t1..tn)` value declaration
  into\r\nan instance of the form `instance Ctx => Class t1..tn`.\r\nThus, one can
  write arbitrary Haskell code (returning a class dictionary) to be executed every
  time\r\nan instance is looked up by the GHC machinery.\r\nTo derive an instance
  this way, use  `ToInstance (x :: OverlapMode)` for a declaration, e.g. as follows:\r\n```Haskell\r\nnewtype
  Foo t = Foo t\r\n\r\n{-# ANN deriveEq (ToInstance NoOverlap) #-}\r\nderiveEq ::
  Eq t => Dict (Eq (Foo t))\r\nderiveEq = mapDict (unsafeDerive Foo) Dict\r\n\r\n--
  the result of the above is equal to\r\n-- deriving instance Eq t => Eq (Foo t)\r\n```\r\nYou
  can find a more meaningful example in [`test/Spec/ToInstance01.hs`](https://github.com/achirkin/constraints-deriving/blob/master/test/Spec/ToInstance01.hs#L45-L47)
  or\r\n[`example/Lib/VecBackend.hs`](https://github.com/achirkin/constraints-deriving/blob/master/example/Lib/VecBackend.hs).\r\n\r\n##
  Further work\r\n\r\nOne thing the `DeriveAll` pass misses is an option to blacklist
  some classes to avoid generating undesired instances.\r\nFurthermore, its derivation
  mechanics currently may break functional dependencies (untested).\r\n"
license-name: BSD-3-Clause
