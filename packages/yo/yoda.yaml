homepage: https://github.com/zenzike/yoda
changelog-type: markdown
hash: 2750d3803f0264a1757194211c760216bb562d84f852d5a8a7eaaf53873ca7a2
test-bench-deps: {}
maintainer: nicolas.wu@gmail.com
synopsis: Parser combinators for young padawans
changelog: ! '# Revision history for yoda


  ## 0.1.0.0  -- 2018-10-26


  * First version. Released on an unsuspecting world.

'
basic-deps:
  base: ! '>=4.10 && <4.11'
all-versions:
- '0.1.0.0'
author: Nicolas Wu
latest: '0.1.0.0'
description-type: markdown
description: ! "```\n\n                   ██╗   ██╗ ██████╗ ██████╗  █████╗\n                   ╚██╗
  ██╔╝██╔═══██╗██╔══██╗██╔══██╗\n                    ╚████╔╝ ██║   ██║██║  ██║███████║\n
  \                    ╚██╔╝  ██║   ██║██║  ██║██╔══██║\n                      ██║
  \  ╚██████╔╝██████╔╝██║  ██║\n                      ╚═╝    ╚═════╝ ╚═════╝ ╚═╝  ╚═╝\n\n
  \                 parser combinators for young padawans\n\n```\n\nIntroduction\n============\n\nYoda
  is a small parser combinator library. It is not efficient, nor\nbeautiful, but it
  hopes to teach young padawans to use the source\nand learn to write a parser.\n\n
  \   ╔═════════════════════════════════════════════════════════════╗\n    ║                                                             ║\n
  \   ║  <(-,-)>  Do, or do not, there is no try.  -- Master Yoda   ║\n    ║                                                             ║\n
  \   ╚═════════════════════════════════════════════════════════════╝\n\nYoda is a
  parser in the Parsec family of libraries, which includes\nParsec, attoparsec, Megaparsec,
  and trifecta. The main difference is\nthat Yoda does not require you to use the
  `try` function: it\nautomatically tries all alternatives for you.\n\nThe module
  exports the following functions and types. Some of these\nfunctions are defined
  outside of this file, namely, those marked under\n`Functor`, `Applicative`, and
  `Alternative`.\n\n```lhs\n\n> {-# LANGUAGE InstanceSigs #-}\n> module Yoda\n>   (
  Parser\n>   , parse\n>   , parseMaybe\n>   , parseIO\n>\n>   -- Functor\n>   , (<$>),
  (<$)\n>\n>   -- Applicative\n>   , pure, (<*>), (<*), (*>), (<**>)\n>\n>   -- Alternative\n>
  \  , (<|>), empty, some, many\n>   , chainl, chainl1, chainr, chainr1\n>\n>   --
  Monad\n>   , return, (>>=)\n>\n>   -- Miscellaneous\n>   , item, look, eof, char,
  string\n>   , oneOf, noneOf, sepBy, sepBy1\n>   , (<:>)\n>\n>   , try  -- not needed,
  but here for historic reasons\n>\n>   ) where\n\n```\n\nWe have to import some classes
  whose instances we will be\nimplementing for our parsers.\n```lhs\n\n> import Control.Monad\n>
  import Control.Applicative\n> import Data.List\n\n```\n\nParser\n======\n\nOur parsers
  will take in a `String` and produce a list of possible\nparses, along with remaining
  unparsed strings.\n```lhs\n\n> newtype Parser a = Parser (String -> [(a, String)])\n\n>
  parse :: Parser a -> (String -> [(a, String)])\n> parse (Parser p) = p\n\n> parseIO
  :: Parser a -> String -> IO a\n> parseIO p fileName = do\n>   file <- readFile fileName\n>
  \  let Just result = parseMaybe p file\n>   return result\n\n> parseMaybe :: Parser
  a -> String -> Maybe a\n> parseMaybe px ts = case parse px ts of\n>   []             ->
  Nothing\n>   ((x, ts'):txs) -> Just x\n\n```\nThis parser tries to push out a character
  from the incoming stream. It\nfails to parse if there is no remaining input.\n```lhs\n\n>
  item :: Parser Char\n> item = Parser (\\ts -> case ts of\n>   []      -> []\n>   (t:ts')
  -> [(t, ts')])\n\n```\nNow we implement Luke, I mean, look:\n```lhs\n\n> look ::
  Parser String\n> look = Parser (\\ts -> [(ts, ts)])\n\n```\nIt is also useful to
  know if we have reached the end of the input:\n```lhs\n\n> eof :: Parser ()\n> eof
  = Parser (\\ts -> case ts of\n>   [] -> [((), ts)]\n>   _  -> [])\n\n```\nAt this
  stage, we can output what has been given to us on the input,\nbut we have no way
  to change the outcome of what we do based on that\ninput.\n\nWe'll now start climbing
  the class hierarchy. Each class provides its\nown ways of combining and working
  with parsers, and extends the power\nof our combinator language with new functionality.\n\n\nFunctor\n=======\n\nThe
  functor instance captures the idea of modifying the output of\nsuccessful parses.\n```lhs\n\n>
  instance Functor Parser where\n>   fmap :: (a -> b) -> Parser a -> Parser b\n>   fmap
  f (Parser px) = Parser (\\ts -> [ (f x, ts') | (x, ts') <- px ts])\n\n```\nDerived
  combinators:\n```lhs\n\n< (<$>) :: Functor f => (a -> b) -> f a -> f b\n< (<$>)
  = fmap\n<\n< (<$) :: Functor f => a -> f b -> f a\n< (<$) = fmap . const\n\n```\n\nApplicative\n===========\n\nThe
  applicative instance shows how parsers can be chained together.\n```lhs\n\n> instance
  Applicative Parser where\n>   pure :: a -> Parser a\n>   pure x = Parser (\\ts ->
  [(x, ts)])\n>\n>   (<*>) :: Parser (a -> b) -> Parser a -> Parser b\n>   Parser
  pf <*> Parser px =\n>     Parser (\\ts -> [ (f x, ts'') | (f, ts')  <- pf ts\n>
  \                                 , (x, ts'') <- px ts'])\n\n```\nDerived combinators:\n```lhs\n\n<
  (<*) :: Applicative f => f a -> f b -> f a\n< px <* py = const <$> px <*> py\n<\n<
  (*>) :: Applicative f => f a -> f b -> f b\n< px *> py = flip const <$> px <*> py\n<
  \      -- = id <$ px <*> py\n<\n< (<**>) :: Applicative f => f a -> f (a -> b) ->
  f b\n< px <**> pf = (flip ($)) <$> px <*> pf\n\n> between :: Applicative m => m
  open -> m close -> m a -> m a\n> between popen pclose px = popen *> px <* pclose\n\n\n```\n\nAlternative\n===========\n\nChoices
  between parsers are given by the `Alternative` class. This\nclass assumes that the
  given Parser is already `Applicative`.\n```lhs\n\n> instance Alternative Parser
  where\n>   empty :: Parser a\n>   empty = Parser (\\ts -> [])\n>\n>   (<|>) :: Parser
  a -> Parser a -> Parser a\n>   Parser px <|> Parser py = Parser (\\ts -> px ts ++
  py ts)\n\n```\n\nDerived combinators\n-------------------\n```lhs\n\n< some :: Alternative
  f => f a -> f [a]\n< some px = px <:> many px\n<\n< many :: Alternative f => f a
  -> f [a]\n< many px = some px <|> pure []\n\n> choice :: Alternative f => [f a]
  -> f a\n> choice = foldr (<|>) empty\n\n> chainl :: Alternative f => f a -> f (a
  -> a -> a) -> a -> f a\n> chainl px pf x = chainl1 px pf <|> pure x\n\n> chainl1
  :: Alternative f => f a -> f (a -> a -> a) -> f a\n> chainl1 px pf = foldl' (flip
  ($)) <$> px <*> (many (flip <$> pf <*> px))\n\n> chainr :: Alternative f => f a
  -> f (a -> a -> a) -> a -> f a\n> chainr px pf x = chainr1 px pf <|> pure x\n\n>
  chainr1 :: Alternative f => f a -> f (a -> a -> a) -> f a\n> chainr1 px pf = flip
  (foldr ($)) <$> (many (px <**> pf)) <*> px\n\n```\nMonad\n=====\n\nThe monad instance
  allows the value in the result of one parser to\ninfluence the output of the parse.\n```lhs\n\n>
  instance Monad Parser where\n>   return :: a -> Parser a\n>   return ofTheJedi =
  pure ofTheJedi   -- sorry, I couldn't help it.\n>\n>   (>>=) :: Parser a -> (a ->
  Parser b) -> Parser b\n>   Parser px >>= f = Parser (\\ts -> concat [ parse (f x)
  ts' | (x, ts') <- px ts ])\n\n```\nDerived combinators:\n```lhs\n\n> satisfy ::
  (Char -> Bool) -> Parser Char\n> satisfy p = item >>= \\t -> if p t then pure t
  else empty\n\n```\nOr if you prefer do notation:\n```lhs\n\n< satisfy p = do t <-
  item\n<                if p t then pure t\n<                       else empty\n\n>
  char :: Char -> Parser Char\n> char c = satisfy (c ==)\n\n```\nWhich is equivalent
  to the following:\n```lhs\n\n< char :: Char -> Parser Char\n< char c = do t <- item\n<
  \            if c == t then pure c\n<                       else empty\n\n> oneOf
  :: [Char] -> Parser Char\n> oneOf = satisfy . flip elem\n>\n> noneOf :: [Char] ->
  Parser Char\n> noneOf cs = satisfy (not . flip elem cs)\n>\n> string :: String ->
  Parser String\n> string []     = return \"\"\n> string (c:cs) = char c <:> string
  cs\n>\n> sepBy  :: Alternative f => f a -> f sep -> f [a]\n> sepBy px psep = sepBy1
  px psep <|> pure []\n>\n> sepBy1 :: Alternative f => f a -> f sep -> f [a]\n> sepBy1
  px psep = px <:> (many (psep *> px))\n>\n> (<:>) :: Applicative f => f a -> f [a]
  -> f [a]\n> px <:> pxs = (:) <$> px <*> pxs\n\n\n```\nThere is a try after all,
  but it is only here to make this work with\ncode written for other members of the
  Parsec family.\n```lhs\n\n> try :: Parser a -> Parser a\n> try = id\n\n\n```\n\n\n\nPronunciation
  \   /prəˌnʌnsɪˈeɪʃ(ə)n/\n====================================\n\nMost of the symbols
  in this file are not easily pronounced, so let's establish\nsome nomenclature.\n\n
  \   Symbol   Name\n\n    <$>      fmap\n    <$       const fmap\n\n    <*>      tie
  fighter, or just \"tie\", ap\n    <*       tie left,\n    *>       tie right,\n
  \   <**>     tie bomber, pa\n\n    >>=      bind\n\n    <|>      or\n\n    <:>      lift
  cons\n\n"
license-name: BSD3
