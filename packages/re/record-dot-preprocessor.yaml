homepage: https://github.com/ndmitchell/record-dot-preprocessor#readme
changelog-type: text
hash: 3992d6fb325501230bb6667dcac02c40832ab24e153c39aa498272509152d119
test-bench-deps: {}
maintainer: Neil Mitchell <ndmitchell@gmail.com>
synopsis: Preprocessor to allow record.field syntax
changelog: ! "Changelog for record-dot-preprocessor\n\n0.1.2, released 2018-07-26\n
  \   Make qualified types in records work\n    Add LINE droppings to get approximate
  line numbers correct\n    Don't depend on anything not imported from Control.Lens\n0.1.1,
  released 2018-05-09\n    Handle - as an update operator\n    Be compatible with
  qualified imports\n0.1, released 2018-05-06\n    Initial version\n"
basic-deps:
  extra: -any
  base: ! '>=4.6 && <5'
  filepath: -any
all-versions:
- '0.1'
- '0.1.1'
- '0.1.2'
author: Neil Mitchell <ndmitchell@gmail.com>
latest: '0.1.2'
description-type: markdown
description: ! '# record-dot-preprocessor [![Hackage version](https://img.shields.io/hackage/v/record-dot-preprocessor.svg?label=Hackage)](https://hackage.haskell.org/package/record-dot-preprocessor)
  [![Stackage version](https://www.stackage.org/package/record-dot-preprocessor/badge/nightly?label=Stackage)](https://www.stackage.org/package/record-dot-preprocessor)
  [![Build Status](https://img.shields.io/travis/ndmitchell/record-dot-preprocessor/master.svg)](https://travis-ci.org/ndmitchell/record-dot-preprocessor)


  In almost every programming language `a.b` will get the `b` field from the `a` data
  type, and many different data types can have a `b` field. The reason this feature
  is ubiquitous is because it''s _useful_. The `record-dot-preprocessor` brings this
  feature to Haskell. Some examples:


  ```haskell

  data Company = Company {name :: String, owner :: Person}

  data Person = Person {name :: String, age :: Int}


  display :: Company -> String

  display c = c.name ++ " is run by " ++ c.owner.name


  nameAfterOwner :: Company -> Company

  nameAfterOwner c = c{name = c.owner.name ++ "''s Company"}

  ```


  Here we declare two records both with `name` as a field, then write `c.name` and
  `c.owner.name` to get those fields. We can also write `c{name = x}` as a record
  update, which still works even though `name` is no longer unique.


  ## How do I use this magic?


  First install `record-dot-preprocessor` with either `stack install record-dot-preprocessor`
  or `cabal update && cabal install record-dot-preprocessor`. Then add `{-# OPTIONS_GHC
  -F -pgmF=record-dot-preprocessor #-}` to the top of the file. Suddenly your records
  will work. You must make sure that the preprocessor is applied both to the file
  where your records are defined, and where the record syntax is used.


  The resulting program will require GHC 8.2 or above and the [`lens` library](https://hackage.haskell.org/package/lens),
  or a module called `Control.Lens` exporting the contents of [`Lens.Micro` from `microlens`](https://hackage.haskell.org/package/microlens/docs/Lens-Micro.html)
  (which has significantly less dependencies).


  ## What magic is available, precisely?


  * `e.b`, where `e` is an expression (not a constructor) and there are no whitespace
  on either side of the `.`, is translated to a record lookup. If you want to use
  the standard `.` function composition operator, insert a space. If you want to use
  a qualfied module name, then `e` will look like a constructor, so it won''t clash.

  * `e{b = c}` is a record update. Provided the record was defined in a module where
  `record-dot-preprocessor` was used, the meaning will be equivalent to before. If
  you want to use a normal unchanged record update, insert a space before the `{`.

  * `e{b * c}`, where `*` is an arbitrary operator, is equivalent to `e{b = e.b *
  c}`. If you want to apply an arbitrary function as `c`, use the `&` operator. Think
  `e.b *= c` in C-style languages.

  * `e.b.c{d.e * 1, f.g = 2}` also works and all variants along those lines.


  ## I don''t believe in magic, what''s the underlying science?


  On the way back from [ZuriHac 2017](https://2017.zurihac.info/) [Neil Mitchell](https://ndmitchell.com)
  and [Mathieu Boespflug](https://www.tweag.io/contact) were discussing lenses and
  the sad state of records in Haskell. We both agreed that overloaded labels should
  be defined such that they resolve to lenses. With the right instances, you could
  define `a ^. #foo` to get the `foo` field from the expression `a`. This preprocessor
  just turns `a.foo` into `a ^. #foo`, and generates the right instances. If you really
  want to see the magic under the hood simply run `record-dot-preprocessor yourfile.hs`
  and it will print out what it generates.


  ## How does this magic compare to other magic?


  Records in Haskell are well known to be [pretty lousy](https://www.yesodweb.com/blog/2011/09/limitations-of-haskell).
  There are [many proposals](https://wiki.haskell.org/Extensible_record) that aim
  to make Haskell records more powerful using dark arts taken from type systems and
  category theory. This preprocessor aims for simplicity - combining existing elements
  into a coherent story. The aim is to do no worse than Java, not achieve perfection.

'
license-name: BSD3
