homepage: https://github.com/ndmitchell/record-dot-preprocessor#readme
changelog-type: text
hash: eb5d60f224a3ea7edf09c720eed87efd7df6b2f0c1de109a70e100e8ccfdefc1
test-bench-deps: {}
maintainer: Neil Mitchell <ndmitchell@gmail.com>
synopsis: Preprocessor to allow record.field syntax
changelog: |
  Changelog for record-dot-preprocessor

  0.1.5, released 2019-02-09
      #10, support fields named 'x'
  0.1.4, released 2018-09-07
      Licensed under BSD-3-Clause OR Apache-2.0
  0.1.3, released 2018-07-26
      Give a unique name to each _preprocessor_unused
  0.1.2, released 2018-07-26
      Make qualified types in records work
      Add LINE droppings to get approximate line numbers correct
      Don't depend on anything not imported from Control.Lens
  0.1.1, released 2018-05-09
      Handle - as an update operator
      Be compatible with qualified imports
  0.1, released 2018-05-06
      Initial version
basic-deps:
  extra: -any
  base: ! '>=4.8 && <5'
  filepath: -any
all-versions:
- '0.1'
- 0.1.1
- 0.1.2
- 0.1.3
- 0.1.4
- 0.1.5
author: Neil Mitchell <ndmitchell@gmail.com>
latest: 0.1.5
description-type: markdown
description: |
  # record-dot-preprocessor [![Hackage version](https://img.shields.io/hackage/v/record-dot-preprocessor.svg?label=Hackage)](https://hackage.haskell.org/package/record-dot-preprocessor) [![Stackage version](https://www.stackage.org/package/record-dot-preprocessor/badge/nightly?label=Stackage)](https://www.stackage.org/package/record-dot-preprocessor) [![Build Status](https://img.shields.io/travis/ndmitchell/record-dot-preprocessor/master.svg)](https://travis-ci.org/ndmitchell/record-dot-preprocessor)

  In almost every programming language `a.b` will get the `b` field from the `a` data type, and many different data types can have a `b` field. The reason this feature is ubiquitous is because it's _useful_. The `record-dot-preprocessor` brings this feature to Haskell. Some examples:

  ```haskell
  data Company = Company {name :: String, owner :: Person}
  data Person = Person {name :: String, age :: Int}

  display :: Company -> String
  display c = c.name ++ " is run by " ++ c.owner.name

  nameAfterOwner :: Company -> Company
  nameAfterOwner c = c{name = c.owner.name ++ "'s Company"}
  ```

  Here we declare two records both with `name` as a field, then write `c.name` and `c.owner.name` to get those fields. We can also write `c{name = x}` as a record update, which still works even though `name` is no longer unique.

  ## How do I use this magic?

  First install `record-dot-preprocessor` with either `stack install record-dot-preprocessor` or `cabal update && cabal install record-dot-preprocessor`. Then add `{-# OPTIONS_GHC -F -pgmF=record-dot-preprocessor #-}` to the top of the file. Suddenly your records will work. You must make sure that the preprocessor is applied both to the file where your records are defined, and where the record syntax is used.

  The resulting program will require GHC 8.2 or above and the [`lens` library](https://hackage.haskell.org/package/lens), or a module called `Control.Lens` exporting the contents of [`Lens.Micro` from `microlens`](https://hackage.haskell.org/package/microlens/docs/Lens-Micro.html) (which has significantly less dependencies).

  ## What magic is available, precisely?

  * `e.b`, where `e` is an expression (not a constructor) and there are no whitespace on either side of the `.`, is translated to a record lookup. If you want to use the standard `.` function composition operator, insert a space. If you want to use a qualfied module name, then `e` will look like a constructor, so it won't clash.
  * `e{b = c}` is a record update. Provided the record was defined in a module where `record-dot-preprocessor` was used, the meaning will be equivalent to before. If you want to use a normal unchanged record update, insert a space before the `{`.
  * `e{b * c}`, where `*` is an arbitrary operator, is equivalent to `e{b = e.b * c}`. If you want to apply an arbitrary function as `c`, use the `&` operator. Think `e.b *= c` in C-style languages.
  * `e.b.c{d.e * 1, f.g = 2}` also works and all variants along those lines.

  ## I don't believe in magic, what's the underlying science?

  On the way back from [ZuriHac 2017](https://2017.zurihac.info/) [Neil Mitchell](https://ndmitchell.com) and [Mathieu Boespflug](https://www.tweag.io/contact) were discussing lenses and the sad state of records in Haskell. We both agreed that overloaded labels should be defined such that they resolve to lenses. With the right instances, you could define `a ^. #foo` to get the `foo` field from the expression `a`. This preprocessor just turns `a.foo` into `a ^. #foo`, and generates the right instances. If you really want to see the magic under the hood simply run `record-dot-preprocessor yourfile.hs` and it will print out what it generates.

  ## How does this magic compare to other magic?

  Records in Haskell are well known to be [pretty lousy](https://www.yesodweb.com/blog/2011/09/limitations-of-haskell). There are [many proposals](https://wiki.haskell.org/Extensible_record) that aim to make Haskell records more powerful using dark arts taken from type systems and category theory. This preprocessor aims for simplicity - combining existing elements into a coherent story. The aim is to do no worse than Java, not achieve perfection.
license-name: BSD-3-Clause
