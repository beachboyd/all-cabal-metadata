homepage: https://github.com/jamesdbrock/replace-megaparsec
changelog-type: markdown
hash: 9f20d5bbc5e7845980134235306a9c2cf74f784c281575fcca381f7d3e49f1bb
test-bench-deps:
  bytestring: -any
  Cabal: -any
  base: ! '>=4.12 && <5.0'
  text: -any
  megaparsec: -any
  replace-megaparsec: -any
maintainer: jamesbrock@gmail.com
synopsis: Stream editing with parsers
changelog: |
  # Revision history for replace-megaparsec

  ## 1.1.0.0 -- 2019-08-24

  * First version. Megaparsec.
basic-deps:
  base: -any
  megaparsec: -any
all-versions:
- 1.0.0.0
author: James Brock
latest: 1.0.0.0
description-type: markdown
description: "# replace-megaparsec\n\n__replace-megaparsec__ is for finding text patterns,
  and also editing and\nreplacing the found patterns.\nThis activity is traditionally
  done with regular expressions,\nbut __replace-megaparsec__ uses\n[__Megaparsec__](http://hackage.haskell.org/package/megaparsec)\nparsers
  instead for the pattern matching.\n\n__replace-megaparsec__ can be used in the same
  sort of “pattern capture”\nor “find all” situations in which one would use Python\n[`re.findall`](https://docs.python.org/3/library/re.html#re.findall)\nor\nPerl
  [`m//`](https://perldoc.perl.org/functions/m.html),\nor\nUnix [`grep`](https://www.gnu.org/software/grep/).\n\n__replace-megaparsec__
  can be used in the same sort of “stream editing”\nor “search-and-replace” situations
  in which one would use Python\n[`re.sub`](https://docs.python.org/3/library/re.html#re.sub),\nor\nPerl
  [`s///`](https://perldoc.perl.org/functions/s.html),\nor Unix\n[`sed`](https://www.gnu.org/software/sed/manual/html_node/The-_0022s_0022-Command.html),\nor\n[`awk`](https://www.gnu.org/software/gawk/manual/gawk.html).\n\n##
  Why would we want to do pattern matching and substitution with parsers instead of
  regular expressions?\n\n* Parsers have a nicer syntax than\n  [regular expressions](https://en.wikipedia.org/wiki/Regular_expression),\n
  \ which are notoriously\n  [difficult to read](https://en.wikipedia.org/wiki/Write-only_language).\n\n*
  Regular expressions can do “group capture” on sections of the matched\n  pattern,
  but they can only return stringy lists of the capture groups. Parsers\n  can construct
  typed data structures based on the capture groups, guaranteeing\n  no disagreement
  between the pattern rules and the rules that we're using\n  to build data structures
  based on the pattern matches.\n  \n  For example, consider\n  scanning a string
  for numbers. A lot of different things can look like a number,\n  and can have leading
  plus or minus signs, or be in scientific notation, or\n  have commas, or whatever.
  If we try to parse all of the numbers out of a string\n  using regular expressions,
  then we have to make sure that the regular expression\n  and the string-to-number
  conversion function agree about exactly what is\n  and what isn't a numeric string.
  We can get into an awkward situation in which\n  the regular expression says it
  has found a numeric string but the\n  string-to-number conversion function fails.
  A typed parser will perform both\n  the pattern match and the conversion, so it
  will never be in that situation.\n\n* Regular expressions are only able to pattern-match\n
  \ [regular](https://en.wikipedia.org/wiki/Chomsky_hierarchy#The_hierarchy)\n  grammers.\n
  \ Parsers are able pattern-match with context-free grammers, and\n  even context-sensitive
  or Turing-complete grammers, if needed. See below for\n  an example of lifting a
  `Parser` into a `State` monad for context-sensitive\n  pattern-matching.\n\n## Examples\n\nTry
  the examples in `ghci` by\nrunning `cabal v2-repl` in the `replace-megaparsec/`\nroot
  directory.\n\nThe examples depend on these imports.\n\n```haskell\nimport Replace.Megaparsec\nimport
  Text.Megaparsec\nimport Text.Megaparsec.Char\nimport Text.Megaparsec.Char.Lexer\n```\n\n###
  Parsing with `sepCap` family of parser combinators\n\nThe following examples show
  how to match a pattern to a string of text\nand deconstruct the string of text by
  separating it into sections\nwhich match the pattern, and sections which don't match.\n\n####
  Pattern-match, capture only the parsed result\n\nSeparate the input string into
  sections which can be parsed as a hexadecimal\nnumber with a prefix `\"0x\"`, and
  sections which can't.\n\n```haskell\nlet hexparser = string \"0x\" >> hexadecimal
  :: Parsec Void String Integer\nparseTest (sepCap hexparser) \"0xA 000 0xFFFF\"\n```\n```haskell\n[Right
  10,Left \" 000 \",Right 65535]\n```\n\n#### Pattern match, capture only the matched
  text\n\nJust get the strings sections which match the hexadecimal parser, throw
  away\nthe parsed number.\n\n```haskell\nlet hexparser = string \"0x\" >> hexadecimal
  :: Parsec Void String Integer\nparseTest (findAll hexparser) \"0xA 000 0xFFFF\"\n```\n```haskell\n[Right
  \"0xA\",Left \" 000 \",Right \"0xFFFF\"]\n```\n\n#### Pattern match, capture the
  matched text and the parsed result\n\nCapture the parsed hexadecimal number, as
  well as the string section which\nparses as a hexadecimal number.\n\n```haskell\nlet
  hexparser = string \"0x\" >> hexadecimal :: Parsec Void String Integer\nparseTest
  (findAllCap hexparser) \"0xA 000 0xFFFF\"\n```\n```haskell\n[Right (\"0xA\",10),Left
  \" 000 \",Right (\"0xFFFF\",65535)]\n```\n\n#### Pattern match, capture only the
  locations of the matched patterns\n\nFind all of the sections of the stream which
  match\nthe `Text.Megaparsec.Char.space1` parser (a string of whitespace).\nPrint
  a list of the offsets of the beginning of every pattern match.\n\n```haskell\nimport
  Data.Either\nlet spaceoffset = getOffset <* space1 :: Parsec Void String Int\nparseTest
  (return . rights =<< sepCap spaceoffset) \" a  b  \"\n```\n```haskell\n[0,2,5]\n```\n\n###
  Edit text strings by running parsers with `streamEdit`\n\nThe following examples
  show how to search for a pattern in a string of text\nand then edit the string of
  text to substitute in some replacement text\nfor the matched patterns.\n\n#### Pattern
  match and replace with a constant\n\nReplace all carriage-return-newline instances
  with newline.\n\n```haskell\nstreamEdit crlf (const \"\\n\") \"1\\r\\n\\r\\n2\"\n```\n```haskell\n\"1\\n\\n2\"\n```\n\n####
  Pattern match and edit the matches\n\nReplace alphabetic characters with the next
  character in the alphabet.\n\n```haskell\nstreamEdit (some letterChar) (fmap succ)
  \"HAL 9000\"\n```\n```haskell\n\"IBM 9000\"\n```\n\n#### Pattern match and edit
  the matches\n\nFind all of the string sections *`s`* which can be parsed as a\nhexadecimal
  number *`r`*,\nand if *`r≤16`*, then replace *`s`* with a decimal number.\n\n```haskell\nlet
  hexparser = string \"0x\" >> hexadecimal :: Parsec Void String Integer\nstreamEdit
  (match hexparser) (\\(s,r) -> if r <= 16 then show r else s) \"0xA 000 0xFFFF\"\n```\n```haskell\n\"10
  000 0xFFFF\"\n```\n\n#### Context-sensitive pattern match and edit the matches\n\nCapitalize
  the third letter in a string. The `capthird` parser searches for\nindividual letters,
  and it needs to remember how many times it has run so\nthat it can match successfully
  only on the third time that it finds a letter.\nTo enable the parser to remember
  how many times it has run, we'll\ncompose the parser with a `State` monad from\nthe
  `mtl` package. (Run in `ghci` with `cabal v2-repl -b mtl`).\n\n```haskell\nimport
  qualified Control.Monad.State.Strict as MTL\nimport Control.Monad.State.Strict (get,
  put, evalState)\nimport Data.Char (toUpper)\n\nlet capthird :: ParsecT Void String
  (MTL.State Int) String\n    capthird = do\n        x <- letterChar\n        i <-
  get\n        put (i+1)\n        if i==3 then return [x] else empty\n\nflip evalState
  1 $ streamEditT capthird (return . fmap toUpper) \"a a a a a\"\n```\n```haskell\n\"a
  a A a a\"\n```\n\n## Alternatives\n\n<http://hackage.haskell.org/package/regex>\n\n<http://hackage.haskell.org/package/pipes-parse>\n\n<http://hackage.haskell.org/package/stringsearch>\n\n<http://hackage.haskell.org/package/substring-parser>\n\n<http://hackage.haskell.org/package/pcre-utils>\n\n<http://hackage.haskell.org/package/template>\n"
license-name: BSD-3-Clause
