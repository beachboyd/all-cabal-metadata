homepage: ''
changelog-type: markdown
hash: 0070ce3f29301753972ebf28658e1958c7550e2e6878f68837736149b01457fa
test-bench-deps:
  bytestring: ! '>=0.10'
  sop-core: ! '>=0.4.0.0 && <0.5'
  base: ! '>=4.10.0.0 && <5'
  text: ! '>=1.1'
  doctest: ! '>=0.16'
  red-black-record: -any
  tasty-hunit: ! '>=0.9.2'
  tasty: ! '>=0.10.1.1'
  aeson: ! '>=1.4.0.0 && <1.5'
  profunctors: ! '>=5'
maintainer: diaz_carrete@yahoo.com
synopsis: Extensible records and variants indexed by a type-level Red-Black tree.
changelog: "# Revision history for red-black-record\r\n\r\n## 1.0.0.0 -- YYYY-mm-dd\r\n\r\n*
  First version. Released on an unsuspecting world.\r\n"
basic-deps:
  sop-core: ! '>=0.4.0.0 && <0.5'
  base: ! '>=4.10.0.0 && <5'
all-versions:
- 1.0.0.0
- 1.0.0.1
author: Daniel Diaz
latest: 1.0.0.1
description-type: markdown
description: "# red-black-record\r\n\r\n## What's this?\r\n\r\nA library that provides
  extensible records and variants, both indexed by a\r\ntype-level [red-black](https://en.wikipedia.org/wiki/Red%E2%80%93black_tree)\r\ntree
  that maps `Symbol` keys to `Type`s. The keys correspond to fields names in\r\nrecords,
  and to branch names in variants. Many record functions have their\r\nvariant mirror-images
  and viceversa.\r\n\r\nEach value type in a field or branch comes wrapped in a type
  constructor of\r\nkind `Type -> Type`. Typically, it will be an [identity\r\nfunctor](http://hackage.haskell.org/package/sop-core-0.4.0.0/docs/Data-SOP.html#t:I),\r\nbut
  it can also be `Maybe` or some other `Applicative` for parsing, validation\r\nand
  so on.\r\n\r\nIf we forget about the keys and only keep the values, records are
  isomorphic to\r\n[n-ary unlabeled\r\nproducts](http://hackage.haskell.org/package/sop-core-0.4.0.0/docs/Data-SOP.html#t:NP),\r\nand
  variants are isomorphic to [n-ary unlabeled\r\nsums](http://hackage.haskell.org/package/sop-core-0.4.0.0/docs/Data-SOP.html#t:NS).\r\nThe
  [sop-core](http://hackage.haskell.org/package/sop-core) library provides\r\nsuch
  unlabeled types, along with a rich API for manipulating them. Instead of\r\nreinventing
  the wheel, red-black-record defines conversion functions to\r\nfacilitate working
  in the \"unlabeled\" world and then coming back to records and\r\nvariants.\r\n\r\nThere
  is another world towards which bridges must be built: the everyday\r\nHaskell world
  of conventional records and sums. In fact, one of the motivations\r\nof extensible
  records and variants is to serve as \"generalized\" versions of\r\nvanilla data
  types. Advanced use cases can rely on these generalized versions,\r\nthereby avoiding
  intrusive changes to the original types. red-black-record\r\nprovides conversion
  typeclasses with default implementations by way of\r\n[`GHC.Generic`](http://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Generics.html).\r\n\r\nFor
  examples on how to use the library, check the haddocks for the\r\n`Data.RBR.Examples`
  module.\r\n\r\n## FAQ\r\n\r\n### What extensions do I need to use this library?\r\n\r\n-
  `DataKinds`\r\n\r\n- `TypeApplications`\r\n\r\n  To be able to specify field and
  branch names.\r\n\r\n- `FlexibleContexts`\r\n\r\n- `TypeFamilies`\r\n\r\n- `DeriveGeneric
  `\r\n\r\n  For interfacing with normal records.\r\n\r\n- `PartialTypeSignatures`\r\n\r\n###
  My type signatures are getting big and scary because of those type-level trees.
  What to do?\r\n\r\nThe\r\n[`-XPartialTypeSignatures`](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html?#extension-PartialTypeSignatures)\r\nextension
  can help with that, in combination with the\r\n[-Wno-partial-type-signatures](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#ghc-flag--Wpartial-type-signatures)\r\nGHC
  flag that disables the warning message emitted when the underscore is\r\nencountered
  in a signature.\r\n\r\nThe flag can be set globally in the\r\n[ghc-options](https://www.haskell.org/cabal/users-guide/developing-packages.html?#pkg-field-ghc-options)\r\nsection
  of the .cabal file, and also for particular modules with the\r\n[OPTIONS_GHC](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html?highlight=options_ghc#options-ghc-pragma)\r\nfile-header
  pragma.\r\n\r\n### The `Show` instance for record doesn't show any field names.\r\n\r\nThe
  field names exist only at the type level. Also, the `Show` instance uses\r\nn-ary
  products and sums from\r\n[sop-core](http://hackage.haskell.org/package/sop-core),
  which do not have\r\nfield labels.\r\n\r\nFor fancier output, use the \"pretty-show\"
  functions instead.\r\n\r\n### Working with two records, I'm getting errors about
  incompatible types even as both records have the exact same fields.\r\n\r\nAlas,
  the order of insertion in the type-level tree matters :( Different\r\ninsertion
  orders can produce structurally different trees, even as they encode\r\nthe same
  symbol-to-type map.\r\n\r\nAs a workaround, one can use the `-Subset` functions
  to convert between\r\nequivalent structures.\r\n\r\n### I can't insert into a record
  when a field with the same name but different type already exists. Why not simply
  overwrite it?\r\n\r\nThat limitation was intentional, because allowing it would
  make impossible to\r\nimplement of `widen` for `Variant`. When/if key deletion gets
  implemented\r\ntype-level tree, one solution would be to explicitly delete the field
  and then\r\ninsert it again.\r\n\r\n### The library doesn't use Proxy and relies
  on type application instead. But what’s the order of the type parameters?\r\n\r\nFor
  typeclass methods, it's the order in which the type variables appear in the\r\ntypeclass
  declaration.\r\n\r\nFor standalone functions, it’s the order in which the type variables
  appear in\r\nthe `forall`.\r\n\r\n### What's the deal with all those -I suffixed
  versions of functions?\r\n\r\nThis library aims to provide\r\n[HKD](http://reasonablypolymorphic.com/blog/higher-kinded-data/)-like\r\nfunctionality
  by wrapping all the fields of a record in a type constructor.\r\n\r\nBut sometimes
  we are working with \"pure\" records without effects, and we just\r\nwant to get
  and set a field's value. In that case, the type constructor that\r\nwraps each field
  will be an identity functor `I` (from\r\n[sop-core](http://hackage.haskell.org/package/sop-core)).
  The -I suffixed\r\nfunctions wrap and unwrap the field's value on behalf of the
  user.\r\n\r\n### What's the deal with all those -Subset suffixed versions of functions?\r\n\r\nThese
  functions target multiple fields or branches at the same time. They can\r\nbe used
  to build lawful lenses and prisms over fragmenst of a structure.\r\n\r\nThey can
  also be used to convert between type-level trees that have the same\r\nentries but
  different structure.\r\n\r\n### I want a version of \"match\" that when it fails
  returns a variant with the unmatched cases.\r\n\r\nThat isn't implemented (yet).
  It would require key deletion on the type-level\r\ntree.\r\n\r\n## Inspirations\r\n\r\n-
  The code for the red-black tree has been lifted from [\"Persistent Red Black\r\n
  \ Trees in Haskell\"](https://abhiroop.github.io/Haskell-Red-Black-Tree/).\r\n\r\n-
  Besides depending on sop-core, I have copied and adapted code from it. In\r\n  particular
  the `KeysValuessAll` typeclass is a version of the `All` typeclass\r\n  from sop-core.
  \r\n\r\n- [Surgery for data\r\n  types](https://blog.poisson.chat/posts/2018-11-26-type-surgery.html).\r\n
  \ [reddit](https://www.reddit.com/r/haskell/comments/a0gi4z/surgery_for_data_types/).\r\n\r\n##
  Alternatives\r\n\r\n- [generics-sop](http://hackage.haskell.org/package/generics-sop)
  and\r\n  [records-sop](http://hackage.haskell.org/package/records-sop). Like\r\n
  \ red-black-record, both of these libraries build upon sop-core. They are in\r\n
  \ fact written by the same author of sop-core. generics-sop can provide\r\n  sum-of-products
  representations of any datatype with a Generic instance\r\n  (red-black-record is
  more limited, it only converts types that fit the named\r\n  record or variant mold—so
  no types with anonymous fields for example). \r\n  \r\n  If you don't need to explicitly
  target *individual* fields in the generic\r\n  representation, you'll be better
  off using generics-sop instead of\r\n  red-black-record. \r\n  \r\n  On top of generics-sop,
  records-sop provides named field accessors and record\r\n  subtyping based on a
  type-level list of fields (unlike the type-level tree\r\n  used by red-black-record).
  It doesn't seem to provide variants.\r\n\r\n- [superrecord](http://hackage.haskell.org/package/superrecord).
  This library\r\n  provides very efficient field access at runtime because the fields
  are backed\r\n  internally by an array. Uses a *sorted* type-level list of fields,
  to avoid\r\n  the problems of multiple orderings of the same fields.\r\n\r\n- [vinyl](http://hackage.haskell.org/package/vinyl).
  One of the oldest and more\r\n  fully-featured extensible records libraries. Uses
  a type level list of\r\n  fields. The fields' values are wrapped in a type constructor,
  like in\r\n  sop-core. The records seem to use an auxiliary sum type that serves
  as a\r\n  \"code\" for the fields.\r\n\r\n- [HTree](https://github.com/i-am-tom/learn-me-a-haskell#htree).
  Another\r\n  implementation of extensible records using type-level red-black trees.\r\n\r\n-
  [megarecord](https://github.com/jvanbruegge/Megarecord). Seems to be a\r\n  proof-of-concept
  for a future [row polymorphism\r\n  extension](https://github.com/ghc-proposals/ghc-proposals/pull/180)
  for\r\n  Haskell.\r\n\r\n- [generic-data-surgery](https://hackage.haskell.org/package/generic-data-surgery)\r\n\r\n-
  [Coxswain](https://ghc.haskell.org/trac/ghc/wiki/Plugins/TypeChecker/RowTypes/Coxswain)\r\n\r\n"
license-name: BSD-3-Clause
