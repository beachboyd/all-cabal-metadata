homepage: https://github.com/peti/flexible-defaults
changelog-type: ''
hash: 819302b6febc67007d64fa25611f4a562555cd7c7157921d69ef585ba4fe3471
test-bench-deps: {}
maintainer: Peter Simons <simons@cryp.to>
synopsis: Generate default function implementations for complex type classes.
changelog: ''
basic-deps:
  base: ! '>=3 && <5'
  containers: -any
  th-extras: -any
  transformers: -any
  template-haskell: -any
all-versions:
- '0.0.0.1'
- '0.0.0.2'
- '0.0.0.3'
- '0.0.1.0'
- '0.0.1.1'
- '0.0.1.2'
- '0.0.2'
author: James Cook <mokus@deepbondi.net>
latest: '0.0.2'
description-type: haddock
description: ! 'Template Haskell code to implement default implementations

  for type-class functions based on which functions are

  already implemented.  Currently extremely crude but

  still fairly effective.


  When defining a type class with many functions, each

  of which can be implemented based on arbitrary subsets

  of the others, the standard default-implementation

  concept breaks down quite badly.  This library provides

  a system by which more complex rules can be described

  for choosing default implementations based on which

  ones the user supplies.  These implementations can

  additionally be given \"suitability scores\", so that

  when multiple possible choices could be made, the

  library can choose the \"best\" one.'
license-name: PublicDomain
