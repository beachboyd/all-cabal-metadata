homepage: http://quid2.org
changelog-type: text
hash: 002a0e0ae656ea8cc02a772d0bcb6ea7dbd7f2e79070959cc748ad1e7138eb38
test-bench-deps:
  flat: -any
  bytestring: -any
  base: -any
  text: -any
  array: -any
  containers: -any
  ghc-prim: -any
  tasty-quickcheck: -any
  tasty-hunit: -any
  tasty: -any
  deepseq: ==1.4.*
  QuickCheck: ! '>=2.10'
maintainer: tittoassini@gmail.com
synopsis: Principled and efficient bit-oriented binary serialization.
changelog: ! "Significant and compatibility-breaking changes.\n\nVersion 0.3.4:\n\t-
  Redisegned Generics-based instance generation (Data.Flat.Class) to reduce compilation
  time and improve encoding and decoding performance\n\t- Fixed GHCJS Double bug and
  tested GHCJS with full test suite\n\nVersion 0.3:\n\t- Removed 'flatStrict' and
  'unflatStrict' (use 'flat' and 'unflat' instead that also encode/decode strictly)\n\t-
  `unflatWith` now takes a decoder for the unpadded value (previously it expected
  a padded decoder) and decodes the padded value\n\t- Added some decoding primitives\n\t-
  Added Data.ByteString.Convert\n\nVersion 0.3.1:\n\t- Tested with ghc 8.2.1\n\t-
  Dropped dependencies on the 'cpu', 'derive' and 'tasty' packages to make it compatible
  with the Eta compiler (https://github.com/typelead/eta)\n"
basic-deps:
  bytestring: ! '>=0.10.6'
  base: ! '>=4.8 && <5'
  text: -any
  dlist: ! '>=0.6'
  array: ! '>=0.5.1.0'
  containers: -any
  ghc-prim: -any
  deepseq: ! '>=1.4'
  pretty: ! '>=1.1.2'
  mono-traversable: ! '>=0.10.0.2'
  primitive: -any
  vector: -any
all-versions:
- '0.2'
- '0.2.2'
- '0.3'
- '0.3.2'
- '0.3.4'
author: Pasqualino `Titto` Assini
latest: '0.3.4'
description-type: markdown
description: ! "\n[![Build Status](https://travis-ci.org/Quid2/flat.svg?branch=master)](https://travis-ci.org/Quid2/flat)\n[![Hackage
  version](https://img.shields.io/hackage/v/flat.svg)](http://hackage.haskell.org/package/flat)\n\nHaskell
  implementation of [Flat](http://quid2.org/docs/Flat.pdf), a principled, portable
  and efficient binary data format ([specs](http://quid2.org)).\n\n### How To Use
  It For Fun and Profit\n\nTo (de)serialise a data type, make it an instance of the
  `Flat` class.\n\nThere is `Generics` based support to automatically derive instances
  of additional types.\n\nLet's see some code, we need a couple of extensions:\n\n```haskell\n{-#
  LANGUAGE DeriveGeneric, DeriveAnyClass #-}\n```\n\nImport the Flat library:\n\n```haskell\nimport
  Data.Flat\n```\n\nDefine a couple of custom data types, deriving Generic and Flat:\n\n```haskell\ndata
  Direction = North | South | Center | East | West deriving (Show,Generic,Flat)\n```\n\n```haskell\ndata
  List a = Nil | Cons a (List a) deriving (Show,Generic,Flat)\n```\n\nFor encoding,
  use `flat`, for decoding, use `unflat`:\n\n```haskell\nunflat . flat $ Cons North
  (Cons South Nil) :: Decoded (List Direction)\n-> Right (Cons North (Cons South Nil))\n```\n\n\nFor
  the decoding to work correctly, you will naturally need to know the type of the
  serialised data. This is ok for applications that do not require long-term storage
  and that do not need to communicate across independently evolving agents. For those
  who do, you will need to supplement `flat` with something like [zm](https://github.com/Quid2/zm).\n\n####
  Define Instances for Abstract/Primitive types\n\n A set of primitives are available
  to define `Flat` instances for abstract or primitive types.\n\n Instances for some
  common, primitive or abstract data types (Bool,Words,Int,String,Text,ByteStrings,Tuples,
  Lists, Sequences, Maps ..) are already defined in [Data.Flat.Instances](https://github.com/Quid2/flat/blob/master/src/Data/Flat/Instances.hs).\n\n####
  Optimal Bit-Encoding\n\nA pecularity of Flat is that it uses an optimal bit-encoding
  rather than the usual byte-oriented one.\n\n To see this, let's define a pretty
  printing function: `bits` encodes a value as a sequence of bits, `prettyShow` displays
  it nicely:\n\n```haskell\np :: Flat a => a -> String\np = prettyShow . bits\n```\n\nNow
  some encodings:\n\n```haskell\np West\n-> \"111\"\n```\n\n\n```haskell\np (Nil::List
  Direction)\n-> \"0\"\n```\n\n\n```haskell\naList = Cons North (Cons South (Cons
  Center (Cons East (Cons West Nil))))\np aList\n-> \"10010111 01110111 10\"\n```\n\n\nAs
  you can see, `aList` fits in less than 3 bytes rather than 11 as would be the case
  with other Haskell byte oriented serialisation packages like `binary` or `store`.\n\nFor
  the serialisation to work with byte-oriented devices or storage, we need to add
  some padding:\n\n```haskell\nf :: Flat a => a -> String\nf = prettyShow . paddedBits\n```\n\n```haskell\nf
  West\n-> \"11100001\"\n```\n\n\n```haskell\nf (Nil::List Direction)\n-> \"00000001\"\n```\n\n\n```haskell\nf
  $ Cons North (Cons South (Cons Center (Cons East (Cons West Nil))))\n-> \"10010111
  01110111 10000001\"\n```\n\nThe padding is a sequence of 0s terminated by a 1 running
  till the next byte boundary (if we are already at a byte boundary it will add an
  additional byte of value 1, that's unfortunate but there is a good reason for this,
  check the [specs](http://quid2.org/docs/Flat.pdf)).\n\nByte-padding is automatically
  added by the function `flat` and removed by `unflat`.\n\n### Performance\n\nFor
  some hard data, see this [comparison of the major haskell serialisation libraries](https://github.com/haskell-perf/serialization).\n\nBriefly:\n
  * Size: `flat` produces significantly smaller binaries than all other libraries
  (3/4 times usually)\n * Encoding: `store` and `flat` are usually faster\n * Decoding:
  `store`, `flat` and `cereal` are usually faster\n * Transfer time (serialisation
  time + transport time on the network + deserialisation at the receiving end): `flat`
  is usually faster for all but the highest network speeds\n\n### Compatibility\n\n####
  [GHC](https://www.haskell.org/ghc/) \n\nTested with:\n  * [ghc](https://www.haskell.org/ghc/)
  7.10.3, 8.0.2, 8.2.2, 8.4.4 and 8.6.1 (x64)\n\nShould also work with (not recently
  tested):\n  * [ghc](https://www.haskell.org/ghc/) 7.10.3/LLVM 3.5.2 (Arm7)\n\n####
  \ [GHCJS](https://github.com/ghcjs/ghcjs)\n \nPasses all tests in the `flat` testsuite,
  except for those relative to short bytestrings (Data.ByteString.Short) that are
  unsupported by `ghcjs`.\n\nCheck [stack-ghcjs.yaml](https://github.com/Quid2/flat/blob/master/stack-ghcjs.yaml)
  to see with what versions of `ghcjs` it has been tested.\n\nIf you use a different
  version of `ghcjs`, you might want to run the test suite by setting your compiler
  in [stack-ghcjs.yaml](https://github.com/Quid2/flat/blob/master/stack-ghcjs.yaml)
  and then running:\n\n`stack test --stack-yaml=stack-ghcjs.yaml`\n\nNOTE: Versions
  prior to 0.33 encode `Double` values incorrectly when they are not aligned with
  a byte boundary.\n\nNOTE: A native [TypeScript/JavaScript version](https://github.com/Quid2/ts)
  of `flat` is under development.\n\n#### [ETA](https://eta-lang.org/)\n\nIt builds
  (with etlas 1.5.0.0 and eta eta-0.8.6b2 under macOS Sierra) and seems to be working,
  though the full test suite could not be run due to Eta's issues compiling some of
  the test suite dependencies.\n\n### Installation\n\nGet the latest stable version
  from [hackage](https://hackage.haskell.org/package/flat).\n\n### Known Bugs and
  Infelicities\n\n#### Longish compilation times\n\n'flat` relies more than other
  serialisation libraries on extensive inlining for its good performance, this unfortunately
  leads to longer compilation times. \n\nIf you have many data types or very large
  ones this might become an issue.\n\nA couple of good practices that will eliminate
  or mitigate this problem are:\n\n* During development, turn optimisations off (`stack
  --fast` or `-O0` in the cabal file).\n\n* Keep your serialisation code in a separate
  module(s).\n\n#### Data types with more than 512 constructors are currently unsupported\n\nSee
  also the [full list of open issues](https://github.com/Quid2/flat/issues).\n\n###
  Acknowledgements\n\n `flat` reuses ideas and readapts code from various packages,
  mainly: `store`, `binary-bits` and `binary` and includes contributions from Justus
  Sagem√ºller.\n"
license-name: BSD3
