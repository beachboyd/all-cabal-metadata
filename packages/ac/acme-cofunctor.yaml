homepage: https://github.com/jaspervdj/acme-cofunctor
changelog-type: markdown
hash: 744d6188df805652d9e78976e814c2dd93fed9bfd20c3759a3e7fe7605134144
test-bench-deps: {}
maintainer: Jasper Van der Jeugt <m@jaspervdj.be>
synopsis: A Cofunctor is a structure from category theory dual to Functor
changelog: ! "CHANGELOG\n=========\n\n- 0.1.1.0 (2017-05-13)\n    * Add `Data.Cofunctor.Cocoyoneda`
  module\n\n- 0.1.0.0 (2014-11-28)\n    * Initial release\n"
basic-deps:
  base: ! '>=4 && <5'
all-versions:
- 0.1.0.0
- 0.1.1.0
author: Jasper Van der Jeugt <m@jaspervdj.be>
latest: 0.1.1.0
description-type: markdown
description: ! "acme-cofunctor\n==============\n\nA `Cofunctor` is a structure from
  category theory dual to `Functor`.\n\nWe all know that a `Functor` is defined by
  the operation 'fmap':\n\n    fmap :: (a -> b) -> (f a -> f b)\n\nThis means that
  its dual must be defined by the following operation:\n\n    cofmap :: (b -> a) ->
  (f b -> f a)\n\nSince beginning his investigations, the author of this package has
  discovered\nthat this pattern is _at least_ as commonly used as `Functor`. In fact,
  many\nubiquitous Haskell types (e.g. `[]`, `Maybe`, `((->) a)` turn out to have
  a\n`Cofunctor` instance.\n"
license-name: BSD-3-Clause
