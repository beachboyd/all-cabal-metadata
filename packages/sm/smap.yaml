homepage: https://github.com/wyager/smap#readme
changelog-type: markdown
hash: 4e868efe8c3b42c8cb261b0cee141aa4ee24846736f826f5d67e0af66bd5975d
test-bench-deps:
  streaming: -any
  bytestring: -any
  base: ! '>=4.7 && <5'
  unordered-containers: -any
  text: -any
  strict: -any
  smap: -any
  hashable: -any
  attoparsec: -any
  siphash: -any
  transformers: -any
  optparse-applicative: -any
  streaming-bytestring: -any
  resourcet: -any
maintainer: will@yager.io
synopsis: A command line tool for working with sets and maps
changelog: |
  # Changelog for smap

  ## Unreleased changes
basic-deps:
  streaming: -any
  bytestring: -any
  base: ! '>=4.7 && <5'
  unordered-containers: -any
  text: -any
  strict: -any
  smap: -any
  hashable: -any
  attoparsec: -any
  siphash: -any
  transformers: -any
  optparse-applicative: -any
  streaming-bytestring: -any
  resourcet: -any
all-versions:
- 0.1.0
- 0.2.0
author: Will Yager
latest: 0.2.0
description-type: markdown
description: "# smap - a command line tool for sets and maps\n\n## Installation:\n\nTo
  install from Hackage, run:\n\n```bash\ncabal install smap\n```\n\nTo install from
  source, you can use that or download this repo and run\n\n```bash\nstack install
  smap\n```\n\nYou will need [cabal](https://www.haskell.org/cabal/) or [stack](https://www.haskellstack.org)
  if you don't already have one of them. \n\n## Tutorial:\n\nThe setup:\n\n```bash\ncat
  > patients << EOF\nBob Smith\nJane Doe\nJohn Smith\nCarol Carell\nEOF\n\ncat > has_cold
  << EOF\nJane Doe\nJohn Smith\nEOF\n\ncat > has_mumps << EOF\nJane Doe\nCarol Carell\nEOF\n```\n\n###
  Simple usage (sets)\n\n#### cat - Set Union (and Deduplication)\n\nSick patients:\n\n```bash\n$
  smap cat has_cold has_mumps\nJane Doe\nJohn Smith\nCarol Carell\n```\n\nYou can
  also use `-` instead of a filename to represent stdin/stdout. (This works for any
  command.)\n\n```bash\n$ cat has_cold | smap cat - has_mumps\nJane Doe\nJohn Smith\nCarol
  Carell\n```\n\nIf you don't provide any arguments, `cat` will assume you mean stdin.\n\n```bash\n$
  cat has_cold has_mumps | smap cat\nJane Doe\nJohn Smith\nCarol Carell\n```\n\n####
  sub - Set subtraction\n\nHealthy patients:\n\n```bash\n$ smap sub patients has_cold
  has_mumps\nBob Smith\n```\n\n#### int - Set intersection\n\nPatients with both a
  cold and mumps:\n\n```bash\n$ smap int has_cold has_mumps\nJane Doe\n```\n\nIt's
  worth noting that both **int** and **sub** treat their first argument as a *stream*,
  not a *set*. This means that they won't deduplicate values from their first argument.
  In practice you will find that this is the most useful arrangement. You can always
  use `smap cat` to turn a stream into a set.\n\n\nTo put this all together, let's
  find patients who only have a cold or mumps, but not both:\n\n```bash\n$ smap sub
  <(smap cat has_cold has_mumps) <(smap int has_cold has_mumps)\nCarol Carell\nJohn
  Smith\n```\n\n\nIf you haven't seen the `<(command)` syntax before, it's a very
  useful shell tool called [process substitution](https://www.tldp.org/LDP/abs/html/process-sub.html).\n\n###
  Advanced usage (maps)\n\nWhen using `smap` with sets, the behavior is pretty straightforward.
  It gets a bit more complicated when\ndealing with maps.\n\nIf you provide `smap`
  with a filepath, it will construct a map where the keys equal the values. (This\nis
  equivalent to a set). If you pass in `+file1,file2` \nas an argument, `smap` will
  construct a map using lines from file1 as keys and lines from file2 as values. \n\nWe
  can get a list of patient last names using `cut -f 2 -d ' ' <patient file>`\n\n####
  Pick one patient from each family:\n\n```bash\n$ smap cat +<(cut -f 2 -d ' ' patients),patients\nBob
  Smith\nJane Doe\nCarol Carell\n```\n\nTo understand the above:\n\n* `<(cut -f 2
  -d ' ' patients)` gets a list of all the patients' last names and creates a pipe
  containing this list. \n* `+<(cut -f 2 -d ' ' patients),patients` constructs a stream
  where the keys are the last names and the values are the whole names.\n\n`cat` deduplicates
  by key, so if we see a second (or third, or fourth, etc.) person from a given family
  we don't print them out.\n\n\n#### Patients who have family members with a cold:\n\n```bash\n$
  smap int +<(cut -f 2 -d ' ' patients),patients <(cut -f 2 -d ' ' has_cold)\nBob
  Smith\nJane Doe\nJohn Smith\n```\n\nTo understand the above:\n\n* `<(cut -f 2 -d
  ' ' patients)` gets a list of all the patients' last names.\n* `+<(cut -f 2 -d '
  ' patients),patients` constructs a stream where the keys are the last names and
  the values are the whole names.\n* `<(cut -f 2 -d ' ' has_cold)` gets a list of
  family names of everyone who has a cold.\n\nSo `int` is filtering the first argument
  (treated as a `key,value` stream) by the keys present in the second argument.\n\n###
  Approximate mode\n\nIf you're processing lots of lines and running up against memory
  limits, \nyou can use the `--approximate` or `-a` option to keep track of a 64-bit
  hash \nof each line instead of the entire line. You can also use \n`--approx-with-key`
  or `-k` if you want to specify the SipHash key.\n"
license-name: BSD-3-Clause
