homepage: https://github.com/wyager/smap#readme
changelog-type: markdown
hash: bc2e4dda23cb3554ce81175af7119b44437571d61e576c29953fa510afb41c60
test-bench-deps:
  streaming: -any
  bytestring: -any
  base: ! '>=4.7 && <5'
  unordered-containers: -any
  text: -any
  strict: -any
  smap: -any
  hashable: -any
  attoparsec: -any
  siphash: -any
  transformers: -any
  optparse-applicative: -any
  streaming-bytestring: -any
  resourcet: -any
maintainer: will@yager.io
synopsis: A command line tool for working with sets and maps
changelog: |
  # Changelog for smap

  ## Unreleased changes
basic-deps:
  streaming: -any
  bytestring: -any
  base: ! '>=4.7 && <5'
  unordered-containers: -any
  text: -any
  strict: -any
  smap: -any
  hashable: -any
  attoparsec: -any
  siphash: -any
  transformers: -any
  optparse-applicative: -any
  streaming-bytestring: -any
  resourcet: -any
all-versions:
- 0.1.0
author: Will Yager
latest: 0.1.0
description-type: markdown
description: "# smap - a command line tool for sets and maps\n\n## Installation:\n\nTo
  install from Hackage, run:\n\n```bash\ncabal install smap\n```\n\nTo install from
  source, you can use that or download this repo and run\n\n```bash\nstack install
  smap\n```\n\nYou will need [cabal](https://www.haskell.org/cabal/) or [stack](https://www.haskellstack.org)
  if you don't already have one of them. \n\n## Tutorial:\n\nThe setup:\n\n```bash\ncat
  > patients << EOF\nBob Smith\nJane Doe\nJohn Smith\nCarol Carell\nEOF\n\ncat > has_cold
  << EOF\nJane Doe\nJohn Smith\nEOF\n\ncat > has_mumps << EOF\nJane Doe\nCarol Carell\nEOF\n```\n\n###
  Simple usage (sets)\n\n#### cat - Set Union (and Deduplication)\n\nSick patients:\n\n```bash\n$
  smap cat has_cold has_mumps\nJane Doe\nJohn Smith\nCarol Carell\n```\n\nYou can
  also use `-` instead of a filename to represent stdin/stdout. (This works for any
  command.)\n\n```bash\n$ cat has_cold | smap cat - has_mumps\nJane Doe\nJohn Smith\nCarol
  Carell\n```\n\nIf you don't provide any arguments, `cat` will assume you mean stdin.\n\n```bash\n$
  cat has_cold has_mumps | smap cat\nJane Doe\nJohn Smith\nCarol Carell\n```\n\n####
  sub - Set subtraction\n\nHealthy patients:\n\n```bash\n$ smap sub patients has_cold
  has_mumps\nBob Smith\n```\n\n#### int - Set intersection\n\nPatients with both a
  cold and mumps:\n\n```bash\n$ smap int has_cold has_mumps\nJane Doe\n```\n\n####
  xor - Symmetric difference\n\nPatients who only have a cold or mumps, but not both:\n\n```bash\n$
  smap xor has_cold has_mumps\nCarol Carell\nJohn Smith\n```\n\n### Advanced usage
  (maps)\n\nWhen using `smap` with sets, the behavior is pretty straightforward. It
  gets a bit more complicated when\ndealing with maps.\n\nIf you provide `smap` with
  a filepath, it will construct a map where the keys equal the values. (This\nis equivalent
  to a set). If you pass in `+file1,file2` \nas an argument, `smap` will construct
  a map using lines from file1 as keys and lines from file2 as values. \n\nWe can
  get a list of patient last names using `cut -f 2 -d ' ' <patient file>`\n\n####
  Pick one patient from each family:\n\n```bash\n$ smap cat +<(cut -f 2 -d ' ' patients),patients\nBob
  Smith\nJane Doe\nCarol Carell\n```\n\nTo understand the above:\n\n* `<(cut -f 2
  -d ' ' patients)` gets a list of all the patients' last names and creates a virtual
  file with this list. See [bash process substitution](https://www.tldp.org/LDP/abs/html/process-sub.html).\n*
  `+<(cut -f 2 -d ' ' patients),patients` constructs a stream where the keys are the
  last names and the values are the whole names.\n\n`cat` deduplicates by key, so
  if we see a second (or third, or fourth, etc.) person from a given family we don't
  print them out.\n\n\n#### Patients who have family members with a cold:\n\n```bash\n$
  smap int +<(cut -f 2 -d ' ' patients),patients <(cut -f 2 -d ' ' has_cold)\nBob
  Smith\nJane Doe\nJohn Smith\n```\n\nTo understand the above:\n\n* `<(cut -f 2 -d
  ' ' patients)` gets a list of all the patients' last names.\n* `+<(cut -f 2 -d '
  ' patients),patients` constructs a stream where the keys are the last names and
  the values are the whole names.\n* `<(cut -f 2 -d ' ' has_cold)` gets a list of
  family names of everyone who has a cold.\n\nSo `int` is filtering the first argument
  (treated as a `key,value` stream) by the keys present in the second argument.\n\n###
  Approximate mode\n\nIf you're processing lots of lines and running up against memory
  limits, \nyou can use the `--approximate` option to keep track of a 64-bit hash
  \nof each line instead of the entire line.\n"
license-name: BSD-3-Clause
