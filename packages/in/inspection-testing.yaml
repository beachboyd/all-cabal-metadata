homepage: https://github.com/nomeata/inspection-testing
changelog-type: markdown
hash: aa18cb8518b49b3e6b39a490b259ea3ffb32406a4372a2a99abc51642b208266
test-bench-deps:
  base: ! '>=4.9 && <4.12'
  inspection-testing: -any
maintainer: mail@joachim-breitner.de
synopsis: GHC plugin to do inspection testing
changelog: ! '# Revision history for inspection-testing


  ## 0.1.1.2 -- 2017-11-12


  * Hotfix: Do not abort if there are expected failures


  ## 0.1.1.1 -- 2017-11-12


  * Show summary stats

  * Pull in less tests, to make inclusion in stackage easier


  ## 0.1.1 -- 2017-11-09


  * More complete output when `(===)` fails

  * Variant `(==-)` that ignores types when comparing terms


  ## 0.1 -- 2017-11-09


  * Repackaged as inspection-testing


  ## 0.1.1  -- 2017-09-05


  * Also run simplifier in stage 0


  ## 0.1  -- 2017-08-26


  * Initial release to hackage


  ## 0  -- 2017-02-06


  * Development of ghc-proofs commences

'
basic-deps:
  ghc: ! '>=8.0.2 && <8.4'
  base: ! '>=4.9 && <4.12'
  containers: -any
  template-haskell: -any
all-versions:
- '0.1'
- '0.1.1'
- '0.1.1.1'
- '0.1.1.2'
author: Joachim Breitner
latest: '0.1.1.2'
description-type: markdown
description: ! "Inspection Testing for Haskell\n==============================\n\nThis
  GHC plugin allows you to embed assertions about the intermediate code into\nyour
  Haskell code, and have them checked by GHC. This is called _inspection\ntesting_
  (as it automates what you do when you manually inspect the\nintermediate code).\n\nSynopsis\n--------\n\nSee
  the `Test.Inspection` module for the documentation, but there really isn't much\nmore
  to it than:\n\n```haskell\n{-# LANGUAGE TemplateHaskell #-}\n{-# OPTIONS_GHC -O
  -fplugin Test.Inspection.Plugin #-}\nmodule Simple where\n\nimport Test.Inspection\nimport
  Data.Maybe\n\nlhs, rhs :: (a -> b) -> Maybe a -> Bool\nlhs f x = isNothing (fmap
  f x)\nrhs f Nothing = True\nrhs f (Just _) = False\n\ninspect $ 'lhs === 'rhs\n```\n\nIf
  you compile this, you will reassurringly read:\n\n```\n$ ghc Simple.hs\n[1 of 1]
  Compiling Simple           ( Simple.hs, Simple.o )\nexamples/Simple.hs:14:1: lhs
  === rhs passed.\ninspection testing successful\n      expected successes: 1\n```\n\nSee
  the [`examples/`](examples/) directory for more examples of working proofs.\n\nIf
  an assertion fails, for example\n\n```haskell\nbad1, bad2 :: Int\nbad1 = 2 + 2\nbad2
  = 5\n\ninspect $ 'bad1 === 'bad2\n```\nthen the compiler will tell you so, and abort
  the compilation:\n```\n$ ghc Simple.hs -dsuppress-idinfo\n[5 of 5] Compiling Simple
  \          ( examples/Simple.hs, examples/Simple.o )\nexamples/Simple.hs:14:1: lhs
  === rhs passed.\nexamples/Simple.hs:20:1: bad1 === bad2 failed:\n    LHS:\n        bad1
  :: Int\n        bad1 = I# 4#\n\n    RHS:\n        bad2 :: Int\n        bad2 = I#
  5#\n\n\nexamples/Simple.hs: error:\n    inspection testing unsuccessful\n          expected
  successes: 1\n         unexpected failures: 1\n```\n\nWhat can I check for?\n---------------------\n\nCurrently,
  inspection-testing supports\n\n * checking two definitions to be equal (useful in
  the context of generic programming)\n * checking the absence of a certain type (useful
  in the context of list or stream fusion)\n * checking the absence of allocation
  (generally useful)\n\nPossible further applications includes\n\n * checking that
  all recursive functions are (efficiently called) join-points\n * asserting strictness
  properties (e.g. in `Data.Map.Strict`)\n * peforming some of these checks only within
  recursive loops\n\nLet me know if you need any of these, or have further ideas.\n\nHelp,
  I am drowining in Core!\n-----------------------------\n\ninspection-testing prints
  the Core more or less like GHC would, and the same\nflags can be used to control
  the level of detail. In particular, you might want\nto pass to GHC a selection of
  the following flags:\n\n    -dsuppress-idinfo -dsuppress-coercions -dsuppress-type-applications\n
  \   -dsuppress-module-prefixes -dsuppress-type-signatures -dsuppress-uniques\n\nCan
  I comment or help?\n----------------------\n\nSure! We can use the GitHub issue
  tracker for discussions, and obviously\ncontributions are welcome.\n\n"
license-name: MIT
