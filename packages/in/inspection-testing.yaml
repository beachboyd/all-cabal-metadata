homepage: https://github.com/nomeata/inspection-testing
changelog-type: markdown
hash: 60705ff40e6f03905a1eebeee96b0411324c1e1609911888a67853dd71376789
test-bench-deps:
  bytestring: -any
  base: ! '>=4.9 && <4.12'
  text: ==1.2.2.2
  inspection-testing: -any
  generic-lens: ==0.4.0.1
maintainer: mail@joachim-breitner.de
synopsis: GHC plugin to do inspection testing
changelog: ! '# Revision history for inspection-testing


  ## 0.1.1 -- 2017-11-09


  * More complete output when `(===)` fails

  * Variant `(==-)` that ignores types when comparing terms


  ## 0.1 -- 2017-11-09


  * Repackaged as inspection-testing


  ## 0.1.1  -- 2017-09-05


  * Also run simplifier in stage 0


  ## 0.1  -- 2017-08-26


  * Initial release to hackage


  ## 0  -- 2017-02-06


  * Development of ghc-proofs commences

'
basic-deps:
  ghc: ! '>=8.0.2 && <8.4'
  base: ! '>=4.9 && <4.12'
  containers: -any
  template-haskell: -any
all-versions:
- '0.1'
- '0.1.1'
author: Joachim Breitner
latest: '0.1.1'
description-type: markdown
description: ! "Inspection Testing for Haskell\n==============================\n\nThis
  GHC plugin allows you to embed assertions about the intermediate code into\nyour
  Haskell code, and have them checked by GHC. This is called _inspection\ntesting_
  (as it automates what you do when you manually inspect the\nintermediate code).\n\nSynopsis\n--------\n\nSee
  the `Test.Inspection` module for the documentation, but there really isn't much\nmore
  to it than:\n\n```haskell\n{-# LANGUAGE TemplateHaskell #-}\n{-# OPTIONS_GHC -O
  -fplugin Test.Inspection.Plugin #-}\nmodule Simple where\n\nimport Test.Inspection\nimport
  Data.Maybe\n\nlhs, rhs :: (a -> b) -> Maybe a -> Bool\nlhs f x = isNothing (fmap
  f x)\nrhs f Nothing = True\nrhs f (Just _) = False\n\ninspect $ 'lhs === 'rhs\n```\n\nIf
  you compile this, you will reassurringly read:\n\n```\n$ ghc Simple.hs\n[1 of 1]
  Compiling Simple           ( Simple.hs, Simple.o )\nexamples/Simple.hs:14:1: inspecting
  lhs === rhs\nTest.Inspection tested 1 obligation\n```\n\nSee the [`examples/`](examples/)
  directory for more examples of working proofs.\n\nIf an assertion fails, for example\n\n```haskell\nbad1,
  bad2 :: Int\nbad1 = 2 + 2\nbad2 = 5\n\ninspect $ 'bad1 === 'bad2\n```\nthen the
  compiler will tell you so, and abort the compilation:\n```\n$ ghc Simple.hs\n[1
  of 1] Compiling Simple           ( Simple.hs, Simple.o )\nexamples/Simple.hs:20:1:
  inspecting bad1 === bad2\nObligation fails\n    LHS: ghc-prim-0.5.1.0:GHC.Types.I#
  4#\n    RHS: ghc-prim-0.5.1.0:GHC.Types.I# 5#\nexamples/Simple.hs: error: inspection
  testing unsuccessful\n```\n\nWhat can I check for?\n---------------------\n\nCurrently,
  inspection-testing supports\n\n * checking two definitions to be equal (useful in
  the context of generic programming)\n * checking the absence of a certain type (useful
  in the context of list or stream fusion)\n * checking the absence of allocation
  (generally useful)\n\nPossible further applications includes\n\n * checking that
  all recursive functions are (efficiently called) join-points\n * asserting strictness
  properties (e.g. in `Data.Map.Strict`)\n * peforming some of these checks only within
  recursive loops\n\nLet me know if you need any of these, or have further ideas.\n\nHelp,
  I am drowining in Core!\n-----------------------------\n\ninspection-testing prints
  the Core more or less like GHC would, and the same\nflags can be used to control
  the level of detail. In particular, you might want\nto pass to GHC a selection of
  the following flags:\n\n    -dsuppress-idinfo -dsuppress-coercions -dsuppress-type-applications\n
  \   -dsuppress-module-prefixes -dsuppress-type-signatures -dsuppress-uniques\n\nCan
  I comment or help?\n----------------------\n\nSure! We can use the GitHub issue
  tracker for discussions, and obviously\ncontributions are welcome.\n\n"
license-name: MIT
