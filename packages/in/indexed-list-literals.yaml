homepage: https://github.com/davidm-d/indexed-list-literals
changelog-type: markdown
hash: 446356275aaa585d259c14953e1c94856127e6638eb34aa1610a44d898ec0647
test-bench-deps:
  base: -any
  indexed-list-literals: -any
maintainer: dmillardurrant@gmail.com
synopsis: Type safe indexed list literals
changelog: ! 'Changed GHC.TypeNats to GHC.TypeLits to allow older versions of GHC
  to build the package

'
basic-deps:
  base: ! '>=4.9 && <=4.11'
  OneTuple: ! '>=0.2.1'
all-versions:
- '0.1.0.0'
- '0.1.0.1'
author: David Millar-Durrant
latest: '0.1.0.1'
description-type: haddock
description: ! 'This is an incredibly simple library, which makes writing lists where
  the length is known at compile time a little bit nicer.


  If you write a function with the signature


  > vector :: ILL input length output => input -> Vector length output

  then


  > v :: Vector 3 Int

  > v = vector (1,2,3)

  >

  > x :: Vector 0 Double

  > x = vector $ ZeroTuple @Double

  >

  > y :: Vector 1 Double

  > y = vector (OneTuple 1)

  >

  > z :: Vector 2 String

  > z = vector ("Hello", "World")


  If want matrix literals you can write a function


  > matrix :: (ILL row width ty, ILL matrix height row) => matrix -> Matrix width
  height ty

  then


  > a :: Matrix 0 0 Bool

  > a = matrix $ ZeroTuple @(ZeroTuple Bool)

  >

  > b :: Matrix 1 2 String

  > b = matrix $ OneTuple ("Hello","World")

  >

  > c :: Matrix 4 5 Double

  > c = matrix ((1,2,3,0,0)

  >            ,(4,5,6,0,0)

  >            ,(7,8,9,0,0)

  >            ,(0,0,0,0,0))

  The full code is in test\/Docs.hs


  This only supports literals of length up to 20, though that can be easily extended
  using the code generator in src\/Data\/IndexedListLiterals.hs'
license-name: BSD3
