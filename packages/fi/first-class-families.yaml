homepage: https://github.com/Lysxia/first-class-families#readme
changelog-type: markdown
hash: 4759bada637c8ee53758495e938591a14d259db8343ab7b4b313bbb1dfc770cf
test-bench-deps:
  first-class-families: -any
  base: -any
maintainer: lysxia@gmail.com
synopsis: First class type families
changelog: |
  # 0.7.0.0

  - Add `Unfoldr`, `Concat`, `ConcatMap`, `Replicate`, `Take`, `Drop`,
    `TakeWhile`, `DropWhile`, `Reverse` to `Data.List`. (gspia)
  - Change `Elem`, `Lookup`, `Zip` to be `data` instead of `type` synonyms.
  - Fix performance of `Filter` and `Find`.

  # 0.6.0.0

  - Add `Fcf.Utils.Case` and `(Fcf.Combinators.>>=)` (TheMatten)
  - Deprecate `Fcf.Bool.Guarded`
  - GHC 8.8 compatibility

  # 0.5.0.0

  - Modularized library

  - `Fcf.Utils`:

      + Add `TError`
      + Rename `Collapse` to `Constraints`

  - `Fcf.Data.List`: Added `Cons`, `Last`, `Init`, `Elem`

  # 0.4.0.0

  - New functions (blmage)

      + `LiftM`, `LiftM2`, `LiftM3`
      + `(<=)`, `(>=)`, `(<)`, `(>)`
      + `Guarded`, `Guard((:=))`, `Otherwise`

  # 0.3.0.1

  - GHC 8.6 compatibility

  # 0.3.0.0

  - More new functions, (isovector)

  # 0.2.0.0

  - A whole bunch of basic functions (isovector)
  - Remove `Traverse` (now `Map`), `BimapPair`, `BimapEither` (now `Bimap`)

  # 0.1.0.0

  Initial version
basic-deps:
  base: ! '>=4.9 && <4.14'
all-versions:
- 0.1.0.0
- 0.2.0.0
- 0.3.0.0
- 0.3.0.1
- 0.4.0.0
- 0.5.0.0
- 0.6.0.0
- 0.7.0.0
author: Li-yao Xia
latest: 0.7.0.0
description-type: markdown
description: |
  # First-class type families [![Hackage](https://img.shields.io/hackage/v/first-class-families.svg)](https://hackage.haskell.org/package/first-class-families) [![Build Status](https://travis-ci.org/Lysxia/first-class-families.svg)](https://travis-ci.org/Lysxia/first-class-families)

  For example, consider this simple type family:

  ```haskell
  type family   FromMaybe (a :: k) (m :: Maybe k) :: k
  type instance FromMaybe a 'Nothing  = a
  type instance FromMaybe a ('Just b) = b
  ```

  With first-class-families (fcfs), it translates to a `data` declaration
  and instances for a single `Eval` family:

  ```haskell
  import Fcf

  data FromMaybe :: k -> Maybe k -> Exp k
  type instance Eval (FromMaybe a 'Nothing)  = a
  type instance Eval (FromMaybe a ('Just b)) = b
  ```

  That way, the `FromMaybe` constructor can be partially applied,
  and passed to higher-order fcfs such as `Map`:

  ```haskell
  Eval (Map (FromMaybe 0) '[ 'Just 1, 'Nothing ])  =  '[ 1, 0 ] :: [Nat]
  ```

  Essential language extensions:

  ```haskell
  {-# LANGUAGE
      DataKinds,
      PolyKinds,
      TypeFamilies,
      TypeInType,
      TypeOperators,
      UndecidableInstances #-}
  ```

  ## See also

  [Haskell with only one type family](http://blog.poisson.chat/posts/2018-08-06-one-type-family.html) (blogpost)

  ---

  Contributions are welcome. Feel free to open an issue or make a PR on
  [Github](https://github.com/Lysxia/first-class-families)!
license-name: MIT
