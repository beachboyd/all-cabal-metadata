homepage: https://github.com/ChrisPenner/lens-regex-pcre#readme
changelog-type: markdown
hash: eb079a3b5bf80adf81044f9aa82f1c8e1e7c8d1f531e6129b1a162247dd91e6d
test-bench-deps:
  pcre-light: -any
  pcre-heavy: -any
  base: ! '>=4.7 && <5'
  hspec: -any
  text: -any
  lens: -any
  lens-regex-pcre: -any
  template-haskell: -any
maintainer: example@example.com
synopsis: ''
changelog: "# Changelog for lens-regex-pcre\n\n# 0.3.0.0 \nUnify `iregex` into `regex`
  as a single indexed traversal\n\n# 0.2.0.0 \nUnify `grouped`, `groups`, and `igroups`
  into just `groups` with optional traversal\n\n# 0.1.1.0 \nAdds `grouped` and `matchAndGroups`\n\n#
  0.1.0.1 \nDoc fixes\n\n# 0.1.0.0 \nInitial Release\n"
basic-deps:
  pcre-light: -any
  pcre-heavy: -any
  base: ! '>=4.7 && <5'
  text: -any
  lens: -any
  template-haskell: -any
all-versions:
- 0.1.0.0
- 0.1.0.1
- 0.1.1.0
- 0.2.0.0
- 0.3.0.0
author: Chris Penner
latest: 0.3.0.0
description-type: markdown
description: "# lens-regex-pcre\n\n[Hackage and Docs](http://hackage.haskell.org/package/lens-regex-pcre)\n\n*
  NOTE: I don't promise that this is __fast__ yet, nor do I have any benchmarks;\n*
  NOTE: currently only supports `Text` but should be generalizable to more string-likes;
  open an issue if you need it\n\nBased on `pcre-heavy`; so it should support any
  regexes which it supports.\nI'll likely add a way to pass settings in soon; make
  an issue if you need this :)\n\nWorking with Regexes in Haskell kinda sucks; it's
  tough to figure out which libs\nto use, and even after you pick one it's tough to
  figure out how to use it.\n\nAs it turns out; regexes are a very lens-like tool;
  Traversals allow you to select\nand alter zero or more matches; traversals can even
  carry indexes so you know which match or group you're working\non.\n\nNote that
  all traversals in this library are not techically lawful, as the semantics of regular
  expressions don't allow for it;\nThey break the 'multi-set' idempotence law of traversals
  (same one broken by `filtered` from `lens`); in reality this isn't usually a problem
  (I've literally never encountered an issue with it); but consider yourself warned.
  Test your code.\n\nHere are a few examples:\n\n```haskell\ntxt :: Text\ntxt = \"raindrops
  on roses and whiskers on kittens\"\n\n-- Search\nλ> has (regex [rx|whisk|]) txt\nTrue\n\n--
  Get matches\nλ> txt ^.. regex [rx|\\br\\w+|] . match\n[\"raindrops\",\"roses\"]\n\n--
  Edit matches\nλ> txt & regex [rx|\\br\\w+|] . match %~ T.intersperse '-' . T.toUpper\n\"R-A-I-N-D-R-O-P-S
  on R-O-S-E-S and whiskers on kittens\"\n\n-- Get Groups\nλ> txt ^.. regex [rx|(\\w+)
  on (\\w+)|] . groups\n[[\"raindrops\",\"roses\"],[\"whiskers\",\"kittens\"]]\n\n--
  Edit Groups\nλ> txt & regex [rx|(\\w+) on (\\w+)|] . groups %~ reverse\n\"roses
  on raindrops and kittens on whiskers\"\n\n-- Get the third match\nλ> txt ^? iregex
  [rx|\\w+|] . index 2 . match\nJust \"roses\"\n\n-- Match integers, 'Read' them into
  ints, then sort them in-place\n-- dumping them back into the source text afterwards.\nλ>
  \"Monday: 29, Tuesday: 99, Wednesday: 3\" \n   & partsOf (iregex [rx|\\d+|] . match
  . unpacked . _Show @Int) %~ sort\n\"Monday: 3, Tuesday: 29, Wednesday: 99\"\n\n```\n\nBasically
  anything you want to do is possible somehow.\n\nExpected behaviour (and examples)
  can be found in the test suite:\n\n```haskell\ndescribe \"regex\" $ do\n    describe
  \"match\" $ do\n        describe \"getting\" $ do\n            it \"should find
  one match\" $ do\n                \"abc\" ^.. regex [rx|b|] . match\n                `shouldBe`
  [\"b\"]\n\n            it \"should find many matches\" $ do\n                \"a
  b c\" ^.. regex [rx|\\w|] . match\n                `shouldBe` [\"a\", \"b\", \"c\"]\n\n
  \           it \"should fold\" $ do\n                \"a b c\" ^. regex [rx|\\w|]
  . match\n                `shouldBe` \"abc\"\n\n            it \"should match with
  a group\" $ do\n                \"a b c\" ^.. regex [rx|(\\w)|] . match\n                `shouldBe`
  [\"a\", \"b\", \"c\"]\n\n            it \"should match with many groups\" $ do\n
  \               \"a b c\" ^.. regex [rx|(\\w) (\\w)|] . match\n                `shouldBe`
  [\"a b\"]\n\n            it \"should be greedy when overlapping\" $ do\n                \"abc\"
  ^.. regex [rx|\\w+|] . match\n                `shouldBe`[\"abc\"]\n\n            it
  \"should respect lazy modifiers\" $ do\n                \"abc\" ^.. regex [rx|\\w+?|]
  . match\n                `shouldBe`[\"a\", \"b\", \"c\"]\n\n        describe \"setting\"
  $ do\n            it \"should allow setting\" $ do\n                (\"one two three\"
  & regex [rx|two|] . match .~ \"new\")\n                `shouldBe` \"one new three\"\n\n
  \           it \"should allow setting many\" $ do\n                (\"one <two>
  three\" & regex [rx|\\w+|] . match .~ \"new\")\n                `shouldBe` \"new
  <new> new\"\n\n            it \"should allow mutating\" $ do\n                (\"one
  two three\" & regex [rx|two|] . match %~ (<> \"!!\"). T.toUpper)\n                `shouldBe`
  \"one TWO!! three\"\n\n            it \"should allow mutating many\" $ do\n                (\"one
  two three\" & regex [rx|two|] . match %~ T.toUpper)\n                `shouldBe`
  \"one TWO three\"\n\ndescribe \"iregex\" $ do\n    describe \"match\" $ do\n        it
  \"should allow folding with index\" $ do\n            (\"one two three\" ^.. (iregex
  [rx|\\w+|] <. match) . withIndex)\n            `shouldBe` [(0, \"one\"), (1, \"two\"),
  (2, \"three\")]\n\n        it \"should allow getting with index\" $ do\n            (\"one
  two three\" ^.. iregex [rx|\\w+|] . index 1 . match)\n            `shouldBe` [\"two\"]\n\n
  \       it \"should allow setting with index\" $ do\n            (\"one two three\"
  & iregex [rx|\\w+|] <. match .@~ T.pack . show)\n            `shouldBe` \"0 1 2\"\n\n
  \       it \"should allow mutating with index\" $ do\n            (\"one two three\"
  & iregex [rx|\\w+|] <. match %@~ \\i s -> (T.pack $ show i) <> \": \" <> s)\n            `shouldBe`
  \"0: one 1: two 2: three\"\n\ndescribe \"groups\" $ do\n    describe \"getting\"
  $ do\n        it \"should get groups\" $ do\n            \"a b c\" ^.. regex [rx|(\\w)|]
  . groups\n            `shouldBe` [[\"a\"], [\"b\"], [\"c\"]]\n\n        it \"should
  get multiple groups\" $ do\n            \"raindrops on roses and whiskers on kittens\"
  ^.. regex [rx|(\\w+) on (\\w+)|] . groups\n            `shouldBe` [[\"raindrops\",\"roses\"],[\"whiskers\",\"kittens\"]]\n\n
  \       it \"should allow getting a specific index\" $ do\n            (\"one two
  three four\" ^.. regex [rx|(\\w+) (\\w+)|] . groups . ix 1)\n            `shouldBe`
  [\"two\", \"four\"]\n\n    describe \"setting\" $ do\n        it \"should allow
  setting groups as a list\" $ do\n            (\"one two three\" & regex [rx|(\\w+)
  (\\w+)|] . groups .~ [\"1\", \"2\"])\n            `shouldBe` \"1 2 three\"\n\n        it
  \"should allow editing when result list is the same length\" $ do\n            (\"raindrops
  on roses and whiskers on kittens\" & regex [rx|(\\w+) on (\\w+)|] . groups %~ reverse)\n
  \           `shouldBe` \"roses on raindrops and kittens on whiskers\"\n\n    describe
  \"traversed\" $ do\n        it \"should allow setting all group matches\" $ do\n
  \           (\"one two three\" & regex [rx|(\\w+) (\\w+)|] . groups . traversed
  .~ \"new\")\n            `shouldBe` \"new new three\"\n\n        it \"should allow
  mutating\" $ do\n            (\"one two three four\" & regex [rx|one (two) (three)|]
  . groups . traversed %~ (<> \"!!\") . T.toUpper)\n            `shouldBe` \"one TWO!!
  THREE!! four\"\n\n        it \"should allow folding with index\" $ do\n            (\"one
  two three four\" ^.. regex [rx|(\\w+) (\\w+)|] . groups . traversed . withIndex)\n
  \           `shouldBe` [(0, \"one\"), (1, \"two\"), (0, \"three\"), (1, \"four\")]\n\n
  \       it \"should allow setting with index\" $ do\n            (\"one two three
  four\" & regex [rx|(\\w+) (\\w+)|] . groups . traversed .@~ T.pack . show)\n            `shouldBe`
  \"0 1 0 1\"\n\n        it \"should allow mutating with index\" $ do\n            (\"one
  two three four\" & regex [rx|(\\w+) (\\w+)|] . groups . traversed %@~ \\i s -> (T.pack
  $ show i) <> \": \" <> s)\n            `shouldBe` \"0: one 1: two 0: three 1: four\"\n\n
  \       it \"should compose indices with matches\" $ do\n            (\"one two
  three four\" ^.. (iregex [rx|(\\w+) (\\w+)|] <.> groups . traversed) . withIndex)\n
  \           `shouldBe` [((0, 0), \"one\"), ((0, 1), \"two\"), ((1, 0), \"three\"),
  ((1, 1), \"four\")]\n\ndescribe \"matchAndGroups\" $ do\n    it \"should get match
  and groups\" $ do\n        \"raindrops on roses and whiskers on kittens\" ^.. regex
  [rx|(\\w+) on (\\w+)|] . matchAndGroups\n        `shouldBe` [(\"raindrops on roses\",[\"raindrops\",\"roses\"]),(\"whiskers
  on kittens\",[\"whiskers\",\"kittens\"])]\n```\n"
license-name: BSD-3-Clause
