homepage: https://github.com/ChrisPenner/lens-regex-pcre#readme
changelog-type: markdown
hash: 5200b6a2f41c9ed8251800fb583873889033139ff14ce9f23ba88a771a0a1439
test-bench-deps:
  pcre-light: -any
  pcre-heavy: -any
  base: ! '>=4.7 && <5'
  hspec: -any
  text: -any
  lens: -any
  lens-regex-pcre: -any
  template-haskell: -any
maintainer: example@example.com
synopsis: ''
changelog: "# Changelog for lens-regex-pcre\n\n# 1.1.0 \nAdds `grouped` and `matchAndGroups`\n\n#
  1.0.1 \nDoc fixes\n\n# 1.0.0 \nInitial Release\n"
basic-deps:
  pcre-light: -any
  pcre-heavy: -any
  base: ! '>=4.7 && <5'
  text: -any
  lens: -any
  template-haskell: -any
all-versions:
- 0.1.0.0
- 0.1.0.1
- 0.1.1.0
author: Chris Penner
latest: 0.1.1.0
description-type: markdown
description: "# lens-regex-pcre\n\n* NOTE: I don't promise that this is __fast__ yet;\n*
  NOTE: currently only supports `Text` but should be generalizable to more string-likes;
  open an issue if you need it\n\nBased on `pcre-heavy`; so it should support any
  regexes which it supports.\nI'll likely add a way to pass settings in soon; make
  an issue if you need this :)\n\nWorking with Regexes in Haskell kinda sucks; it's
  tough to figure out which libs\nto use, and even after you pick one it's tough to
  figure out how to use it.\n\nAs it turns out; regexes are a very lens-like tool;
  Traversals allow you to select\nand alter zero or more matches; traversals can even
  carry indexes so you know which match or group you're working\non.\n\n\nNote that
  all traversals in this library are not techically lawful; the break the 'multi-set'\nidempotence
  law; in reality this isn't usually a problem; but consider yourself warned. Test
  your code.\n\nHere are a few examples:\n\n```haskell\n-- Getting all matches:\n>
  \"one _two_ three _four_\" ^.. regex [rx|_\\w+_|] . match\n[\"_two_\",\"_four_\"]\n\n--
  Regex replace/mutation\n> \"one _two_ three _four_\" & regex [rx|_\\w+_|] . match
  %~ T.toUpper\n\"one _TWO_ three _FOUR_\"\n\n-- Getting groups with their index.\n>
  \"1/2 and 3/4\" ^.. regex [rx|(\\d+)/(\\d+)|] . igroups . withIndex\n[(0,\"1\"),(1,\"2\"),(0,\"3\"),(1,\"4\")]\n\n--
  Check for any matches:\n> has (regex [rx|ne+dle|]) \"a needle in a haystack\"\nTrue\n\n--
  Check for matches which also match a predicate:\n> has (regex [rx|\\w+|] . match
  . filtered ((> 7) . T.length)) \"one word here is loooooooong\"\nTrue\n\n-- Get
  the third match\n>  \"alpha beta charlie delta\" ^? (iregex [rx|\\w+|] . index 2
  . match)\nJust \"charlie\"\n\n-- Replace the third match\n> \"alpha beta charlie
  delta\" & (iregex [rx|\\w+|] . index 2 . match) .~ \"GAMMA\"\n\"alpha beta GAMMA
  delta\"\n\n-- Sort all matches alphabetically in place\n> \"*charlie* beta = _alpha_
  delta\" & partsOf (iregex [rx|[a-z]+|] . match) %~ sort\n\"*alpha* beta = _charlie_
  delta\"\n\n-- Match integers, 'Read' them into ints, then sort each match in-place\n>
  \"Monday: 29, Tuesday: 99, Wednesday: 3\" & partsOf' (iregex [rx|\\d+|] . match
  . unpacked . _Show @Int) %~ sort\n\"Monday: 3, Tuesday: 29, Wednesday: 99\"\n```\n\nBasically
  anything you want to do is possible somehow.\n\nExpected behaviour (and examples)
  can be found in the test suite:\n\n```haskell\nimport Control.Lens\nimport Control.Lens.Regex\n\ndescribe
  \"regex\" $ do                                                                                            \n
  \   describe \"match\" $ do                                                                                        \n
  \       describe \"getting\" $ do                                                                                  \n
  \           it \"should find one match\" $ do                                                                      \n
  \               \"abc\" ^.. regex [rx|b|] . match                                                                  \n
  \               `shouldBe` [\"b\"]                                                                                 \n
  \                                                                                                                \n
  \           it \"should find many matches\" $ do                                                                   \n
  \               \"a b c\" ^.. regex [rx|\\w|] . match                                                               \n
  \               `shouldBe` [\"a\", \"b\", \"c\"]                                                                       \n
  \                                                                                                                \n
  \           it \"should fold\" $ do                                                                                \n
  \               \"a b c\" ^. regex [rx|\\w|] . match                                                                \n
  \               `shouldBe` \"abc\"                                                                                 \n
  \                                                                                                                \n
  \           it \"should match with a group\" $ do                                                                  \n
  \               \"a b c\" ^.. regex [rx|(\\w)|] . match                                                             \n
  \               `shouldBe` [\"a\", \"b\", \"c\"]                                                                       \n
  \                                                                                                                \n
  \           it \"should match with many groups\" $ do                                                              \n
  \               \"a b c\" ^.. regex [rx|(\\w) (\\w)|] . match                                                        \n
  \               `shouldBe` [\"a b\"]                                                                               \n
  \                                                                                                                \n
  \           it \"should be greedy when overlapping\" $ do                                                          \n
  \               \"abc\" ^.. regex [rx|\\w+|] . match                                                                \n
  \               `shouldBe`[\"abc\"]                                                                                \n
  \                                                                                                                \n
  \           it \"should respect lazy modifiers\" $ do                                                              \n
  \               \"abc\" ^.. regex [rx|\\w+?|] . match                                                               \n
  \               `shouldBe`[\"a\", \"b\", \"c\"]                                                                        \n
  \                                                                                                                \n
  \       describe \"setting\" $ do                                                                                  \n
  \           it \"should allow setting\" $ do                                                                       \n
  \               (\"one two three\" & regex [rx|two|] . match .~ \"new\")                                             \n
  \               `shouldBe` \"one new three\"                                                                       \n
  \                                                                                                                \n
  \           it \"should allow setting many\" $ do                                                                  \n
  \               (\"one <two> three\" & regex [rx|\\w+|] . match .~ \"new\")                                           \n
  \               `shouldBe` \"new <new> new\"                                                                       \n
  \                                                                                                                \n
  \           it \"should allow mutating\" $ do                                                                      \n
  \               (\"one two three\" & regex [rx|two|] . match %~ (<> \"!!\"). T.toUpper)
  \                             \n                `shouldBe` \"one TWO!! three\"                                                                     \n
  \                                                                                                                \n
  \           it \"should allow mutating many\" $ do                                                                 \n
  \               (\"one two three\" & regex [rx|two|] . match %~ T.toUpper)                                         \n
  \               `shouldBe` \"one TWO three\"                                                                       \n
  \                                                                                                                \n
  \   describe \"groups\" $ do                                                                                       \n
  \       describe \"getting\" $ do                                                                                  \n
  \           it \"should get a group\" $ do                                                                         \n
  \               \"a b c\" ^.. regex [rx|(\\w)|] . groups                                                            \n
  \               `shouldBe` [\"a\", \"b\", \"c\"]                                                                       \n
  \                                                                                                                \n
  \           it \"should get many groups\" $ do                                                                     \n
  \               \"one two three\" ^.. regex [rx|(\\w+) (\\w+)|] . groups                                             \n
  \               `shouldBe` [\"one\", \"two\"]                                                                        \n
  \                                                                                                                \n
  \       describe \"setting\" $ do                                                                                  \n
  \           it \"should allow setting\" $ do                                                                       \n
  \               (\"one two three\" & regex [rx|(\\w+) (\\w+)|] . groups .~ \"new\")
  \                                   \n                `shouldBe` \"new new three\"
  \                                                                      \n                                                                                                                 \n
  \           it \"should allow setting many\" $ do                                                                  \n
  \               (\"one two three four\" & regex [rx|(\\w+) (\\w+)|] . groups .~
  \"new\")                               \n                `shouldBe` \"new new new
  new\"                                                                     \n                                                                                                                 \n
  \           it \"should allow mutating\" $ do                                                                      \n
  \               (\"one two three four\" & regex [rx|one (two) three|] . groups %~
  (<> \"!!\") . T.toUpper)           \n                `shouldBe` \"one TWO!! three
  four\"                                                                \n                                                                                                                 \n
  \           it \"should allow mutating\" $ do                                                                      \n
  \               (\"one two three four\" & regex [rx|one (two) (three)|] . groups
  %~ (<> \"!!\") . T.toUpper)         \n                `shouldBe` \"one TWO!! THREE!!
  four\"                                                              \n                                                                                                                 \ndescribe
  \"iregex\" $ do                                                                                           \n
  \   describe \"match\" $ do                                                                                        \n
  \       it \"should allow folding with index\" $ do                                                                \n
  \           (\"one two three\" ^.. (iregex [rx|\\w+|] <. match) . withIndex)                                        \n
  \           `shouldBe` [(0, \"one\"), (1, \"two\"), (2, \"three\")]                                                    \n
  \                                                                                                                \n
  \       it \"should allow getting with index\" $ do                                                                \n
  \           (\"one two three\" ^.. iregex [rx|\\w+|] . index 1 . match)                                             \n
  \           `shouldBe` [\"two\"]                                                                                   \n
  \                                                                                                                \n
  \       it \"should allow setting with index\" $ do                                                                \n
  \           (\"one two three\" & iregex [rx|\\w+|] <. match .@~ T.pack . show)                                      \n
  \           `shouldBe` \"0 1 2\"                                                                                   \n
  \                                                                                                                \n
  \       it \"should allow mutating with index\" $ do                                                               \n
  \           (\"one two three\" & iregex [rx|\\w+|] <. match %@~ \\i s -> (T.pack
  $ show i) <> \": \" <> s)             \n            `shouldBe` \"0: one 1: two 2:
  three\"                                                                  \n                                                                                                                 \ndescribe
  \"igroups\" $ do                                                                                          \n
  \   it \"should allow folding with index\" $ do                                                                    \n
  \       (\"one two three four\" ^.. regex [rx|(\\w+) (\\w+)|] . igroups . withIndex)
  \                                \n        `shouldBe` [(0, \"one\"), (1, \"two\"),
  (0, \"three\"), (1, \"four\")]                                           \n                                                                                                                 \n
  \   it \"should allow getting a specific index\" $ do                                                              \n
  \       (\"one two three four\" ^.. regex [rx|(\\w+) (\\w+)|] . igroups . index
  1)                                   \n        `shouldBe` [\"two\", \"four\"]                                                                               \n
  \                                                                                                                \n
  \   it \"should allow setting with index\" $ do                                                                    \n
  \       (\"one two three four\" & regex [rx|(\\w+) (\\w+)|] . igroups .@~ T.pack
  . show)                             \n        `shouldBe` \"0 1 0 1\"                                                                                     \n
  \                                                                                                                \n
  \   it \"should allow mutating with index\" $ do                                                                   \n
  \       (\"one two three four\" & regex [rx|(\\w+) (\\w+)|] . igroups %@~ \\i s
  -> (T.pack $ show i) <> \": \" <> s)    \n        `shouldBe` \"0: one 1: two 0:
  three 1: four\"                                                              \n
  \                                                                                                                \n
  \   it \"should compose indices with matches\" $ do                                                                \n
  \       (\"one two three four\" ^.. (iregex [rx|(\\w+) (\\w+)|] <.> igroups) . withIndex)
  \                           \n        `shouldBe` [((0, 0), \"one\"), ((0, 1), \"two\"),
  ((1, 0), \"three\"), ((1, 1), \"four\")]                       \n                                                                                                                 \ndescribe
  \"grouped\" $ do                                                                                          \n
  \   it \"should get all groups in batches\" $ do                                                                   \n
  \       \"raindrops on roses and whiskers on kittens\" ^.. regex [rx|(\\w+) on (\\w+)|]
  . grouped                    \n        `shouldBe` [[\"raindrops\",\"roses\"],[\"whiskers\",\"kittens\"]]
  \                                               \n    it \"should allow editing
  when result list is the same length\" $ do                                           \n
  \       (\"raindrops on roses and whiskers on kittens\" & regex [rx|(\\w+) on (\\w+)|]
  . grouped %~ reverse)         \n        `shouldBe` \"roses on raindrops and kittens
  on whiskers\"                                                  \n                                                                                                                 \ndescribe
  \"matchAndGroups\" $ do                                                                                   \n
  \   it \"should get match and groups\" $ do                                                                        \n
  \       \"raindrops on roses and whiskers on kittens\" ^.. regex [rx|(\\w+) on (\\w+)|]
  . matchAndGroups             \n        `shouldBe` [(\"raindrops on roses\",[\"raindrops\",\"roses\"]),(\"whiskers
  on kittens\",[\"whiskers\",\"kittens\"])] \n```\n"
license-name: BSD-3-Clause
