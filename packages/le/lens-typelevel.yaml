homepage: https://github.com/mstksg/lens-typelevel#readme
changelog-type: markdown
hash: 1deb843674ceb8a7614fae993c7633a0968ef7552f055a5e5f681a5060c2bee2
test-bench-deps: {}
maintainer: justin@jle.im
synopsis: Type-level lenses using singletons
changelog: ! 'Changelog

  =========


  Version 0.1.0.0

  ---------------


  *October 26, 2018*


  <https://github.com/mstksg/lens-typelevel/releases/tag/v0.1.0.0>


  *   Initial release.


'
basic-deps:
  base: ! '>=4.12 && <5'
  singletons: ! '>=2.5'
all-versions:
- '0.1.0.0'
author: Justin Le
latest: '0.1.0.0'
description-type: markdown
description: ! '# [lens-typelevel][]


  [![lens-typelevel on Hackage](https://img.shields.io/hackage/v/lens-typelevel.svg?maxAge=86400)](https://hackage.haskell.org/package/lens-typelevel)

  [![Build Status](https://travis-ci.org/mstksg/lens-typelevel.svg?branch=master)](https://travis-ci.org/mstksg/lens-typelevel)


  van Laarhoven lenses at the type level using *[singletons][]* defunctionalization.


  [lens-typelevel]: http://hackage.haskell.org/package/lens-typelevel

  [singletons]: https://hackage.haskell.org/package/singletons


  ```haskell

  ghci> :kind! ''("hello", 6 ) & L1_ .~ ''True

  ''( ''True, 6 )


  ghci> :kind! ''("hello", 6 ) ^. L2_

  6


  ghci> :kind! ''("hello", 6 ) ^. To_ SndSym0

  6


  ghci> :kind! ''("hello", ''True ) & L2_ %~ NotSym0

  ''("hello", ''False )


  ghci> :kind! ''[ ''True, ''False, ''False ] & Traverse_ %~ NotSym0

  ''[ ''False, ''True, ''True ]


  ghci> :kind! ''("hello", ''(6, ''False ) ) ^. L2_ .@ L1_

  6


  ghci> type TestList = ''[ ''("hello", ''True), ''("world", ''False), ''("curry",
  ''False)]

  ghci> :kind! TestLst ^.. Traverse_ .@ L1_

  ''["hello", "world", "curry"]


  ghci> :kind! ''[] ^?! Traverse_

  Error "Failed indexing into empty traversal"


  ghci> :kind! ''["hello", "world", "curry"] & IxList_ (''S ''Z) .~ "haskell"

  ''["hello", "haskell", "curry"]

  ```


  It''s pretty much the exact same representation as the *lens* library; it''s

  essentially an API-faithful port with the same representation and essentially

  the same implementation.  We even have `CloneLens_` and `CloneTraversal_`

  implemented using type-level versions of `Context` and `Bazaar`:


  ```haskell

  ghci> :kind! ''("hello", 6) ^. CloneLens_ L1_

  "hello"

  ```


  Using prefix function names:


  ```haskell

  ghci> :kind! Set  L1_       ''True        ''("hello", 6     )

  ''( ''True, 6 )


  ghci> :kind! View L2_                    ''("hello", 6     )

  6


  ghci> :kind! View (To_ SndSym0)          ''("hello", 6     )

  6


  ghci> :kind! Over L2_       NotSym0      ''("hello", ''True )

  ''("hello", ''False )


  ghci> :kind! Over Traverse_ NotSym0      ''[ ''True, ''False, ''False ]

  ''[ ''False, ''True, ''True ]


  ghci> :kind! View (L2_ .@ L1_)           ''("hello", ''(6, ''False ) )

  6


  ghci> type TestList = ''[ ''("hello", ''True), ''("world", ''False), ''("curry",
  ''False)]

  ghci> :kind! ToListOf (Traverse_ .@ L1_) TestList

  ''["hello", "world", "curry"]


  ghci> :kind! UnsafePreview Traverse_     ''[]

  Error "Failed indexing into empty traversal"


  ghci> :kind! Set (IxList_ (''S ''Z)) "haskell" ''["hello", "world", "curry"]

  ''["hello", "haskell", "curry"]

  ```

'
license-name: BSD3
