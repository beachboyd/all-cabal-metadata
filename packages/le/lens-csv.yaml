homepage: https://github.com/ChrisPenner/lens-csv#readme
changelog-type: markdown
hash: 56d56d0886d7615e54e4e04e7ac4d22205c75259425ceddd26400bfd55336fc9
test-bench-deps:
  bytestring: -any
  base: ! '>=4.7 && <5'
  lens: -any
  cassava: -any
  lens-csv: -any
maintainer: christopher.penner@gmail.com
synopsis: ''
changelog: |
  # Changelog for lens-csv

  ## Unreleased changes
basic-deps:
  bytestring: -any
  base: ! '>=4.7 && <5'
  lens: -any
  cassava: -any
all-versions:
- 0.1.0.0
author: Chris Penner
latest: 0.1.0.0
description-type: markdown
description: "# lens-csv\n\nA lensy layer on top of Cassava which affords streaming,
  traversable, CSV parsing.\n\nCurrently experimental (but working). Looking to improve
  error handling soon, currently parse failures are simply passed over by the traversals.\n\nExample:\n\n```haskell\n>>>
  import Data.ByteString.Lazy as BL\n>>> myCsv <- BL.readFile \"./data/simple.csv\"\n>>>
  myCsv ^.. namedCsv . taking 2 rows . column @String \"state_code\" \n[ \"NY\"\n,
  \"CA\"\n]\n\n>>> myCsv ^.. namedCsv . taking 2 rows . _NamedRecord @(M.Map String
  String)\n[ fromList [(\"population\",\"19540000\"), (\"state_code\",\"NY\")]\n,
  fromList [(\"population\",\"39560000\"), (\"state_code\",\"CA\")]\n]\n\n-- For csv
  files without headers\n>>> myCsv ^.. csv . taking 2 rows . _Record @[String]\n[
  [\"state_code\", \"population\"]\n, [\"NY\"        , \"19540000\"]\n]\n\n-- 'column'
  infers whether it's a named or unnamed csv and accepts the appropriate index type
  (either ByteString or Int)\n>>> myCsv ^.. csv . rows . column @Int 1\n[19540000,39560000]\n\n--
  Use traversals to edit cells 'in-place' (add 1337 to California's population)\n>>>
  BL.putStrLn $ myCsv & namedCsv . row 1 . column @Int \"population\" +~ 1337\nstate_code,population\nNY,19540000\nCA,39561337\n```\n"
license-name: BSD-3-Clause
