homepage: https://github.com/emilypi/lens-process
changelog-type: markdown
hash: 1bc337df880493173a4b670a122e6e72d2ce6e3c2ccfe4cad1ad54c2cfbc2825
test-bench-deps:
  stm: ! '>=2.5 && <2.6'
  lens-process: -any
  base: ! '>=4.4 && <5'
  filepath: ! '>=1.2 && <1.5'
  process: ! '>=1.5 && <1.7'
  lens: ! '>=4.17 && <4.18'
  exitcode: ! '>=0.1.0.2 && <0.1.1'
  tasty-hunit: -any
  tasty: -any
maintainer: Emily Pillmore <emilypi@cohomolo.gy>
synopsis: Optics for system processes
changelog: |
  # Revision history for lens-process

  ## 0.1.0.0 -- YYYY-mm-dd

  * First version. Released on an unsuspecting world.
basic-deps:
  stm: ! '>=2.5 && <2.6'
  base: ! '>=4.0 && <5'
  filepath: ! '>=1.0 && <1.5'
  process: ! '>=1.5 && <1.7'
  lens: ! '>=4.0 && <4.18'
  mtl: ! '>=2.2 && <2.3'
  exitcode: ! '>=0.1.0.2 && <0.1.1'
all-versions:
- 0.0.1.0
- 0.0.2.0
- 0.0.3.0
- 0.0.4.0
author: Emily Pillmore
latest: 0.0.4.0
description-type: markdown
description: |2

  # lens-process

  [![Hackage](https://img.shields.io/hackage/v/lens-process.svg)](https://hackage.haskell.org/package/lens-process)
  [![Build Status](https://travis-ci.org/emilypi/lens-process.svg?branch=master)](https://travis-ci.org/emilypi/lens-process)

  ### This package is still in Beta!

  This package is intended to be on the lighter side, with few dependencies aside from `lens`. For full disclosure, this is the minimal dependency graph of `lens-process`:

  ![lens-process dependencies](dependencies.png)

  ### Motivation

  `lens-process` provides optics for the [process](https://hackage.haskell.org/package/process) package. These optics provide convenient lenses, traversals, and prisms, as well as classy variants for significant classifiable portions of the library for convenience. In addition, we provide some combinators for working with `CreateProcess` types. The intention of this package is to create a well-typed optical layer for `process`, reflecting the shape of certain types of commands at the type level. For instance, consider the following:

  ```haskell
  myStdInProcess
    :: forall a
    . CommandProcess
    -> (Handle -> IO StdStream)
    -> IO (Either Text a)
  myStdInProcess cp f g = do
    (mhin, _, _, _) <- createProcess cp
    case mhin of
      Nothing -> error "oh no!"
      Just t -> f t

  ```

  This is very standard `process` code. However, if anyone else encounters this code, it is immediately apparent that information is lacking from the type signature. What `Handle` are we using? What type of command are we running? It is not reflected. Consider instead this replacement:

  ```haskell
  myStdInProcess
    :: forall a b c
    . (HasStdIn a, IsUseHandle b)
    => a -> (b -> IO c) -> IO c
  myStdInProcess cp f = do
    handler <- createProcess cp
    case handler ^? _Stdin . _Just . re _UsesHandle of
      Nothing -> error "oh no!"
      Just t -> f t

  ```

  What have we gained here? Well, for one, I know I'm working with something that only has a `_Stdin`, and that i will be piping whatever its `_Stdin` entry is into a `UseHandle`. Then, my function handles it accordingly. Much information has been gained! Classy optics gives us the necessary information to proceed as planned with more confidence.
license-name: BSD-3-Clause
