homepage: https://github.com/i-am-tom/higgledy
changelog-type: markdown
hash: af2b31d09e999587efac5b9507c7ce4e8d93ccbe010ade8f0b0ec712fb585a15
test-bench-deps:
  base: -any
  higgledy: -any
  hspec: ^>=2.7.0
  doctest: ^>=0.16.0
  lens: ^>=4.17
  QuickCheck: -any
maintainer: tom.harding@habito.com
synopsis: Partial types as a type constructor.
changelog: |
  # Revision history for partial-structures

  ## 0.1.0.0 -- YYYY-mm-dd

  * First version. Released on an unsuspecting world.
basic-deps:
  barbies: ^>=1.1.0.0
  base: ^>=4.12.0.0
  generic-lens: ^>=1.1.0.0
  QuickCheck: ^>=2.13.0
all-versions:
- 0.1.0.0
author: Tom Harding
latest: 0.1.0.0
description-type: markdown
description: "# Higgledy \U0001F4DA\n\nHigher-kinded data via generics: all\\* the
  benefits, but none\\* of the\nboilerplate.\n\n## Introduction\n\nWhen we work with
  [higher-kinded\ndata](https://reasonablypolymorphic.com/blog/higher-kinded-data),
  we find\nourselves writing types like:\n\n```haskell\ndata User f\n  = User\n      {
  name :: f String\n      , age  :: f Int\n      , ...\n      }\n```\n\nThis is good
  - we can use `f ~ Maybe` for partial data, `f ~ Identity` for\ncomplete data, etc
  - but it introduces a fair amount of noise, and we have a\nlot of boilerplate deriving
  to do. Wouldn't it be nice if we could get back to\nwriting simple types as we know
  and love them, and get all this stuff for\n_free_?\n\n```haskell\ndata User\n  =
  User\n      { name :: String\n      , age  :: Int\n      , ...\n      }\n  deriving
  Generic\n\n-- HKD for free!\ntype UserF f = HKD User f\n```\n\nAs an added little
  bonus, any `HKD`-wrapped object is automatically an instance\nof all the [Barbie](http://hackage.haskell.org/package/barbies)
  classes, so no\nneed to derive anything more than `Generic`!\n\n## API\n\nAll examples
  below were compiled with the following extensions, modules, and\nexample data types:\n\n```haskell\n{-#
  LANGUAGE DataKinds        #-}\n{-# LANGUAGE DeriveGeneric    #-}\n{-# LANGUAGE TypeApplications
  #-}\nmodule Example where\n\nimport Control.Lens ((.~), (^.), (&), Const (..), Identity,
  anyOf)\nimport Data.Generic.HKD\nimport Data.Maybe (isJust, isNothing)\nimport Data.Monoid
  (Last (..))\nimport GHC.Generics (Generic)\n\n-- An example of a record (with named
  fields):\ndata User\n  = User\n      { name      :: String\n      , age       ::
  Int\n      , likesDogs :: Bool\n      }\n  deriving (Generic, Show)\n\nuser :: User\nuser
  = User \"Tom\" 25 True\n\n-- An example of a product (without named fields):\ndata
  Triple\n  = Triple Int () String\n  deriving (Generic, Show)\n\ntriple :: Triple\ntriple
  = Triple 123 () \"ABC\"\n```\n\n### The HKD type constructor\n\nThe `HKD` type takes
  two parameters: your model type, and the functor in which\nwe want to wrap all our
  inputs. By picking different functors for the second\nparameter, we can recover
  various behaviours:\n\n```haskell\ntype Partial a = HKD a  Last          -- Fields
  may be missing.\ntype Bare    a = HKD a  Identity      -- All must be present.\ntype
  Labels  a = HKD a (Const String) -- Every field holds a string.\n```\n\n### Fresh
  objects\n\nWhen we want to start working with the `HKD` interface, we have a couple
  of\noptions, depending on the functor in question. The first option is to use\n`mempty`:\n\n```haskell\neg0
  :: Partial User\neg0 = mempty\n-- User\n--   { name      = Last {getLast = Nothing}\n--
  \  , age       = Last {getLast = Nothing}\n--   , likesDogs = Last {getLast = Nothing}\n--
  \  }\n```\n\nOther 'Alternative'-style functors lead to very different results:\n\n```haskell\neg1
  :: Labels Triple\neg1 = mempty\n-- Triple\n--   Const \"\"\n--   Const \"\"\n--
  \  Const \"\"\n```\n\nOf course, this method requires every field to be monoidal.
  If we try with\n`Identity`, for example, we're in trouble if all our fields aren't
  themselves\nmonoids:\n\n```haskell\neg2 :: Bare Triple\neg2 = mempty\n-- error:\n--
  • No instance for (Monoid Int) arising from a use of ‘mempty’\n```\n\nThe other
  option is to `deconstruct` a complete object. This effectively lifts\na type into
  the `HKD` structure with `pure` applied to each field:\n\n```haskell\neg3 :: Bare
  User\neg3 = deconstruct user\n-- User\n--   { name      = Identity \"Tom\"\n--   ,
  age       = Identity 25\n--   , likesDogs = Identity True\n--   }\n```\n\nThis approach
  works with any applicative we like, so we can recover the other\nbehaviours:\n\n```haskell\neg4
  :: Partial Triple\neg4 = deconstruct @Last triple\n-- Triple\n--   Last {getLast
  = Just 123}\n--   Last {getLast = Just ()}\n--   Last {getLast = Just \"ABC\"}\n```\n\nThere's
  also `construct` for when we want to escape our `HKD` wrapper, and\nattempt to _construct_
  our original type:\n\n```haskell\neg5 :: Last Triple\neg5 = construct eg4\n-- Last
  {getLast = Just (Triple 123 () \"ABC\")}\n```\n\n### Field Access\n\nThe `field`
  lens, when given a type-applied field name, allows us to focus on\nfields within
  a record:\n\n```haskell\neg6 :: Last Int\neg6 = eg0 ^. field @\"age\"\n-- Last {getLast
  = Nothing}\n```\n\nAs this is a true `Lens`, it also means that we can _set_ values
  within our\nrecord (note that these set values will _also_ need to be in our functor
  of\nchoice):\n\n```haskell\neg7 :: Partial User\neg7 = eg0 & field @\"name\"      .~
  pure \"Evil Tom\"\n          & field @\"likesDogs\" .~ pure False     \n-- User\n--
  \  { name      = Last {getLast = Just \"Evil Tom\"}\n--   , age       = Last {getLast
  = Nothing}\n--   , likesDogs = Last {getLast = Just False}\n--   }\n```\n\nThis
  also means, for example, we can check whether a particular value has been\ncompleted
  for a given partial type:\n\n```haskell\neg8 :: Bool\neg8 = anyOf (field @\"name\")
  (isJust . getLast) eg0\n-- False\n```\n\nFinally, thanks to the fact that this library
  exploits some of the internals of\n`generic-lens`, we'll also get a nice type error
  when we mention a field that\ndoesn't exist in our type:\n\n```haskell\neg9 :: Identity
  ()\neg9 = eg3 ^. field @\"oops\"\n-- error:\n-- • The type User does not contain
  a field named 'oops'.\n```\n\n### Position Access\n\nJust as with field names, we
  can use positions when working with non-record\nproduct types:\n\n```haskell\neg10
  :: Labels Triple\neg10 = mempty & position @1 .~ Const \"hello\"\n              &
  position @2 .~ Const \"world\"\n-- Triple\n--   Const \"hello\"\n--   Const \"world\"\n--
  \  Const \"\"\n```\n\nAgain, this is a `Lens`, so we can just as easily _set_ values:\n\n```haskell\neg11
  :: Partial User\neg11 = eg7 & position @2 .~ pure 25\n-- User\n--   { name      =
  Last {getLast = Just \"Evil Tom\"}\n--   , age       = Last {getLast = Just 25}\n--
  \  , likesDogs = Last {getLast = Just False}\n--   }\n```\n\nSimilarly, the internals
  here come to us courtesy of `generic-lens`, so the\ntype errors are a delight:\n\n```haskell\neg9
  :: Identity ()\neg9 = deconstruct @Identity triple ^. position @4\n-- error:\n--
  • The type Triple does not contain a field at position 4\n```\n\n### Labels\n\nOne
  neat trick we can do - thanks to the generic representation - is get the\nnames
  of the fields into the functor we're using. The `label` function gives us\nthis
  interface:\n\n```haskell\neg10 :: Labels User\neg10 = label eg11\n-- User\n--   {
  name = Const \"name\"\n--   , age = Const \"age\"\n--   , likesDogs = Const \"likesDogs\"\n--
  \  }\n```\n\nBy combining this with some of the\n[Barbies](http://hackage.haskell.org/package/barbies)
  interface (the entirety\nof which is available to any `HKD`-wrapped type) such as
  `bprod` and `bmap`, we\ncan implement functions such as `labelsWhere`, which returns
  the names of all\nfields whose values satisfy some predicate:\n\n```haskell\neg13
  :: [String]\neg13 = labelsWhere (isNothing . getLast) eg7\n-- [\"age\"]\n```\n"
license-name: MIT
