homepage: https://github.com/nitros12/calamity
changelog-type: markdown
hash: 0661481be548511369f420019cd8f566d8f252d3b4e98a81fc2462a406481c8e
test-bench-deps: {}
maintainer: ben@bensimms.moe
synopsis: A library for writing discord bots
changelog: "# Changelog for Calamity\n\n## 0.1.14.0\n\n*2020-06-08*\n\n* Unpacked
  the `user` field of `Member` into itself.\n\n* Add message formatting utilities
  (`Calamity.Utils.Message`).\n\n* Add support for allowed mentions in `Tellable`.\n\n*
  Change Snowflake's show instance to just show the numberic id.\n\n* Added parsers
  for RawEmoji and Either.\n\n## 0.1.13.0\n\n*2020-06-06*\n\n* Changed event handlers
  to take tuples instead of being higher arity when there\n  is more than one parameter
  to the callback.\n\n## 0.1.12.0\n\n*2020-06-06*\n\n* Changed some events to take
  enums instead of booleans: `GuildCreateEvt` and\n  `GuildDeleteEvt`.\n\n## 0.1.11.2\n\n*2020-06-03*\n\n*
  Moved the internal `UpdatedMessage` from\n  `Calamity.Types.Model.Channel.Message`
  into\n  `Calamity.Types.Model.Channel.UpdatedMessage`.\n\n## 0.1.11.0\n\n*2020-05-31*\n\n*
  Add command parameter parsers for channel/guild/emoji\n* Support allowed mentions\n*
  Support invite events\n* Support setting gateway intents\n* Add `Calamity.Types.Model.Guild.Permission`
  and `Calamity.Utils.Permissions`\n  and change permissions fields from `Word64`
  to `Permissions`\n* Add `Calamity.Utils.Colour` and change color fields from `Word64`
  to\n  `Data.Color.Color Double`\n\n## 0.1.10.0\n\n*2020-05-27*\n\n* Renamed `Calamity.Commands.Parser.KleeneConcat`
  to\n  `Calamity.Commands.Parser.KleeneStarConcat` and added\n  `Calamity.Commands.Parser.KleenePlusConcat`\n
  \ \n* Added `Calamity.Types.Upgradeable`\n\n## 0.1.9.2\n\n*2020-05-23*\n\n* Added
  a default help command, located in `Calamity.Commands.Help`.\n\n* Commands now have
  the list of parameters they take\n\n## 0.1.9.1\n\n*2020-05-23*\n\n* Added `Calamity.Commands.Parser.Named`
  for parameters that have a name.\n\n* General improvements to parser errors\n\n##
  0.1.9.0\n\n*2020-05-22*\n\n* Added commands, located in `Calamity.Commands`, along
  with a DSL for declaring\n  commands nicely.\n  \n* Renamed `waitUntil` to `waitUntilM`,
  and introduced a variant with a pure\n  check function that takes the original name
  of `waitUntil`.\n\n## 0.1.8.0\n\n*2020-05-15*\n\n* Did a large rework of how event
  handlers are stored internally.\n* introduced `waitUntil`\n\n## 0.1.4.0\n\n* Added
  back extra exports of `Calamity.Types.Partial` from\n  `Calamity.Types.Model.Guild.Guild`,
  `Calamity.Type.Model.Guild.Emoji`, and\n  `Calamity.Types.Model.Channel`. There
  is now way to export the constructor\n  without also exporting Partial apparently?\n\n\n##
  0.1.3.0\n\n*2020-04-27*\n\n* Removed extra exports of `Calamity.Types.Partial` from\n
  \ `Calamity.Types.Model.Guild.Guild`, `Calamity.Type.Model.Guild.Emoji`, and\n  `Calamity.Types.Model.Channel`\n\n*
  Added missing exports of `CreateGuildEmojiOptions` and\n  `ModifyGuildEmojiOptions`
  from `Calamity.HTTP.Emoji`\n\n* Added missing exports of `CreateGuildData` and `ModifyGuildData`
  from\n  `Calamity.HTTP.Guild`\n\n## 0.1.2.0\n\n*2020-04-27*\n\n* Calamity.Client:
  runBotIO now has a `Polysemy.Fail` effect\n\n## Unreleased changes\n"
basic-deps:
  focus: '>=1.0 && <2'
  polysemy-plugin: '>=0.2 && <0.3'
  exceptions: '>=0.10 && <0.11'
  fmt: '>=0.6 && <0.7'
  bytestring: '>=0.10 && <0.11'
  reflection: '>=2.1 && <3'
  lens-aeson: '>=1.1 && <2'
  stm: '>=2.5 && <3'
  base: '>=4.12 && <5'
  data-default-class: '>=0.1 && <0.2'
  time: '>=1.8 && <1.11'
  unordered-containers: '>=0.2 && <0.3'
  text: '>=1.2 && <2'
  deque: '>=0.4 && <0.5'
  safe-exceptions: '>=0.1 && <2'
  megaparsec: '>=8 && <9'
  di-polysemy: '>=0.1.3 && <0.2'
  generic-override-aeson: '>=0.0.0.0 && <0.0.1'
  text-show: '>=3.8 && <4'
  async: '>=2.2 && <3'
  websockets: '>=0.12 && <0.13'
  http-date: '>=0.0.8 && <0.1'
  containers: '>=0.6 && <0.7'
  lens: '>=4.18 && <5'
  concurrent-extra: '>=0.7 && <0.8'
  wuss: '>=1.1 && <2'
  data-flags: '>=0.0.3 && <0.1'
  mtl: '>=2.2 && <3'
  unagi-chan: '>=0.4 && <0.5'
  wreq-patchable: '>=1.0 && <2'
  hashable: '>=1.2 && <2'
  generic-override: '>=0.0.0.0 && <0.0.1'
  stm-chans: '>=3.0 && <4'
  polysemy: '>=1.3 && <2'
  generic-lens: '>=2.0 && <3'
  colour: '>=2.3.5 && <2.4'
  deepseq: '>=1.4.4.0 && <2'
  df1: '>=0.3 && <0.5'
  scientific: '>=0.3 && <0.4'
  stm-containers: '>=1.1 && <2'
  http-types: '>=0.12 && <0.13'
  typerep-map: '>=0.3 && <0.4'
  aeson: '>=1.4 && <2'
  vector: '>=0.12 && <0.13'
all-versions:
- 0.1.0.0
- 0.1.2.0
- 0.1.3.0
- 0.1.3.1
- 0.1.4.0
- 0.1.4.1
- 0.1.4.2
- 0.1.4.3
- 0.1.4.4
- 0.1.5.0
- 0.1.5.1
- 0.1.6.0
- 0.1.6.1
- 0.1.6.2
- 0.1.7.0
- 0.1.8.0
- 0.1.8.1
- 0.1.9.0
- 0.1.9.1
- 0.1.9.2
- 0.1.9.3
- 0.1.9.4
- 0.1.10
- 0.1.10.1
- 0.1.11.0
- 0.1.11.1
- 0.1.11.2
- 0.1.12.0
- 0.1.13.0
- 0.1.14.0
author: Ben Simms
latest: 0.1.14.0
description-type: markdown
description: |
  <h1 align="center">Calamity</h1>

  <!-- [![Hackage](https://img.shields.io/hackage/v/calamity)](https://hackage.haskell.org/package/calamity) -->
  <!-- [![Gitlab pipeline status](https://img.shields.io/gitlab/pipeline/nitros12/calamity)](https://gitlab.com/nitros12/calamity/pipelines) -->
  <!-- [![License](https://img.shields.io/github/license/nitros12/calamity)](https://github.com/nitros12/calamity/blob/master/LICENSE) -->
  <!-- [![Hackage-Deps](https://img.shields.io/hackage-deps/v/calamity)](https://hackage.haskell.org/package/calamity) -->

  <p align="center">
    <a href="https://hackage.haskell.org/package/calamity"><img src="https://img.shields.io/hackage/v/calamity" alt="Hackage"></a>
    <a href="https://gitlab.com/nitros12/calamity/pipelines"><img src="https://img.shields.io/gitlab/pipeline/nitros12/calamity" alt="Gitlab pipeline status"></a>
    <a href="https://github.com/nitros12/calamity/blob/master/LICENSE"><img src="https://img.shields.io/github/license/nitros12/calamity" alt="License"></a>
    <a href="https://hackage.haskell.org/package/calamity"><img src="https://img.shields.io/hackage-deps/v/calamity" alt="Hackage-Deps"></a>
  </p>

  Calamity is a Haskell library for writing discord bots, it uses
  [Polysemy](https://hackage.haskell.org/package/polysemy) as the core library for
  handling effects, allowing you to pick and choose how to handle certain features
  of the library.

  The current customisable effects are:

  * Cache: The default cache handler keeps the cache in memory, however you could
    write a cache handler that stores cache in a database for example.

  * Metrics: The library has counters, gauges, and histograms installed to measure
    useful things, by default these are not used (and cost nothing), but could be
    combined with [Prometheus](https://hackage.haskell.org/package/prometheus). An
    example of using prometheus as the metrics handler can be found
    [here](https://github.com/nitros12/calamity-example).

  # Docs

  You can find documentation on hackage: [here](https://hackage.haskell.org/package/calamity)

  # Example

  An example project can be found at:
  [nitros12/calamity-example](https://github.com/nitros12/calamity-example)

  ``` haskell
  {-# LANGUAGE DataKinds #-}
  {-# LANGUAGE FlexibleContexts #-}
  {-# LANGUAGE GADTs #-}
  {-# LANGUAGE LambdaCase #-}
  {-# LANGUAGE OverloadedLabels #-}

  {-# LANGUAGE OverloadedStrings #-}
  {-# LANGUAGE PolyKinds #-}
  {-# LANGUAGE ScopedTypeVariables #-}
  {-# LANGUAGE TemplateHaskell #-}
  {-# LANGUAGE TypeApplications #-}

  {-# LANGUAGE TypeOperators #-}

  module Main where

  import           Calamity
  import           Calamity.Cache.InMemory
  import           Calamity.Commands
  import qualified Calamity.Commands.Context                  as CommandContext
  import           Calamity.Metrics.Noop

  import           Control.Concurrent
  import           Control.Concurrent.STM.TVar
  import           Control.Lens
  import           Control.Monad

  import           Data.Text.Lazy              ( Text, fromStrict )
  import           Data.Text.Strict.Lens

  import qualified DiPolysemy                  as DiP

  import qualified Polysemy                    as P
  import qualified Polysemy.Async              as P
  import qualified Polysemy.AtomicState        as P
  import qualified Polysemy.Embed              as P
  import qualified Polysemy.Fail               as P

  import           Prelude                     hiding ( error )

  import           TextShow

  data Counter m a where
    GetCounter :: Counter m Int

  P.makeSem ''Counter

  runCounterAtomic :: P.Member (P.Embed IO) r => P.Sem (Counter ': r) a -> P.Sem r a
  runCounterAtomic m = do
    var <- P.embed $ newTVarIO (0 :: Int)
    P.runAtomicStateTVar var $ P.reinterpret (\case
                                                GetCounter -> P.atomicState (\v -> (v + 1, v))) m

  handleFailByLogging m = do
    r <- P.runFail m
    case r of
      Left e -> DiP.error (e ^. packed)
      _      -> pure ()

  info, debug :: BotC r => Text -> P.Sem r ()
  info = DiP.info
  debug = DiP.info

  tellt :: (BotC r, Tellable t) => t -> Text -> P.Sem r (Either RestError Message)
  tellt t m = tell t $ L.toStrict m

  main :: IO ()
  main = do
    token <- view packed <$> getEnv "BOT_TOKEN"
    void . P.runFinal . P.embedToFinal . runCounterAtomic . runCacheInMemory . runMetricsNoop . useConstantPrefix "!"
      $ runBotIO (BotToken token) $ do
      addCommands $ do
        helpCommand
        command @'[User] "utest" $ \ctx u -> do
          void $ tellt ctx $ "got user: " <> showtl u
        command @'[Named "u" User, Named "u1" User] "utest2" $ \ctx u u1 -> do
          void $ tellt ctx $ "got user: " <> showtl u <> "\nand: " <> showtl u1
        command @'[L.Text, Snowflake User] "test" $ \ctx something aUser -> do
          info $ "something = " <> showt something <> ", aUser = " <> showt aUser
        command @'[] "hello" $ \ctx -> do
          void $ tellt ctx "heya"
        group "testgroup" $ do
          command @'[[L.Text]] "test" $ \ctx l -> do
            void $ tellt ctx ("you sent: " <> showtl l)
          command @'[] "count" $ \ctx -> do
            val <- getCounter
            void $ tellt ctx ("The value is: " <> showtl val)
          group "say" $ do
            command @'[KleenePlusConcat L.Text] "this" $ \ctx msg -> do
              void $ tellt ctx msg
        command @'[Snowflake Emoji] "etest" $ \ctx e -> do
          void $ tellt ctx $ "got emoji: " <> showtl e
        command @'[] "explode" $ \ctx -> do
          Just x <- pure Nothing
          debug "unreachable!"
        command @'[] "bye" $ \ctx -> do
          void $ tellt ctx "bye!"
          stopBot
        command @'[] "fire-evt" $ \ctx -> do
          fire $ customEvt @"my-event" ("aha" :: L.Text, ctx ^. #message)
        command @'[L.Text] "wait-for" $ \ctx s -> do
          void $ tellt ctx ("waiting for !" <> s)
          waitUntil @'MessageCreateEvt (\msg -> msg ^. #content == ("!" <> s))
          void $ tellt ctx ("got !" <> s)
      react @'MessageCreateEvt $ \msg -> handleFailByLogging $ case msg ^. #content of
        "!say hi" -> replicateM_ 3 . P.async $ do
          info "saying heya"
          Right msg' <- tellt msg "heya"
          info "sleeping"
          P.embed $ threadDelay (5 * 1000 * 1000)
          info "slept"
          void . invoke $ EditMessage (msg ^. #channelID) msg' (Just "lol") Nothing
          info "edited"
        _ -> pure ()
      react @('CustomEvt "command-error" (CommandContext.Context, CommandError)) $ \(ctx, e) -> do
        info $ "Command failed with reason: " <> showt e
        case e of
          ParseError n r -> void . tellt ctx $ "Failed to parse parameter: `" <> L.fromStrict n <> "`, with reason: ```\n" <> r <> "```"
      react @('CustomEvt "my-event" (L.Text, Message)) $ \(s, m) ->
        void $ tellt m ("Somebody told me to tell you about: " <> s)
  ```
license-name: MIT
