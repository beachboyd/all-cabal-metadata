homepage: https://github.com/nitros12/calamity
changelog-type: markdown
hash: 21b13ef3bc00bb8d5d66b45bf9968127ae5826ae41e8fe595cb21634a7042346
test-bench-deps: {}
maintainer: ben@bensimms.moe
synopsis: A library for writing discord bots
changelog: |
  # Changelog for Calamity

  ## 0.1.4.0

  * Added back extra exports of `Calamity.Types.Partial` from
    `Calamity.Types.Model.Guild.Guild`, `Calamity.Type.Model.Guild.Emoji`, and
    `Calamity.Types.Model.Channel`. There is now way to export the constructor
    without also exporting Partial apparently?


  ## 0.1.3.0

  *2020-04-27*

  * Removed extra exports of `Calamity.Types.Partial` from
    `Calamity.Types.Model.Guild.Guild`, `Calamity.Type.Model.Guild.Emoji`, and
    `Calamity.Types.Model.Channel`

  * Added missing exports of `CreateGuildEmojiOptions` and
    `ModifyGuildEmojiOptions` from `Calamity.HTTP.Emoji`

  * Added missing exports of `CreateGuildData` and `ModifyGuildData` from
    `Calamity.HTTP.Guild`

  ## 0.1.2.0

  *2020-04-27*

  * Calamity.Client: runBotIO now has a `Polysemy.Fail` effect

  ## Unreleased changes
basic-deps:
  focus: '>=1.0 && <2'
  polysemy-plugin: '>=0.2 && <0.3'
  exceptions: '>=0.10 && <0.11'
  fmt: '>=0.6 && <0.7'
  bytestring: '>=0.10 && <0.11'
  reflection: '>=2.1 && <3'
  lens-aeson: '>=1.1 && <2'
  stm: '>=2.5 && <3'
  base: '>=4.12 && <5'
  data-default-class: '>=0.1 && <0.2'
  time: '>=1.8 && <1.11'
  unordered-containers: '>=0.2 && <0.3'
  text: '>=1.2 && <2'
  deque: '>=0.4 && <0.5'
  di-polysemy: '>=0.1.1 && <0.2'
  generic-override-aeson: '>=0.0.0.0 && <0.0.1'
  text-show: '>=3.8 && <4'
  async: '>=2.2 && <3'
  websockets: '>=0.12 && <0.13'
  http-date: '>=0.0.8 && <0.1'
  containers: '>=0.6 && <0.7'
  lens: '>=4.18 && <5'
  concurrent-extra: '>=0.7 && <0.8'
  wuss: '>=1.1 && <2'
  mtl: '>=2.2 && <3'
  wreq-patchable: '>=1.0 && <2'
  hashable: '>=1.2 && <2'
  generic-override: '>=0.0.0.0 && <0.0.1'
  stm-chans: '>=3.0 && <4'
  polysemy: '>=1.3 && <2'
  generic-lens: '>=2.0 && <3'
  deepseq: '>=1.4.4.0 && <2'
  df1: '>=0.3 && <0.4'
  scientific: '>=0.3 && <0.4'
  stm-containers: '>=1.1 && <2'
  http-types: '>=0.12 && <0.13'
  typerep-map: '>=0.3 && <0.4'
  aeson: '>=1.4 && <2'
  vector: '>=0.12 && <0.13'
all-versions:
- 0.1.0.0
- 0.1.2.0
- 0.1.3.0
- 0.1.3.1
- 0.1.4.0
- 0.1.4.1
- 0.1.4.2
- 0.1.4.3
author: Ben Simms
latest: 0.1.4.3
description-type: markdown
description: |
  <h1 align="center">Calamity</h1>

  <!-- [![Hackage](https://img.shields.io/hackage/v/calamity)](https://hackage.haskell.org/package/calamity) -->
  <!-- [![Gitlab pipeline status](https://img.shields.io/gitlab/pipeline/nitros12/calamity)](https://gitlab.com/nitros12/calamity/pipelines) -->
  <!-- [![License](https://img.shields.io/github/license/nitros12/calamity)](https://github.com/nitros12/calamity/blob/master/LICENSE) -->
  <!-- [![Hackage-Deps](https://img.shields.io/hackage-deps/v/calamity)](https://hackage.haskell.org/package/calamity) -->

  <p align="center">
    <a href="https://hackage.haskell.org/package/calamity"><img src="https://img.shields.io/hackage/v/calamity" alt="Hackage"></a>
    <a href="https://gitlab.com/nitros12/calamity/pipelines"><img src="https://img.shields.io/gitlab/pipeline/nitros12/calamity" alt="Gitlab pipeline status"></a>
    <a href="https://github.com/nitros12/calamity/blob/master/LICENSE"><img src="https://img.shields.io/github/license/nitros12/calamity" alt="License"></a>
    <a href="https://hackage.haskell.org/package/calamity"><img src="https://img.shields.io/hackage-deps/v/calamity" alt="Hackage-Deps"></a>
  </p>

  Calamity is a Haskell library for writing discord bots, it uses
  [Polysemy](https://hackage.haskell.org/package/polysemy) as the core library for
  handling effects, allowing you to pick and choose how to handle certain features
  of the library.

  The current customisable effects are:

  * Cache: The default cache handler keeps the cache in memory, however you could
    write a cache handler that stores cache in a database for example.

  * Metrics: The library has counters, gauges, and histograms installed to measure
    useful things, by default these are not used (and cost nothing), but could be
    combined with [Prometheus](https://hackage.haskell.org/package/prometheus). An
    example of using prometheus as the metrics handler can be found
    [here](https://github.com/nitros12/calamity-example).

  # Docs

  You can find documentation on hackage: [here](https://hackage.haskell.org/package/calamity)

  # Example

  An example project can be found at:
  [nitros12/calamity-example](https://github.com/nitros12/calamity-example)

  ``` haskell
  {-# LANGUAGE DataKinds #-}
  {-# LANGUAGE FlexibleContexts #-}
  {-# LANGUAGE GADTs #-}
  {-# LANGUAGE LambdaCase #-}
  {-# LANGUAGE OverloadedLabels #-}

  {-# LANGUAGE OverloadedStrings #-}
  {-# LANGUAGE PolyKinds #-}
  {-# LANGUAGE ScopedTypeVariables #-}
  {-# LANGUAGE TemplateHaskell #-}
  {-# LANGUAGE TypeApplications #-}

  {-# LANGUAGE TypeOperators #-}

  module Main where

  import           Calamity
  import           Calamity.Cache.InMemory
  import           Calamity.Metrics.Noop

  import           Control.Concurrent
  import           Control.Concurrent.STM.TVar
  import           Control.Lens
  import           Control.Monad

  import           Data.Text.Lazy              ( Text, fromStrict )
  import           Data.Text.Strict.Lens

  import qualified DiPolysemy                  as DiP

  import qualified Polysemy                    as P
  import qualified Polysemy.Async              as P
  import qualified Polysemy.AtomicState        as P
  import qualified Polysemy.Embed              as P
  import qualified Polysemy.Fail               as P

  import           Prelude                     hiding ( error )

  import           TextShow

  data Counter m a where
    GetCounter :: Counter m Int

  P.makeSem ''Counter

  runCounterAtomic :: P.Member (P.Embed IO) r => P.Sem (Counter ': r) () -> P.Sem r ()
  runCounterAtomic m = do
    var <- P.embed $ newTVarIO (0 :: Int)
    P.runAtomicStateTVar var $ P.reinterpret (\case
                                                GetCounter -> P.atomicState (\v -> (v + 1, v))) m

  handleFailByLogging m = do
    r <- P.runFail m
    case r of
      Left e -> DiP.error (e ^. packed)
      _      -> pure ()

  handleFailByPrinting m = do
    r <- P.runFail m
    case r of
      Left e -> P.embed $ print (show e)
      _      -> pure ()

  info = DiP.info @Text
  debug = DiP.info @Text

  main :: IO ()
  main = do
    P.runFinal . P.embedToFinal . handleFailByPrinting . runCounterAtomic . runCacheInMemory . runMetricsNoop $ runBotIO
      (BotToken "") $ do
        react @"messagecreate" $ \msg -> handleFailByLogging $ do
          when (msg ^. #content == "!count") $ replicateM_ 3 $ do
            val <- getCounter
            info $ "the counter is: " <> fromStrict (showt val)
            void . invokeRequest $ CreateMessage (msg ^. #channelID) ("The value is: " <> showt val)
          when (msg ^. #content == "!say hi") $ replicateM_ 3 . P.async $ do
            info "saying heya"
            Right msg' <- invokeRequest $ CreateMessage (msg ^. #channelID) "heya"
            info "sleeping"
            P.embed $ threadDelay (5 * 1000 * 1000)
            info "slept"
            void . invokeRequest $ EditMessage (msg ^. #channelID) msg' (Just "lol") Nothing
            info "edited"
          when (msg ^. #content == "!explode") $ do
            Just x <- pure Nothing
            debug "unreachable!"
          when (msg ^. #content == "!bye") $ do
            void . invokeRequest $ CreateMessage (msg ^. #channelID) "bye!"
            stopBot
  ```
license-name: MIT
