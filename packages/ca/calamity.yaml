homepage: https://github.com/nitros12/calamity
changelog-type: markdown
hash: 53c92d943fbf196a5e91a58b73ca55120075a8dad994a3d8962a6b02e25ebd49
test-bench-deps: {}
maintainer: ben@bensimms.moe
synopsis: A library for writing discord bots
changelog: |
  # Changelog for Calamity

  ## Unreleased changes
basic-deps:
  focus: '>=1.0 && <2'
  polysemy-plugin: ==0.2.*
  exceptions: ==0.10.*
  fmt: ==0.6.*
  bytestring: ==0.10.*
  reflection: '>=2.1 && <3'
  lens-aeson: '>=1.1 && <2'
  stm: '>=2.5 && <3'
  base: '>=4.12 && <5'
  data-default-class: ==0.1.*
  time: '>=1.8 && <1.11'
  unordered-containers: ==0.2.*
  text: '>=1.2 && <2'
  deque: ==0.4.*
  di-polysemy: ==0.1.*
  generic-override-aeson: '>=0.0.0.0 && <0.0.1'
  text-show: '>=3.8 && <4'
  async: '>=2.2 && <3'
  websockets: ==0.12.*
  http-date: '>=0.0.8 && <0.1'
  lens: '>=4.18 && <5'
  concurrent-extra: ==0.7.*
  wuss: '>=1.1 && <2'
  mtl: '>=2.2 && <3'
  wreq-patchable: '>=1.0 && <2'
  hashable: '>=1.2 && <2'
  generic-override: '>=0.0.0.0 && <0.0.1'
  stm-chans: '>=3.0 && <4'
  polysemy: '>=1.3 && <2'
  generic-lens: '>=2.0 && <3'
  deepseq: '>=1.4.4.0 && <2'
  df1: ==0.3.*
  scientific: ==0.3.*
  stm-containers: '>=1.1 && <2'
  http-types: ==0.12.*
  typerep-map: ==0.3.*
  aeson: '>=1.4 && <2'
  vector: ==0.12.*
all-versions:
- 0.1.0.0
author: Ben Simms
latest: 0.1.0.0
description-type: markdown
description: |
  # Calamity

  A discord library for haskell

  # Example

  ``` haskell
  {-# LANGUAGE DataKinds #-}
  {-# LANGUAGE FlexibleContexts #-}
  {-# LANGUAGE GADTs #-}
  {-# LANGUAGE LambdaCase #-}
  {-# LANGUAGE OverloadedLabels #-}

  {-# LANGUAGE OverloadedStrings #-}
  {-# LANGUAGE PolyKinds #-}
  {-# LANGUAGE ScopedTypeVariables #-}
  {-# LANGUAGE TemplateHaskell #-}
  {-# LANGUAGE TypeApplications #-}

  {-# LANGUAGE TypeOperators #-}

  module Main where

  import           Calamity
  import           Calamity.Cache.InMemory

  import           Control.Concurrent
  import           Control.Concurrent.STM.TVar
  import           Control.Lens
  import           Control.Monad

  import           Data.Text.Lazy              ( Text, fromStrict )
  import           Data.Text.Strict.Lens

  import qualified DiPolysemy                  as DiP

  import qualified Polysemy                    as P
  import qualified Polysemy.Async              as P
  import qualified Polysemy.AtomicState        as P
  import qualified Polysemy.Embed              as P
  import qualified Polysemy.Fail               as P

  import           Prelude                     hiding ( error )

  import           TextShow

  data Counter m a where
    GetCounter :: Counter m Int

  P.makeSem ''Counter

  runCounterAtomic :: P.Member (P.Embed IO) r => P.Sem (Counter ': r) () -> P.Sem r ()
  runCounterAtomic m = do
    var <- P.embed $ newTVarIO (0 :: Int)
    P.runAtomicStateTVar var $ P.reinterpret (\case
                                                GetCounter -> P.atomicState (\v -> (v + 1, v))) m

  handleErrorByLogging m = do
    r <- P.runFail m
    case r of
      Left e -> DiP.error (e ^. packed)
      _      -> pure ()

  info = DiP.info @Text
  debug = DiP.info @Text

  main :: IO ()
  main = do
    P.runFinal . P.embedToFinal . runCounterAtomic . runCacheInMemory $ runBotIO (BotToken "") $ do
      react @"messagecreate" $ \msg -> handleErrorByLogging $ do
        when (msg ^. #content == "!count") $ replicateM_ 3 $ do
          val <- getCounter
          info $ "the counter is: " <> fromStrict (showt val)
          void . invokeRequest $ CreateMessage (msg ^. #channelID) ("The value is: " <> showt val)
        when (msg ^. #content == "!say hi") $ replicateM_ 3 . P.async $ do
          info "saying heya"
          Right msg' <- invokeRequest $ CreateMessage (msg ^. #channelID) "heya"
          info "sleeping"
          P.embed $ threadDelay (5 * 1000 * 1000)
          info "slept"
          void . invokeRequest $ EditMessage (msg ^. #channelID) msg' (Just "lol") Nothing
          info "edited"
        when (msg ^. #content == "!explode") $ do
          Just x <- pure Nothing
          debug "unreachable!"
        when (msg ^. #content == "!bye") $ do
          void . invokeRequest $ CreateMessage (msg ^. #channelID) "bye!"
          stopBot
  ```
license-name: MIT
