homepage: https://github.com/nitros12/calamity
changelog-type: markdown
hash: 4b6fd060c9c56dd9c830da1c9ba844abec5b1c44c43b6147c6d7b9e471e7a574
test-bench-deps: {}
maintainer: ben@bensimms.moe
synopsis: A library for writing discord bots
changelog: |
  # Changelog for Calamity

  ## 0.1.2.0

  *2020-04-27*

  * Calamity.Client: runBotIO now has a `Polysemy.Fail` effect

  ## Unreleased changes
basic-deps:
  focus: '>=1.0 && <2'
  polysemy-plugin: '>=0.2 && <0.3'
  exceptions: '>=0.10 && <0.11'
  fmt: '>=0.6 && <0.7'
  bytestring: '>=0.10 && <0.11'
  reflection: '>=2.1 && <3'
  lens-aeson: '>=1.1 && <2'
  stm: '>=2.5 && <3'
  base: '>=4.12 && <5'
  data-default-class: '>=0.1 && <0.2'
  time: '>=1.8 && <1.11'
  unordered-containers: '>=0.2 && <0.3'
  text: '>=1.2 && <2'
  deque: '>=0.4 && <0.5'
  di-polysemy: '>=0.1.1 && <0.2'
  generic-override-aeson: '>=0.0.0.0 && <0.0.1'
  text-show: '>=3.8 && <4'
  async: '>=2.2 && <3'
  websockets: '>=0.12 && <0.13'
  http-date: '>=0.0.8 && <0.1'
  containers: '>=0.6 && <0.7'
  lens: '>=4.18 && <5'
  concurrent-extra: '>=0.7 && <0.8'
  wuss: '>=1.1 && <2'
  mtl: '>=2.2 && <3'
  wreq-patchable: '>=1.0 && <2'
  hashable: '>=1.2 && <2'
  generic-override: '>=0.0.0.0 && <0.0.1'
  stm-chans: '>=3.0 && <4'
  polysemy: '>=1.3 && <2'
  generic-lens: '>=2.0 && <3'
  deepseq: '>=1.4.4.0 && <2'
  df1: '>=0.3 && <0.4'
  scientific: '>=0.3 && <0.4'
  stm-containers: '>=1.1 && <2'
  http-types: '>=0.12 && <0.13'
  typerep-map: '>=0.3 && <0.4'
  aeson: '>=1.4 && <2'
  vector: '>=0.12 && <0.13'
all-versions:
- 0.1.0.0
- 0.1.2.0
author: Ben Simms
latest: 0.1.2.0
description-type: markdown
description: |
  # Calamity

  A discord library for haskell

  # Example

  ``` haskell
  {-# LANGUAGE DataKinds #-}
  {-# LANGUAGE FlexibleContexts #-}
  {-# LANGUAGE GADTs #-}
  {-# LANGUAGE LambdaCase #-}
  {-# LANGUAGE OverloadedLabels #-}

  {-# LANGUAGE OverloadedStrings #-}
  {-# LANGUAGE PolyKinds #-}
  {-# LANGUAGE ScopedTypeVariables #-}
  {-# LANGUAGE TemplateHaskell #-}
  {-# LANGUAGE TypeApplications #-}

  {-# LANGUAGE TypeOperators #-}

  module Main where

  import           Calamity
  import           Calamity.Cache.InMemory
  import           Calamity.Metrics.Noop

  import           Control.Concurrent
  import           Control.Concurrent.STM.TVar
  import           Control.Lens
  import           Control.Monad

  import           Data.Text.Lazy              ( Text, fromStrict )
  import           Data.Text.Strict.Lens

  import qualified DiPolysemy                  as DiP

  import qualified Polysemy                    as P
  import qualified Polysemy.Async              as P
  import qualified Polysemy.AtomicState        as P
  import qualified Polysemy.Embed              as P
  import qualified Polysemy.Fail               as P

  import           Prelude                     hiding ( error )

  import           TextShow

  data Counter m a where
    GetCounter :: Counter m Int

  P.makeSem ''Counter

  runCounterAtomic :: P.Member (P.Embed IO) r => P.Sem (Counter ': r) () -> P.Sem r ()
  runCounterAtomic m = do
    var <- P.embed $ newTVarIO (0 :: Int)
    P.runAtomicStateTVar var $ P.reinterpret (\case
                                                GetCounter -> P.atomicState (\v -> (v + 1, v))) m

  handleFailByLogging m = do
    r <- P.runFail m
    case r of
      Left e -> DiP.error (e ^. packed)
      _      -> pure ()

  handleFailByPrinting m = do
    r <- P.runFail m
    case r of
      Left e -> P.embed $ print (show e)
      _      -> pure ()

  info = DiP.info @Text
  debug = DiP.info @Text

  main :: IO ()
  main = do
    P.runFinal . P.embedToFinal . handleFailByPrinting . runCounterAtomic . runCacheInMemory . runMetricsNoop $ runBotIO
      (BotToken "") $ do
        react @"messagecreate" $ \msg -> handleFailByLogging $ do
          when (msg ^. #content == "!count") $ replicateM_ 3 $ do
            val <- getCounter
            info $ "the counter is: " <> fromStrict (showt val)
            void . invokeRequest $ CreateMessage (msg ^. #channelID) ("The value is: " <> showt val)
          when (msg ^. #content == "!say hi") $ replicateM_ 3 . P.async $ do
            info "saying heya"
            Right msg' <- invokeRequest $ CreateMessage (msg ^. #channelID) "heya"
            info "sleeping"
            P.embed $ threadDelay (5 * 1000 * 1000)
            info "slept"
            void . invokeRequest $ EditMessage (msg ^. #channelID) msg' (Just "lol") Nothing
            info "edited"
          when (msg ^. #content == "!explode") $ do
            Just x <- pure Nothing
            debug "unreachable!"
          when (msg ^. #content == "!bye") $ do
            void . invokeRequest $ CreateMessage (msg ^. #channelID) "bye!"
            stopBot
  ```
license-name: MIT
