homepage: https://github.com/frerich/catamorphism
changelog-type: ''
hash: 19ae5492f2ca4ccff9b5806bd5e3aae0ea1fc445cd9227aaffbd4b37024c982f
test-bench-deps:
  base: -any
  hspec: -any
  catamorphism: -any
maintainer: frerich.raabe@gmail.com
synopsis: Exposes a Template Haskell function for generating catamorphisms.
changelog: ''
basic-deps:
  base: ! '>=4.6 && <4.12'
  template-haskell: ! '>=2.8 && <2.14'
all-versions:
- '0.3.0.0'
- '0.4.0.0'
- '0.4.0.1'
- '0.5.0.0'
- '0.5.0.1'
- '0.5.1.0'
- '0.6.0.0'
- '0.6.1.0'
- '0.6.1.1'
author: Frerich Raabe
latest: '0.6.1.1'
description-type: haddock
description: ! 'This module exposes a ''makeCata'' function which can create catamorphisms
  for

  arbitrary Haskell types. Catamorphisms are functions which deconstruct some

  value by replacing each data constructor with a custom function yielding a

  new value. See <http://www.haskell.org/haskellwiki/Catamorphisms> for a more

  in-depth discussion of catamorphisms in Haskell.


  The Haskell base package already comes with a couple of standard

  catamorphisms, such as ''maybe'' (for ''Maybe'' values). The ''maybe'' function

  could have been generated using ''makeCata'' as follows:


  > -- Defines ''maybe :: b -> (a -> b) -> Maybe a -> b''

  > $(makeCata defaultOptions ''''Maybe)


  However, catamorphisms are especially useful for recursive data structures.

  Consider the following simple example which defines a basic data type for

  modelling sums of numbers, supporting variables:


  > import Data.Morphism.Cata

  > import Data.Maybe (fromJust)

  >

  > data Expr a = Number a

  >             | Variable Char

  >             | Sum (Expr a) (Expr a)

  >

  > -- Defines ''expr :: (a -> b) -> (Char -> b) -> (b -> b -> b) -> Expr a -> b''

  > $(makeCata defaultOptions ''''Expr)


  The ''makeCata'' invocation defines a ''expr'' function which works like a fold
  on

  ''Expr'' values; it can be used to implement various useful other functions:


  > -- Evaluate an Expr, given some variable bindings

  > eval :: Num a => [(Char, a)] -> Expr a -> a

  > eval vars = expr id (fromJust . (`lookup` vars)) (+)

  >

  > -- Pretty-prints an Expr

  > pprint :: Show a => Expr a -> String

  > pprint = expr show show (\a b -> a ++ " + " ++ b)

  >

  > -- Counts the number of variables used in an expr

  > numVars :: Expr a -> Int

  > numVars = expr (const 1) (const 0) (+)'
license-name: BSD3
