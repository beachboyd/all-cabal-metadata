homepage: https://github.com/roman/Haskell-capataz#readme
changelog-type: markdown
hash: f5f3ad77fd3e8727ded8d6300574b86fa5efbd13f916fad9f3968cf7bb0a81d7
test-bench-deps:
  bytestring: ! '>=0.10.8.2 && <0.11'
  tasty-smallcheck: ! '>=0.8.1 && <0.9'
  stm: ! '>=2.4.4.1 && <2.5'
  base: ! '>=4.10.1.0 && <4.11'
  time: ! '>=1.8.0.2 && <1.9'
  unordered-containers: ! '>=0.2.8.0 && <0.3'
  text: ! '>=1.2.3.0 && <1.3'
  uuid: ! '>=1.3.13 && <1.4'
  teardown: ! '>=0.3.0.0 && <0.4'
  safe-exceptions: ! '>=0.1.7.0 && <0.2'
  async: ! '>=2.1.1.1 && <2.3'
  protolude: ! '>=0.2.1 && <0.3'
  data-default: ! '>=0.7.1.1 && <0.8'
  capataz: -any
  tasty-hunit: ! '>=0.10.0.1 && <0.11'
  pretty-show: ! '>=1.6.16 && <1.7'
  tasty-rerun: ! '>=1.1.9 && <1.2'
  tasty: ! '>=0.12.0.1 && <0.13'
  microlens: ! '>=0.4.8.3 && <0.5'
  vector: ! '>=0.12.0.1 && <0.13'
maintainer: open-source@roman-gonzalez.info
synopsis: OTP-like supervision trees in Haskell
changelog: ! "# Change log\n\ncapataz uses [Semantic Versioning][1].\nThe change log
  is available [on GitHub][2].\n\n[1]: http://semver.org/spec/v2.0.0.html\n[2]: https://github.com/roman/capataz/releases\n\n##
  v0.1.0.1\n\n* Bump bounds of `async` dependency\n\n## v0.1.0.0 Who supervises the
  supervisor?\n\n**BREAKING CHANGES**\n\n* Introduction of the `Process` type which
  is composed of both `Supervisor` and\n  `Worker` types\n* Replace `defWorkerSpec`
  in favor of `workerSpec` and `workerSpecWithDefaults`\n  to build static workers\n*
  Replace of `defWorkerOptions` in favor of `buildWorkerOptions` and\n  `buildWorkerOptionsWithDefaults`
  to build dynamic workers\n* Replace `terminateWorker` in favor of `terminateProcess`\n*
  Add `supervisorSpec`, `supervisorSpecWithDefaults` to build static supervision\n
  \ trees\n* Add `forkSupervisor`, `buildSupervisorOptions` and\n  `buildSupervisorOptionsWithDefaults`
  to build dynamic supervision trees\n* Replace usage of default records semantics
  in favor of Lenses\n* Add `joinCapatazThread` to avoid providing direct access to
  async of root\n  supervision tree\n* Add `getSupervisorProcessId` to access the
  `ProcessId` of a given `Supervisor`\n  record (for dynamic termination)\n* Add `getSupervisorAsync`
  to access the `Async ()` record of a supervisor\n  process thread\n* Add `getCapatazTeardown`
  to access the `Teardown` record of the capataz system\n* Move `CapatazEvent` records
  to new module `Control.Concurrent.Capataz.Event`\n  to avoid requiring `DuplicateRecordFields`
  extension on API users\n* Remove `WorkerAction` alias as it is used for library
  development\n  documentation\n* Add capataz-repo-watcher example to showcase static
  supervision trees\n* Update capataz-simple-example unix-process example\n* `forkCapataz`
  signature now requires name for root supervisor\n\n## v0.0.0.2\n\n* Bump bounds
  of `tasty` dependency\n\n## v0.0.0.1\n\n* Bump bounds of `tasty` dependency\n* Bump
  bounds of `tasty-hunit` dependency\n\n## v0.0.0.0\n\n* First release of capataz\n*
  Support for supervising simple worker `IO ()` sub-routines\n"
basic-deps:
  bytestring: ! '>=0.10.8.2 && <0.11'
  stm: ! '>=2.4.4.1 && <2.5'
  base: ! '>=4.10.1.0 && <4.11'
  time: ! '>=1.8.0.2 && <1.9'
  unordered-containers: ! '>=0.2.8.0 && <0.3'
  text: ! '>=1.2.3.0 && <1.3'
  uuid: ! '>=1.3.13 && <1.4'
  teardown: ! '>=0.3.0.0 && <0.4'
  safe-exceptions: ! '>=0.1.7.0 && <0.2'
  async: ! '>=2.1.1.1 && <2.3'
  protolude: ! '>=0.2.1 && <0.3'
  data-default: ! '>=0.7.1.1 && <0.8'
  microlens: ! '>=0.4.8.3 && <0.5'
  vector: ! '>=0.12.0.1 && <0.13'
all-versions:
- '0.0.0.0'
- '0.0.0.1'
- '0.0.0.2'
- '0.1.0.0'
- '0.1.0.1'
author: Roman Gonzalez
latest: '0.1.0.1'
description-type: markdown
description: ! "# Capataz\n\n> Our greatest glory is not in never failing, but in
  rising every time we fail.– Confucius\n\n## Table Of Contents\n\n* [Raison d'etre](#raison-detre)\n*
  [Documentation](#documentation)\n* [Development](#development)\n\n## Raison d'être\n\nAs
  time progresses, I've come to love developing concurrent applications in\nHaskell,
  its API (STM, MVars, etc.) and light threading RTS bring a lot to the\ntable. There
  is another technology that is more famous than Haskell in\nregards to concurrency,
  and that is Erlang, more specifically its OTP library.\n\nIf you wonder why that
  is, you may need to look into the OTP library design,\nactors systems (in general)
  provide an architecture that enables applications to\nbe tolerant to failure through
  the enforcement of communication via message\npassing and by making use of a critical
  infrastructure piece called a *Supervisor*.\n\nAfter trying to replicate Erlang's
  behavior on Haskell applications by using the\n[distributed-process](https://hackage.haskell.org/package/distributed-process)\nlibrary
  (a clone of OTP), and after implementing several (disposable) iterations\nof actor
  systems in Haskell, I've settled with just this library, one that\nprovides a simple
  Supervisor API.\n\nThis library is intended to be a drop-in replacement to `forkIO`
  invocations\nthroughout your codebase, the difference being, you'll need to do a
  bit more of\nsetup specifying supervision rules, and also pass along a reference
  of a\nsupervisor for every thread you fork.\n\n### Why not [distributed-process](https://hackage.haskell.org/package/distributed-process)?\n\n`distributed-process`
  is an impressive library, and brings many great utilities\nif you need to develop
  applications that need to be distributed and reliable.\nHowever, it is a heavyweight
  solution that will enforce serious changes to your\napplication. This library is
  intended to provide the reliability benefits of\n`distributed-process`, without
  the constraints imposed by the *distributed*\npart.\n\n### Why not a complete actor
  system?\n\nActor systems are very pervasive, they impose specific design constraints
  on\nyour application which can be rather expensive. This library attempts to bring\nsome
  of the reliability benefits of actor systems without the \"change all your\napplication
  to work with actors\" part of the equation.\n\nThat said, this library can serve
  as a basis for a more prominent library that\nprovides an opinionated Inter-Process
  communication scheme. If you happen to\nattempt at doing exactly that, please let
  me know, I would love to learn about\nsuch initiatives.\n\n### Why not [async](https://hackage.haskell.org/package/async)?\n\n`async`
  is a fabulous library that allows Applicative composition of small\nasynchronous
  sub-routines into bigger ones and link errors between them. Given\nthis, `async`
  fits the bill perfectly for small operations that happen\nconcurrently, not necessarily
  for long living threads that need to be restarted.\nThis library attempts not to
  replace async's forte, but rather provides other\nbenefits not found in `async`,
  like automatically restarting threads with a given\nrecipe under error situations.\n\n##
  Documentation\n\nDocumentation can be found [here](https://romanandreg.gitbooks.io/capataz/content/)\n\n##
  Installation\n\n[![Hackage](https://img.shields.io/hackage/v/capataz.svg)](https://img.shields.io/hackage/v/capataz.svg)\n[![Stackage
  LTS](https://www.stackage.org/package/capataz/badge/lts)](http://stackage.org/lts/package/capataz)\n[![Stackage
  Nightly](https://www.stackage.org/package/capataz/badge/nightly)](http://stackage.org/nightly/package/capataz)\n\nMake
  sure you include the following entry on your [cabal file's\ndependecies](https://www.haskell.org/cabal/users-guide/developing-packages.html#build-information)\nsection.\n\n```cabal\nlibrary:\n
  \ build-depends: capataz\n```\n\nOr on your `package.yaml`\n\n```\ndependencies:\n-
  capataz\n```\n\n## Development\n\n[![Build Status](https://travis-ci.org/roman/Haskell-capataz.svg?branch=master)](https://travis-ci.org/roman/Haskell-capataz)\n[![Github](https://img.shields.io/github/commits-since/roman/haskell-capataz/v0.1.0.0.svg)](https://img.shields.io/github/commits-since/roman/haskell-capataz/v0.1.0.0.svg)\n[![Hackage
  Dependencies](https://img.shields.io/hackage-deps/v/capataz.svg)](http://packdeps.haskellers.com/feed?needle=capataz)\n\nFollow
  the [developer guidelines](https://romanandreg.gitbooks.io/capataz/content/developer-guidelines.html)\n\n##
  In future releases\n\n* Replace Protolude in favor of RIO\n* Documentation of performance
  analysis\n* Documentation improvements\n* capataz-dashboard package that provides
  web-ui with Supervisor statistics\n* Ensure unit tests always finish on all concurrent
  scenarios (dejafu experiment)\n"
license-name: MIT
