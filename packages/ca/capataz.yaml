homepage: https://github.com/roman/Haskell-capataz#readme
changelog-type: markdown
hash: a199e21a07744511ad3715ff2f87398eaef97c69063fc0429a6e27f431766797
test-bench-deps:
  bytestring: ! '>=0.10.8.2 && <0.11'
  tasty-smallcheck: ! '>=0.8.1 && <0.9'
  stm: ! '>=2.4.4.1 && <2.5'
  base: ! '>=4.10.1.0 && <4.11'
  time: ! '>=1.8.0.2 && <1.9'
  unordered-containers: ! '>=0.2.8.0 && <0.3'
  text: ! '>=1.2.2.2 && <1.3'
  uuid: ! '>=1.3.13 && <1.4'
  teardown: ! '>=0.3.0.0 && <0.4'
  safe-exceptions: ! '>=0.1.6.0 && <0.2'
  async: ! '>=2.1.1.1 && <2.2'
  protolude: ==0.2.*
  data-default: ! '>=0.7.1.1 && <0.8'
  capataz: -any
  tasty-hunit: ! '>=0.10.0.1 && <0.11'
  pretty-show: ! '>=1.6.16 && <1.7'
  tasty-rerun: ! '>=1.1.8 && <1.2'
  tasty: ! '>=1.0.0.1 && <1.1'
  vector: ! '>=0.12.0.1 && <0.13'
maintainer: capataz@roman-gonzalez.info
synopsis: OTP-like supervision trees in Haskell
changelog: ! '# Change log


  capataz uses [Semantic Versioning][1].

  The change log is available [on GitHub][2].


  [1]: http://semver.org/spec/v2.0.0.html

  [2]: https://github.com/roman/capataz/releases


  ## v0.0.0.2


  * Bump bounds of `tasty` dependency


  ## v0.0.0.1


  * Bump bounds of `tasty` dependency

  * Bump bounds of `tasty-hunit` dependency


  ## v0.0.0.0


  * First release of capataz

  * Support for supervising simple worker `IO ()` sub-routines

'
basic-deps:
  bytestring: ! '>=0.10.8.2 && <0.11'
  stm: ! '>=2.4.4.1 && <2.5'
  base: ! '>=4.10.1.0 && <4.11'
  time: ! '>=1.8.0.2 && <1.9'
  unordered-containers: ! '>=0.2.8.0 && <0.3'
  text: ! '>=1.2.2.2 && <1.3'
  uuid: ! '>=1.3.13 && <1.4'
  teardown: ! '>=0.3.0.0 && <0.4'
  safe-exceptions: ! '>=0.1.6.0 && <0.2'
  async: ! '>=2.1.1.1 && <2.2'
  protolude: ==0.2.*
  data-default: ! '>=0.7.1.1 && <0.8'
  vector: ! '>=0.12.0.1 && <0.13'
all-versions:
- '0.0.0.0'
- '0.0.0.1'
- '0.0.0.2'
author: Roman Gonzalez
latest: '0.0.0.2'
description-type: markdown
description: ! "# Capataz\n\n> Our greatest glory is not in never failing, but in
  rising every time we fail.â€“ Confucius\n\n## Table Of Contents\n\n* [Raison d'etre](#raison-detre)\n*
  [Documentation](#documentation)\n* [Development](#development)\n\n## Raison d'etre\n\nAs
  time progresses, I've come to love developing concurrent applications in\nHaskell,
  its API (STM, MVars, etc.) and light threading RTS bring a lot to the\ntable. There
  is another technology that is more famous than Haskell in\nregards to concurrency,
  and that is Erlang, more specifically its OTP library.\n\nIf you wonder why that
  is, you may need to look into the OTP library design,\nactors systems (in general)
  provide an architecture that enables applications to\nbe tolerant to failure through
  the enforcement of communication via message\npassing and by making use of a critical
  infrastructure piece called a *Supervisor*.\n\nAfter trying to replicate Erlang's
  behavior on Haskell applications by using the\n[distributed-process](https://hackage.haskell.org/package/distributed-process)\nlibrary
  (a clone of OTP), and after implementing several (disposable) iterations\nof actor
  systems in Haskell, I've settled with just this library, one that\nprovides a simple
  Supervisor API.\n\nThis library is intended to be a drop-in replacement to `forkIO`
  invocations\nthroughout your codebase, the difference being, you'll need to do a
  bit more of\nsetup specifying supervision rules, and also pass along a reference
  of a\ncapataz descriptor to every thread fork.\n\n### Why not [distributed-process](https://hackage.haskell.org/package/distributed-process)?\n\n`distributed-process`
  is an impressive library, and brings many great utilities\nif you need to develop
  applications that are reliable. However, it is a\nheavyweight solution that will
  enforce serious changes to your application. It\nalso optimizes its implementation
  around the *distributed* part of its name.\nThis library is intended to provide
  some benefits of `distributed-process` ,\nwithout the baggage.\n\n### Why not a
  complete actor system?\n\nActor systems are very pervasive, they impose specific
  design constraints on\nyour application which can be rather expensive. This library
  attempts to bring\nsome of the reliability benefits of actor systems without the
  \"change all your\napplication to work with actors\" part of the equation.\n\nThat
  said, this library can serve as a basis for a more prominent library that\nprovides
  an opinionated Inter-Process communication scheme. If you happen to\nattempt at
  doing exactly that, please let me know, I would love to learn about\nsuch initiatives.\n\n###
  Why not [async](https://hackage.haskell.org/package/async)?\n\n`async` is a fabulous
  library that allows Applicative composition of small\nasynchronous sub-routines
  into bigger ones and link errors between them. Given\nthis, `async` fits the bill
  perfectly for small operations that happen\nconcurrently, not necessarily for long
  living threads that need to be restarted.\nThis library attempts not to replace
  async's forte, but rather provides other\nbenefits not found in `async`, like automatically
  restarting threads with a given\nrecipe under error situations.\n\n## Documentation\n\nDocumentation
  can be found [here](https://romanandreg.gitbooks.io/capataz/content/)\n\n## Installation\n\n[![Hackage](https://img.shields.io/hackage/v/capataz.svg)](https://img.shields.io/hackage/v/capataz.svg)\n[![Stackage
  LTS](https://www.stackage.org/package/capataz/badge/lts)](http://stackage.org/lts/package/capataz)\n[![Stackage
  Nightly](https://www.stackage.org/package/capataz/badge/nightly)](http://stackage.org/nightly/package/capataz)\n\nMake
  sure you include the following entry on your [cabal file's\ndependecies](https://www.haskell.org/cabal/users-guide/developing-packages.html#build-information)\nsection.\n\n```cabal\nlibrary:\n
  \ build-depends: capataz\n```\n\nOr on your `package.yaml`\n\n```\ndependencies:\n-
  capataz\n```\n\n## Development\n\n[![Build Status](https://travis-ci.org/roman/Haskell-capataz.svg?branch=master)](https://travis-ci.org/roman/Haskell-capataz)\n[![Github](https://img.shields.io/github/commits-since/roman/haskell-capataz/v0.0.0.1.svg)](https://img.shields.io/github/commits-since/roman/haskell-capataz/v0.0.0.1.svg)\n[![Hackage
  Dependencies](https://img.shields.io/hackage-deps/v/capataz.svg)](http://packdeps.haskellers.com/feed?needle=capataz)\n\nFollow
  the [developer guidelines](https://romanandreg.gitbooks.io/capataz/content/developer-guidelines.html)\n\n##
  In next release\n\n* Add support for supervising supervisors\n* Ensure unit tests
  always finish on all concurrent scenarios (dejafu experiment)\n"
license-name: MIT
