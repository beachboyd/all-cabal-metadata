homepage: https://github.com/centromere/cacophony#readme
changelog-type: markdown
hash: 7490df13b4d38005e82133eb7c9c506c335692d223eeed684e67d80b2ef34d95
test-bench-deps:
  hlint: -any
  bytestring: -any
  base: ! '>=4.9 && <5'
  text: -any
  criterion: -any
  cacophony: -any
  async: -any
  base16-bytestring: -any
  attoparsec: -any
  deepseq: -any
  aeson: -any
  directory: -any
maintainer: John Galt <jgalt@centromere.net>
synopsis: A library implementing the Noise protocol.
changelog: ! "# 0.10.1\n\n* Set default GHC version to 8.4\n\n* Support GHC > 8.0.2\n\n*
  Parse pattern names more efficiently in unit tests\n\n* Use preferred Curve448 module
  from cryptonite\n\n* Add list of supported handshake parameters to README\n\n# 0.10.0\n\n*
  Completely refactored API\n\n* Added rev32 support\n\n* Removed examples because
  they are difficult to maintain\n\n* Added noise-repl tool\n\n# 0.9.2\n\n* Added
  ability to export raw symmetric keys\n\n# 0.9.1\n\n* Enabled llvm flag support on
  executables\n\n* Removed deepseq library dependency\n\n* Disallowed reserved nonce
  (2^64 - 1)\n\n* Fixed problem with CipherState count not incrementing\n\n# 0.9.0\n\n*
  Removed secondary key support (rev 31)\n\n* Renamed dh tokens (rev 31)\n\n* Added
  Noise-C vectors\n\n* Regenerated test vectors\n\n* Now using IsString instance of
  ScrubbedBytes from memory package\n\n* Linting\n\n# 0.8.0\n\n* Exceptions are now
  provided by the safe-exceptions package\n  (breaking API change)\n\n* Added Noise\\_XXfallback
  pattern\n\n* Minor improvements to handshake pattern definition\n\n* Updated non-standard
  handshake patterns to conform with rev 30\n\n* Fixed bug which caused echo-server
  to read wrong public key\n\n# 0.7.0\n\n* Major API overhaul and refactoring\n\n*
  Added test vector support\n\n* Added secondary symmetric key support\n\n* Added
  GHC 8.0.2 to unit tests\n\n* Removed Noise\\_XR\n\n* General code cleanup and other
  minor tweaks\n\n# 0.6.0\n\n* Added ability to abort handshakes based on the remote
  party's public key\n\n* Improved documentation\n\n* Factored out ScrubbedBytes utilities
  to separate module\n\n* Added echo-server and echo-client example\n\n* Renamed HandshakeStateParams
  to HandshakeOpts\n\n# 0.5.0\n\n* Added Curve448 support\n\n* Major refactoring and
  API changes\n  A DSL was created to represent handshake patterns.\n\n* Added GHC
  7.10.3 to unit tests\n\n# 0.4.0\n\n* Improved documentation\n\n* Added basic benchmarks\n\n*
  Added better exception handling\n\n* Improved handshakeState API\n\n* Added psk2
  functionality\n\n* Unit test cleanup\n\n* Renamed symmetricHandshake to symmetricState\n\n*
  Added BLAKE2, SHA512, AESGCM support\n\n# 0.3.0\n\n* Brought API up to date with
  current version of spec (17)\n\n# 0.2.0\n\n* Added support for one-way handshakes\n\n*
  Fixed Noise\\_IX\n\n* Added helper functions for ScrubbedBytes / ByteString conversion\n\n#
  0.1.0.0\n\n* First version.\n"
basic-deps:
  exceptions: -any
  free: -any
  bytestring: -any
  base: ! '>=4.9 && <5'
  safe-exceptions: -any
  monad-coroutine: -any
  memory: -any
  lens: -any
  cryptonite: ! '>=0.22'
  mtl: -any
  transformers: -any
all-versions:
- 0.10.0
- 0.10.1
author: ''
latest: 0.10.1
description-type: markdown
description: ! "# cacophony\n\n[![Build Status](https://travis-ci.org/centromere/cacophony.svg?branch=master)](https://travis-ci.org/centromere/cacophony)\n[![Haskell](http://b.repl.ca/v1/language-haskell-blue.png)](http://www.haskell.org)\n\nThis
  library implements the [Noise](https://noiseprotocol.org) protocol.\n\n## Basic
  Usage\n\n1. Import the modules for the kind of handshake you'd like to use.\n\n
  \  For example, if you want to use `Noise_IK_25519_AESGCM_SHA256`, your imports
  would be:\n\n   ```haskell\n   import Crypto.Noise\n   import Crypto.Noise.Cipher.AESGCM\n
  \  import Crypto.Noise.DH -- Used to generate and manipulate keys\n   import Crypto.Noise.DH.Curve25519\n
  \  import Crypto.Noise.Hash.SHA256\n   import Crypto.Noise.HandshakePatterns (noiseIK)\n
  \  ```\n\n2. Set the handshake parameters.\n\n   Ensure that you provide the keys
  which are required by the handshake pattern you choose. For example,\n   the `Noise_IK`
  pattern requires that the initiator provides a local static key and a remote static
  key,\n   while the responder is only responsible for a local static key. You can
  use `defaultHandshakeOpts` to\n   return a default set of options in which all keys
  are set to `Nothing`. The initiator must set a\n   local ephemeral key for all handshake
  patterns. The responder must set a local ephemeral key for all\n   interactive (i.e.
  not one-way) patterns.\n\n   ```haskell\n   -- Initiator\n   localEphemeralKey <-
  dhGenKey :: IO (KeyPair Curve25519)\n\n   let dho = defaultHandshakeOpts InitiatorRole
  \"prologue\" :: HandshakeOpts Curve25519\n       iho = setLocalStatic      (Just
  localStaticKey)\n             . setLocalEphemeral (Just localEphemeralKey)\n             .
  setRemoteStatic   (Just remoteStaticKey) -- communicated out-of-band\n             $
  dho\n\n   -- Responder\n   localEphemeralKey <- dhGenKey :: IO (KeyPair Curve25519)\n\n
  \  let dho = defaultHandshakeOpts ResponderRole \"prologue\" :: HandshakeOpts Curve25519\n
  \      rho = setLocalStatic      (Just localStaticKey)\n             . setLocalEphemeral
  (Just localEphemeralKey)\n             $ dho\n   ```\n\n3. Create the Noise state.\n\n
  \  ```haskell\n   -- Initiator\n   let ins = noiseState iho noiseIK :: NoiseState
  AESGCM Curve25519 SHA256\n\n   -- Responder\n   let rns = noiseState rho noiseIK
  :: NoiseState AESGCM Curve25519 SHA256\n   ```\n\n4. Send and receive messages.\n\n
  \  ```haskell\n   -- Initiator\n   let writeResult = writeMessage \"They must find
  it difficult -- those who have taken authority as the truth, rather than truth as
  the authority.\" ins\n   case writeResult of\n     NoiseResultMessage ciphertext
  ins' -> ...\n     NoiseResultNeedPSK   _ -> error \"something terrible happened\"
  -- will never happen in Noise_IK\n     NoiseResultException _ -> error \"something
  terrible happened\"\n\n   -- Responder\n   let readResult = readMessage ciphertext
  rns\n   case readResult of\n     NoiseResultMessage plaintext rns' -> ...\n     NoiseResultNeedPSK
  \  _ -> error \"something terrible happened\"\n     NoiseResultException _ -> error
  \"something terrible happened\"\n   ```\n\n   **Ensure that you never re-use a NoiseState
  to send more than one message.**\n\n   Decrypted messages are stored internally
  as `ScrubbedBytes` and will be wiped from memory when they are\n   destroyed.\n\n###
  Helper Functions\n\nThe following functions are found in `Crypto.Noise.DH` and are
  used to manipulate keys:\n\n  * `dhGenKey` -- Generate a fresh (private, public)
  key pair\n  * `dhPubToBytes` -- Convert a public key to `ScrubbedBytes`\n  * `dhBytesToPub`
  -- Convert `ScrubbedBytes` to a public key\n  * `dhSecToBytes` -- Convert a private
  key to `ScrubbedBytes`\n  * `dhBytesToPair` -- Convert `ScrubbedBytes` to a (private,
  public) key pair\n\nThe following functions are found in `Crypto.Noise`:\n\n  *
  `remoteStaticKey` -- For handshake patterns where the remote party's static key
  is transmitted, this function\n    can be used to retrieve it. This allows for the
  creation of public key-based access-control lists.\n\n  * `handshakeComplete` --
  Returns `True` if the handshake is complete.\n\n  * `processPSKs` -- This function
  repeatedly applies PSKs to a NoiseState until the list of PSKs becomes empty\n    or
  the handshake pattern stops asking for PSKs.\n\n  * `handshakeHash` -- Retrieves
  the `h` value associated with the conversation's SymmetricState. This value is\n
  \   intended to be used for channel binding. For example, the initiator might cryptographically
  sign this value\n    as part of some higher-level authentication scheme. See section
  11.2 of the protocol for details.\n\n  * `rekeySending` and `rekeyReceiving` --
  Rekeys the given NoiseState according to section 11.3 of the protocol.\n\n## Supported
  Features\n\nAll combinations of the following handshake parameters are officially
  supported and covered by the unit tests:\n\n* Patterns\n  * NN\n  * KN\n  * NK\n
  \ * KK\n  * NX\n  * KX\n  * XN\n  * IN\n  * XK\n  * IK\n  * XX\n  * IX\n  * N\n
  \ * K\n  * X\n  * NNpsk0\n  * NNpsk2\n  * NKpsk0\n  * NKpsk2\n  * NXpsk2\n  * XNpsk3\n
  \ * XKpsk3\n  * XXpsk3\n  * KNpsk0\n  * KNpsk2\n  * KKpsk0\n  * KKpsk2\n  * KXpsk2\n
  \ * INpsk1\n  * INpsk2\n  * IKpsk1\n  * IKpsk2\n  * IXpsk2\n  * Npsk0\n  * Kpsk0\n
  \ * Xpsk1\n\n* Ciphers\n  * AESGCM\n  * ChaChaPoly1305\n\n* Curves\n  * Curve25519\n
  \ * Curve448\n\n* Hashes\n  * BLAKE2b\n  * BLAKE2s\n  * SHA256\n  * SHA512\n\n##
  Vectors\n\nTest vectors can be generated and verified using the `vectors` program.
  It accepts no arguments. When run,\nit will check for the existence of `vectors/cacophony.txt`
  within the current working directory. If it is not\nfound, it is generated. If it
  is found, it is verified. All files within the `vectors/` directory (regardless\nof
  their name) are also verified. Note that this program can only generate and verify
  vectors whose handshake\npatterns are pre-defined in this library.\n\n## Custom
  Handshakes\n\nIf the built-in handshake patterns are insufficient for your application,
  you can define your own. Note that\nthis should be done with care.\n\nExample:\n\n```haskell\nnoiseFOOpsk0
  :: HandshakePattern\nnoiseFOOpsk0 = handshakePattern \"FOOpsk0\" $\n  preInitiator
  s            *>\n  preResponder s            *>\n  initiator (psk *> e *> es *>
  ss) *>\n  responder (e *> ee *> se)\n```\n\n## Handshake Validation\n\n`HandshakePattern`s
  can be validated for compliance as described in sections 7.1 and 9.3 of the protocol:\n\n```\nÎ»>
  let noiseBAD = handshakePattern \"BAD\" $ preResponder ss *> initiator (e *> se
  *> e)\n[DHInPreMsg (0,0),InitMultipleETokens (1,2),InitSecretNotRandom (1,3)]\n\nÎ»>
  validateHandshakePattern noiseKKpsk0\n[]\n```\n\nSee the `Crypto.Noise.Validation`
  module for details.\n\n## Tools\n\n### format-vectors.py\n\nVectors generated by
  the vector program are formatted as minified JSON. This python script takes the
  path\nto a vector file as an argument and reformats it so that it conforms to\n[the
  style](https://github.com/noiseprotocol/noise_wiki/wiki/Test-vectors) specified
  on the Noise Wiki.\n\n### noise-repl\n\nThis program acts as a kind of REPL for
  Noise messages. It supports sending and receiving messages via UDP\nor via a pipe
  to a shell command.\n\nAll messages transmitted via a pipe are expected to be prepended
  by a two byte big-endian length.\n"
license-name: LicenseRef-PublicDomain
