homepage: https://github.com/tweag/capability
changelog-type: markdown
hash: 59fb5c11627d56be3df9f726c920ca12e76a8a4652057ddb6d20bb3c890a9da5
test-bench-deps:
  streaming: ! '>=0.2 && <0.3'
  unliftio: ! '>=0.2 && <0.3'
  base: ! '>=4.12 && <5.0'
  hspec: ! '>=2.0 && <3.0'
  text: ! '>=0.2 && <1.3'
  containers: ! '>=0.6 && <0.7'
  silently: ! '>=1.2 && <1.3'
  lens: ! '>=4.16 && <5.0'
  mtl: ! '>=2.0 && <3.0'
  capability: -any
  temporary: ! '>=1.0 && <1.4'
maintainer: andreas.herrmann@tweag.io
synopsis: Extensional capabilities and deriving combinators
changelog: ! '# Revision history for capability


  ## 0.1.0.0 -- 2018-10-04


  * Initial release.

'
basic-deps:
  streaming: ! '>=0.2 && <0.3'
  exceptions: ! '>=0.6 && <0.11'
  unliftio: ! '>=0.2 && <0.3'
  base: ! '>=4.12 && <5.0'
  safe-exceptions: ! '>=0.1 && <0.2'
  monad-control: ! '>=1.0 && <1.1'
  dlist: ! '>=0.8 && <0.9'
  lens: ! '>=4.16 && <5.0'
  unliftio-core: ! '>=0.1 && <0.2'
  mutable-containers: ! '>=0.3 && <0.4'
  mtl: ! '>=2.0 && <3.0'
  monad-unlift: ! '>=0.2 && <0.3'
  generic-lens: ! '>=1.0 && <1.1'
  transformers: ! '>=0.5.5 && <0.6'
  primitive: ! '>=0.6 && <0.7'
all-versions:
- '0.1.0.0'
author: ''
latest: '0.1.0.0'
description-type: markdown
description: ! "# capability: effects, extensionally\n\nA capability is a type class
  that says explicitly which effects\na function is allowed to use. The [`mtl`][mtl]
  works like this too.\nBut unlike the `mtl`, this library decouples effects from
  their\nimplementation. What this means in practice:\n\n- You can implement large
  sets of capabilities using the\n  efficient [`ReaderT` pattern][readert], rather
  than a slow monad\n  transformer stack.\n- Capabilities compose well: e.g. it's
  easy to have multiple reader\n  effects.\n- You can use a writer effect without
  implementing it as a writer\n  monad (which is known to [leak space][writer-space-leak]).\n-
  You can reason about effects. For instance, if a monad provides a\n reader effect
  at type `IORef A`, it also provides a state effect at type `A`\n\nFor more on these,
  you may want to read the announcement [blog\n post][blog].\n\nThis library is an
  alternative to the [`mtl`][mtl]. It defines a set\nof standard, reusable capability
  type classes, such as the `HasReader`\nand `HasState` type classes, which provide
  the standard reader and\nstate effects, respectively.\n\nWhere `mtl` instances only
  need to be defined once and for all,\ncapability-style programming has traditionally
  suffered from verbose\nboilerplate: rote instance definitions for every new implementation
  of\nthe capability. Fortunately GHC 8.6 introduced\nthe [`DerivingVia`][deriving-via]
  language extension. We use it to\nremove the boilerplate, turning capability-style
  programming into an\nappealing alternative to `mtl`-style programming. The\n[`generic-lens`][generic-lens]
  library is used to access fields of\nstructure in the style of the [`ReaderT` pattern][readert].\n\nAn
  additional benefit of separating capabilities from their\nimplementation is that
  they avoid a pitfall of the `mtl`. In the\n`mtl`, two different `MonadState` are
  disambiguated by their types,\nwhich means that it is difficult to have two `MonadState
  Int` in the\nsame monad stack. Capability type classes are parameterized by a name\n(also
  known as a *tag*). This makes it possible to combine multiple\nversions of the same
  capability. For example,\n\n```haskell\ntwoStates :: (HasState \"a\" Int m, HasState
  \"b\" Int m) => m ()\n```\n\nHere, the tags `\"a\"` and `\"b\"` refer to different
  state spaces.\n\nIn summary, compared to the `mtl`:\n\n- capabilities represent
  what effects a function can use, rather than\n  how the monad is constructed;\n-
  capabilities are named, rather than disambiguated by type;\n- capabilites are discharged
  with deriving-via combinators\n  and [`generic-lens`][generic-lens], rather than
  with instance\n  resolution.\n\nAn example usage looks like this:\n\n``` haskell\ntestParity
  :: (HasReader \"foo\" Int m, HasState \"bar\" Bool m) => m ()\ntestParity = do\n
  \ num <- ask @\"foo\"\n  put @\"bar\" (even num)\n\ndata Ctx = Ctx { foo :: Int,
  bar :: IORef Bool }\n  deriving Generic\n\nnewtype M a = M { runM :: Ctx -> IO a
  }\n  deriving (Functor, Applicative, Monad) via ReaderT Ctx IO\n  -- Use DerivingVia
  to derive a HasReader instance.\n  deriving (HasReader \"foo\" Int) via\n    --
  Pick the field foo from the Ctx record in the ReaderT environment.\n    Field \"foo\"
  \"ctx\" (MonadReader (ReaderT Ctx IO))\n  -- Use DerivingVia to derive a HasState
  instance.\n  deriving (HasState \"bar\" Bool) via\n    -- Convert a reader of IORef
  to a state capability.\n    ReaderIORef (Field \"bar\" \"ctx\" (MonadReader (ReaderT
  Ctx IO)))\n\nexample :: IO ()\nexample = do\n    rEven <- newIORef False\n    runM
  testParity (Ctx 2 rEven)\n    readIORef rEven >>= print\n    runM testParity (Ctx
  3 rEven)\n    readIORef rEven >>= print\n```\n\nFor more complex examples, see the
  [Examples section](#examples) and\nthe [`examples` subtree](./examples).\n\nThis
  package is not available on Hackage yet, as some of its\ndependencies have not been
  updated to GHC 8.6, yet.\n\nAPI documentation can be found in the artifacts tab
  of any successful\nbuild in the [CircleCI project][circleci].\n\n[circleci]: https://circleci.com/gh/tweag/capabilities-via/tree/master\n[mtl]:
  http://hackage.haskell.org/package/mtl\n[blog]: https://www.tweag.io/posts/2018-10-04-capability.html\n[deriving-via]:
  https://downloads.haskell.org/~ghc/8.6.1/docs/html/users_guide/glasgow_exts.html#deriving-via\n[generic-lens]:
  https://hackage.haskell.org/package/generic-lens\n[readert]: https://www.fpcomplete.com/blog/2017/06/readert-design-pattern\n[writer-space-leak]:
  https://blog.infinitenegativeutility.com/2016/7/writer-monads-and-space-leaks\n\n##
  Examples\n\nAn example is provided in [`WordCount`](examples/WordCount.hs).\nExecute
  the following commands to try it out:\n\n```\n$ nix-shell --pure --run \"cabal configure
  --enable-tests\"\n$ nix-shell --pure --run \"cabal repl examples\"\n\nghci> :set
  -XOverloadedStrings\nghci> wordAndLetterCount \"ab ba\"\nLetters\n'a': 2\n'b': 2\nWords\n\"ab\":
  1\n\"ba\": 1\n```\n\nTo execute all examples and see if they produce the expected
  results run\n\n```\n$ nix-shell --pure --run \"cabal test examples --show-details=streaming
  --test-option=--color\"\n```\n\n## Build instructions\n\n### Nix Shell\n\nSome of
  this package's dependencies require patches to build with GHC 8.6.\nThese patches
  are defined in\n[`nix/haskell/default.nix`](nix/haskell/default.nix).\nA development
  environment with all patched dependencies in scope is defined in\n[`shell.nix`](shell.nix).\n\n###
  Cachix Nix Cache\n\nA Nix cache for this package's dependencies is provided via
  [cachix][cachix].\nIf you have [cachix][cachix] installed, then you can activate
  it by executing\n\n```\n$ cachix use tweag\n```\n\n[cachix]: https://cachix.org/\n\n###
  Build\n\nThe build instructions assume that you have [Nix][nix] installed.\nExecute
  the following command to build the library.\n\n```\n$ nix-shell --pure --run \"cabal
  configure\"\n$ nix-shell --pure --run \"cabal build\"\n```\n\n[nix]: https://nixos.org/nix/\n"
license-name: BSD3
