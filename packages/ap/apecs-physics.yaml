homepage: https://github.com/jonascarpay/apecs-physics#readme
changelog-type: ''
hash: 1ca53beb9723e35a74372c9f29295c171819c48b3116039c6ae3115eb1cb8ac0
test-bench-deps: {}
maintainer: jonascarpay@gmail.com
synopsis: 2D physics for apecs
changelog: ''
basic-deps:
  apecs: -any
  inline-c: -any
  base: ! '>=4.7 && <4.13'
  containers: -any
  linear: -any
  template-haskell: -any
  vector: -any
all-versions:
- '0.2.0.0'
- '0.3.0'
author: Jonas Carpay
latest: '0.3.0'
description-type: markdown
description: ! "# apecs-physics\n\n2D physics library for apecs.\nUses the [Chipmunk](https://github.com/slembcke/Chipmunk2D)
  physics engine.\nThe [apecs-gloss](../apecs-gloss) package provides a simple optional
  [gloss](https://github.com/benl23x5/gloss)-based renderer.\n\nFeel free to create
  an issue or PR for suggestions/questions/requests/critiques/spelling fixes/etc.\nSee
  [TODO.md](TODO.md) for suggestions if you want to help out with the code.\n\nThe
  examples directory contains a number of examples, each can be run with `stack build
  && stack <examplename>`:\n\n### helloworld\n![Screenshot](helloworld.png)\n\n```haskell\nmakeWorld
  \"World\" [''Physics, ''BodyPicture, ''Camera]\n```\nGenerate a world.\nThe `Physics`
  component adds a physics space to the world.\nThe `BodyPicture` contains a gloss
  `Picture`, which the renderer will match to the `Body`'s position and orientation.\nThe
  `Camera` component tracks a camera position and zoom factor.\n\n```haskell\ninitialize
  = do\n  set global ( Camera (V2 0 1) 60\n             , earthGravity )\n```\nGlobals
  can be set with any entity argument, `global` is just an alias for -1.\n`earthGravity
  = V2 0 (-9.81)`, normal earth surface gravity if we assume normal MKS units.\nNote
  that the positive y-axis points upwards.\n\n```haskell\n  let ballShape = cCircle
  0.5\n  newEntity ( DynamicBody\n            , Shape ballShape\n            , Position
  (V2 0 3)\n            , Density 1\n            , Elasticity 0.9\n            , BodyPicture
  . color red . toPicture $ ballShape )\n```\nStill in the initialize function, here
  we see our first object being instantiated.\nThe type of ballShape is `Convex`,
  the apecs-physics format for shapes.\n`Convex` is a convex polygon, consisting of
  a number of vertices and a radius.\nIn the case of a circle, the polygon consists
  of a single point with a non-zero radius.\nBoth Chipmunk and gloss only support
  convex polygons, `Convex` is used to give them a common interface.\n\nA `DynamicBody`
  is one of three types of bodies.\nIt is a normal body, fully affected by physical
  forces.\nThe elasticity of a collision is the product of the elasticities of the
  colliding shapes.\n\nThe final line shows how to do rendering.\n`BodyPicture` expects
  a gloss `Picture`, in this case we derive one from `ballShape :: Convex` using `toPicture`.\n`color
  red` comes from gloss, and is just one of the many `Picture` manipulation functions.\nAlternatively,
  you can use a `Bitmap` to use actual sprites.\n\n```haskell\n  let lineShape = hLine
  6\n  newEntity ( StaticBody\n            , Angle (-pi/20)\n            , Shape lineShape\n
  \           , Elasticity 0.9\n            , BodyPicture . color white . toPicture
  $ lineShape )\n```\nStatic bodies are not affected by physics, and generally rarely
  move.\nThey are equivalent to bodies with infinite mass and moment, and zero velocity.\nChanging
  their position triggers an explicit rehash of their shapes, wish is relatively expensive.\n\n```haskell\nmain
  = do\n  w <- initWorld\n  runSystem initialize w\n  defaultSimulate w\n```\n`defaultSimulate`
  is a convenience wrapper around gloss' `simulateIO`.\nYou can find its definition
  in `Apecs.Physics.Gloss`, in case you want to change the rendering behavior.\n\n###
  tumbler\n![Screenshot](tumbler.png)\n\n```haskell\ninitialize :: System World ()\ninitialize
  = do\n  set global ( Camera 0 50\n             , earthGravity )\n\n  let sides =
  toEdges $ cRectangle 5\n  tumbler <- newEntity ( KinematicBody\n                       ,
  AngularVelocity (-1)\n                       , BodyPicture . color white . foldMap
  toPicture $ sides )\n```\nAs previously stated, both Chipmunk and gloss exclusively
  have _convex_ polygon primitives.\nOur tumbler, however, is obiously not convex.\nFortunately,
  composing shapes is really easy.\nWe use `toEdges` to turn a rectangle into an outline
  of one, and use `foldMap` to make a composite `Picture`.\n\nA `KinematicBody` is
  halfway between a `DynamicBody` and a `StaticBody`.\nIt can have an (angular) velocity,
  but will not respond to forces.\nIt can be used for e.g. moving platforms, or in
  this case.\nNote that we did not add any shapes to the tumbler yet.\n\n```haskell\n
  \ forM_ sides $ \\line -> newEntity (ShapeExtend (cast tumbler) $ setRadius 0.05
  line)\n```\nThe time has come to talk about the destinction between shapes and bodies.\nA
  body can have multiple shapes.\nShapes belonging to the same body _cannot move relative
  to one another_, i.e. a body is a fixture for multiple shapes.\nWhen using the normal
  `Shape` data constructor to add a shape to a body, we actually create two Chipmunk
  structs; one for the body, and one for the shape, even though they are addressed
  by the same entity in apecs.\n\nWhen we want to add multiple shapes to a body, however,
  we need to make new entities for each individual shape.\nThe reason for this is
  that this way, we can still easily change the properties of each individual shape.\n`Shape`
  actually just represents a special case of `ShapeExtend`, the case in which the
  body has the same entity as the shape.\n\nWhen you use a tuple of components in
  apecs, they are added in the order you list them in the tuple.\nThis is important
  to realize, as _adding a shape to an entity wihout a body is a noop_.\nAlways make
  sure you first add a body, and then the shapes.\nThis also comes up when e.g. setting
  a shape's properties: you can only set a shape's `Mass` or `Density` when there
  is a shape in the first place.\nIf you don't, you will get a runtime error about
  simulating zero-mass `DynamicBodies`.\n\n```haskell\n  replicateM_ 200 $ do\n    x
  <- liftIO$ randomRIO (-2, 2)\n    y <- liftIO$ randomRIO (-2, 2)\n    r <- liftIO$
  randomRIO (0.1, 0.2)\n    let ballshape = cCircle r\n    let c = (realToFrac x+2)/3\n
  \   newEntity ( DynamicBody\n              , Position (V2 x y)\n              ,
  Shape ballshape\n              , BodyPicture . color (makeColor 1 c c 1) . toPicture
  $ ballshape\n              , Density 1 )\n\n  return ()\n```\nFinally, we randomly
  add a bunch of balls.\n\n### constraints\n![Screenshot](constraints.png)\n\nThe
  final example is a gallery of (some of) the available constraints.\nDrag shapes
  around with the left mouse button, create a new box with the right.\n\nThis example
  is too large to fully include here, but if you have made it this far, I recommend
  looking at the source.\nAside from demonstrating constraints, queries and interaction
  it also contains some neat tricks like:\n```haskell\nlet rubber = (Friction 0.5,
  Elasticity 0.5, Density 1)\nnewEntity ( DynamicBody\n          , someShape\n          ,
  rubber )\n```\nNesting tuples creates composable and reusable pieces of configuration
  (this is an apecs thing, not an apecs-physics thing).\nThis can also be useful if
  you find yourself needing bigger tuples than the current maximum.\n\nConstraints
  are a lot like shapes, but instead of having one associated `Body`, they have two.\nIt
  also comes in the varieties `Constraint` and `ConstraintExtend`.\n\nDragging an
  object with the mouse is also done using a constraint.\nThe mouse position actually
  controls the position of a static body without shapes, and we use a PinJoint to
  attach whatever we are dragging to it.\n"
license-name: BSD3
