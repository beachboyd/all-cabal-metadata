homepage: https://github.com/leshow/i3ipc#readme
changelog-type: ''
hash: 7792e8365b4156b38261108d1ee2dd5c5f3c8eb9f29107cfb49b0a9e198b55e8
test-bench-deps:
  bytestring: -any
  base: -any
  hspec: -any
  i3ipc: -any
  aeson: -any
maintainer: cameron.evan@gmail.com
synopsis: A type-safe wrapper around i3's IPC
changelog: ''
basic-deps:
  bytestring: ! '>=0.10 && <0.11'
  base: ! '>=4.7 && <5'
  text: ! '>=1.2.1.0 && <1.3'
  network: ! '>=2.6.3.5 && <3.1'
  containers: ! '>=0.5.10 && <0.7'
  binary: ! '>=0.8.6 && <0.10'
  typed-process: ! '>=0.2.4 && <0.3'
  aeson: ! '>=1.2 && <1.5'
  vector: ! '>=0.11.0 && <0.13'
all-versions:
- 0.1.0.0
- 0.1.0.1
author: Evan Cameron
latest: 0.1.0.1
description-type: markdown
description: |
  # i3ipc

  [![Build Status](https://travis-ci.com/leshow/i3ipc.svg?branch=master)](https://travis-ci.com/leshow/i3ipc)

  Haskell type-safe bindings for working with i3 using it's unix socket IPC

  ## Subscribing

  Subscribe to events:

  ```haskell
  import qualified I3IPC.Subscribe   as Sub
  import           I3IPC              ( subscribe )

  -- will print all events
  main :: IO ()
  main = subscribe print [Sub.Workspace, Sub.Window]
  ```

  An example of explicitly matching on some events and printing their fields:

  ```haskell
  import qualified I3IPC.Subscribe               as Sub
  import           I3IPC.Event
  import           I3IPC                          ( subscribe )

  main :: IO ()
  main = subscribe handle [Sub.Workspace, Sub.Window]
   where
    handle :: Either String Event -> IO ()
    handle (Right evt) = case evt of
      Workspace WorkspaceEvent { wrk_current } -> print wrk_current
      Window WindowEvent { win_container } -> print win_container
      _ -> error "No other event types"
    handle (Left err) = error err
  ```

  ## Sending Messages

  Sending Messages to i3:

  ```haskell
  import           I3IPC              ( connecti3
                                      , getWorkspaces
                                      )

  main :: IO ()
  main = do
      soc <- connecti3
      print $ getWorkspaces soc
  ```

  Alternatively, you can ignore the convenience functions and construct these messages yourself:

  ```haskell
  import qualified I3IPC.Message     as Msg
  import           I3IPC              ( connecti3
                                      , receiveMsg
                                      )

  main :: IO ()
  main = do
      soc <- connecti3
      print $ Msg.sendMsg soc Msg.Workspaces >> receiveMsg soc
  ```

  ## Community

  I'm happy to take PRs or suggestions, or simply fix issues for this library.
license-name: BSD-3-Clause
