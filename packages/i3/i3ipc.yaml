homepage: https://github.com/leshow/i3ipc#readme
changelog-type: ''
hash: db80119b7e81f104c08a8f687d58452dba7493d6723afce6feb84c9a4d370496
test-bench-deps:
  bytestring: -any
  base: -any
  hspec: -any
  i3ipc: -any
  aeson: -any
maintainer: cameron.evan@gmail.com
synopsis: A type-safe wrapper around i3's IPC
changelog: ''
basic-deps:
  bytestring: ! '>=0.10 && <0.11'
  base: ! '>=4.7 && <5'
  text: ! '>=1.2.1.0 && <1.3'
  network: ! '>=2.6.3.5 && <3.1'
  containers: ! '>=0.5.10 && <0.7'
  binary: ! '>=0.8.6 && <0.10'
  typed-process: ! '>=0.2.4 && <0.3'
  aeson: ! '>=1.2 && <1.5'
  vector: ! '>=0.11.0 && <0.13'
all-versions:
- 0.1.0.0
author: Evan Cameron
latest: 0.1.0.0
description-type: markdown
description: |
  # i3ipc

  [![Build Status](https://travis-ci.com/leshow/i3ipc.svg?branch=master)](https://travis-ci.com/leshow/i3ipc)

  Haskell type-safe bindings for working with i3 using it's unix socket IPC

  Subscribe to events:

  ```haskell
  import qualified I3IPC.Subscribe   as Sub
  import           I3IPC              ( subscribe )

  -- will print all events
  main :: IO ()
  main = subscribe print [Sub.Workspace, Sub.Window]
  ```

  Sending Messages to i3:

  ```haskell
  import           I3IPC              ( connecti3
                                      , getWorkspaces
                                      )

  main :: IO ()
  main = do
      soc <- connecti3
      print getWorkspaces
  ```

  Alternatively, you can ignore the convenience functions and construct these messages yourself:

  ```haskell
  import qualified I3IPC.Message     as Msg
  import           I3IPC              ( connecti3
                                      , receiveMsg
                                      )

  main :: IO ()
  main = do
      soc <- connecti3
      print $ Msg.sendMsg soc Msg.Workspaces >> receiveMsg soc
  ```

  I'm happy to take PRs or suggestions, or simply fix issues for this library.
license-name: BSD-3-Clause
