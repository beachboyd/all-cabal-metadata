homepage: https://github.com/frontrowed/closed#readme
changelog-type: ''
hash: 23777f91ce7f5c6c75d11f168dbaae6f4caada6d16dcc5b6f19b4af8e2da797b
test-bench-deps:
  closed: -any
  base: ! '>=4.9 && <5'
  hspec: -any
  markdown-unlit: -any
  cassava: -any
  hashable: -any
  deepseq: -any
  QuickCheck: -any
  aeson: -any
  vector: -any
maintainer: Front Row Education <engineering@frontrowed.com>
synopsis: Integers bounded by a closed interval
changelog: ''
basic-deps:
  base: ! '>=4.9 && <5'
  cassava: -any
  hashable: -any
  deepseq: -any
  QuickCheck: -any
  aeson: -any
all-versions:
- '0.1.0'
author: Chris Parks <chris@frontrowed.com>
latest: '0.1.0'
description-type: text
description: ! "# closed: Integers bounded by a closed interval\n\n## Build\n\n  ```plaintext\n
  \ stack build\n  ```\n\n## Tutorial\n\n### Overview\n\nThis package exports one
  core data type `Closed (n :: Nat) (m :: Nat)`\nfor describing integers bounded by
  a closed interval. That is, given\n`cx :: Closed n m`, `getClosed cx` is an integer
  `x` where `n <= x <= m`.\n\nWe also export a type family `Bounds` for describing
  open and half-open\nintervals in terms of closed intervals.\n\n  ```plaintext\n
  \ Bounds (Inclusive 0) (Inclusive 10) => Closed 0 10\n  Bounds (Inclusive 0) (Exclusive
  10) => Closed 0 9\n  Bounds (Exclusive 0) (Inclusive 10) => Closed 1 10\n  Bounds
  (Exclusive 0) (Exclusive 10) => Closed 1 9\n  ```\n\n### Preamble\n\n  For most
  uses of `closed`, you'll only need `DataKinds` and maybe\n  `TypeFamilies`. The
  other extensions below just make some of the\n  tests concise.\n\n  ```haskell\n
  \ {-# LANGUAGE TypeFamilies #-}\n  {-# LANGUAGE DataKinds #-}\n  {-# LANGUAGE OverloadedStrings
  #-}\n  {-# LANGUAGE OverloadedLists #-}\n  {-# LANGUAGE TypeApplications #-}\n  {-#
  LANGUAGE ScopedTypeVariables #-}\n  {-# OPTIONS_GHC -fno-warn-unticked-promoted-constructors
  #-}\n\n  module Main where\n\n  import Closed\n  import Control.Exception\n  import
  Data.Aeson\n  import qualified Data.Csv as CSV\n  import Data.Vector\n  import Data.Proxy\n
  \ import GHC.TypeLits\n  import Test.Hspec\n  import Test.Hspec.QuickCheck\n\n  main
  :: IO ()\n  main = hspec $ do\n  ```\n\n### Construction\n\n  The safe constructor
  `closed` uses `Maybe` to indicate failure. There is\n  also an unsafe constructor
  `unsafeClosed` as well as a `Num` instance that implements\n  `fromInteger`.\n\n
  \ ```haskell\n    describe \"safe construction\" $ do\n\n      it \"should successfully
  construct values in the specified bounds\" $ do\n        let result = closed 2 ::
  Maybe (Bounds (Inclusive 2) (Exclusive 5))\n        getClosed <$> result `shouldBe`
  Just 2\n\n      it \"should fail to construct values outside the specified bounds\"
  $ do\n        let result = closed 1 :: Maybe (Bounds (Inclusive 2) (Exclusive 5))\n
  \       getClosed <$> result `shouldBe` Nothing\n\n    describe \"unsafe construction\"
  $ do\n\n      it \"should successfully construct values in the specified bounds\"
  $ do\n        let result = unsafeClosed 2 :: Bounds (Inclusive 2) (Exclusive 5)\n
  \       getClosed result `shouldBe` 2\n\n      it \"should fail to construct values
  outside the specified bounds\" $ do\n        let result = unsafeClosed 1 :: Bounds
  (Inclusive 2) (Exclusive 5)\n        evaluate (getClosed result) `shouldThrow` anyErrorCall\n\n
  \   describe \"unsafe literal construction\" $ do\n\n      it \"should successfully
  construct values in the specified bounds\" $ do\n        let result = 2 :: Bounds
  (Inclusive 2) (Exclusive 5)\n        getClosed result `shouldBe` 2\n\n      it \"should
  fail to construct values outside the specified bounds\" $ do\n        let result
  = 1 :: Bounds (Inclusive 2) (Exclusive 5)\n        evaluate (getClosed result) `shouldThrow`
  anyErrorCall\n  ```\n\n### Elimination\n\n  Use `getClosed` to extract the `Integer`
  from a `Closed` value.\n\n  ```haskell\n    describe \"elimination\" $ do\n\n      it
  \"should allow the integer value to be extracted\" $ do\n        let result = 1
  :: Bounds (Inclusive 0) (Exclusive 10)\n        getClosed result `shouldBe` 1\n
  \ ```\n\n### Bounds Manipulation\n\n  The upper and lower bounds can be queried,
  strengthened, and weakened.\n\n  ```haskell\n    describe \"bounds manipulation\"
  $ do\n\n      let cx = 4 :: Bounds (Inclusive 2) (Exclusive 10)\n\n      it \"should
  allow querying the bounds\" $ do\n        upperBound cx `shouldBe` (Proxy :: Proxy
  9)\n        lowerBound cx `shouldBe` (Proxy :: Proxy 2)\n\n      it \"should allow
  weakening the bounds\" $ do\n        upperBound (weakenUpper cx) `shouldBe` (Proxy
  :: Proxy 10)\n        lowerBound (weakenLower cx) `shouldBe` (Proxy :: Proxy 1)\n\n
  \     it \"should allow weakening the bounds by more than one\" $ do\n        upperBound
  (weakenUpper cx) `shouldBe` (Proxy :: Proxy 20)\n        lowerBound (weakenLower
  cx) `shouldBe` (Proxy :: Proxy 0)\n\n      it \"should allow strengthening the bounds\"
  $ do\n        upperBound <$> strengthenUpper cx `shouldBe` Just (Proxy :: Proxy
  8)\n        lowerBound <$> strengthenLower cx `shouldBe` Just (Proxy :: Proxy 3)\n\n
  \     it \"should allow strengthening the bounds by more than one\" $ do\n        upperBound
  <$> strengthenUpper cx `shouldBe` Just (Proxy :: Proxy 7)\n        lowerBound <$>
  strengthenLower cx `shouldBe` Just (Proxy :: Proxy 4)\n  ```\n\n### Arithmetic\n\n
  \ Arithmetic gets stuck at the upper and lower bounds instead of wrapping.\n\n  ```haskell\n
  \   describe \"arithmetic\" $ do\n\n      it \"addition to the maxBound should have
  no effect\" $ do\n        let result = maxBound :: Bounds (Inclusive 1) (Exclusive
  10)\n        result + 1 `shouldBe` result\n\n      it \"subtraction from the minBound
  should have no effect\" $ do\n        let result = minBound :: Bounds (Inclusive
  1) (Exclusive 10)\n        result - 1 `shouldBe` result\n  ```\n\n### Serialization\n\n
  \ Parsing of closed values is strict.\n\n  ```haskell\n    describe \"json\" $ do\n\n
  \     it \"should successfully parse values in the specified bounds\" $ do\n        let
  result = eitherDecode \"1\" :: Either String (Bounds (Inclusive 1) (Exclusive 10))\n
  \       result `shouldBe` Right 1\n\n      it \"should fail to parse values outside
  the specified bounds\" $ do\n        let result = eitherDecode \"0\" :: Either String
  (Bounds (Inclusive 1) (Exclusive 10))\n        result `shouldBe` Left \"Error in
  $: parseJSON: Integer 0 is not representable in Closed 1 9\"\n\n    describe \"csv\"
  $ do\n\n      it \"should successfully parse values in the specified bounds\" $
  do\n        let result = CSV.decode CSV.NoHeader \"1\" :: Either String (Vector
  (CSV.Only (Bounds (Inclusive 1) (Exclusive 10))))\n        result `shouldBe` Right
  [CSV.Only 1]\n\n      it \"should fail to parse values outside the specified bounds\"
  $ do\n        let result = CSV.decode CSV.NoHeader \"0\" :: Either String (Vector
  (CSV.Only (Bounds (Inclusive 1) (Exclusive 10))))\n        result `shouldBe` Left
  \"parse error (Failed reading: conversion error: parseField: Integer 0 is not representable
  in Closed 1 9) at \\\"\\\"\"\n  ```\n\n### Testing\n\n  Closed values can be generated
  with QuickCheck\n\n  ```haskell\n    describe \"quickcheck\" $ do\n\n      prop
  \"should always generate values in the specified bounds\" $\n        \\(cx :: Closed
  0 1000) ->\n          natVal (lowerBound cx) <= getClosed cx &&\n          getClosed
  cx <= natVal (upperBound cx)\n  ```\n\n## Remarks\n\nThis library was inspired by
  [finite-typelits](https://hackage.haskell.org/package/finite-typelits)\nand [finite-typelits-bounded](https://github.com/pseudonom/finite-typelits-bounded).
  The differences\nare summarized below:\n\n* `finite-typelits` - A value of `Finite
  (n :: Nat)` is in the half-open interval `[0, n)`. Uses modular arithmetic.\n* `finite-typelits-bounded`
  - A value of `Finite (n :: Nat)` is in the half-open interval `[0, n)`. Uses bounded
  arithmetic.\n* `closed` - A value of `Closed (n :: Nat) (m :: Nat)` is in the closed
  interval `[n, m]`. Uses bounded arithmetic.\n"
license-name: MIT
