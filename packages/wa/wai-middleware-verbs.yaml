homepage: https://github.com/athanclark/wai-middleware-verbs#readme
changelog-type: ''
hash: 364a2dd46e99721f65636f0e97189961b3dabbd2f051b3f6937ea902f61a159c
test-bench-deps: {}
maintainer: athan.clark@localcooking.com
synopsis: Route Wai middlewares based on HTTP verbs
changelog: ''
basic-deps:
  exceptions: -any
  wai: ! '>=3.2.1'
  base: ! '>=4.8 && <5'
  unordered-containers: -any
  mtl: -any
  mmorph: -any
  hashable: -any
  transformers-base: -any
  monad-logger: -any
  transformers: -any
  resourcet: -any
  http-types: -any
all-versions:
- '0.2.0'
- '0.3.0'
- '0.3.1'
- '0.3.2'
- '0.3.2.1'
author: Athan Clark
latest: '0.3.2.1'
description-type: markdown
description: ! "wai-middleware-verbs\n====================\n\nRoute to different Wai
  middleware based on the incoming HTTP verb\ndetected.\n\n## Usage\n\nThis library
  depends on the [wai-transformers](https://hackage.haskell.org/package/wai-transformers)\npackage
  - we expect middleware to already be lifted to `MiddlewareT m`.\n\nAs an example,
  here could be your application:\n\n```haskell\nimport Network.Wai.Trans\nimport
  Network.Wai.Middleware.Verbs\n\n\nmyMid1 :: MiddlewareT (ReaderT Env m)\nmyMid2
  :: Middleware\n\nuploader :: Request -> m (Maybe u)\nuploader _ = return Nothing\n\nuploadResponse
  :: Maybe u -> MiddlewareT m\nuploadResponse _ = liftMiddleware (\\t -> runReaderT
  t config) myMid2\n\nverbRoutes :: VerbListenerT (MiddlewareT m) u m ()\nverbRoutes
  = do\n  get myMid1\n  post uploader uploadResponse\n```\n\nThen, to use your newly
  assembled verb-router, turn the Verbs into a Middleware:\n\n```haskell\nverbMid
  :: MiddlewareT (ReaderT Env m)\nverbMid = verbsToMiddleware verbRoutes\n```\n\nFrom
  there, you can deconstruct your monolithic monad stack back down to `IO`,\nand plug-it-in
  to your existing middleware.\n"
license-name: BSD3
