homepage: http://github.com/harendra-kumar/streamly
changelog-type: markdown
hash: 1f660b674dd464ed65a4a4500e5a6902d2b42c6233222e1e334c29da17f1d720
test-bench-deps:
  base: ! '>=4.8 && <5'
  hspec: ! '>=2.0 && <3'
  criterion: ! '>=1 && <2'
  containers: ! '>=0.5 && <0.6'
  atomic-primops: ! '>=0.8 && <0.9'
  mtl: ! '>=2.2 && <3'
  streamly: -any
maintainer: harendra.kumar@gmail.com
synopsis: Beautiful Streaming, Concurrent and Reactive Composition
changelog: ! '## 0.1.0


  * Initial release

'
basic-deps:
  exceptions: ! '>=0.8 && <0.9'
  stm: ! '>=2.4.3 && <2.5'
  base: ! '>=4.8 && <5'
  monad-control: ! '>=1.0 && <2'
  lockfree-queue: ! '>=0.2.3 && <0.3'
  lifted-base: ! '>=0.2 && <0.3'
  containers: ! '>=0.5 && <0.6'
  atomic-primops: ! '>=0.8 && <0.9'
  mtl: ! '>=2.2 && <3'
  transformers-base: ! '>=0.4 && <0.5'
  transformers: ! '>=0.4 && <0.6'
all-versions:
- '0.1.0'
author: Harendra Kumar
latest: '0.1.0'
description-type: markdown
description: ! "# Streamly\n\n[![Gitter chat](https://badges.gitter.im/composewell/gitter.svg)](https://gitter.im/composewell/streamly)\n[![Build
  Status](https://travis-ci.org/composewell/streamly.svg?branch=master)](https://travis-ci.org/composewell/streamly)\n[![Windows
  Build status](https://ci.appveyor.com/api/projects/status/ajxg0c79raou9ned?svg=true)](https://ci.appveyor.com/project/harendra-kumar/streamly)\n[![Coverage
  Status](https://coveralls.io/repos/composewell/streamly/badge.svg?branch=master&service=github)](https://coveralls.io/github/composewell/streamly?branch=master)\n\n##
  Stream`ing` `Concurrent`ly\n\nStreamly is a monad transformer unifying non-determinism\n([list-t](https://hackage.haskell.org/package/list-t)/[logict](https://hackage.haskell.org/package/logict)),\nconcurrency
  ([async](https://hackage.haskell.org/package/async)),\nstreaming ([conduit](https://hackage.haskell.org/package/conduit)\\/[pipes](https://hackage.haskell.org/package/pipes)),\nand
  FRP ([Yampa](https://hackage.haskell.org/package/Yampa)\\/[reflex](https://hackage.haskell.org/package/reflex))\nfunctionality
  in a concise and intuitive API.\nHigh level concurrency makes concurrent applications
  almost indistinguishable\nfrom non-concurrent ones.  By changing a single combinator
  you can control\nwhether the code runs serially or concurrently.  It naturally integrates\nconcurrency
  with streaming rather than adding it as an afterthought.\nMoreover, it interworks
  with the popular streaming libraries.\n\nSee the haddock documentation for full
  reference.  It is recommended to read\nthe comprehensive tutorial module `Streamly.Tutorial`
  first. Also see\n`Streamly.Examples` for some working examples.\n\n## Non-determinism\n\nThe
  monad instance composes like a list monad.\n\n``` haskell\nloops = $ do\n    x <-
  each [1,2]\n    y <- each [3,4]\n    liftIO $ putStrLn $ show (x, y)\n\nmain = runStreaming
  $ serially $ loops\n```\n```\n(1,3)\n(1,4)\n(2,3)\n(2,4)\n```\n\n## Magical Concurrency\n\nTo
  run the above code with demand-driven concurrency i.e. each iteration in the\nloops
  can run concurrently depending on the consumer rate:\n\n``` haskell\nmain = runStreaming
  $ asyncly $ loops\n```\n\nTo run it with full parallelism irrespective of demand:\n\n```
  haskell\nmain = runStreaming $ parallely $ loops\n```\n\nTo run it serially but
  interleaving the outer and inner loop iterations:\n\n``` haskell\nmain = runStreaming
  $ interleaving $ loops\n```\n\nYou can fold multiple streams or IO actions using
  parallel combinators like\n`<|`, `<|>`. For example, to concurrently generate the
  squares and then\nconcurrently sum the square roots of all combinations:\n\n```
  haskell\nmain = do\n  print $ sum $ asyncly $ do\n      -- Squaring is concurrent
  (<|)\n      x2 <- forEachWith (<|) [1..100] $ \\x -> return $ x * x\n      y2 <-
  forEachWith (<|) [1..100] $ \\y -> return $ y * y\n      -- sqrt is concurrent (asyncly)\n
  \     return $ sqrt (x2 + y2)\n```\n\nOf course, the actions running in parallel
  could be arbitrary IO actions.  To\nconcurrently list the contents of a directory
  tree recursively:\n\n``` haskell\nimport Path.IO (listDir, getCurrentDir)\nimport
  Streamly\n\nmain = runStreaming $ serially $ getCurrentDir >>= readdir\n   where
  readdir d = do\n            (dirs, files) <- lift $ listDir d\n            liftIO
  $ mapM_ putStrLn $ map show files\n            -- read the subdirs concurrently\n
  \           foldMapWith (<|>) readdir dirs\n```\n\nIn the above examples we do not
  think in terms of threads, locking or\nsynchronization, rather we think in terms
  of what can run in parallel, the rest\nis taken care of automatically. With `asyncly`
  and `<|` the programmer does not\nhave to worry about how many threads are to be
  created they are automatically\nadjusted based on the demand of the consumer.\n\nThe
  concurrency facilities provided by streamly can be compared with\n[OpenMP](https://en.wikipedia.org/wiki/OpenMP)
  and\n[Cilk](https://en.wikipedia.org/wiki/Cilk) but with a more declarative\nexpression.
  \ Concurrency support does not compromise performance in\nnon-concurrent cases,
  the performance of the library is at par or better than\nmost of the existing streaming
  libraries.\n\n## Streaming\n\nStreaming is effortless, simple and straightforward.
  Streamly data type behaves\njust like a list and combinators are provided in `Streamly.Prelude`
  to\ntransform or fold streamly streams. Unlike other libraries and like `streaming`\nlibrary
  the combinators explicitly consume a stream and produce a stream,\ntherefore, no
  special operator is needed to join stream stages, just a forward\n(`$`) or reverse
  (`&`) function application operator is enough.\n\n```haskell\nimport Streamly\nimport
  Streamly.Prelude as S\nimport Data.Function ((&))\n\nmain = S.each [1..10]\n     &
  fmap (+ 1)\n     & S.drop 2\n     & S.filter even\n     & fmap (* 3)\n     & S.takeWhile
  (< 25)\n     & S.mapM (\\x -> putStrLn (\"saw \" ++ show x) >> return x)\n     &
  S.toList . serially\n     >>= print\n```\n\nFold style combinators can be used to
  fold purely or monadically. You can also\nuse the beautiful `foldl` library for
  folding.\n\n```haskell\nmain = S.each [1..10]\n     & serially\n     & S.foldl (+)
  0 id\n     >>= print\n```\n\nStreams can be combined together in multiple ways:\n\n```haskell\nreturn
  1 <> return 2               -- serial, combine atoms\nS.each [1..10] <> S.each [11..20]
  \ -- serial\nS.each [1..10] <| S.each [11..20]  -- demand driven parallel\nS.each
  [1..10] <=> S.each [11..20] -- serial but interleaved\nS.each [1..10] <|> S.each
  [11..20] -- fully parallel\n```\n\nAs we have already seen streams can be combined
  using monadic composition in a\nnon-deterministic manner. This allows arbitrary
  manipulation and combining of\nstreams. See `Streamly.Examples.MergeSortedStreams`
  for a more complicated\nexample.\n\n## Reactive Programming (FRP)\n\nStreamly is
  a foundation for first class reactive programming as well by virtue\nof integrating
  concurrency and streaming. See `Streamly.Examples.AcidRainGame`\nand `Streamly.Examples.CirclingSquare`
  for an SDL based animation example.\n\n## Contributing\n\nThe code is available
  under BSD-3 license [on\ngithub](https://github.com/composewell/streamly). Join
  the [gitter\nchat](https://gitter.im/composewell/streamly) channel for discussions.
  All\ncontributions are welcome!\n\nThis library was originally inspired by the `transient`
  package authored by\nAlberto G. Corona.\n"
license-name: BSD3
