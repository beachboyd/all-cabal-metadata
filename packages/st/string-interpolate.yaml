homepage: ''
changelog-type: markdown
hash: 18aed53315aaf613bee1b28dfb16c8d0ec69bfbeeb492b6205bb7fa2dac80379
test-bench-deps:
  bytestring: -any
  string-interpolate: -any
  Interpolation: -any
  base: ==4.*
  hspec: -any
  text: -any
  quickcheck-text: -any
  criterion: -any
  interpolatedstring-perl6: -any
  quickcheck-instances: -any
  interpolate: -any
  formatting: -any
  QuickCheck: -any
maintainer: williamyaoh@gmail.com
synopsis: Haskell string/text/bytestring interpolation that just works
changelog: |
  # CHANGELOG

  ## Unreleased

  ## v0.1.0.0 (2019-03-17)

  + Add support for using Text and ByteString `Builder`s as both sinks
    and sources
  + Add support for interpolating Chars without the surrounding quotes

  ## v0.0.1.0 (2019-03-10)

  + Initial release
basic-deps:
  bytestring: -any
  base: ==4.*
  text: -any
  utf8-string: -any
  text-conversions: -any
  haskell-src-meta: -any
  template-haskell: -any
all-versions:
- 0.0.1.0
- 0.1.0.0
author: William Yao
latest: 0.1.0.0
description-type: markdown
description: "# string-interpolate [![pipeline status](https://gitlab.com/williamyaoh/string-interpolate/badges/master/pipeline.svg)](https://gitlab.com/williamyaoh/string-interpolate/commits/master)
  [![hackage version](https://img.shields.io/hackage/v/string-interpolate.svg)](http://hackage.haskell.org/package/string-interpolate)
  [![license](https://img.shields.io/badge/license-BSD--3-ff69b4.svg)](https://gitlab.com/williamyaoh/string-interpolate/blob/master/LICENSE)\n\nHaskell
  having 5 different textual types in common use (String, strict and lazy\nText, strict
  and lazy ByteString) means that doing any kind of string\nmanipulation becomes a
  complicated game of type tetris with constant conversion\nback and forth. What if
  string handling was as simple and easy as it is in\nliterally any other language?\n\nBehold:\n\n```haskell\nshowWelcomeMessage
  :: Text -> Integer -> Text\nshowWelcomeMessage username visits =\n  [i|Welcome to
  my website, #{username}! You are visitor #{visits}!|]\n```\n\nNo more needing to
  `mconcat`, `mappend`, and `(<>)` to glue strings together.\nNo more having to remember
  a gajillion different functions for converting\nbetween strict and lazy versions
  of Text, or having to worry about encoding\nbetween Text <=> ByteString. No more
  getting bitten by trying to work with\nUnicode ByteStrings. It just works!\n\n**string-interpolate**
  provides a quasiquoter, `i`, that allows you to interpolate\nexpressions directly
  into your string. It can produce anything that is an\ninstance of `IsString`, and
  can interpolate anything which is an instance of\n`Show`.\n\n## Unicode handling\n\n**string-interpolate**
  handles converting to/from Unicode when converting\nString/Text to ByteString and
  vice versa. Lots of libraries use ByteString to\nrepresent human-readable text,
  even though this is not safe. There are lots of\nuseful libraries in the ecosystem
  that are unfortunately annoying to work with\nbecause of the need to generate ByteStrings
  containing application-specific info.\nInsisting on explicitly converting to/from
  UTF-8 in these cases and handling\ndecoding failures adds lots of syntactic noise,
  when often you can reasonably\nassume that a given ByteString will, 95% of the time,
  contain Unicode text.\nSo string-interpolate aims to provide reasonable defaults
  around conversion\nbetween ByteString and real textual types so that developers
  don't need to\nconstantly be aware of text encodings.\n\nWhen converting a String/Text
  to a ByteString, string-interpolate will\nautomatically encode it as a sequence
  of UTF-8 bytes. When converting a\nByteString to String/Text, string-interpolate
  will assume that the ByteString\ncontains a UTF-8 string, and convert the characters
  accordingly. Any invalid\ncharacters in the ByteString will be converted to the
  Unicode replacement\ncharacter � (U+FFFD).\n\nRemember: string-interpolate is not
  designed for 100% correctness around text\nencodings, just for convenience in the
  most common case. If you absolutely need\nto be aware of text encodings and to handle
  decode failures, take a look at\n[text-conversions](https://hackage.haskell.org/package/text-conversions).\n\n##
  Usage\n\nFirst things first: add **string-interpolate** to your dependencies:\n\n```yaml\ndependencies:\n
  \ - string-interpolate\n```\n\nand import the quasiquoter and enable `-XQuasiQuotes`:\n\n```haskell\n{-#
  LANGUAGE QuasiQuotes #-}\n\nimport Data.String.Interpolate ( i )\n```\n\nWrap anything
  you want to be interpolated with `#{}`:\n\n```haskell\nλ> name = \"William\"\nλ>
  [i|Hello, #{name}!|] :: String\n>>> \"Hello, William!\"\n```\n\nYou can interpolate
  in anything which implements `Show`:\n\n```haskell\nλ> import Data.Time\nλ> now
  <- getCurrentTime\nλ> [i|The current time is #{now}.|] :: String\n>>> \"The current
  time is 2019-03-10 18:58:40.573892546 UTC.\"\n```\n\n...and interpolate into anything
  which implements `IsString`.\n\nstring-interpolate *must* know what concrete type
  it's producing; it cannot be\nused to generate a `IsString a => a`. If you're using
  string-interpolate from\nGHCi, make sure to add type signatures to toplevel usages!\n\nStrings
  and characters are always interpolated without surrounding quotes.\n\n```haskell\nλ>
  verb = 'c'\nλ> noun = \"sea\"\nλ> [i|We went to go #{verb} the #{noun}.|] :: String\n>>>
  \"We went to go c the sea.\"\n```\n\nYou can also interpolate arbitrary expressions:\n\n```haskell\nλ>
  [i|Tomorrow's date is #{addDays 1 $ utctDay now}.|] :: String\n>>> \"Tomorrow's
  date is 2019-03-11.\"\n```\n\nBackslashes are handled exactly the same way they
  are in normal Haskell strings.\nIf you need to put a literal `#{` into your string,
  prefix the pound symbol with\na backslash:\n\n```haskell\nλ> [i|\\#{ some inner
  text }#|] :: String\n>>> \"#{ some inner text }#\"\n```\n\n## Comparison to other
  interpolation libraries\n\nSome other interpolation libraries available:\n\n* [interpolate](https://hackage.haskell.org/package/interpolate)\n*
  [formatting](https://hackage.haskell.org/package/formatting)\n* Text.Printf, from
  base\n* [neat-interpolation](https://hackage.haskell.org/package/neat-interpolation)\n*
  [Interpolation](http://hackage.haskell.org/package/Interpolation)\n* [interpolatedstring-perl6](http://hackage.haskell.org/package/interpolatedstring-perl6-1.0.1)\n\nOf
  these, Text.Printf isn't exception-safe, and neat-interpolation can only\nproduce
  Text values. interpolate, formatting, Interpolation, and\ninterpolatedstring-perl6
  provide different solutions to the problem of\nproviding a general way of interpolating
  any value, into any kind of text.\n\n### Features\n\n|                                          \t|
  string-interpolate \t| interpolate \t| formatting \t| Interpolation \t| interpolatedstring-perl6
  \t|\n|------------------------------------------\t|--------------------\t|-------------\t|------------\t|---------------\t|--------------------------\t|\n|
  String/Text support                      \t| ✅                  \t| ✅           \t|
  ✅          \t| ⚠️             \t| ✅                        \t|\n| ByteString support
  \                      \t| ✅                  \t| ✅           \t| ❌          \t|
  ⚠️             \t| ✅                        \t|\n| Can interpolate arbitrary Show
  instances \t| ✅                  \t| ✅           \t| ✅          \t| ✅             \t|
  ✅                        \t|\n| Unicode-aware                            \t| ✅                  \t|
  ❌           \t| ✅          \t| ❌             \t| ❌                        \t|\n|
  Multiline strings                        \t| ❌                  \t| ❌           \t|
  ❌          \t| ✅             \t| ✅                        \t|\n\n⚠ `Interpolation`
  supports all five textual formats, but doesn't allow you\n  to mix and match; that
  is, you can't interpolate a String into an output\n  string of type Text, and vice
  versa.\n\n### Performance\n\nOverall: **string-interpolate** is competitive with
  the fastest interpolation\nlibraries, only getting outperformed by **Interpolation**
  and\n**interpolatedstring-perl6**, and even then mostly on ByteStrings. Since\nthese
  two libraries don't handle Unicode and **string-interpolate** converts\nthings to
  UTF-8, some slowdown is to be expected here.\n\nWe run three benchmarks: small string
  interpolation (<100 chars) with a single\ninterpolation parameter; small strings
  with multiple interpolation parameters,\nand large string (~100KB) interpolation.
  Each of these benchmarks is then\nrun against `String`, strict `Text`, and strict
  `ByteString`.\n\n|                          \t| **string-interpolate** \t| **interpolate**
  \t| **formatting** \t| **Interpolation** \t| **interpolatedstring-perl6** \t|\n|--------------------------\t|------------------------\t|-----------------\t|----------------\t|-------------------\t|------------------------------\t|\n|
  small String             \t| 1x                     \t| 1x              \t| 2x             \t|
  1x                \t| 1x                           \t|\n| multi interp, String     \t|
  1x                     \t| 7x              \t| 2.3x           \t| 0.63x             \t|
  0.63x                        \t|\n| small Text               \t| 1x                     \t|
  28x             \t| 1.5x           \t| 2.2x              \t| 2.2x                         \t|\n|
  multi interp, Text       \t| 1x                     \t| 22x             \t| 1.6x
  \          \t| 2.9x              \t| 2.9x                         \t|\n| large Text
  \              \t| 1x                     \t| 30,000x         \t| 1x             \t|
  80x               \t| 80x                          \t|\n| small ByteString         \t|
  1x                     \t| 15x             \t| N/A            \t| 0.35x             \t|
  0.35x                        \t|\n| multi interp, ByteString \t| 1x                     \t|
  10x             \t| N/A            \t| 0.5x              \t| 0.5x                         \t|\n|
  large ByteString         \t| 1x                     \t| 100,000x        \t| N/A
  \           \t| 1.6x              \t| 1.6x                         \t|\n\n(We don't
  bother running tests on large `String`s, because no one is working\nwith data that
  large using `String` anyways.)\n\nIn particular, notice that **Interpolation** and
  **interpolatedstring-perl6**\nblow up on large Text; **string-interpolation** and
  **formatting** have\nconsistent performance across all benchmarks, with string-interpolation
  leading\nthe pack in `Text` cases.\n\nAll results were tested on my local machine.
  If you'd like to attempt to replicate\nthe results, the benchmarks are in `bench/`
  and can be run with a simple\n`stack bench`.\n"
license-name: BSD-3-Clause
