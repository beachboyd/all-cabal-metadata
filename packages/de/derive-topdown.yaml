homepage: https://github.com/HaskellZhangSong/derive-topdown
changelog-type: ''
hash: c592fc005db86b513299e3601501841198d3ebeaec4c383f0ace8ada5f142368
test-bench-deps: {}
maintainer: songzh <Haskell.Zhang.Song@hotmail.com>
synopsis: Help Haskellers derive class instances for composited data types.
changelog: ''
basic-deps:
  base: ! '>=4.8 && <5.0'
  syb: ! '>=0.4'
  th-expand-syns: ! '>=0.4.3'
  mtl: ! '>=2.1.0'
  transformers: ! '>=0.4.2'
  template-haskell: ! '>=2.10'
  primitive: ! '>=0.6.2'
all-versions:
- '0.0.0.1'
- '0.0.0.2'
- '0.0.0.7'
author: songzh <Haskell.Zhang.Song@hotmail.com>
latest: '0.0.0.7'
description-type: markdown
description: ! "# derive-topdown\nThis is a Haskell project which will derive type
  class instances from top for a composite data type\n### standalone deriving\n\n\t{-#
  LANGUAGE StandaloneDeriving,\n\t\tConstraintKinds,      \n\t\tUndecidableInstances,\n\t\t--
  You maybe need a lot of other extensions like FlexibleInstances and DerivingStrategies.\n\t\tDeriveGeneric\n\t#-}\n\t{-#
  OPTIONS_GHC -ddump-splices #-}\n\t\n\timport Data.Derive.TopDown\n\timport GHC.Generics\n\timport
  Data.Binary\n\timoprt Data.Aeson\n\timport Data.Aeson.TH\n\n\tdata Gender = Male
  | Female\n\ttype Age = Int\n\tdata Person a = P {name :: String , age :: Int, gender
  :: Gender}\n\tdata Department a = D {dname :: String , \n\t\t\t\t\t\t   head ::
  Person a, \n\t\t\t\t\t\t   staff :: [Person a]}\n\tdata Company a = C {cname ::
  String, \n\t                    departments :: [Department a]}\n\t\n\tderivings
  [''Eq, ''Ord, ''Generic] ''Company\n\nYou will get:\n\n\t\tderivings [''Eq, ''Ord,
  ''Generic] ''Company\n\t  ======>\n\t    deriving instance Eq Gender\n\t    deriving
  instance Eq (Person a_acKV)\n\t    deriving instance Eq a_acKU => Eq (Department
  a_acKU)\n\t    deriving instance Eq a_acKT => Eq (Company a_acKT)\n\t    deriving
  instance Ord Gender\n\t    deriving instance Ord (Person a_acKV)\n\t    deriving
  instance Ord a_acKU => Ord (Department a_acKU)\n\t    deriving instance Ord a_acKT
  => Ord (Company a_acKT)\n\t    deriving instance Generic Gender\n\t    deriving
  instance Generic (Person a_acKV)\n\t    deriving instance Generic (Department a_acKU)\n\t
  \   deriving instance Generic (Company a_acKT)\n\n\nFor empty class instances deriving
  we can use it in this way. With DeriveAnyClasses and Generic class, we can use standalone
  deriving to do it. However, this is no reason to prevent you from doing this.\n\n\t
  \   instances [''Binary] ''Company\n\t  ======>\n\t    instance Binary Gender\n\t
  \   instance Binary (Person a_af50)\n\t    instance Binary a_af4Z => Binary (Department
  a_af4Z)\n\t    instance Binary a_af4Y => Binary (Company a_af4Y)\n\nFor generating
  instances with a template Haskell function, `derivingTHs` can be used:\n\t\n\t   deriving_ths\n\t
  \     [(''ToJSON, deriveToJSON defaultOptions),\n\t       (''FromJSON, deriveFromJSON
  defaultOptions)]\n\t      ''Company\n\t  ======>\n\t    instance ToJSON Gender where\n\t
  \     toJSON\n\t        = \\ value_amQG\n\t            -> case value_amQG of {\n\t
  \                Male -> String (text-1.2.2.2:Data.Text.pack \"Male\")\n\t                 Female
  -> String (text-1.2.2.2:Data.Text.pack \"Female\") }\n\t      toEncoding\n\t        =
  \\ value_amQH\n\t            -> case value_amQH of {\n\t                 Male\n\t
  \                  -> Data.Aeson.Encoding.Internal.text\n\t                        (text-1.2.2.2:Data.Text.pack
  \"Male\")\n\t                 Female\n\t                   -> Data.Aeson.Encoding.Internal.text\n\t
  \                       (text-1.2.2.2:Data.Text.pack \"Female\") }\n\t    instance
  ToJSON a_amqg => ToJSON (Person a_amqg) where\n\t      toJSON\n\t        = \\ value_amQy\n\t
  \       ...\n\t        ...\n\t\t\nYou can use this function with `derive`(http://hackage.haskell.org/package/derive)
  package. It can handle more type classes, like Arbitrary in QuickCheck, especially. "
license-name: BSD3
