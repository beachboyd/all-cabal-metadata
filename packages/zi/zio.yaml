homepage: https://github.com/githubuser/haskell-zio#readme
changelog-type: markdown
hash: ef0f5012bdf4624dc1412d73baf852817862ff73dd02d65528d959ca8e6a5cf5
test-bench-deps:
  unexceptionalio: -any
  base: -any
  zio: -any
  mtl: -any
  unexceptionalio-trans: -any
  transformers: -any
maintainer: brandon.barker@cornell.edu
synopsis: ''
changelog: |
  # Changelog for haskell-zio

  ## Unreleased changes
basic-deps:
  unexceptionalio: '>=0.5.1 && <0.6'
  base: '>=4.7 && <5'
  mtl: '>=2.2 && <2.3'
  unexceptionalio-trans: '>=0.5.1 && <0.6'
  transformers: '>=0.5.6 && <0.6'
all-versions:
- 0.1.0.0
author: Brandon Elam Barker
latest: 0.1.0.0
description-type: markdown
description: "# haskell-zio\n\nA [small](src/ZIO/Trans.hs) monad-transformer analogue
  to the\nScala [ZIO](https://github.com/zio/zio)\nlibrary (basically, [UIO](http://hackage.haskell.org/package/unexceptionalio)
  +\n[Reader](hackage.haskell.org/package/transformers/docs/Control-Monad-Trans-Reader.html)
  +\n[Either/ExceptT](hackage.haskell.org/package/mtl/docs/Control-Monad-Except.html)).\n\nI
  like to call `ZIO` a *best-practices monad for applications*. It\nwraps in a `Reader`
  monad for carrying around configuration and\nenvironment data, and slightly more
  controversially, makes\nerror-handling more explicit by making all recoverable\\\n[exceptions
  and errors](https://wiki.haskell.org/Error_vs._Exception)\npart of the return-type
  of functions.\n\nNote that this is meant to provide the same basic functionality
  of the `ZIO` monad.\nWhile I'm not immediately looking into other features of ZIO-the-library,
  such as\nconcurrency, I welcome suggestions via issues or pull requests.\n\n## Comparison
  to other Haskell libraries\n\n- [UIO](http://hackage.haskell.org/package/unexceptionalio)
  This ZIO library\nbuilds upon UIO (Unexceptional-IO) as a dependency, and it is
  the\ninner-most monad in the transformer stack. We use UIO, in conjunction\nwith
  `ExceptT`, to model possible error states (or the lack thereof)\nmore explicitly.
  In other words, we are trying to make all errors or\nexceptions.\n[checked exceptions](https://en.wikibooks.org/wiki/Java_Programming/Checked_Exceptions),
  where possible. See the [blog post](https://singpolyma.net/2018/05/error-handling-in-haskell/)
  (or [backup](docs/UIO.md)) for more details.\n- [RIO](https://hackage.haskell.org/package/rio)\n[integrates](hackage.haskell.org/package/rio/docs/src/RIO.Prelude.RIO.html#RIO)
  `ReaderT` with `IO`, but somewhat like Scala ZIO, provides\nmuch additional functionality,
  and providing much of that functionality\\\nwill be a goal of haskell-zio as well.\n-
  [Trio](https://github.com/snoyberg/trio) has essentially the same goals\nas ZIO
  (and I believe it is isomorphic to ZIO), but is a self-described\nexperiment at
  the moment. The major experimental aspect I'm aware of is\nthat it is avoiding usage
  of `ExceptT` to improve performance, which\nI have not investigated. We are currently
  aiming for stability here,\nbut ideally any code written for haskell-ZIO could easily
  be transferred\nto using `Trio`, or vice versa. If you see a difference, **please
  raise an\nissue** so we can document it or fix it.\n\n## The Scala-Haskell ZIO dictionary\n\n###
  Type Aliases\nThe Scala ZIO type parameters and\n[aliases](https://zio.dev/docs/overview/overview_index#type-aliases)
  are\nlargely reproduced in Haskell, though in some cases we can't exactly\nreproduce
  them. For instance, `IO` is already taken in Haskell at\na very fundamental level.
  As well, `UIO` has the same meaning as in\nthe Scala implementation, but it isn't
  an alias, since it is an inner\nmonad of the `ZIO` type.\n\nAn apparent downsize
  of having `UIO`, `EIO`, and `ZIO` as distinct\n(non-aliased) types is that one might
  feel inclined to provide APIs\nfor one or more of these when warranted. For this
  reason `UEIO e`,\n`UZIO a`, and other aliases along with associated lift and unlift\nfunctions
  are provided. These aliases have `Void` in the expanded type,\nand in some cases,
  it is more appropriate to use a universal quantifier,\ne.g., when lifting into a
  type, we usually have some Error type in mind\nother than `Void` (that's one big
  reason why we're using this library!),\nso we'd prefer to have e.g. `uelift :: âˆ€
  e a. UIO a -> EIO e a`,\nnot `uelift :: UIO a -> UEIO a`.\n\n[//]: # (Table generated
  from docs/type_aliases.csv using https://www.tablesgenerator.com/markdown_tables)\n\n|
  Haskell Type \t| Alias for                           \t| Scala Type   \t| Notes
  \                                                                                                \t|\n|--------------\t|-------------------------------------\t|--------------\t|-------------------------------------------------------------------------------------------------------\t|\n|
  `ZIO r e a`  \t|                                     \t| `ZIO[R,E,A]` \t|                                                                                                       \t|\n|
  `UIO a`      \t|                                     \t| `UIO[A]`     \t| This is
  a type alias in Scala but a concrete type in Haskell due to UIO being an inner monadic
  type.  \t|\n| `EIO e a`    \t|                                     \t| `IO[E, A]`
  \  \t| This is a type alias in Scala but a concrete type in Haskell due to EIO being
  an inner monadic type.  \t|\n| `RIO r a`    \t| `ZIO r SomeNonPseudoException a`
  \   \t| `RIO[R, A]`  \t| Same idea as in Scala. Not to be confused with the RIO
  library's `RIO` monad, but they are isomorphic. \t|\n| `Task a`     \t| `ZIO Void
  SomeNonPseudoException a` \t| `Task[A]`    \t|                                                                                                       \t|\n|
  `UEIO a`     \t| `EIO Void a`                        \t| `UIO[A]`     \t|                                                                                                       \t|\n|
  `URIO r a`   \t| `ZIO r Void a`                      \t| `URIO[R, A]` \t| Same idea
  as in Scala; a ZIO value isomorphic to a RIO value (can be projected to the RIO
  value).     \t|\n| `UZIO a`     \t| `ZIO Void Void a`                   \t| `UIO[A]`
  \    \t|                                                                                                       \t|\n"
license-name: MPL-2.0
