homepage: https://github.com/ofmooseandmen/jord
changelog-type: markdown
hash: b1ab53c054e78856a827473ee9dba7b55679ee42069a88481ed04a4326644104
test-bench-deps:
  base: ! '>=4.9 && <5'
  hspec: ==2.*
  HUnit: ==1.6.*
  jord: -any
maintainer: Cedric Liegeois <ofmooseandmen@yahoo.com>
synopsis: Geographical Position Calculations
changelog: "### 1.0.0.0\r\n\r\n- New API (does not allow mixing position in different
  coordinate systems)\r\n- Exact solution for both direct and inverse geodetic problems
  (Vincenty)\r\n- Conversion between different coordinate systems\r\n\r\n### 0.6.0.0\r\n\r\n-
  Fixed Ellipsoid: constructor expected inverseFlattening and not flattening\r\n\r\n###
  0.5.0.0\r\n\r\n- Added Benchmarks\r\n- Added GreatArc\r\n- Added GreatArc from tuple
  of positions\r\n- Added GreatArc from GreatCircle\r\n- Added GreatArc from Track
  and Duration\r\n- Added alongTrackDistance\r\n- Added GreatArcs intersection\r\n\r\n###
  0.4.2.0\r\n\r\n- Fixed intercept\r\n- jord-exe renamed jord-repl\r\n\r\n### 0.4.1.0\r\n\r\n-
  Fixed interceptBySpeed\r\n- Nautical miles symbol is \"nm\"\r\n- REPL: intercept
  for intercept, interceptBySpeed and interceptByTime\r\n- REPL: show length and speed
  in user selected unit\r\n\r\n### 0.4.0.0\r\n\r\n- Added ECEF, frames and delta to
  REPL\r\n- Added Speed\r\n- Added Duration\r\n- Added Kinematics: course, position,
  CPA and intercept\r\n\r\n### 0.3.1.0\r\n\r\n- Added ECEF position\r\n- Added Frames
  (Body, Local, North East Down)\r\n- Added delta and target from position(s), frame
  and earth model\r\n- Added earth models (WGS84, WGS72, GRS80 and derived spherical
  models)\r\n- Builds against LTS 12.2 (GHC 8.4.3) and LTS 11.18 (GHC 8.2.2)\r\n\r\n###
  0.2.0.0\r\n\r\n- GeoPos -> LatLong\r\n- Split Position from GreatCircle\r\n- require
  base >= 4.9\r\n\r\n### 0.1.0.0\r\n\r\n- Initial version\r\n"
basic-deps:
  base: ! '>=4.9 && <5'
  criterion: -any
  jord: -any
all-versions:
- 0.1.0.0
- 0.2.0.0
- 0.3.0.0
- 0.3.1.0
- 0.4.0.0
- 0.4.1.0
- 0.4.2.0
- 0.5.0.0
- 0.6.0.0
- 1.0.0.0
author: Cedric Liegeois
latest: 1.0.0.0
description-type: markdown
description: "# Jord - Geographical Position Calculations\r\n\r\n[![travis build status](https://img.shields.io/travis/ofmooseandmen/jord/master.svg?label=travis+build)](https://travis-ci.org/ofmooseandmen/jord)\r\n[![Hackage](https://img.shields.io/hackage/v/jord.svg)](http://hackage.haskell.org/package/jord)\r\n[![license](https://img.shields.io/badge/license-BSD3-lightgray.svg)](https://opensource.org/licenses/BSD-3-Clause)\r\n\r\n>
  __Jord__ [_Swedish_] is __Earth__ [_English_]\r\n\r\n## What is this?\r\n\r\nJord
  is a [Haskell](https://www.haskell.org) library that implements various geographical
  position calculations using the algorithms described in [Gade, K. (2010) - A Non-singular
  Horizontal Position Representation](http://www.navlab.net/Publications/A_Nonsingular_Horizontal_Position_Representation.pdf),\r\n[Shudde,
  Rex H. (1986) - Some tactical algorithms for spherical geometry](https://calhoun.nps.edu/bitstream/handle/10945/29516/sometacticalalgo00shud.pdf)
  and [Vincenty, T. (1975) - Direct and Inverse Solutions of Geodesics on the Ellipsoid](https://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf):\r\n\r\n-
  conversion between ECEF (earth-centred, earth-fixed), latitude/longitude and [*n*-vector](https://www.navlab.net/nvector)
  positions for spherical and ellipsoidal earth model,\r\n- conversion between latitude/longitude
  and *n*-vector positions,\r\n- local, body and north, east, down Frames: delta between
  positions, target position from reference position and delta,\r\n- great circles:
  surface distance, initial & final bearing, interpolated position, great circle intersections,
  cross track distance, ...,\r\n- geodesic: surface distance, initial & final bearing
  and destination,\r\n- kinematics: position from p0, bearing and speed, closest point
  of approach between tracks, intercept (time, speed, minimum speed),\r\n- transformation
  between coordinate systems (both fixed and time-dependent).\r\n\r\n## How do I build
  it?\r\n\r\nIf you have [Stack](https://docs.haskellstack.org/en/stable/README/),\r\nthen:\r\n```sh\r\n$
  stack build --test\r\n```\r\n\r\n## How do I use it?\r\n\r\n[See documentation on
  Hackage](http://hackage.haskell.org/package/jord/docs/Data-Geo-Jord.html)\r\n\r\n##
  Solutions to the 10 examples from [NavLab](https://www.navlab.net/nvector)\r\n\r\n###
  Example 1: A and B to delta\r\n\r\n*Given two positions, A and B as latitudes, longitudes
  and depths relative to Earth, E.*\r\n \r\n*Find the exact vector between the two
  positions, given in meters north, east, and down, and find the direction (azimuth)\r\nto
  B, relative to north. Assume WGS-84 ellipsoid. The given depths are from the ellipsoid
  surface. Use position A to\r\ndefine north, east, and down directions. (Due to the
  curvature of Earth and different directions to the North Pole,\r\nthe north, east,
  and down directions will change (relative to Earth) for different places. A must
  be outside the poles\r\nfor the north and east directions to be defined.)*\r\n\r\n```haskell\r\nimport
  Data.Geo.Jord.LocalFrames\r\n\r\nposA = wgs84Pos 1 2 (metres 3)\r\nposB = wgs84Pos
  4 5 (metres 6)\r\n\r\ndelta = nedBetween posA posB \r\n-- > Ned (Vector3d {vx =
  331730.234781, vy = 332997.874989, vz = 17404.271362})\r\nslantRange delta \r\n--
  > 470.356717903km\r\nbearing delta \r\n-- > 45°6'33.347\"\r\nelevation delta \r\n--
  > -2°7'14.011\"\r\n```\r\n\r\n### Example 2: A and B to delta\r\n\r\n*A radar or
  sonar attached to a vehicle B (Body coordinate frame) measures the distance and
  direction to an object C.\r\nWe assume that the distance and two angles (typically
  bearing and elevation relative to B) are already combined to the\r\nvector p_BC_B
  (i.e. the vector from B to C, decomposed in B). The position of B is given as n_EB_E
  and z_EB, and the\r\norientation (attitude) of B is given as R_NB (this rotation
  matrix can be found from roll/pitch/yaw by using zyx2R).*\r\n \r\n*Find the exact
  position of object C as n-vector and depth ( n_EC_E and z_EC ), assuming Earth ellipsoid
  with semi-major\r\naxis a and flattening f. For WGS-72, use a = 6 378 135 m and
  f = 1/298.26.*\r\n\r\n```haskell\r\nimport Data.Geo.Jord.LocalFrames\r\n\r\nf =
  frameB (decimalDegrees 40) (decimalDegrees 20) (decimalDegrees 30)\r\np = nvectorHeightPos
  1 2 3 (metres 400) WGS72\r\nd = deltaMetres 3000 2000 100\r\n\r\ntarget p f d\r\n--
  > 53°18'46.839\"N,63°29'6.179\"E 406.006018m (WGS72)\r\n```\r\n\r\n### Example 3:
  ECEF-vector to geodetic latitude\r\n\r\n*Position B is given as an “ECEF-vector”
  p_EB_E (i.e. a vector from E, the center of the Earth, to B, decomposed in E).\r\nFind
  the geodetic latitude, longitude and height (latEB, lonEB and hEB), assuming WGS-84
  ellipsoid.*\r\n\r\n```haskell\r\nimport Data.Geo.Jord.Position\r\n\r\ngeocentricMetresPos
  5733900.0 (-6371000.0) 7008100.000000001 WGS84\r\n-- > 39°22'43.495\"N,48°0'46.035\"W
  4702.059834295km (WGS84)\r\n```\r\n\r\n### Example 4: Geodetic latitude to ECEF-vector\r\n\r\n*Geodetic
  latitude, longitude and height are given for position B as latEB, lonEB and hEB,
  find the ECEF-vector\r\nfor this position, p_EB_E.*\r\n\r\n```haskell\r\nimport
  Data.Geo.Jord.Position\r\n\r\ngcvec (wgs84Pos 1 2 (metres 3))\r\n-- > Vector3d {vx
  = 6373290.277218281, vy = 222560.20067473655, vz = 110568.82718177968}\r\n```\r\n\r\n###
  Example 5: Surface distance\r\n\r\n*Find the surface distance sAB (i.e. great circle
  distance) between two positions A and B. The heights of A and B are\r\nignored,
  i.e. if they don’t have zero height, we seek the distance between the points that
  are at the surface of the\r\nEarth, directly above/below A and B. The Euclidean
  distance (chord length) dAB should also be found.\r\nUse Earth radius 6371e3 m.
  Compare the results with exact calculations for the WGS-84 ellipsoid.*\r\n\r\n```haskell\r\nimport
  Data.Geo.Jord.GreatCircle\r\n\r\nposA = s84Pos 88 0 zero\r\nposB = s84Pos 89 (-170)
  zero\r\n\r\nsurfaceDistance posA posB\r\n-- > 332.456901835km\r\n```\r\n\r\n*Exact
  solution for the WGS84 ellipsoid*\r\n\r\n```haskell\r\nimport Data.Geo.Jord.Geodesic\r\n\r\nposA
  = wgs84Pos 88 0 zero\r\nposB = wgs84Pos 89 (-170) zero\r\n\r\nsurfaceDistance posA
  posB\r\n-- > Just 333.947509469km\r\n```\r\n\r\n### Example 6: Interpolated position\r\n\r\n*Given
  the position of B at time t0 and t1, n_EB_E(t0) and n_EB_E(t1).*\r\n \r\n*Find an
  interpolated position at time ti, n_EB_E(ti). All positions are given as n-vectors.*\r\n\r\n```haskell\r\nimport
  Data.Geo.Jord.GreatCircle\r\n\r\nposA = s84Pos 89 0 zero\r\nposB = s84Pos 89 180
  zero\r\nf = (16 - 10) / (20 - 10) :: Double\r\n\r\ninterpolate posA posB f\r\n--
  > 89°47'59.929\"N,180°0'0.000\"E 0.0m (S84)\r\n```\r\n\r\n### Example 7: Mean position\r\n\r\n*Three
  positions A, B, and C are given as n-vectors n_EA_E, n_EB_E, and n_EC_E. Find the
  mean position, M, given as\r\nn_EM_E. Note that the calculation is independent of
  the depths of the positions.*\r\n\r\n```haskell\r\nimport Data.Geo.Jord.GreatCircle\r\n\r\nps
  = [s84Pos 90 0 zero, s84Pos 60 10 zero, s84Pos 50 (-20) zero]\r\n\r\nmean ps\r\n--
  > Just 67°14'10.150\"N,6°55'3.040\"W 0.0m (S84)\r\n```\r\n\r\n### Example 8: A and
  azimuth/distance to B\r\n\r\n*We have an initial position A, direction of travel
  given as an azimuth (bearing) relative to north (clockwise), and\r\nfinally the
  distance to travel along a great circle given as sAB. Use Earth radius 6371e3 m
  to find the destination\r\npoint B.*\r\n \r\n*In geodesy this is known as “The first
  geodetic problem” or “The direct geodetic problem” for a sphere, and we see\r\nthat
  this is similar to Example 2, but now the delta is given as an azimuth and a great
  circle distance.\r\n(“The second/inverse geodetic problem” for a sphere is already
  solved in Examples 1 and 5.)*\r\n\r\n```haskell\r\nimport Data.Geo.Jord.GreatCircle\r\n\r\np
  = s84Pos 80 (-90) zero\r\n\r\ndestination p (decimalDegrees 200) (metres 1000)\r\n--
  > 79°59'29.575\"N,90°1'3.714\"W 0.0m (S84)\r\n```\r\n\r\n*Exact solution for the
  WGS84 ellipsoid*\r\n\r\n```haskell\r\nimport Data.Geo.Jord.Geodesic\r\n\r\np = wgs84Pos
  80 (-90) zero\r\n\r\ndestination p (decimalDegrees 200) (metres 1000)\r\n-- > Just
  79°59'29.701\"N,90°1'3.436\"W 0.0m (WGS84)\r\n```\r\n\r\n### Example 9: Intersection
  of two paths\r\n\r\n*Define a path from two given positions (at the surface of a
  spherical Earth), as the great circle that goes through\r\nthe two points.*\r\n
  \r\n*Path A is given by A1 and A2, while path B is given by B1 and B2.*\r\n \r\n*Find
  the position C where the two great circles intersect.*\r\n\r\n```haskell\r\nimport
  Control.Monad (join)\r\nimport Data.Geo.Jord.GreatCircle\r\n\r\na1 = s84Pos 51.885
  0.235 zero\r\na2 = s84Pos 48.269 13.093 zero\r\nb1 = s84Pos 49.008 2.549 zero\r\nb2
  = s84Pos 56.283 11.304 zero\r\n\r\nga = greatCircleThrough a1 a2\r\ngb = greatCircleThrough
  b1 b2\r\njoin (intersections <$> ga <*> gb)\r\n-- > Just (50°54'6.260\"N,4°29'39.052\"E
  0.0m (S84),50°54'6.260\"S,175°30'20.947\"W 0.0m (S84))\r\n\r\nma = minorArc a1 a2\r\nmb
  = minorArc b1 b2\r\njoin (intersection <$> ma <*> mb)\r\n-- > Just 50°54'6.260\"N,4°29'39.052\"E
  0.0m (S84)\r\n```\r\n\r\n### Example 10: Cross track distance\r\n\r\n*Path A is
  given by the two positions A1 and A2 (similar to the previous example).\r\n \r\n*Find
  the cross track distance sxt between the path A (i.e. the great circle through A1
  and A2) and the position B\r\n(i.e. the shortest distance at the surface, between
  the great circle and B).*\r\n\r\n```haskell\r\nimport Data.Geo.Jord.GreatCircle\r\n\r\np
  = s84Pos 1 0.1 zero\r\ngc = greatCircleThrough (s84Pos 0 0 zero) (s84Pos 10 0 zero)\r\n\r\nfmap
  (\\g -> crossTrackDistance p g) gc\r\n-- > Just 11.117814411km\r\n```\r\n\r\n##
  Solutions to kinematics problems\r\n\r\n### Closest point of approach\r\n\r\n*The
  Closest Point of Approach (CPA) refers to the positions at which two dynamically
  moving objects reach their\r\nclosest possible distance.*\r\n\r\n```haskell\r\nimport
  Data.Geo.Jord.Kinematics\r\n\r\nt1 = Track (s84Pos 20 (-60) zero) (decimalDegrees
  10) (knots 15)\r\nt2 = Track (s84Pos 34 (-50) (metres 10000)) (decimalDegrees 220)
  (knots 300)\r\n\r\ncpa t1 t2\r\n-- > Just (Cpa {\r\n-- >     cpaTime = 3H9M56.155S,\r\n--
  >     cpaDistance = 124.231730834km,\r\n-- >     cpaPosition1 = 20°46'43.641\"N,59°51'11.225\"W
  0.0m (S84),\r\n-- >     cpaPosition2 = 21°24'8.523\"N,60°50'48.159\"W 10000.0m (S84)})\r\n```\r\n\r\n###
  Time required to intercept target\r\n\r\n*Inputs are the initial latitude and longitude
  of an interceptor and a target, and the target course and speed.\r\nAlso input is
  the time of the desired intercept. Outputs are the speed required of the interceptor,
  the course\r\nof the interceptor, the distance travelled to intercept, and the latitude
  and longitude of the intercept.*\r\n\r\n```haskell\r\nimport Data.Geo.Jord.Kinematics\r\n\r\nt
  = Track (s84Pos 34 (-50) zero) (decimalDegrees 220) (knots 600)\r\nip = s84Pos 20
  (-60) zero\r\nd = seconds 2700\r\n\r\ninterceptByTime t ip d\r\n-- > Just (Intercept
  {\r\n-- >     interceptTime = 0H45M0.000S,\r\n-- >     interceptDistance = 1015.302358852km,\r\n--
  >     interceptPosition = 28°8'12.046\"N,55°27'21.411\"W 0.0m (S84),\r\n-- >     interceptorBearing
  = 26°7'11.649\",\r\n-- >     interceptorSpeed = 1353.736478km/h})\r\n```\r\n\r\n###
  Time required to intercept target\r\n\r\n*Inputs are the initial latitude and longitude
  of an interceptor and a target, and the target course and speed. For a\r\ngiven
  interceptor speed, it may or may not be possible to make an intercept.*\r\n\r\n*The
  first algorithm is to compute the minimum interceptor speed required to achieve
  intercept and the time required to\r\nmake such and intercept.*\r\n\r\n*The second
  algorithm queries the user to input an interceptor speed. If the speed is at least
  that required for intercept\r\nthen the time required to intercept is computed.*\r\n\r\n```haskell\r\nimport
  Data.Geo.Jord.Kinematics\r\n\r\nt = Track (s84Pos 34 (-50) zero) (decimalDegrees
  220) (knots 600)\r\nip = s84Pos 20 (-60) zero\r\n\r\nintercept t ip\r\n-- > Just
  (Intercept {\r\n-- >     interceptTime = 1H39M53.831S,\r\n-- >     interceptDistance
  = 162.294627463km,\r\n-- >     interceptPosition = 20°43'42.305\"N,61°20'56.848\"W
  0.0m (S84),\r\n-- >     interceptorBearing = 300°10'18.053\",\r\n-- >     interceptorSpeed
  = 97.476999km/h})\r\n\r\ninterceptBySpeed t ip (knots 700)\r\n-- > Just (Intercept
  {\r\n-- >     interceptTime = 0H46M4.692S,\r\n-- >     interceptDistance = 995.596069189km,\r\n--
  >     interceptPosition = 27°59'36.764\"N,55°34'43.852\"W 0.0m (S84),\r\n-- >     interceptorBearing
  = 25°56'7.484\",\r\n-- >     interceptorSpeed = 1296.399689km/h})\r\n```"
license-name: BSD-3-Clause
