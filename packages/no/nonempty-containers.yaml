homepage: https://github.com/mstksg/nonempty-containers#readme
changelog-type: markdown
hash: 94dc35dbce993a62487b88f5dc9df4ba8631955768e2012c5eddb8dc94ec93ee
test-bench-deps:
  semigroupoids: -any
  these: -any
  base: ! '>=4.9 && <5'
  comonad: -any
  tasty-hedgehog: -any
  text: -any
  nonempty-containers: -any
  hedgehog: -any
  containers: ! '>=0.5.9'
  tasty: -any
  hedgehog-fn: -any
maintainer: justin@jle.im
synopsis: Non-empty variants of containers data types, with full API
changelog: ! 'Changelog

  =========


  Version 0.1.0.0

  ---------------


  <https://github.com/mstksg/nonempty-containres/releases/tag/v0.1.0.0>


  *   Initial release

'
basic-deps:
  semigroupoids: -any
  these: -any
  base: ! '>=4.9 && <5'
  comonad: -any
  containers: ! '>=0.5.9'
  deepseq: -any
all-versions:
- '0.1.0.0'
author: Justin Le
latest: '0.1.0.0'
description-type: markdown
description: ! "# nonempty-containers\n\nEfficient and optimized non-empty (by construction)
  versions of types from\n*[containers][]*. Inspired by *[non-empty-containers][]*
  library, except\nattempting a more faithful port (with under-the-hood optimizations)
  of the full\n*containers* API.  Also contains a convenient typeclass abstraction
  for\nconverting betwewen non-empty and possibly-empty variants, as well as pattern\nsynonym-based
  conversion methods.\n\n[containers]: http://hackage.haskell.org/package/containers\n[non-empty-containers]:
  http://hackage.haskell.org/package/non-empty-containers\n\nNon-empty *by construction*
  means that the data type is implemented using a\ndata structure where it is structurally
  impossible to represent an empty\ncollection.\n\nUnlike similar packages (see below),
  this package is defined to be a\n*drop-in replacement* for the *containers* API
  in most situations.  More or\nless every single function is implemented with the
  same asymptotics and\ntypeclass constraints.  An extensive test suite (with 457
  total tests) is\nprovided to ensure that the behavior of functions are identical
  to their\noriginal *containers* counterparts.\n\nCare is also taken to modify the
  interface of specific functions to reflect\nnon-emptiness and emptiness as concepts,
  including:\n\n1.  Functions that might return empty results (like `delete`, `filter`)
  return\n    possibly-empty variants instead.\n\n2.  Functions that totally partition
  a non-empty collection (like `partition`,\n    `splitAt`, `span`) would previously
  return a tuple of either halves:\n\n    ```haskell\n    mapEither :: (a -> Either
  b c) -> Map k a -> (Map k b, Map k c)\n    ```\n\n    The final result is always
  a total partition (every item in the original\n    map is represented in the result),
  so, to reflect this, [`These`][these] is\n    returned instead:\n\n    ```haskell\n
  \   data These a b = This  a\n                   | That    b\n                   |
  These a b\n\n    mapEither :: (a -> Either b c) -> NEMap k a -> These (NEMap k c)
  (NEMap k c)\n    ```\n\n    This preserves the invariance of non-emptiness: either
  we have a non-empty\n    map in the first camp (containing all original values),
  a non-empty map in\n    the second camp (containing all original values), or a split
  between two\n    non-empty maps in either camp.\n\n    [these]: https://hackage.haskell.org/package/these\n\n3.
  \ Typeclass-polymorphic functions are made more general (or have more general\n
  \   variants provided) whenever possible.  This means that functions like\n    `foldMapWithKey`
  are written for all `Semigroup m` instead of only `Monoid\n    m`, and `traverseWithKey1`
  is provided to work for all `Apply f` instances\n    (instead of only `Applicative
  f` instances).\n\n    `Foldable1` and `Traversable1` instances are also provided,
  to provide\n    `foldMap1` and `traverse1`.\n\n4.  Functions that can \"potentially
  delete\" (like `alter` and `updateAt`)\n    return possibly-empty variants.  However,
  alternatives are offered\n    (whenever not already present) with variants that
  disallow deletion,\n    allowing for guaranteed non-empty maps to be returned.\n\nContains
  non-empty versions for:\n\n*   `Map`\n*   `IntMap`\n*   `Set`\n*   `IntSet`\n*   `Sequence`\n\nA
  typeclass abstraction (in *Data.Containers.NonEmpty*) is provided to allow\nfor
  easy conversions between non-empty and possibly-empty variants.  Note that\n`Tree`,
  from *Data.Tree*, is already non-empty by construction.\n\nSimilar packages include:\n\n*
  \  [non-empty-containers][]: Similar approach with similar data types, but API\n
  \   is limited to a few choice functions.\n*   [non-empty][]: Similar approach with
  similar data types, but is meant to be\n    more general and work for a variety
  of more data types.\n*   [nonempty-alternative][]: Similar approach, but is instead
  a generalized\n    data type for all `Alternative` instances.\n\n[non-empty]: http://hackage.haskell.org/package/non-empty\n[nonempty-alternative]:
  http://hackage.haskell.org/package/nonempty-alternative\n\nCurrently not implemented:\n\n*
  \  Extended merging functions.  However, there aren't too many benefits to be\n
  \   gained from lifting extended merging functions, because their\n    emptiness/non-emptiness
  guarantees are difficult to statically conclude.\n*   Strict variants of Map functions.
  \ This is something that I wouldn't mind,\n    and might add in the future.  PR's
  are welcomed!\n"
license-name: BSD3
