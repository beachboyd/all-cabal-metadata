homepage: https://github.com/mstksg/nonempty-containers#readme
changelog-type: markdown
hash: a572d9cfcb3f5f1b5564f254f34c76837312df187c4e0202c443885b5f711966
test-bench-deps:
  semigroupoids: -any
  these: -any
  base: ! '>=4.9 && <5'
  comonad: -any
  tasty-hedgehog: -any
  text: -any
  nonempty-containers: -any
  hedgehog: -any
  containers: ! '>=0.5.9'
  tasty: -any
  hedgehog-fn: -any
maintainer: justin@jle.im
synopsis: Non-empty variants of containers data types, with full API
changelog: ! "Changelog\n=========\n\nVersion 0.1.1.0\n---------------\n\n*December
  8, 2018*\n\n<https://github.com/mstksg/nonempty-containres/releases/tag/v0.1.1.0>\n\n*
  \  `Comonad` instances added for `Map k` and `IntMap`, based on [Faucelme's\n    suggestion][comonad]\n\n[comonad]:
  https://www.reddit.com/r/haskell/comments/a1qjcy/nonemptycontainers_nonempty_variants_of/eat5r4h/\n\nVersion
  0.1.0.0\n---------------\n\n<https://github.com/mstksg/nonempty-containres/releases/tag/v0.1.0.0>\n\n*
  \  Initial release\n"
basic-deps:
  semigroupoids: -any
  these: -any
  base: ! '>=4.9 && <5'
  comonad: -any
  containers: ! '>=0.5.9'
  deepseq: -any
all-versions:
- 0.1.0.0
- 0.1.1.0
author: Justin Le
latest: 0.1.1.0
description-type: markdown
description: ! "# [nonempty-containers][]\n\n[nonempty-containers]: http://hackage.haskell.org/package/nonempty-containers\n\nEfficient
  and optimized non-empty (by construction) versions of types from\n*[containers][]*.
  Inspired by *[non-empty-containers][]* library, except\nattempting a more faithful
  port (with under-the-hood optimizations) of the full\n*containers* API.  Also contains
  a convenient typeclass abstraction for\nconverting between non-empty and possibly-empty
  variants, as well as pattern\nsynonym-based conversion methods.\n\n[containers]:
  http://hackage.haskell.org/package/containers\n[non-empty-containers]: http://hackage.haskell.org/package/non-empty-containers\n\nNon-empty
  *by construction* means that the data type is implemented using a\ndata structure
  where it is structurally impossible to represent an empty\ncollection.\n\nUnlike
  similar packages (see below), this package is defined to be a\n*drop-in replacement*
  for the *containers* API in most situations.  More or\nless every single function
  is implemented with the same asymptotics and\ntypeclass constraints.  An extensive
  test suite (with 457 total tests) is\nprovided to ensure that the behavior of functions
  are identical to their\noriginal *containers* counterparts.\n\nCare is also taken
  to modify the interface of specific functions to reflect\nnon-emptiness and emptiness
  as concepts, including:\n\n1.  Functions that might return empty results (like `delete`,
  `filter`) return\n    possibly-empty variants instead.\n\n2.  Functions that totally
  partition a non-empty collection (like `partition`,\n    `splitAt`, `span`) would
  previously return a tuple of either halves:\n\n    ```haskell\n    mapEither ::
  (a -> Either b c) -> Map k a -> (Map k b, Map k c)\n    ```\n\n    The final result
  is always a total partition (every item in the original\n    map is represented
  in the result), so, to reflect this, [`These`][these] is\n    returned instead:\n\n
  \   ```haskell\n    data These a b = This  a\n                   | That    b\n                   |
  These a b\n\n    mapEither :: (a -> Either b c) -> NEMap k a -> These (NEMap k b)
  (NEMap k c)\n    ```\n\n    This preserves the invariance of non-emptiness: either
  we have a non-empty\n    map in the first camp (containing all original values),
  a non-empty map in\n    the second camp (containing all original values), or a split
  between two\n    non-empty maps in either camp.\n\n    [these]: https://hackage.haskell.org/package/these\n\n3.
  \ Typeclass-polymorphic functions are made more general (or have more general\n
  \   variants provided) whenever possible.  This means that functions like\n    `foldMapWithKey`
  are written for all `Semigroup m` instead of only `Monoid\n    m`, and `traverseWithKey1`
  is provided to work for all `Apply f` instances\n    (instead of only `Applicative
  f` instances).\n\n    `Foldable1` and `Traversable1` instances are also provided,
  to provide\n    `foldMap1` and `traverse1`.\n\n4.  Functions that can \"potentially
  delete\" (like `alter` and `updateAt`)\n    return possibly-empty variants.  However,
  alternatives are offered\n    (whenever not already present) with variants that
  disallow deletion,\n    allowing for guaranteed non-empty maps to be returned.\n\nContains
  non-empty versions for:\n\n*   `Map`\n*   `IntMap`\n*   `Set`\n*   `IntSet`\n*   `Sequence`\n\nA
  typeclass abstraction (in *Data.Containers.NonEmpty*) is provided to allow\nfor
  easy conversions between non-empty and possibly-empty variants.  Note that\n`Tree`,
  from *Data.Tree*, is already non-empty by construction.\n\nSimilar packages include:\n\n*
  \  [non-empty-containers][]: Similar approach with similar data types, but API\n
  \   is limited to a few choice functions.\n*   [nonemptymap][]: Another similar
  approach, but is limited only to `Map`,\n    and is also not a complete API port.\n*
  \  [non-empty-sequence][]: Similar to *nonemptymap*, but for `Seq`.  Also not\n
  \   a complete API port.\n*   [non-empty][]: Similar approach with similar data
  types, but is meant to be\n    more general and work for a variety of more data
  types.\n*   [nonempty-alternative][]: Similar approach, but is instead a generalized\n
  \   data type for all `Alternative` instances.\n\n[nonemptymap]: https://hackage.haskell.org/package/nonemptymap\n[non-empty-sequence]:
  https://hackage.haskell.org/package/non-empty-sequence\n[non-empty]: https://hackage.haskell.org/package/non-empty\n[nonempty-alternative]:
  https://hackage.haskell.org/package/nonempty-alternative\n\nCurrently not implemented:\n\n*
  \  Extended merging functions.  However, there aren't too many benefits to be\n
  \   gained from lifting extended merging functions, because their\n    emptiness/non-emptiness
  guarantees are difficult to statically conclude.\n*   Strict variants of Map functions.
  \ This is something that I wouldn't mind,\n    and might add in the future.  PR's
  are welcomed!\n"
license-name: BSD-3-Clause
