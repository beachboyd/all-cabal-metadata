homepage: https://morpheusgraphql.com
changelog-type: markdown
hash: c301b02806a0d72e77ac479370a0db38a5b394b032db266a38d30237a962a085
test-bench-deps:
  bytestring: ! '>=0.10.4 && <0.11'
  morpheus-graphql: -any
  base: ! '>=4.7 && <5'
  unordered-containers: ! '>=0.2.8.0 && <0.3'
  text: ! '>=1.2.3.0 && <1.3'
  uuid: ! '>=1.0 && <=1.4'
  megaparsec: ! '>=7.0.0 && <8.0'
  websockets: ! '>=0.11.0 && <=0.12.5.3'
  containers: ! '>=0.4.2.1 && <0.7'
  mtl: ! '>=2.0 && <=2.2.2'
  tasty-hunit: -any
  transformers: ! '>=0.3.0.0 && <0.6'
  tasty: -any
  scientific: ! '>=0.3.6.2 && <0.4'
  aeson: -any
  template-haskell: -any
  vector: ! '>=0.12.0.1 && <0.13'
maintainer: d.nalchevanidze@gmail.com
synopsis: Morpheus GraphQL
changelog: |
  ## [0.5.0] - 31.10.2019

  ### Added

  - dummy support of `directives`, only parsing not actual implementation

  ### Fixed

  - can be parsed `implements` with multiple interfaces separated by `&`
  - can be parsed default value on `inputobject`
  - Parser supports anonymous Operation: `query` , `mutation` , `subscription`
    for example:

    ```
    mutation {
       name
    }
    ```

  - Morpheus client does not breaks on `Boolean` type, converts every GraphQL type `Boolean` to haskell `Bool` and GQL `String` to `Text`

  ### Changed

  - Reduced `GQLRootResolver` signature :

    `GQLRootResolver IO () () Query () ()` -> `GQLRootResolver IO () Query () ()`

    `GQLRootResolver IO Channel Content Query Mutation Subscription` -> `GQLRootResolver IO APIEvent Query Mutation Subscription`

    where `APIEvent = Event Channel Content`

  - `GQLRootResolver` automatically assigns corresponding monad to GraphQL Types.

    you can write just:

    ```hs
    GQLRootResolver IO APIEvent Query  Mutation Subscription
    ```

    instead of:

    ```hs
    GQLRootResolver IO APIEvent (Query (Resolver IO))  (Mutation (MutResolver IO ApiEvent) (Subscription (SubResolver IO ApiEvent))
    ```

    where operations are generated by `importGQLDocument` or have form :

    ```
    data Query m = Query {
      field1 :: Args -> m Field1,
      ....
    }
    ```

  - `()` was replaced with `Undefined` in `GQLRootResolver` for empty operations `mutation`, `subscription`
    ```
    rootResolver :: GQLRootResolver IO () Query Undefined Undefined
    ```
  - Root Operations `Query`, `Mutation`, `Subscription` are passed to root resolvers without boxing inside a monad.
  - there are only 3 kind of resolvers `MutResolver`, `SubResolver` , `QueryResolver` defined by GADT `Resolver`

  ## [0.4.0] - 09.10.2019

  ## Changed

  - support of Default Value:

    - on query: Parsing Validating and resolving
    - on Document: only Parsing

  - 'lens' is removed from Library, client field collision can be handled with GraphQL `alias`:
    ```gql
    {
      user {
        name
        friend {
          friendName: name
        }
      }
    }
    ```

  ### Fixed:

  - `Data.Morpheus.Document.toGraphQLDocument` generates only my user defined types. #259
  - Morpheus Client Namespaces Input Type Fields, they don't collide anymore:
    example:
    schema:

    ```gql
    input Person {
      name: String!
    }
    ```

    query:

    ```gql
    query GetUser (parent: Person!) {
      ....
    }
    ```

    wil generate:

    ```hs
    data GetUserArgs = GetUserArgs {
      getUserArgsParent: Person
    } deriving ...

    data Person = Person {
      personName: Person
    } deriving ...
    ```

  - Morpheus Client Generated Output Object And Union Types don't collide:

    ```gql
    type Person {
      name: String!
      parent: Person!
      friend: Person!
    }
    ```

    And we select

    ```gql
    {
      user {
        name
        friend {
          name
        }
        parent {
          name
        }
        bestFriend: friend {
          name
          parent {
            name
          }
        }
      }
    }
    ```

    client will Generate:

    - `UserPerson` from `{user`
    - `UserFriendPerson`: from `{user{freind`
    - `UserParentPerson`: from `{user{parent`
    - `UserBestFriendPerson`: from `{user{bestFrend`
    - `UserBestFriendParentPerson`: from `{user{bestFrend{parent`

  - GraphQL Client Defines enums and Input Types only once per query and they don't collide

  ## [0.3.1] - 05.10.2019

  ### Changed

  - removed dependencies: attoparsec , utf8-string
  - updated aeson lower bound up to: 1.4.4.0

  ## [0.3.0] - 04.10.2019

  ### Added

  - user can import GraphQL Document and generate types with it.

    ```haskell
      importGQLDocument "API.gql"
    ```

    this will generate types defined in `API.gql`

  ### Fixed

  - `String` defined in GQLDcoument will be converted to `Text` by template haskell

  - `importGQLDocument` and `gqlDocument` supports Mutation, Subscription and Resolvers with custom Monad

    for example. if we have:

    ```gql
    type Deity {
      name: String!
      power: Power!
    }
    ```

    where `Power` is another object defined by gql schema.
    template haskell will represent this type as:

    ```haskell
       data Deity m = Deity {
         name :: () -> m Text,
         power :: () -> m (Power m)
       }
    ```

    where `m` is resolver Monad.

  - `importGQLDocumentWithNamespace` generates namespaced haskell records. so that you have no more problem with name collision.
    from this gql type:

    ```gql
    type Deity {
      name: (id:Int)String!
      power: Power!
    }
    ```

    will be generated.

    ```haskell
    data Deity m = Deity {
      deityName :: DeityNameArgs -> m Text,
      deityPower :: () -> m (Power m)
    }

    data DeityNameArgs = DeityNameArgs {
      deityNameArgsId :: Int
    }
    ```

  ### Changed

  - `GQLType` is mandatory for every GQL Type (including Query, Mutation and Subscription)
  - subscription Resolver changed

    from:

    ```haskell
      Subscription {newDeity = \args -> Event {channels = [ChannelA], content = newDeityResolver } }
    ```

    to:

    ```haskell
      Subscription {newDeity = \args -> SubResolver {subChannels = [ChannelA], subResolver = newDeityResolver } }
    ```

  ## [0.2.2] - 30.08.2019

  ### Fixed

  - Parser Supports GraphQL multiline comments
  - Morpheus GraphQL Client: Support GraphQL Alias
  - Support of GraphQL Interfaces on GraphQL Document:

    ```gql
    # simple.gql
    interface Node {
      nodeId: ID!
    }

    type SimpleType implements Node {
      nodeId: ID!
      name: String!
    }
    ```

    morpheus compiler will read interfaces and validate implements.
    template haskell will generate haskell types only for types not for interfaces.

    haskell type from `simple.gql`:

    ```haskell
     data SimpleType = SimpleType {
        nodeId :: ID!
        name   :: Text!
      }  deriving (Generic)
    ```

    at the time compiler does not validates field Arguments by interface

  ## [0.2.1] - 23.08.2019

  - assets are added to cabal source files

  ## [0.2.0] - 23.08.2019

  ### Added

  - Parser Supports GraphQL comments
  - Enhanced Subscription: mutation can trigger subscription with arguments
  - Experimental Support of Input Unions
  - GraphQL schema generating with: `Data.Morpheus.Document.toGraphQLDocument`
  - Generating dummy Morpheus Api from `schema.gql`:

    ```
    morpheus build schema/mythology.gql src/MythologyApi.hs
    ```

    [details](https://github.com/morpheusgraphql/morpheus-graphql/issues/184)

  - `convertToJSONName` & `convertToHaskellName` has been extended to support all Haskell 2010 reserved identities. [details](https://github.com/morpheusgraphql/morpheus-graphql/issues/207)

  - `GraphQL Client` with Template haskell QuasiQuotes (Experimental, Not fully Implemented)

    ```haskell
    defineQuery
      [gql|
        query GetHero ($byRealm: Realm)
          {
            deity (realm:$byRealm) {
              power
              fullName
            }
          }
      |]
    ```

    will Generate:

    - response type `GetHero`, `Deity` with `Lens` Instances
    - input types: `GetHeroArgs` , `Realm`
    - instance for `Fetch` typeClass

    so that

    ```haskell
      fetchHero :: Args GetHero -> m (Either String GetHero)
      fetchHero = fetch jsonRes args
          where
            args = GetHeroArgs {byRealm = Just Realm {owner = "Zeus", surface = Just 10}}
            jsonRes :: ByteString -> m ByteString
            jsonRes = <fetch query from server>
    ```

    resolves well typed response `GetHero`.

  - Ability to define `GQLSchema` with GraphQL syntax ,
    so that with this schema

    ```haskell

    [gqlDocument|
      type Query {
        deity (uid: Text! ) : Deity!
      }

      type Deity {
        name  : Text!
        power : Text
      }
    |]

    rootResolver :: GQLRootResolver IO () () Query () ()
    rootResolver =
      GQLRootResolver {queryResolver = return Query {deity}, mutationResolver = pure (), subscriptionResolver = pure ()}
      where
        deity DeityArgs {uid} = pure Deity {name, power}
          where
            name _ = pure "Morpheus"
            power _ = pure (Just "Shapeshifting")
    ```

    Template Haskell Generates types: `Query` , `Deity`, `DeityArgs`, that can be used by `rootResolver`

    generated types are not compatible with `Mutation`, `Subscription`,
    they can be used only in `Query`, but this issue will be fixed in next release

  ### Fixed:

  - Parser supports enums inside input Object
  - fulfilled fragment Validation (added: unusedFragment,nameConflict)
  - correct decoding of Enums with more than 3 constructor #201

  ### Changed

  - WebSocket subProtocol changed from `graphql-subscriptions` to `graphql-ws`

  - type familiy `KIND` is moved into typeClasses `GQLType`, so you should replace

    ```haskell
    type instance KIND Deity = OBJECT

    instance GQLType Deity where
      description  = const "Custom Description for Client Defined User Type"

    data Deity = Deity { fullName :: Text } deriving (Generic)
    ```

    with

    ```haskell
    instance GQLType Deity where
    type KIND Deity = OBJECT
    description = const "Custom Description for Client Defined User Type"

    data Deity = Deity { fullName :: Text } deriving (Generic)
    ```

  - Duplicated variable names in Http requests are validated using `Aeson`'s `jsonNoDup` function. So the following request will
    result in a parsing error

    ```
    {"query":"...",
    "variables":{"email":"foo@mail.net", "email":"bar@mail.net",...}}
    ```

  ## [0.1.1] - 1.07.2019

  ### Fixed:

  - () as Subscription or Mutation does not defines Operator without fields

  ## [0.1.0] - 30.06.2019

  thanks for contributing to: @krisajenkins, @hovind, @vmchale, @msvbg

  ### Added

  - support for Union Types: `type instance KIND <type> = UNION`
  - support of haskell Types: `Map`, `Set`, and Pair `(a,b)`
  - GraphQL Resolver supports custom Monad
  - add `Interpreter` class with instances:

    - `ByteString -> m ByteString` and Lazy `ByteString`, where `m` is resolver monad
    - `Text -> m Text` and Lazy `Text`, where `m` is resolver monad
    - `GQLRequest -> m GQLResponse` , When you using it inside another Component that have Manual `ToJSON` deriving,
      you have to ensure that `GQLResponse` will be encoded with `toEncoding`, and not with `toJSON`.

  - Schema Validation:

    - Name Collision

  - support of Parsing input values: `Objects`,`Arrays`
  - support scalar type: `ID`
  - scalar Types are validated by `GQLScalar` instance function `parseValue`
  - TypeFamily `KIND` with:

    - `SCALAR`
    - `OBJECT`,
    - `ENUM`
    - `INPUT_OBJECT`
    - `UNION`

  - inline Fragments
  - GraphQL [Aliases](https://graphql.org/learn/queries/#aliases)
  - Subscriptions: `GQLSubscription`

    - `a -> EffectM b` operation: is resolver that contains side effect in `EffectM`.
      is used for Mutation and Subscribe communication
    - `gqlEffectResolver ["CHANNEL_ID"]`: packs as effect Resolver.
      if mutation and subscription resolver have same channel then
      every call of mutation will trigger subscription resolver
    - `GQLState`: shared state between `http` and `websocket` server
    - `gqlSocketApp` :converts `interpreter` to `websocket` application
    - `graphql-subscriptions`: `Apollo GraphQL` subProtocol

  - language:
    - Query supports : `__type(name:"type")`
    - On every Object can be selected : `__typename`

  ### Changed

  - `GQLRootResolver`, `GQLType(..)` , `GQLScalar(..)`
    are moved in `Data.Morpheus.Types`
  - `GQLRoot { query, mutation, subscription }` to `GQLRootResolver {queryResolver, mutationResolver, subscriptionResolver}`
  - `interpreter`: can be used in `http` and `websocket` server
  - `GQLKind` renamed as `GQLType`
  - types can be derived just with `(Generic,GQLType)`
  - haskell record field `type'` will generate GQL Object field `type`
  - public API (all other modules are hidden):
    - Data.Morpheus
    - Data.Morpheus.Kind
    - Data.Morpheus.Types
    - Data.Morpheus.Execution.Subscription

  ### Fixed:

  - parser can read fields with digits like: a1 , \_1
  - you can use Wrapped type and Wrapped Primitive Types issue #136:
    - wrapped TypesNames will be separated with "\_" : typeName(Either A B) -> "Either_A_B"
  - introspection:
    - argument supports `Non-Null` and `List`
    - every field has correct kind

  ### Removed

  - `GQLArgs`: you can derive arguments just with `Generic` without `GQLArgs`
  - `GQLObject`: replaced with instance `type instance KIND <Type> = OBJECT`
  - `GQLEnum`: replaced with instance `type instance KIND <Type> = ENUM`
  - `GQLInput`: replaced with instance `type instance KIND <Type> = INPUT_OBJECT`
  - `Typeable` : with new deriving it is not required anymore
  - `Wrapper`: with TypeFamilies there is no need for `Wrapper`
  - `a ::-> b` is Replaced by `a -> ResM b` where `ResM` is alias for `Resolver IO a`
  - `GQLMutation` , `GQLQuery` : with new deriving it is not required anymore
  - `Resolver` constructor replaced by functions:
    - `gqlResolver` : packs `m Either String a` to `Resolver m a`
    - `gqlEffectResolver`: resolver constructor for effectedResolver
    - `liftEffectResolver`: lifts normal resolver to Effect Resolver.
basic-deps:
  warp: -any
  wai-websockets: ! '>=1.0 && <=3.5'
  bytestring: ! '>=0.10.4 && <0.11'
  wai: -any
  morpheus-graphql: -any
  base: ! '>=4.7 && <5'
  unordered-containers: ! '>=0.2.8.0 && <0.3'
  text: ! '>=1.2.3.0 && <1.3'
  uuid: ! '>=1.0 && <=1.4'
  megaparsec: ! '>=7.0.0 && <8.0'
  filepath: ! '>=1.1 && <1.5'
  websockets: ! '>=0.11.0 && <=0.12.5.3'
  containers: ! '>=0.4.2.1 && <0.7'
  mtl: ! '>=2.0 && <=2.2.2'
  transformers: ! '>=0.3.0.0 && <0.6'
  optparse-applicative: ! '>=0.12 && <0.15'
  scientific: ! '>=0.3.6.2 && <0.4'
  scotty: -any
  aeson: ! '>=1.4.4.0 && <=1.6'
  template-haskell: -any
  vector: ! '>=0.12.0.1 && <0.13'
all-versions:
- 0.0.1
- 0.1.0
- 0.1.1
- 0.2.0
- 0.2.1
- 0.2.2
- 0.3.0
- 0.3.1
- 0.4.0
- 0.5.0
author: Daviti Nalchevanidze
latest: 0.5.0
description-type: markdown
description: "# Morpheus GraphQL [![Hackage](https://img.shields.io/hackage/v/morpheus-graphql.svg)](https://hackage.haskell.org/package/morpheus-graphql)
  [![CircleCI](https://circleci.com/gh/morpheusgraphql/morpheus-graphql.svg?style=svg)](https://circleci.com/gh/morpheusgraphql/morpheus-graphql)\n\nBuild
  GraphQL APIs with your favourite functional language!\n\nMorpheus GraphQL (Server
  & Client) helps you to build GraphQL APIs in Haskell with native haskell types.\nMorpheus
  will convert your haskell types to a GraphQL schema and all your resolvers are just
  native Haskell functions. Mopheus GraphQL can also convert your GraphQL Schema or
  Query to Haskell types and validate them in compile time.\n\nMorpheus is still in
  an early stage of development, so any feedback is more than welcome, and we appreciate
  any contribution!\nJust open an issue here on GitHub, or join [our Slack channel](https://morpheus-graphql-slack-invite.herokuapp.com/)
  to get in touch.\n\n## Getting Started\n\n### Setup\n\nTo get started with Morpheus,
  you first need to add it to your project's dependencies, as follows (assuming you're
  using hpack):\n\n_package.yml_\n\n```yaml\ndependencies:\n  - morpheus-graphql\n```\n\nAdditionally,
  you should tell stack which version to pick:\n\n_stack.yml_\n\n```yaml\nresolver:
  lts-14.8\n\nextra-deps:\n  - morpheus-graphql-0.5.0\n```\n\nAs Morpheus is quite
  new, make sure stack can find morpheus-graphql by running `stack upgrade` and `stack
  update`\n\n### Building your first GraphQL API\n\n### with GraphQL syntax\n\n_schema.gql_\n\n```gql\ntype
  Query {\n  deity(name: String!): Deity!\n}\n\ntype Deity {\n  name: String!\n  power:
  String\n}\n```\n\n_API.hs_\n\n```haskell\n{-# LANGUAGE DeriveGeneric         #-}\n{-#
  LANGUAGE FlexibleContexts      #-}\n{-# LANGUAGE FlexibleInstances     #-}\n{-#
  LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE NamedFieldPuns        #-}\n{-#
  LANGUAGE OverloadedStrings     #-}\n{-# LANGUAGE ScopedTypeVariables   #-}\n{-#
  LANGUAGE TemplateHaskell       #-}\n{-# LANGUAGE TypeFamilies          #-}\n\nmodule
  API (api) where\n\nimport qualified Data.ByteString.Lazy.Char8 as B\n\nimport           Data.Morpheus
  \             (interpreter)\nimport           Data.Morpheus.Document     (importGQLDocumentWithNamespace)\nimport
  \          Data.Morpheus.Types        (GQLRootResolver (..), IORes)\nimport           Data.Text
  \                 (Text)\n\nimportGQLDocumentWithNamespace \"schema.gql\"\n\nrootResolver
  :: GQLRootResolver IO () Query Undefined Undefined\nrootResolver =\n  GQLRootResolver\n
  \   {\n      queryResolver = Query {queryDeity},\n      mutationResolver = Undefined,
  \n      subscriptionResolver = Undefined\n    }\n  where\n    queryDeity QueryDeityArgs
  {queryDeityArgsName} = pure Deity {deityName, deityPower}\n      where\n        deityName
  _ = pure \"Morpheus\"\n        deityPower _ = pure (Just \"Shapeshifting\")\n\napi
  :: ByteString -> IO ByteString\napi = interpreter rootResolver\n```\n\nTemplate
  Haskell Generates types: `Query` , `Deity`, `DeityArgs`, that can be used by `rootResolver`\n\n`importGQLDocumentWithNamespace`
  will generate Types with namespaced fields. if you don't need napespacing use `importGQLDocument`\n\n###
  with Native Haskell Types\n\nTo define a GraphQL API with Morpheus we start by defining
  the API Schema as a native Haskell data type,\nwhich derives the `Generic` typeclass.
  Lazily resolvable fields on this `Query` type are defined via `a -> IORes b`, representing
  resolving a set of arguments `a` to a concrete value `b`.\n\n```haskell\ndata Query
  m = Query\n  { deity :: DeityArgs -> m Deity\n  } deriving (Generic, GQLType)\n\ndata
  Deity = Deity\n  { fullName :: Text         -- Non-Nullable Field\n  , power    ::
  Maybe Text   -- Nullable Field\n  } deriving (Generic)\n\ninstance GQLType Deity
  where\n  type  KIND Deity = OBJECT\n\ndata DeityArgs = DeityArgs\n  { name      ::
  Text        -- Required Argument\n  , mythology :: Maybe Text  -- Optional Argument\n
  \ } deriving (Generic)\n```\n\nFor each field in the `Query` type defined via `a
  -> m b` (like `deity`) we will define a resolver implementation that provides the
  values during runtime by referring to\nsome data source, e.g. a database or another
  API. Fields that are defined without `a -> m b` you can just provide a value.\n\nIn
  above example, the field of `DeityArgs` could also be named using reserved identities
  (such as: `type`, `where`, etc), in order to avoid conflict, a prime symbol (`'`)
  must be attached. For example, you can have:\n\n```haskell\ndata DeityArgs = DeityArgs\n
  \ { name      :: Text        -- Required Argument\n  , mythology :: Maybe Text  --
  Optional Argument\n  , type'     :: Text\n  } deriving (Generic)\n```\n\nThe field
  name in the final request will be `type` instead of `type'`. The Morpheus request
  parser converts each of the reserved identities in Haskell 2010 to their corresponding
  names internally. This also applies to selections.\n\n```haskell\nresolveDeity ::
  DeityArgs -> IORes Deity\nresolveDeity args = QueryResolver $ ExceptT $ askDB (name
  args) (mythology args)\n\naskDB :: Text -> Maybe Text -> IO (Either String Deity)\naskDB
  = ...\n```\n\nNote that the type `a -> IORes b` is just Synonym for `a -> ExceptT
  String IO b`\n\nTo make this `Query` type available as an API, we define a `GQLRootResolver`
  and feed it to the Morpheus `interpreter`. A `GQLRootResolver` consists of `query`,
  `mutation` and `subscription` definitions, while we omit the latter for this example:\n\n```haskell\nrootResolver
  :: GQLRootResolver IO () Query Undefined Undefined\nrootResolver =\n  GQLRootResolver\n
  \   { queryResolver = Query {deity = resolveDeity}\n    , mutationResolver = Undefined\n
  \   , subscriptionResolver = Undefined\n    }\n\ngqlApi :: ByteString -> IO ByteString\ngqlApi
  = interpreter rootResolver\n```\n\nAs you can see, the API is defined as `ByteString
  -> IO ByteString` which we can either invoke directly or use inside an arbitrary
  web framework\nsuch as `scotty` or `serverless-haskell`. We'll go for `scotty` in
  this example:\n\n```haskell\nmain :: IO ()\nmain = scotty 3000 $ post \"/api\" $
  raw =<< (liftIO . gqlApi =<< body)\n```\n\nIf we now send a POST request to `http://localhost:3000/api`
  with a GraphQL Query as body for example in a tool like `Insomnia`:\n\n```GraphQL\nquery
  GetDeity {\n  deity (name: \"Morpheus\") {\n    fullName\n    power\n  }\n}\n```\n\nour
  query will be resolved!\n\n```JSON\n{\n  \"data\": {\n    \"deity\": {\n      \"fullName\":
  \"Morpheus\",\n      \"power\": \"Shapeshifting\"\n    }\n  }\n}\n```\n\n## Serverless
  Example\n\nIf you are interested in creating a `Morpheus GraphQL` API with `Serverless`,
  you should take a look at our example in this repository:\n[_Mythology API_](https://github.com/morpheusgraphql/mythology-api)
  it is our example project build with `Morpheus GraphQL` and `Serverless-Haskell`,\nwhere
  you can query different mythology characters with `GraphiQL`.\n\nMythology API is
  deployed on : [_api.morpheusgraphql.com_](https://api.morpheusgraphql.com) where
  you can test it with `GraphiQL`\n\n![Mythology Api](./assets/img/mythology-api.png
  \"mythology-api\")\n\n## Advanced topics\n\n### Enums\n\nYou can use Union Types
  as Enums, but they're not allowed to have any parameters.\n\n```haskell\ndata City\n
  \ = Athens\n  | Sparta\n  | Corinth\n  | Delphi\n  | Argos\n  deriving (Generic)\n\ninstance
  GQLType City where\n  type KIND City = ENUM\n```\n\n### Union types\n\nTo use union
  type, all you have to do is derive the `GQLType` class. Using GraphQL [_fragments_](https://graphql.org/learn/queries/#fragments),
  the arguments of each data constructor can be accessed from the GraphQL client.\n\n```haskell\ndata
  Character\n  = DEITY Deity\n  | HUMAN Human\n  deriving (Generic)\n\ninstance GQLType
  Character where\n  type KIND City = UNION\n```\n\n### Scalar types\n\nTo use custom
  scalar types, you need to provide implementations for `parseValue` and `serialize`
  respectively.\n\n```haskell\ndata Odd = Odd Int  deriving (Generic)\n\ninstance
  GQLScalar Odd where\n  parseValue (Int x) = pure $ Odd (...  )\n  parseValue (String
  x) = pure $ Odd (...  )\n  serialize  (Odd value) = Int value\n\ninstance GQLType
  Odd where\n  type KIND Odd = SCALAR\n```\n\n### Applicative and Monad instance\n\nThe
  `Resolver` type has `Applicative` and `Monad` instances that can be used to compose
  resolvers.\n\n### Introspection\n\nMorpheus converts your schema to a GraphQL introspection
  automatically. You can use tools like `Insomnia` to take a\nlook at the introspection
  and validate your schema.\nIf you need a description for your GQLType inside of
  the introspection you can define the GQLType instance manually\nand provide an implementation
  for the `description` function:\n\n```haskell\ndata Deity = Deity\n{ ...\n} deriving
  (Generic)\n\ninstance GQLType Deity where\n  description = const \"A supernatural
  being considered divine and sacred\"\n```\n\nscreenshots from `Insomnia`\n\n![alt
  text](./assets/img/introspection/spelling.png \"spelling\")\n![alt text](./assets/img/introspection/autocomplete.png
  \"autocomplete\")\n![alt text](./assets/img/introspection/type.png \"type\")\n\n###
  Mutations\n\nIn addition to queries, Morpheus also supports mutations. The behave
  just like regular queries and are defined similarly:\nJust exchange deriving `GQLQuery`
  for `GQLMutation` and declare them separately at the `GQLRootResolver` definition\n\n```haskell\nnewtype
  Mutation m = Mutation\n  { createDeity :: Form -> m Deity\n  } deriving (Generic,
  GQLType)\n\ncreateDeityMutation :: Form -> m (Deity m)\ncreateDeityMutation = ...\n\nrootResolver
  :: GQLRootResolver IO Query Mutation Undefined\nrootResolver =\n  GQLRootResolver\n
  \   { queryResolver = Query {...}\n    , mutationResolver = Mutation {\n       createDeity
  = createDeityMutation\n    }\n    , subscriptionResolver = Undefined\n    }\n\ngqlApi
  :: ByteString -> IO ByteString\ngqlApi = interpreter rootResolver\n```\n\n### Subscriptions\n\nim
  morpheus subscription and mutation communicating with Events,\n`Event` consists
  with user defined `Channel` and `Content`.\n\nevery subscription has own Channel
  by which will be triggered\n\n```haskell\ndata Channel\n  = ChannelA\n  | ChannelB\n\ndata
  Content\n  = ContentA Int\n  | ContentB Text\n\nnewtype Query m = Query\n  { deity
  :: () -> m Deity\n  } deriving (Generic)\n\nnewtype Mutation m = Mutation\n  { createDeity
  :: () -> m Deity\n  } deriving (Generic)\n\nnewtype Subscription m = Subscription\n
  \ { newDeity :: () -> m  Deity\n  } deriving (Generic)\n\ntype APIEvent = Event
  Channel Content\n\nrootResolver :: GQLRootResolver IO APIEvent Query Mutation Subscription\nrootResolver
  =\n  GQLRootResolver\n    { queryResolver = Query {deity = const fetchDeity}\n    ,
  mutationResolver = Mutation {createDeity}\n    , subscriptionResolver = Subscription
  {newDeity}\n    }\n  where\n    createDeity _args = MutResolver events updateDeity\n
  \       where \n        events = [Event {channels = [ChannelA], content = ContentA
  1}]\n        updateDeity = updateDBDeity\n    newDeity _args = SubResolver [ChannelA]
  subResolver\n      where\n        subResolver (Event [ChannelA] (ContentA _value))
  = fetchDeity  -- resolve New State\n        subResolver (Event [ChannelA] (ContentB
  _value)) = fetchDeity   -- resolve New State\n        subResolver _                                    =
  fetchDeity -- Resolve Old State\n```\n\n## Morpheus `GraphQL Client` with Template
  haskell QuasiQuotes\n\n```hs\ndefineByDocumentFile\n    \"./schema.gql\"\n  [gql|\n
  \   query GetHero ($character: Character)\n      {\n        deity (fatherOf:$character)
  {\n          name\n          power\n          worships {\n            deity2Name:
  name\n          }\n        }\n      }\n  |]\n```\n\nwith schema:\n\n```gql\ninput
  Character {\n  name: String!\n}\n\ntype Deity {\n  name: String!\n  worships: Deity\n}\n```\n\nwill
  validate query and Generate:\n\n- namespaced response and variable types\n- instance
  for `Fetch` typeClass\n\n```hs\ndata GetHero = GetHero {\n  deity: DeityDeity\n}\n\n--
  from: {user\ndata DeityDeity = DeityDeity {\n  name: Text,\n  worships: Maybe DeityWorshipsDeity\n}\n\n--
  from: {deity{worships\ndata DeityWorshipsDeity = DeityWorshipsDeity {\n  name: Text,\n}\n\ndata
  GetHeroArgs = GetHeroArgs {\n  getHeroArgsCharacter: Character\n}\n\ndata Character
  = Character {\n  characterName: Person\n}\n```\n\nas you see, response type field
  name collision can be handled with GraphQL `alias`.\n\nwith `fetch` you can fetch
  well typed response `GetHero`.\n\n```haskell\n  fetchHero :: Args GetHero -> m (Either
  String GetHero)\n  fetchHero = fetch jsonRes args\n      where\n        args = GetHeroArgs
  {getHeroArgsCharacter = Person {characterName = \"Zeus\"}}\n        jsonRes :: ByteString
  -> m ByteString\n        jsonRes = <GraphQL APi>\n```\n\ntypes can be generatet
  from `introspection` too:\n\n```haskell\ndefineByIntrospectionFile \"./introspection.json\"\n```\n\n##
  Morpheus CLI for Code Generating\n\nGenerating dummy Morpheus Api from `schema.gql`\n\n```\nmorpheus
  build src/schem.gql src/GQLApi.hs\n```\n\nthis command will generate Haskell API
  and resolvers,\nresolvers will resolve default values for every object\n\n# About\n\n##
  The name\n\n_Morpheus_ is the greek god of sleep and dreams whose name comes from
  the greek word _μορφή_ meaning form or shape.\nHe is said to be able to mimic different
  forms and GraphQL is good at doing exactly that: Transforming data in the shape\nof
  many different APIs.\n\n## Team\n\nMorpheus is written and maintained by [_nalchevanidze_](https://github.com/nalchevanidze)\n\n##
  Roadmap\n\n- Medium future:\n  - Stabilize API\n  - Specification-isomorphic error
  handling\n- Long term:\n  - Support all possible GQL features\n  - Performance optimization\n"
license-name: BSD-3-Clause
