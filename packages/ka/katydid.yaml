homepage: https://github.com/katydid/katydid-haskell
changelog-type: ''
hash: 09bfe3756ed7721c668245e52cb5430c2d10e384be54a4073df0ee811e37b0f1
test-bench-deps:
  base: -any
  json: -any
  filepath: -any
  parsec: -any
  HUnit: -any
  containers: -any
  hxt: -any
  mtl: -any
  tasty-hunit: -any
  tasty: -any
  katydid: -any
  directory: -any
maintainer: awalterschulze@gmail.com
synopsis: A haskell implementation of Katydid
changelog: ''
basic-deps:
  base: ! '>=4.7 && <5'
  json: -any
  parsec: -any
  containers: -any
  hxt: -any
  regex-tdfa: -any
  mtl: -any
  katydid: -any
all-versions:
- '0.1.0.0'
author: Walter Schulze
latest: '0.1.0.0'
description-type: markdown
description: ! "# Katydid\n\n[![Build Status](https://travis-ci.org/katydid/katydid-haskell.svg?branch=master)](https://travis-ci.org/katydid/katydid-haskell)\n\nA
  Haskell implementation of Katydid.\n\nThis includes:\n\n  - [Relapse](https://katydid.github.io/katydid-haskell/Relapse.html):
  Validation Language \n  - Parsers: [JSON](https://katydid.github.io/katydid-haskell/Json.html)
  and [XML](https://katydid.github.io/katydid-haskell/Xml.html)\n\n[Documentation
  for katydid](http://katydid.github.io/)\n\n[Documentation for katydid-haskell](https://katydid.github.io/katydid-haskell/)\n\n[Documentation
  for katydid-haskell/Relapse](https://katydid.github.io/katydid-haskell/Relapse.html)\n\nAll
  JSON and XML tests from [the language agnostic test suite](https://github.com/katydid/testsuite)
  [passes].\n\n## Example\n\nValidating a single structure can be done using the validate
  function:\n```haskell\nvalidate :: Tree t => Refs -> [t] -> Bool\n```\n\n, where
  a tree is a class in the [Parsers](https://katydid.github.io/katydid-haskell/Parsers.html)
  module:\n```haskell\nclass Tree a where\n    getLabel :: a -> Label\n    getChildren
  :: a -> [a]\n```\n\nHere is an example that validates a single JSON tree:\n```haskell\nmain
  = either \n    (\\err -> putStrLn $ \"error:\" ++ err) \n    (\\valid -> if valid
  \n        then putStrLn \"dragons exist\" \n        else putStrLn \"dragons are
  fictional\"\n    ) $\n    Relapse.validate <$> \n        runExcept (Relapse.parseGrammar
  \".DragonsExist == true\") <*> \n        Json.decodeJSON \"{\\\"DragonsExist\\\":
  false}\"\n```\n\n## Efficiency\n\nIf you want to validate multiple trees using the
  same grammar then the filter function does some internal memoization, which makes
  a huge difference.\n\n```haskell\nfilter :: Tree t => Refs -> [[t]] -> [[t]]\n```\n\n"
license-name: BSD3
