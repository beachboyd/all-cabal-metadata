homepage: https://github.com/katydid/katydid-haskell
changelog-type: markdown
hash: 5d3a4a46b105f69663add9609ab22c8d1e691a61b07f04c07d666223130243c8
test-bench-deps:
  base: -any
  text: -any
  json: -any
  filepath: -any
  criterion: ! '>=1.2.2'
  parsec: -any
  HUnit: -any
  containers: -any
  hxt: -any
  mtl: -any
  tasty-hunit: -any
  tasty: -any
  deepseq: -any
  katydid: -any
  directory: -any
maintainer: awalterschulze@gmail.com
synopsis: A haskell implementation of Katydid
changelog: ! '# 2.0.1


  Fixes parsing of builtin regex and contains functions.


  # 2.0.0


  Adds benchmarks


  # 1.1.0


  Cleanup


  # 1.0.0


  First version'
basic-deps:
  base: ! '>=4.7 && <5'
  json: -any
  parsec: -any
  containers: -any
  hxt: -any
  regex-tdfa: -any
  mtl: -any
  deepseq: -any
  katydid: -any
all-versions:
- '0.1.0.0'
- '0.1.1.0'
- '0.2.0.1'
author: Walter Schulze
latest: '0.2.0.1'
description-type: markdown
description: ! "# Katydid\n\n[![Build Status](https://travis-ci.org/katydid/katydid-haskell.svg?branch=master)](https://travis-ci.org/katydid/katydid-haskell)\n\nA
  Haskell implementation of Katydid.\n\nThis includes:\n\n  - [Relapse](https://katydid.github.io/katydid-haskell/Relapse.html):
  Validation Language \n  - Parsers: [JSON](https://katydid.github.io/katydid-haskell/Json.html)
  and [XML](https://katydid.github.io/katydid-haskell/Xml.html)\n\n[Documentation
  for katydid](http://katydid.github.io/)\n\n[Documentation for katydid-haskell](https://katydid.github.io/katydid-haskell/)\n\n[Documentation
  for katydid-haskell/Relapse](https://katydid.github.io/katydid-haskell/Relapse.html)\n\nAll
  JSON and XML tests from [the language agnostic test suite](https://github.com/katydid/testsuite)
  [passes].\n\n[Hackage](https://hackage.haskell.org/package/katydid-0.1.0.0).\n\n##
  Example\n\nValidating a single structure can be done using the validate function:\n```haskell\nvalidate
  :: Tree t => Refs -> [t] -> Bool\n```\n\n, where a tree is a class in the [Parsers](https://katydid.github.io/katydid-haskell/Parsers.html)
  module:\n```haskell\nclass Tree a where\n    getLabel :: a -> Label\n    getChildren
  :: a -> [a]\n```\n\nHere is an example that validates a single JSON tree:\n```haskell\nmain
  = either \n    (\\err -> putStrLn $ \"error:\" ++ err) \n    (\\valid -> if valid
  \n        then putStrLn \"dragons exist\" \n        else putStrLn \"dragons are
  fictional\"\n    ) $\n    Relapse.validate <$> \n        runExcept (Relapse.parseGrammar
  \".DragonsExist == true\") <*> \n        Json.decodeJSON \"{\\\"DragonsExist\\\":
  false}\"\n```\n\n## Efficiency\n\nIf you want to validate multiple trees using the
  same grammar then the filter function does some internal memoization, which makes
  a huge difference.\n\n```haskell\nfilter :: Tree t => Refs -> [[t]] -> [[t]]\n```\n\n"
license-name: BSD3
