homepage: https://github.com/jumper149/haskeme
changelog-type: markdown
hash: 81704b27b7c968407db7a1fb995274e2f5806eab5c2234a7407a764244624612
test-bench-deps: {}
maintainer: felixspringer149@gmail.com
synopsis: Compiler from I- to S-Expressions for the Scheme Programming Language
changelog: |
  # Revision history for haskeme

  ## 0.1.0.0 -- 2019/06/30

  * First version. Released on an unsuspecting world.

  ## 0.1.0.1 -- 2019/06/30

  * Updated README with explanation and examples.
basic-deps:
  base: ==4.12.*
  haskeme: -any
all-versions:
- 0.1.0.0
- 0.1.0.1
author: Felix Springer
latest: 0.1.0.1
description-type: markdown
description: "# haskeme\n\nThis compiler translates Scheme source code written with
  I-Expressions (indented expressions) into S-Expressions (symbolic expressions).\n\n##
  Usage\nHaskeme can read and write files:\n\n    haskeme --input \"program.hss\"
  --output \"program.ss\"\n\nHaskeme can also use `StdIn` and `StdOut`:\n\n    cat
  \"program.hss\" | haskeme > \"program.ss\"\n\n### Options\n- `-i` or `--input` to
  specify input file\n- `-o` or `--output` to specify output file\n\n## I-Expressions\nI-Expressions
  are indented expressions and are translated by few simple rules:\n\n- a new line
  translates to a new S-Expression\n- same indentation as the expression above translates
  to a new S-Expression following the prior one\n- more indentation as the expression
  above translates to a new S-Expression as an argument to the prior one\n- less indentation
  as the expression above, but still more indentation as another expression above
  translates to a new S-Expression, while the prior and further indented block gets
  wrapped in extra parentheses (look at the `let`-example)\n- S-Expression can be
  mixed in while staying in a single line (look at the example for mixed expressions)\n\n\n###
  Example\n- I-Expressions:\n\n    ```\n    define\n      f\n        lambda\n          x\n
  \         let\n              y\n                * x x\n        + y 1\n    ```\n\n-
  S-Expressions:\n\n    ```\n    (define\n      (f\n        (lambda (x)\n          (let
  ((y (* x x)))\n            (+ y 1)))))\n    ```\n\n- mixed I- and S-Expressions:\n\n
  \   ```\n    define\n      f\n        lambda (x)\n          let\n              y
  (* x x)\n            + y 1\n    ```\n    \n## Install\n- install from [Hackage](https://hackage.haskell.org/package/haskeme)
  with cabal:\n\n    ```\n    cabal install haskeme\n    ```\n\n- clone from [GitHub](https://github.com/jumper149/haskeme)
  and compile with `cabal`:\n    \n    ```\n    git clone https://github.com/jumper149/haskeme.git\n
  \   cd haskeme\n    cabal build\n    ```\n\n- clone from GitHub and compile with
  ghc (not recommended, use this [PKGBUILD](https://aur.archlinux.org/cgit/aur.git/tree/PKGBUILD?h=haskeme)
  as a template)\n\n- install from [AUR](https://aur.archlinux.org/packages/haskeme/)
  (only ArchLinux-Users)\n\n### Dependencies\n- `ghc` (make)\n- `cabal` (opt. make)\n"
license-name: BSD-3-Clause
