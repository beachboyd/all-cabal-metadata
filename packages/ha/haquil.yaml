homepage: https://bitbucket.org/functionally/haquil
changelog-type: markdown
hash: 1eff5c5267d92b651e7d14737c40a892e636db0d02392d5ed858795980487ee8
test-bench-deps:
  MonadRandom: -any
  base: -any
  hTensor: -any
  QuickCheck: -any
  template-haskell: -any
  vector: -any
maintainer: Brian W Bush <code@functionally.io>
synopsis: A Haskell implementation of the Quil instruction set for quantum computing.
changelog: ! '# Revision history for quil


  ## 0.1.7.5  -- 2017-12-19


  * added example usage


  ## 0.1.7.3  -- 2017-12-18


  * added measurement


  ## 0.1.5.0  -- 2017-12-17


  * tested two- and three-qubit gates


  ## 0.1.4.0  -- 2017-12-16


  * renamed product operators

  * tested one-qubit gates


  ## 0.1.3.0  -- 2017-12-16


  * added Quil gates


  ## 0.1.2.0  -- 2017-12-16


  * added qubit types and operations


  ## 0.1.0.0  -- 2017-12-15


  * skeleton

'
basic-deps:
  MonadRandom: -any
  base: ! '>=4.9 && <4.10'
  hTensor: -any
  vector: -any
all-versions:
- '0.1.7.5'
author: Brian W Bush <code@functionally.io>
latest: '0.1.7.5'
description-type: markdown
description: ! "quil: An instruction set for quantum computing\n==============================================\n\nThis
  Haskell library implements the Quil language for quantum computing, as specified
  in \"A Practical Quantum Instruction Set Architecture\" <<https://arxiv.org/abs/1608.03355/>>,
  using the indexing conventions in <<https://arxiv.org/abs/1711.02086/>>.\n\nPlease
  report issues at <<https://bwbush.atlassian.net/projects/HQUIL/issues/>>.\n\n\nExample\n-------\n\nThis
  example creates a wavefunction for the [Bell state](https://en.wikipedia.org/wiki/Bell_state)
  and then performs a measurement on its highest qubit.\n\n\t> import Control.Monad.Random
  (evalRandIO)\n\t> import Data.Qubit ((^^*), groundState)\n\t> import Data.Qubit.Gate
  (H, CNOT)\n\t\n\t> -- Construct the Bell state.\n\t> let bell = [h 0, cnot 0 1]
  ^^* groundState 2\n\t> bell\n\t0.7071067811865475|00> + 0.7071067811865475|11> @
  [1,0]\n\t\n\t> -- Measure the Bell wavefunction.\n\t> bell' <- evalRandIO $ measure
  [1] bell\n\t> bell'\n\t([(1,0)],1.0|00> @ [1,0])\n\t\n\t> -- Measure it again.\n\t>
  evalRandIO $ measure [1] bell'\n\t([(1,0)],1.0|00> @ [1,0])\n\t\n\t> -- Measure
  another Bell wavefunction.\n\t> evalRandIO $ measure [1] bell\n\t([(1,0)],1.0|00>
  @ [1,0])\n\t\n\t> -- Measure another Bell wavefunction.\n\t> evalRandIO $ measure
  [1] bell\n\t([(1,1)],1.0|11> @ [1,0])\n"
license-name: MIT
