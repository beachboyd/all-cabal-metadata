homepage: https://github.com/snowleopard/alga
changelog-type: markdown
hash: c0700acf56290af3c5e00c2ce83efa16d3524f47a9ed89991353c0f2fd3fb15f
test-bench-deps:
  extra: ! '>=1.5 && <2'
  base: ! '>=4.7 && <5'
  array: ! '>=0.4 && <0.6'
  base-orphans: ! '>=0.5.4 && <0.9'
  containers: ! '>=0.5.5.1 && <0.8'
  base-compat: ! '>=0.9.1 && <0.11'
  QuickCheck: ! '>=2.9 && <2.12'
  algebraic-graphs: -any
maintainer: ! 'Andrey Mokhov <andrey.mokhov@gmail.com>, github: @snowleopard,

  Alexandre Moine <alexandre@moine.me>, github: @nobrakal'
synopsis: A library for algebraic graph construction and transformation
changelog: ! "# Change log\r\n\r\n## 0.2\r\n\r\n* #117: Add `sparsify`.\r\n* #115:
  Add `isDfsForestOf`.\r\n* #114: Add a basic implementation of edge-labelled graphs.\r\n*
  #107: Drop `starTranspose`.\r\n* #106: Extend `ToGraph` with algorithms based on
  adjacency maps.\r\n* #106: Add `isAcyclic` and `reachable`.\r\n* #106: Rename `isTopSort`
  to `isTopSortOf`.\r\n* #102: Switch the master branch to GHC 8.4.3. Add a CI instance
  for GHC 8.6.1.\r\n* #101: Drop `-O2` from the `ghc-options` section of the Cabal
  file.\r\n* #100: Rename `fromAdjacencyList` to `stars`.\r\n* #79: Improve the API
  consistency: rename `IntAdjacencyMap` to `AdjacencyIntMap`,\r\n       and then rename
  the function that extracts its adjacency map to\r\n       `adjacencyIntMap` to avoid
  the clash with `AdjacencyMap.adjacencyMap`,\r\n       which has incompatible type.\r\n*
  #82, #92: Add performance regression suite.\r\n* #76: Remove benchmarks.\r\n* #74:
  Drop dependency of `Algebra.Graph` on graph type classes.\r\n* #62: Move King-Launchbury
  graphs into `Data.Graph.Typed`.\r\n* #67, #68, #69, #77, #81, #93, #94, #97, #103,
  #110: Various performance improvements.\r\n* #66, #72, #96, #98: Add missing `NFData`
  instances.\r\n\r\n## 0.1.1.1\r\n\r\n* #59: Allow `base-compat-0.10`.\r\n\r\n## 0.1.1\r\n\r\n*
  #58: Update documentation.\r\n* #57: Allow newer QuickCheck.\r\n\r\n## 0.1.0\r\n\r\n*
  Start complying with PVP.\r\n* #48: Add `starTranspose`.\r\n* #48: Add `foldg` to
  `ToGraph`.\r\n* #15: Optimise `removeEdge`.\r\n* #39: Factor out difference lists
  into `Algebra.Graph.Internal`.\r\n* #31: Add `Algebra.Graph.NonEmpty`.\r\n* #32:
  Remove smart constructor `graph`.\r\n* #27, #55: Support GHC versions 7.8.4, 7.10.3,
  8.0.2, 8.2.2, 8.4.1.\r\n* #25: Add `NFData Graph` instance.\r\n* General improvements
  to code, documentation and tests.\r\n\r\n## 0.0.5\r\n\r\n* Add `dfs`.\r\n* #19:
  Move `GraphKL` to an internal module.\r\n* #18: Add `dfsForestFrom`.\r\n* #16: Add
  support for graph export, in particular in DOT format.\r\n* Make API more consistent,
  e.g. rename `postset` to `postSet`.\r\n* Improve documentation and tests.\r\n"
basic-deps:
  base: ! '>=4.7 && <5'
  array: ! '>=0.4 && <0.6'
  containers: ! '>=0.5.5.1 && <0.8'
  base-compat: ! '>=0.9.1 && <0.11'
  mtl: ! '>=2.1 && <2.3'
  deepseq: ! '>=1.3.0.1 && <1.5'
all-versions:
- '0.0.1'
- '0.0.2'
- '0.0.3'
- '0.0.4'
- '0.0.5'
- '0.1.0'
- '0.1.1'
- '0.1.1.1'
- '0.2'
author: ! 'Andrey Mokhov <andrey.mokhov@gmail.com>, github: @snowleopard'
latest: '0.2'
description-type: markdown
description: ! "# Algebraic graphs\n\n[![Hackage version](https://img.shields.io/hackage/v/algebraic-graphs.svg?label=Hackage)](https://hackage.haskell.org/package/algebraic-graphs)
  [![Linux & OS X status](https://img.shields.io/travis/snowleopard/alga/master.svg?label=Linux%20%26%20OS%20X)](https://travis-ci.org/snowleopard/alga)
  [![Windows status](https://img.shields.io/appveyor/ci/snowleopard/alga/master.svg?label=Windows)](https://ci.appveyor.com/project/snowleopard/alga)\n\n**Alga**
  is a library for algebraic construction and manipulation of graphs in Haskell. See\n[this
  Haskell Symposium paper](https://github.com/snowleopard/alga-paper) and the\ncorresponding
  [talk](https://www.youtube.com/watch?v=EdQGLewU-8k) for the motivation\nbehind the
  library, the underlying theory and implementation details. There is also a\n[Haskell
  eXchange talk](https://skillsmatter.com/skillscasts/10635-algebraic-graphs), \nand
  a [tutorial](https://nobrakal.github.io/alga-tutorial) by Alexandre Moine.\n\n##
  Main idea\n\nConsider the following data type, which is defined in the top-level
  module\n[Algebra.Graph](http://hackage.haskell.org/package/algebraic-graphs/docs/Algebra-Graph.html)\nof
  the library:\n\n```haskell\ndata Graph a = Empty | Vertex a | Overlay (Graph a)
  (Graph a) | Connect (Graph a) (Graph a)\n```\n\nWe can give the following semantics
  to the constructors in terms of the pair **(V, E)** of graph *vertices* and *edges*:\n\n*
  `Empty` constructs the empty graph **(∅, ∅)**.\n* `Vertex x` constructs a graph
  containing a single vertex, i.e. **({x}, ∅)**.\n* `Overlay x y` overlays graphs
  **(Vx, Ex)** and **(Vy, Ey)** constructing **(Vx ∪ Vy, Ex ∪ Ey)**.\n* `Connect x
  y` connects graphs **(Vx, Ex)** and **(Vy, Ey)** constructing **(Vx ∪ Vy, Ex ∪ Ey
  ∪ Vx × Vy)**.\n\nAlternatively, we can give an algebraic semantics to the above
  graph construction primitives by defining the following\ntype class and specifying
  a set of laws for its instances (see module [Algebra.Graph.Class](http://hackage.haskell.org/package/algebraic-graphs/docs/Algebra-Graph-Class.html)):\n\n```haskell\nclass
  Graph g where\n    type Vertex g\n    empty   :: g\n    vertex  :: Vertex g -> g\n
  \   overlay :: g -> g -> g\n    connect :: g -> g -> g\n```\n\nThe laws of the type
  class are remarkably similar to those of a [semiring](https://en.wikipedia.org/wiki/Semiring),\nso
  we use `+` and `*` as convenient shortcuts for `overlay` and `connect`, respectively:\n\n*
  (`+`, `empty`) is an idempotent commutative monoid.\n* (`*`, `empty`) is a monoid.\n*
  `*` distributes over `+`, that is: `x * (y + z) == x * y + x * z` and `(x + y) *
  z == x * z + y * z`.\n* `*` can be decomposed: `x * y * z == x * y + x * z + y *
  z`.\n\nThis algebraic structure corresponds to *unlabelled directed graphs*: every
  expression represents a graph, and every\ngraph can be represented by an expression.
  Other types of graphs (e.g. undirected) can be obtained by modifying the\nabove
  set of laws. Algebraic graphs provide a convenient, safe and powerful interface
  for working with graphs in Haskell,\nand allow the application of equational reasoning
  for proving the correctness of graph algorithms.\n\nTo represent *non-empty graphs*,
  we can drop the `Empty` constructor -- see module\n[Algebra.Graph.NonEmpty](http://hackage.haskell.org/package/algebraic-graphs/docs/Algebra-Graph-NonEmpty.html).\n\n##
  How fast is the library?\n\nAlga can handle graphs comprising millions of vertices
  and billions of edges in a matter of seconds, which is fast\nenough for many applications.
  We believe there is a lot of potential for improving the performance of the library,
  and\nthis is one of our top priorities. If you come across a performance issue when
  using the library, please let us know.\n\nSome preliminary benchmarks can be found
  [here](https://github.com/haskell-perf/graphs).\n\n## Blog posts\n\nThe development
  of the library has been documented in the series of blog posts:\n* Introduction:
  https://blogs.ncl.ac.uk/andreymokhov/an-algebra-of-graphs/\n* A few different flavours
  of the algebra: https://blogs.ncl.ac.uk/andreymokhov/graphs-a-la-carte/\n* Graphs
  in disguise or How to plan you holiday using Haskell: https://blogs.ncl.ac.uk/andreymokhov/graphs-in-disguise/\n*
  Old graphs from new types: https://blogs.ncl.ac.uk/andreymokhov/old-graphs-from-new-types/\n"
license-name: MIT
