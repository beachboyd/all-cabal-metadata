homepage: https://github.com/suhailshergill/extensible-effects
changelog-type: ''
hash: 16e867d868aa50c9b9a924b66b4a30b8a1026e9bbe6a850763f901a1879856c9
test-bench-deps:
  test-framework-hunit: ==0.3.*
  test-framework: ==0.8.*
  extensible-effects: -any
  base: ! '>=4.7 && <4.12'
  monad-control: ! '>=1.0'
  test-framework-quickcheck2: ==0.3.*
  criterion: -any
  doctest: -any
  HUnit: -any
  test-framework-th: ! '>=0.2'
  silently: ! '>=1.2'
  mtl: -any
  QuickCheck: -any
maintainer: suhailshergill@gmail.com
synopsis: An Alternative to Monad Transformers
changelog: ''
basic-deps:
  base: ! '>=4.7 && <4.12'
  monad-control: ! '>=1.0 && <1.1'
  transformers-base: ==0.4.*
all-versions:
- '1.0'
- '1.1.0'
- '1.2.0'
- '1.2.1'
- '1.4.1'
- '1.7.1'
- '1.7.1.0'
- '1.7.1.1'
- '1.7.1.2'
- '1.7.2.1'
- '1.8.0.0'
- '1.8.1.0'
- '1.9.0.0'
- '1.9.0.1'
- '1.9.1.0'
- '1.9.2.2'
- '1.10.0.1'
- '1.11.0.0'
- '1.11.0.1'
- '1.11.0.2'
- '1.11.0.3'
- '1.11.0.4'
- '1.11.1.0'
- '2.0.0.0'
- '2.0.0.2'
- '2.0.1.0'
- '2.1.0.0'
- '2.2.1.0'
- '2.3.0.0'
- '2.3.0.1'
- '2.4.0.0'
- '2.5.0.0'
- '2.5.1.0'
- '2.5.1.2'
- '2.5.2.0'
- '2.5.3.0'
- '2.6.0.0'
- '2.6.0.1'
- '2.6.0.2'
- '2.6.0.3'
- '2.6.1.0'
- '2.6.1.1'
- '2.6.2.0'
- '2.6.3.0'
- '3.0.0.0'
- '3.1.0.0'
- '3.1.0.1'
author: Oleg Kiselyov, Amr Sabry, Cameron Swords, Ben Foppa
latest: '3.1.0.1'
description-type: markdown
description: ! "\n# Extensible effects (![Hackage](https://img.shields.io/hackage/v/extensible-effects.svg))\n\n[![Build
  Status](https://travis-ci.org/suhailshergill/extensible-effects.svg?branch=master)](https://travis-ci.org/suhailshergill/extensible-effects)\n[![Join
  the chat at https://gitter.im/suhailshergill/extensible-effects](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/suhailshergill/extensible-effects?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Stories
  in Ready](https://badge.waffle.io/suhailshergill/extensible-effects.png?label=ready&title=Ready)](http://waffle.io/suhailshergill/extensible-effects)\n[![Stories
  in progress](https://badge.waffle.io/suhailshergill/extensible-effects.png?label=in%20progress&title=In%20progress)](http://waffle.io/suhailshergill/extensible-effects)\n\n*Implement
  effectful computations in a modular way!*\n\nThe main monad of this package is `Eff`
  from `Control.Eff`.\n`Eff r a` is parameterized by the effect-list `r` and the monadic-result
  type\n`a` similar to other monads.\nIt is the intention that all other monadic computations
  can be replaced by the\nuse of `Eff`.\n\nIn case you know monad transformers or
  `mtl`:\nThis library provides only one monad that includes all your effects instead
  of\nlayering different transformers.\nIt is not necessary to lift the computations
  through a monad stack.\nAlso, it is not required to lift every `Monad*` typeclass
  (like `MonadError`)\nthough all transformers.\n\n## Quickstart\n\nTo experiment
  with this library, it is suggested to write some lines within\n`ghci`.\n\nRecommended
  Procedure:\n\n1. get `extensible-effects` by doing one of the following:\n  * add
  `extensible-effects` as a dependency to a existing cabal or stack project\n  * `git
  clone https://github.com/suhailshergill/extensible-effects.git`\n2. start `stack
  ghci` or `cabal repl` inside the project\n3. import `Control.Eff` and `Control.Eff.QuickStart`\n4.
  start with the examples provided in the documentation of the `Control.Eff.QuickStart`
  module\n\n## Tour through Extensible Effects\n\nThis section explains the basic
  concepts of this library.\n\n### The Effect List\n\n```haskell\nimport Control.Eff\n```\n\nThe
  effect list `r` in the type `Eff r a` is a central concept in this library.\nIt
  is a type-level list containing effect types.\n\nIf `r` is the empty list, then
  the computation `Eff r` (or `Eff '[]`) does not\ncontain any effects to be handled
  and therefore is a pure computation.\nIn this case, the result value can be retrieved
  by `run :: Eff '[] a -> a`\n\nFor programming within the `Eff r` monad, it is almost
  never necessary to list\nall effects that can appear.\nIt suffices to state what
  types of effects are at least required.\nThis is done via the `Member t r` typeclass.
  It describes that the type `t`\noccurs inside the list `r`.\nIf you really want,
  you can still list all Effects and their order in which\nthey are used (e.g. `Eff
  '[Reader r, State s] a`).\n\n### Handling Effects\n\nFunctions containing something
  like `Eff (x ': r) a -> Eff r a` handle effects.\n\nThe transition from the longer
  list of effects `(x ': r)` to just `r`\nis a type-level indicator that the effect
  `x` has been handled.\nDepending on the effect, some additional input might be required
  or some\ndifferent output than just `a` is produced.\n\nThe handler functions typically
  are called `run*`, `eval*` or `exec*`.\n\n### Most common Effects\n\nThe most common
  effects used are `Writer`, `Reader`, `Exception` and `State`.\n\n`Writer`, `Reader`
  and `State` all provide lazy and strict variants. Each has\nits own module that
  exposes a common interface. Importing one or the other\ncontrols whether the effect
  is strict or lazy in its inputs and outputs. It's\nrecommended that you use the
  lazy variants by default unless you know you need\nstrictness.\n\nIn this section,
  only the core functions associated with an effect are\npresented.\nHave a look at
  the modules for additional details.\n\n#### The Exception Effect\n\n```haskell\nimport
  Control.Eff.Exception\n```\n\nThe exception effect adds the possibility to exit
  a computation preemptively\nwith an exception.\nNote that the exceptions from this
  library are handled by the programmer and\nhave nothing to do with exceptions thrown
  inside the Haskell run-time.\n\n```haskell\nthrowError :: Member (Exc e) r => e
  -> Eff r a\nrunError :: Eff (Exc e ': r) a -> Eff r (Either e a)\n```\n\nAn exception
  can be thrown using the `throwError` function.\nIts return type is `Eff r a` with
  an arbitrary type `a`.\nWhen handling the effect, the result-type changes to `Either
  e a` instead of\njust `a`.\nThis indicates how the effect is handled: The returned
  value is either the\nthrown exception or the value returned from a successful computation.\n\n####
  The State Effect\n\n```haskell\nimport Control.Eff.State.{Lazy | Strict}\n```\n\nThe
  state effect provides readable and writable state during a computation.\n\n```haskell\nget
  :: Member (State s) r => Eff r s\nput :: Member (State s) r => s -> Eff r ()\nmodify
  :: Member (State s) r => (s -> s) -> Eff r ()\nrunState :: s -> Eff (State s ':
  r) a -> Eff r (a, s)\n```\n\nThe `get` function fetches the current state and makes
  it available within\nsubsequent computation. The `put` function sets the state to
  a given value.\n`modify` updates the state using a mapping function by combining
  `get` and\n`put`.\n\nThe state-effect is handled using the `runState` function.\nIt
  takes the initial state as an argument and returns the final state and\neffect-result.\n\n####
  The Reader Effect\n\n```haskell\nimport Control.Eff.Reader.{Strict | Lazy}\n```\n\nThe
  reader effect provides an environment that can be read.\nSometimes it is considered
  as read-only state.\n\n```haskell\nask :: Member (Reader e) r => e -> Eff r e\nrunReader
  :: e -> Eff (Reader e ': r) a -> Eff r a\n```\n\n`ask` can be used to retrieve the
  environment provided to `runReader` from\nwithin a computation which has the `Reader`
  effect.\n\n#### The Writer Effect\n\n```haskell\nimport Control.Eff.Writer.{Strict
  | Lazy}\n```\n\nThe writer effect allows one to collect messages during a computation.\nIt
  is sometimes referred to as write-only state, which gets retrieved at the\nend of
  the computation.\n\n```haskell\ntell :: Member (Writer w) r => w -> Eff r ()\nrunWriter
  :: (w -> b -> b) -> b -> Eff (Writer w ': r) a -> Eff r (a, b)\nrunListWriter ::
  Eff (Writer w ': r) a -> Eff r (a, [w])\n```\n\nRunning a writer can be done in
  several ways.\nThe most general function is `runWriter` which folds over all written
  values.\nHowever, if you only want to collect the values written, the `runListWriter`\nfunction
  does that.\n\nNote that compared to mtl, the value written has no Monoid constraint
  on it and\ncan be collected in any way.\n\n### Using multiple Effects\n\nThe main
  benefit of this library is that multiple effects can be included\nwith ease.\n\nIf
  you need state and want to be able exit the computation with an exception,\nthe
  type of your effectful computation would be the one of `myComp` below.\nThen, both
  the state and exception effect-functions can be used.\nTo handle the effects, both
  the `runState` and `runError` functions have to be\nprovided.\n\n```haskell\nmyComp
  :: (Member (Exc e) r, Member (State s) r) => Eff r a\n\nrun1 :: (Either e a, s)\nrun1
  = run . runState initalState . runError $ myComp\n\nrun2 :: Either e (a, s)\nrun2
  = run . runError . runState initalState $ myComp\n```\n\nHowever, the order of the
  handlers does matter for the final result.\n`run1` and `run2` show different executions
  of the same effectful computation.\nIn `run1`, the returned state `s` is the last
  state seen before an eventual\nexception gets thrown (similar to the semantics in
  typical imperative\nlanguages), while in `run2` the final state is returned only
  if the whole\ncomputation succeeded - transaction style.\n\n### Tips and tricks\n\nThere
  are several constructs that make it easier to work with the effects.\n\nIf only
  a part of the result is necessary for further computation, have a\nlook at the `eval*`
  and `exec*` functions which exist for some effects.\nThe `exec*` functions discard
  the result of the computation (the `a` type).\nThe `eval*` functions discard the
  final result of the effect.\n\nInstead of writing\n`(Member (Exc e) r, Member (State
  s) r) => ...` it is\npossible to use the type operator `<::` and write\n`[ Exc e,
  State s ] <:: r => ...`, which has the same meaning.\n\nIt might be convenient to
  include the necessary language extensions and disable\nclass-constraint warnings
  in your project's `.cabal` file (or `package.yaml` if\nyou're using `stack`).\n\n*Explanation
  is a work in progress.*\n\n## Other Effects\n\n*Work in progress.*\n\n## Integration
  with IO\n\n`IO` or any other monad can be used as a base type for the `Lift` effect.\nThere
  may be at most one instance of the `Lift` effect in the effects list, and it\nmust
  be handled last. `Control.Eff.Lift` exports the `runLift` handler and\n`lift` function
  which provide the ability to run arbitrary monadic actions.\nAlso, there are convenient
  type aliases that allow for shorter type constraints.\n\n```haskell\nf :: IO ()\nf
  = runLift $ do printHello\n                 printWorld\n\n-- These two functions'
  types are equivalent.\n\nprintHello :: SetMember Lift (Lift IO) r => Eff r ()\nprintHello
  = lift (putStr \"Hello\")\n\nprintWorld :: Lifted IO r => Eff r ()\nprintWorld =
  lift (putStrLn \" world!\")\n```\n\nNote that, since `Lift` is a terminal effect,
  you do not need to use `run` to\nextract pure values. Instead, `runLift` returns
  a value wrapped in whatever\nmonad you chose to use.\n\nAdditionally, the `Lift`
  effect provides `MonadBase`, `MonadBaseControl`, and\n`MonadIO` instances that may
  be useful, especially with packages like\n[lifted-base](http://hackage.haskell.org/package/lifted-base),\n[lifted-async](http://hackage.haskell.org/package/lifted-async),
  and other\ncode that uses those typeclasses.\n\n## Integration with Monad Transformers\n\n*Work
  in progress.*\n\n## Writing your own Effects and Handlers\n\n*Work in progress.*\n\n##
  Other packages\n\nSome other packages may implement various effects. Here is a rather
  incomplete\nlist:\n\n* [log-effect](http://hackage.haskell.org/package/log-effect)\n\n##
  Background\n\n`extensible-effects` is based on the work of\n[Extensible Effects:
  An Alternative to Monad Transformers](http://okmij.org/ftp/Haskell/extensible/).\nThe
  [paper](http://okmij.org/ftp/Haskell/extensible/exteff.pdf) and\nthe followup [freer
  paper](http://okmij.org/ftp/Haskell/extensible/more.pdf)\ncontain details. Additional
  explanation behind the approach can be found on [Oleg's website](http://okmij.org/ftp/Haskell/extensible/).\n\n##
  Limitations\n\n### Ambiguity-Flexibility tradeoff\nThe extensibility of `Eff` comes
  at the cost of some ambiguity. A useful\npattern to mitigate this ambiguity is to
  specialize calls to effect handlers\nusing\n[type application](https://ghc.haskell.org/trac/ghc/wiki/TypeApplication)\nor
  type annotation. Examples of this pattern can be seen in\n[Example/Test.hs](./test/Control/Eff/Example/Test.hs).\n\nNote,
  however, that the extensibility can also be traded back, but that detracts\nfrom
  some of the advantages. For details see section 4.1 in the\n[paper](http://okmij.org/ftp/Haskell/extensible/exteff.pdf).\n\nSome
  examples where the cost of extensibility is apparent:\n\n  * Common functions can't
  be grouped using typeclasses, e.g. the `ask` and\n    `getState` functions can't
  be grouped in the case of:\n\n    ```haskell\n    class Get t a where\n      ask
  :: Member (t a) r => Eff r a\n    ```\n\n    `ask` is inherently ambiguous, since
  the type signature only provides\n    a constraint on `t`, and nothing more. To
  specify fully, a parameter\n    involving the type `t` would need to be added, which
  would defeat the\n    point of having the grouping in the first place.\n  * Code
  requires a greater number of type annotations. For details see\n    [#31](https://github.com/suhailshergill/extensible-effects/issues/31).\n\n###
  Current implementation only supports GHC version 7.8 and above\nThis is not a fundamental
  limitation of the design or the approach, but there is\nan overhead with making
  the code compatible across a large number of GHC\nversions. If this is needed, patches
  are welcome :)\n"
license-name: MIT
