homepage: ''
changelog-type: markdown
hash: fca4cbcd0681c9089225b2f1f2b338e88686c1ea53082c62f5c62062e9400f83
test-bench-deps: {}
maintainer: Jasper Van der Jeugt <jasper@fugue.co>
synopsis: A lightweight golden test runner
changelog: |
  # CHANGELOG

   -  0.1.0 (2020-06-20)
       *  Initial release.
basic-deps:
  bytestring: '>=0.10 && <0.11'
  base: '>=4.9 && <5'
  time: '>=1.8 && <1.10'
  Diff: '>=0.3 && <0.5'
  aeson-pretty: '>=0.8 && <0.9'
  unordered-containers: '>=0.2 && <0.3'
  text: '>=1.2 && <1.3'
  filepath: '>=1.4 && <1.5'
  process: '>=1.6 && <1.7'
  async: '>=2.2 && <2.3'
  regex-pcre-builtin: '>=0.95 && <0.96'
  optparse-applicative: '>=0.14 && <0.16'
  Glob: '>=0.10 && <0.11'
  aeson: '>=1.4 && <1.5'
  directory: '>=1.3 && <1.4'
all-versions:
- 0.1.0
author: Jasper Van der Jeugt <jasper@fugue.co>
latest: 0.1.0
description-type: markdown
description: "# goldplate \U0001F3C5\n\n    $ goldplate -j2 tests/\n    Found 32 specs\n
  \   Running 49 executions in 2 jobs\n    Finished in 0.84s\n    Ran 32 specs, 49
  executions, 146 asserts, all A-OK!\n\n`goldplate` is a cute and simple opaque [golden
  test] runner for CLI\napplications.  You place your test cases in a directory, annotate
  them with\n`.goldplate` files, and that's it.  It is completely language agnostic.
  \ And\nperhaps its best feature is that it can automaticallyâœ¨\U0001FA84 fix your
  tests outputs!\n\nGive `goldplate` a try if:\n\n -  You are testing a CLI application\n
  -  The application produces deterministic output (e.g. compilers, prettifiers,\n
  \   convertors)\n -  The application is quick to start (a process is created for
  every test)\n -  Your output is text-based and not huge in size\n\nAt [Fugue](https://fugue.co),
  we've been using internal versions of this tool\nsince 2016, so it should be pretty
  stable.\n\n\n## Table of Contents\n\n-   [Tutorial](#tutorial)\n    -   [Simple
  asserts](#simple-asserts)\n    -   [Feeding input on stdin](#feeding-input-on-stdin)\n
  \   -   [Setting environment\n        variables](#setting-environment-variables)\n
  \   -   [Globbing input files](#globbing-input-files)\n    -   [Post processing:
  find and\n        replace](#post-processing-find-and-replace)\n    -   [Post processing:
  prettify\n        JSON](#post-processing-prettify-json)\n    -   [Created files
  and\n        directories](#created-files-and-directories)\n-   [Installation](#installation)\n
  \   -   [Using stack](#using-stack)\n    -   [Using Cabal](#using-cabal)\n-   [Reference](#reference)\n
  \   -   [Syntax](#syntax)\n    -   [Environment variables](#environment-variables)\n-
  \  [Similar projects](#similar-projects)\n\n## Tutorial\n\nYou can follow along
  with the tutorial by cloning the repository and running\nthis command:\n\n    $
  goldplate tests\n\nAs you can see, `goldplate` itself is tested using `goldplate`.
  \ In this\ntutorial, we'll walk through some examples.  By the end, you should have
  a good\nidea of how to test your CLI application using `goldplate`.\n\n### Simple
  asserts\n\nView example: [`tests/echo.goldplate`](tests/echo.goldplate)\n\nIn this
  very simple example, we just run `echo \"Hello, world!\"`.  This is\nspecified in
  the `command` and `arguments` fields.\n\nThe actual tests that we're executing live
  in the `asserts` field.  This simple\ntest has two asserts:\n\n1.  We verify that
  the exit code is 0 (success).\n2.  We check the `stdout` (output) of the command
  against the file\n    `${GOLDPLATE_NAME}.stdout`.  `GOLDPLATE_NAME` is the name
  of the\n    specification without the extension; so our expected output lives in\n
  \   [`tests/echo.stdout`](tests/echo.stdout) in this case.\n\nWe can check that
  our asserts are correct:\n\n    $ goldplate tests/echo.goldplate\n\nIf we want to
  regenerate the expected output, we can simply do:\n\n    $ rm tests/echo.stdout\n
  \   $ goldplate --fix --pretty-diff tests/echo.goldplate\n\nAnd `goldplate` will
  show you that it fixed one file.\n\n### Feeding input on stdin\n\nView example:
  [`tests/cat.goldplate`](tests/cat.goldplate)\n\nYou can pass one or multiple lines
  of input to the command by using the `stdin`\nfield.\n\n### Setting environment
  variables\n\nView example: [`tests/env.goldplate`](tests/env.goldplate)\n\nThe `environment`
  field can be used to set environment variables for the\nprogram.\n\n### Globbing
  input files\n\nView example: [`tests/glob.goldplate`](tests/glob.goldplate)\n\n`.goldplate`
  files are fairly small but if you have a whole directory of files\nthat you just
  want to run the same command on, they can get very repetitive.\nThis is why `goldplate`
  provides a simple way to pull in multiple input files.\n\nIf the `input_files` field
  is set to a glob, all asserts will be ran for _every_\nmatching input file.  `goldplate`
  will set the following variables:\n\n -  `${GOLDPLATE_INPUT_FILE}`: the path to
  the input file\n -  `${GOLDPLATE_INPUT_NAME}`: the input file without extension\n\n###
  Post processing: find and replace\n\nView example: [`tests/replace.goldplate`](tests/replace.goldplate)\n\nSometimes
  you may want to do a find-and-replace on the actual output, for\nexample to filter
  out timestamps or other information that you do not expect to\nmatch up against
  the expected output.\n\n### Post processing: prettify JSON\n\nView example: [`tests/prettify-json.goldplate`](tests/prettify-json.goldplate)\n\nMany
  modern CLI tools output JSON.  You can use the `prettify_json` post\nprocessor to
  make sure the JSON is converted to a normalized form with sorted\nkeys and consistent
  indentation.\n\n### Created files and directories\n\nView example: [`tests/create.goldplate`](tests/create.goldplate)\n\n`goldplate`
  is geared towards checking the `stdout` and `stderr` outputs of a\nprogram, but
  you can also check that files were created with specific contents.\nIf you do this,
  `goldplate` will remove these files and directories afterwards\nto leave a clean
  repository behind.\n\n## Installation\n\nInstallation through source is done using
  standard Haskell tooling -- [Cabal]\nand [stack] both work well.\n\n### Using stack\n\n1.
  \ Install [stack] for your platform.\n2.  Clone this repository and `cd` into it.\n3.
  \ Run `stack install`.\n4.  Make sure `$HOME/.local/bin` is in your `$PATH`.\n\n###
  Using Cabal\n\n1.  Install [Cabal] for your platform.\n2.  Clone this repository
  and `cd` into it.\n3.  Run `cabal install`.\n4.  Make sure `$HOME/.cabal/bin` is
  in your `$PATH`.\n\n## Reference\n\n### Syntax\n\nEnvironment variables can be spliced
  into the configuration using `${VAR}`\nsyntax within strings.  To escape this syntax,
  use `$${VAR}` to get a literal\n`${VAR}`, `$$${VAR}` to get a literal `$${VAR}`,
  and so on.\n\n### Environment variables\n\nThe test is always executed in the directory
  that holds the `.goldplate` file.\n`goldplate` will always set the following environment
  variables:\n\n -  `GOLDPLATE_FILE`: The filename of the `.goldplate` file, e.g.\n
  \   `echo.goldplate`.\n -  `GOLDPLATE_NAME`: The filename of the `.goldplate` file
  without the\n    extension, e.g. `echo`.\n\nWhen dealing with [multiple input files](#globbing-input-files),
  the following\nadditional variables are set:\n\n -  `GOLDPLATE_INPUT_FILE`: The
  input file name, relative to the current\n    directory.\n -  `GOLDPLATE_INPUT_NAME`:
  The same as `GOLDPLATE_INPUT_FILE` but without\n    any extensions.\n\n## Similar
  projects\n\nA similar project is [smoke].  I think `goldplate` has two major advantages\nover
  smoke:\n\n -  It can fix the output files automatically using `--fix`!  This is
  very\n    useful if you make a change to your tool that affects _a lot_ of test\n
  \   files.  You still need to manually review the diff, but at least you don't\n
  \   need to manually update the specs.\n -  You can avoid most repetitive configs
  by using\n    [simple globbing](#globbing-input-files).\n\n[Cabal]: https://www.haskell.org/cabal/\n[golden
  test]: https://ro-che.info/articles/2017-12-04-golden-tests\n[stack]: https://docs.haskellstack.org/en/stable/README/\n[smoke]:
  https://github.com/SamirTalwar/smoke\n"
license-name: Apache-2.0
