homepage: https://github.com/owensmurray/ribbit
changelog-type: ''
hash: d752fd7fa67fdfb4d75646e727b5b129a1ca1a6663b315f4d4d0c4edabdb5882
test-bench-deps: {}
maintainer: rick@owensmurray.com
synopsis: ribbit
changelog: ''
basic-deps:
  Only: ! '>=0.1 && <0.2'
  base: ! '>=4.12 && <4.13'
  text: ! '>=1.2.3.1 && <1.3'
  om-show: ! '>=0.1.1.0 && <0.2'
  postgresql-simple: ! '>=0.6.2 && <0.7'
all-versions:
- 0.1.0.0
- 0.2.0.0
author: Rick Owens
latest: 0.2.0.0
description-type: markdown
description: "# Ribbit\n\nRibbit is yet another type safe relational database\nlibrary
  for Haskell, heavily inspired by the amazing\n[Servant](http://hackage.haskell.org/package/servant)
  library. The goal\nis to create a type-level language for defining table schemas
  \"as a type\",\nqueries that operate on those schemas, and, tangentially, \"backends\"
  that\ncan do something useful with those types like talk to an actual database.\n\n\nUsing
  Ribbit, you might expect to see something like this:\n\n```haskell\ntype PeopleTable
  =\n  Field \"id\" Int\n  :> Field \"name\" Text\n  :> Field \"age\" Int\n  \n\ntype
  MyQuery = Select '[\"id\", \"name\"] `From` PeopleTable `Where` \"age\" `Equals`
  (?)\n\nmatchingPeople <-\n  query\n    dbConn\n    (Proxy :: Proxy MyQuery)\n    (Only
  21) -- argument that fills in the (?) placeholder\n\n  :: IO [Only Int :> Only Text]\n\n```\n\n##
  Status\n\nThe status of Ribbit is non-functional pre-alpha. My goal though is to\nmake
  sure it is absolutely production ready for the operations it ends\nup supporting,
  but we are a long way from that at the moment.\n\n## How it compares with other
  libraries.\n\nThe short answer is there are a lot of other libraries and I'm not
  sure.\nPersistent and esquelleto are ones I've used, but if you search \"relational\"
  or\n\"sql\" in Hackage there seems to be a lot of other options. Part of the goals\nfor
  this library are to flesh out this approach myself, so I can have a better\ncontext
  for understanding everything else available. In other words, it is part\nresearch
  project. With that in mind, there are at least a couple of specific\ngoals I have
  in mind:\n\n- Avoid template Haskell. Persistent is amazing, but the use of Template\n
  \ Haskell makes certain things difficult, like documenting (or for large\n  projects
  even understanding) everything that is produced by the Template\n  Haskell.\n\n-
  Make the language easy to understand. If you have some basic SQL knowledge,\n  it
  should be immediately obvious what is going on even if you are a beginner\n  Haskeller.\n\n-
  Try to make as much stuff happen at the type level as possible. The ability\n  to
  write your own type classes or type families over Servant API types is, I feel,\n
  \ part of what makes Servant so amazing. I want to replicate that success here.\n
  \ So, for instance, if someone somewhere defines a schema type that looks like\n
  \ this:\n\n  ```haskell\n  type MySchema =\n    Field \"id\" Int\n    :> Field \"name\"
  Text\n    :> Field \"address\" (Maybe Text)\n  ```\n\n  Then you would be free to
  deconstruct this type (using type families),\n  transform it into another schema,
  generate customized `CREATE TABLE`\n  statements if the (forthcoming) ones provided
  aren't good enough for your\n  back-end or use case... that sort of thing. As a
  somewhat contrived example,\n  maybe, for who knows what reason, you never want
  to allow null values in your\n  database. You can write a type family that can inspect
  every field in an\n  arbitrary schema, replacing all the `Maybe a` with just `a`,
  like:\n\n  ```haskell\n  -- With -XPolyKinds\n  type family NoNulls schema where\n
  \   NoNulls (Field name (Maybe typ)) = Field name typ\n    NoNulls (a :> b) = NoNulls
  a :> NoNulls b\n    NoNulls a = a\n\n  NoNulls MySchema \n  -- Same as:\n  --   Field
  \"id\" Int\n  --   :> Field \"name\" Text\n  --   :> Field \"address\" Text <---
  note the lack of Maybe\n  ```\n\n\n## The name: Ribbit\n\nThe name means nothing
  except I kindof like the sound of it. There are so many\n\"sql\", \"relational\",
  \"query\", etc. package names already that I didn't want to:\n\n1) get lost in the
  mix.\n2) step on anyone's toes by choosing too similar a name.\n3) create confusion
  by seeming to be associated with some other package with\n   which I am not.\n\n"
license-name: MIT
