homepage: https://github.com/srid/rib#readme
changelog-type: markdown
hash: a217f02f5e1307c6afd8382f6158838da0d2f1ec574aace8252074de8c8f9fc1
test-bench-deps: {}
maintainer: srid@srid.ca
synopsis: Static site generator using Shake
changelog: "# Change Log for rib\n\n## 0.7.0.0\n\n- Dependency upgrades\n  - mmark:
  0.0.7.2\n  - megaparsec: 0.8\n  - clay: 0.14\n  - shake: 0.8.15\n- New features:\n
  \ - Added Dhall parser, `Rib.Parser.Dhall`\n  - Add `Rib.Extra` containing useful
  but non-essential features\n- MMark, extensions removed:\n  - `ghcSyntaxHighlighter`:
  we already have `skylighting` (which supports more parsers than Haskell)\n  - `obfuscateEmail`:
  requires JS, which is not documented.\n- API changes:\n  - Introduced `Route` functionality
  for simpler management of static routes.\n    - Removed `buildHtmlMulti`, `buildHtml`,
  `readSource` functions and `Source` type.\n  - Introduced `Rib.Shake.forEvery` to
  run a Shake action over a pattern of files when they change.\n  - Exposed `Rib.Shake.writeFileCached`\n
  \ - `MMark.parse` and `Pandoc.parse` now automatically append path to `ribInputDir`
  and do not return Either.\n  - Added `MMark.parseWith` (and `parsePureWith`), to
  specify a custom list of mmark extensions\n- Bug fixes\n  - #95: Fix Shake error
  `resource busy (file is locked)`\n  - #97: Fix Shake error `AsyncCancelled` when
  server thread crashes\n  - #96 & #108: Drop problematic use of Shake `cacheActionWith`\n\n##
  0.6.0.0\n\n- Advance nixpkgs; require Shake >=0.18.4\n- Major API simplication:
  no more type class!\n  - Allow user to specify their own source parser as a Haskell
  function\n  - Removed types `Document` and `Markup` in favour of `Source`\n  - Expose
  `ribInputDir` and `ribOutputDir` for use in custom Shake actions\n- Bug fixes:\n
  \ - #63: create intermediate directories when generating post HTML\n  - #70: Don't
  crash on Shake errors\n  - Fix unnecessary rebuild of all files when only one file
  changed\n    - #66: Use caching (via Shake's `cacheActionWith`), to avoid writing
  HTML to disk until it has changed.\n\n## 0.5.0.0\n\nThis release comes with a major
  API refactor. Key changes:\n\n- Added MMark support, as an alternative to Pandoc\n-
  Allows using arbitrary records to load metadata\n  - This replaces the previous
  complex metadata API\n- Added `Document` type that uses the custom metadata record\n-
  Add top-level `Rib` import namespace for ease of use\n- Remove the following:\n
  \ - JSON cache\n  - `Rib.Simple`\n- Support for Table of Contents via MMark\n\nOther
  changes:\n\n- Use type-safe path types using the [path](http://hackage.haskell.org/package/path)
  library.\n- Fix #40: Gracefully handle rendering/ parsing errors, without dying.\n-
  Misc error reporting improvements\n\n## 0.4.1.0\n\n- `Rib.Pandoc`: \n  - Export
  `render'` and `renderInlines'` (the non-Lucid versions)\n  - Re-export `Text.Pandoc.Readers`
  so the library user does not have to directly depend on `pandoc` only to render
  its documents.\n- `Rib.App`: The `run` funtion now takes two more arguments, specifying
  the input and output directory, which are no longer hardcoded.\n- `Rib.Simple`:
  add LaTeX to default list of readers\n- `Rib.Server`: Remove \".html\" detection
  magic from URLs\n\n## 0.3.0.0\n\n- Rename `Rib.App.Watch` to `Rib.App.WatchAndGenerate`\n\n##
  0.2.0.0\n\n- Initial release.\n"
basic-deps:
  warp: -any
  modern-uri: -any
  shake: ! '>=0.18.5'
  mmark-ext: -any
  exceptions: -any
  lucid: ! '>=2.9.11 && <2.10'
  clay: ! '>=0.14 && <0.15'
  wai: ! '>=3.2.2 && <3.3'
  path: ! '>=0.7.0'
  dhall: -any
  text: ! '>=1.2.3 && <1.3'
  mmark: ! '>=0.0.7.2'
  safe-exceptions: -any
  megaparsec: ! '>=8.0'
  async: -any
  pandoc-include-code: ! '>=1.4.0 && <1.5'
  base-noprelude: ! '>=4.7 && <5'
  pandoc-types: ! '>=1.17.5 && <1.18'
  containers: ! '>=0.6.0 && <0.7'
  pandoc: ! '>=2.7 && <3'
  binary: ! '>=0.8.6 && <0.9'
  relude: ! '>=0.6 && <0.7'
  mtl: ! '>=2.2.2 && <2.3'
  foldl: -any
  cmdargs: ! '>=0.10.20 && <0.11'
  fsnotify: ! '>=0.3.0 && <0.4'
  wai-app-static: ! '>=3.1.6 && <3.2'
  aeson: ! '>=1.4.2 && <1.5'
  path-io: ! '>=1.6.0'
  directory: ! '>=1.0 && <2.0'
all-versions:
- 0.2.0.0
- 0.3.0.0
- 0.4.1.0
- 0.5.0.0
- 0.6.0.0
- 0.7.0.0
author: Sridhar Ratnakumar
latest: 0.7.0.0
description-type: markdown
description: "![Logo](https://raw.githubusercontent.com/srid/rib/master/assets/rib.png)\n\n#
  rib\n\n[![BSD3](https://img.shields.io/badge/License-BSD-blue.svg)](https://en.wikipedia.org/wiki/BSD_License)\n[![Hackage](https://img.shields.io/hackage/v/rib.svg)](https://hackage.haskell.org/package/rib)\n[![built
  with nix](https://builtwithnix.org/badge.svg)](https://builtwithnix.org)\n[![Zulip
  chat](https://img.shields.io/badge/zulip-join_chat-brightgreen.svg)](https://funprog.zulipchat.com/#narrow/stream/218047-Rib)\n\nRib
  is a Haskell **static site generator** that aims to reuse existing libraries instead
  of reinventing the wheel.\n\nHow does it compare to Hakyll?\n\n- Uses the [Shake](https://shakebuild.com/)
  build system at its core.\n- Allows writing Haskell DSL to define HTML ([Lucid](https://chrisdone.com/posts/lucid2/))
  & CSS ([Clay](http://fvisser.nl/clay/))\n- Built-in support for [Pandoc](https://pandoc.org/)
  and [MMark](https://github.com/mmark-md/mmark), while also supporting custom parsers
  (eg: [Dhall](https://github.com/srid/website/pull/6), [TOML](https://github.com/srid/website/pull/7))\n-
  Remain as simple as possible to use (see example below)\n- Nix-based environment
  for reproducibility\n- `ghcid` and fsnotify for \"hot reload\"\n\nRib prioritizes
  the use of *existing* tools over reinventing them, and enables\nthe user to compose
  them as they wish instead of having to write code to fit a\ncustom framework.\n\n**Table
  of Contents**\n\n- [rib](#rib)\n    - [Quick Preview](#quick-preview)\n    - [Getting
  Started](#getting-started)\n    - [Concepts](#concepts)\n        - [Directory structure](#directory-structure)\n
  \       - [Run the site](#run-the-site)\n        - [How Rib works](#how-rib-works)\n
  \       - [Editing workflow](#editing-workflow)\n        - [What's next?](#whats-next)\n
  \   - [Examples](#examples)\n\n## Quick Preview\n\nHere is how your code may look
  like if you were to generate your static site\nusing Rib:\n\n```haskell\n-- | Route
  corresponding to each generated static page.\n--\n-- The `a` parameter specifies
  the data (typically Markdown document) used to\n-- generated the final page text.\ndata
  Route a where\n  Route_Index :: Route ()\n  Route_Article :: ArticleRoute a -> Route
  a\n\n-- | You may even have sub routes.\ndata ArticleRoute a where\n  ArticleRoute_Index
  :: ArticleRoute [(Route MMark, MMark)]\n  ArticleRoute_Article :: Path Rel File
  -> ArticleRoute MMark\n\n-- | The `IsRoute` instance allows us to determine the
  target .html path for\n-- each route. This affects what `routeUrl` will return.\ninstance
  IsRoute Route where\n  routeFile = \\case\n    Route_Index ->\n      pure [relfile|index.html|]\n
  \   Route_Article r ->\n      fmap ([reldir|article|] </>) $ case r of\n        ArticleRoute_Article
  srcPath ->\n          replaceExtension \".html\" srcPath\n        ArticleRoute_Index
  ->\n          pure [relfile|index.html|]\n\n-- | The \"Config\" type generated from
  the Dhall type.\n--\n-- Use `Rib.Parser.Dhall` to parse it (see below).\nmakeHaskellTypes\n
  \ [ SingleConstructor \"Config\" \"Config\" \"./src-dhall/Config.dhall\"\n  ]\n\n--
  | Main entry point to our generator.\n--\n-- `Rib.run` handles CLI arguments, and
  takes three parameters here.\n--\n-- 1. Directory `content`, from which static files
  will be read.\n-- 2. Directory `dest`, under which target files will be generated.\n--
  3. Shake action to run.\n--\n-- In the shake action you would expect to use the
  utility functions\n-- provided by Rib to do the actual generation of your static
  site.\nmain :: IO ()\nmain = Rib.run [reldir|content|] [reldir|dest|] generateSite\n\n--
  | Shake action for generating the static site\ngenerateSite :: Action ()\ngenerateSite
  = do\n  -- Copy over the static files\n  Rib.buildStaticFiles [[relfile|static/**|]]\n
  \ -- Read the site config\n  config :: Config <-\n    Dhall.parse\n      [[relfile|src-dhall/Config.dhall|]]\n
  \     [relfile|config.dhall|]\n  let writeHtmlRoute :: Route a -> a -> Action ()\n
  \     writeHtmlRoute r = writeRoute r . Lucid.renderText . renderPage config r\n
  \ -- Build individual sources, generating .html for each.\n  articles <-\n    Rib.forEvery
  [[relfile|*.md|]] $ \\srcPath -> do\n      let r = Route_Article $ ArticleRoute_Article
  srcPath\n      doc <- MMark.parse srcPath\n      writeHtmlRoute r doc\n      pure
  (r, doc)\n  writeHtmlRoute (Route_Article ArticleRoute_Index) articles\n  writeHtmlRoute
  Route_Index ()\n\n-- | Define your site HTML here\nrenderPage :: Config -> Route
  a -> a -> Html ()\nrenderPage config route val = with html_ [lang_ \"en\"] $ do\n
  \ head_ $ do\n    meta_ [httpEquiv_ \"Content-Type\", content_ \"text/html; charset=utf-8\"]\n
  \   title_ $ routeTitle\n    style_ [type_ \"text/css\"] $ C.render pageStyle\n
  \ body_ $ do\n    with div_ [id_ \"thesite\"] $ do\n      with div_ [class_ \"header\"]
  $\n        with a_ [href_ \"/\"] \"Back to Home\"\n      h1_ routeTitle\n      case
  route of\n        Route_Index ->\n          p_ $ do\n            \"This site is
  work in progress. Meanwhile visit the \"\n            with a_ [href_ $ routeUrl
  $ Route_Article ArticleRoute_Index] \"articles\"\n            \" page.\"\n        Route_Article
  ArticleRoute_Index ->\n          div_ $ forM_ val $ \\(r, src) ->\n            with
  li_ [class_ \"pages\"] $ do\n              let meta = getMeta src\n              b_
  $ with a_ [href_ (Rib.routeUrl r)] $ toHtml $ title meta\n              maybe mempty
  renderMarkdown $ description meta\n        Route_Article (ArticleRoute_Article _)
  ->\n          with article_ [class_ \"post\"] $ do\n            MMark.render val\n
  \ where\n    routeTitle :: Html ()\n    routeTitle = case route of\n      Route_Index
  -> toHtml $ siteTitle config\n      Route_Article (ArticleRoute_Article _) -> toHtml
  $ title $ getMeta val\n      Route_Article ArticleRoute_Index -> \"Articles\"\n
  \   renderMarkdown =\n      MMark.render . either (error . T.unpack) id . MMark.parsePure
  \"<none>\"\n\n-- | Define your site CSS here\npageStyle :: Css\npageStyle = \"div#thesite\"
  ? do\n  C.margin (em 4) (pc 20) (em 1) (pc 20)\n  \".header\" ? do\n    C.marginBottom
  $ em 2\n  \"li.pages\" ? do\n    C.listStyleType C.none\n    C.marginTop $ em 1\n
  \   \"b\" ? C.fontSize (em 1.2)\n    \"p\" ? sym C.margin (px 0)\n\n-- | Metadata
  in our markdown sources\ndata SrcMeta\n  = SrcMeta\n      { title :: Text,\n        --
  | Description is optional, hence `Maybe`\n        description :: Maybe Text\n      }\n
  \ deriving (Show, Eq, Generic, FromJSON)\n\n-- | Get metadata from Markdown's YAML
  block\ngetMeta :: MMark -> SrcMeta\ngetMeta src = case MMark.projectYaml src of\n
  \ Nothing -> error \"No YAML metadata\"\n  Just val -> case fromJSON val of\n    Aeson.Error
  e -> error $ \"JSON error: \" <> e\n    Aeson.Success v -> v\n```\n\n(View full
  [`Main.hs`](https://github.com/srid/rib-sample/blob/master/src/Main.hs) at rib-sample)\n\n##
  Getting Started\n\nThe easiest way to get started with [Rib](/) is to [use the\ntemplate](https://help.github.com/en/articles/creating-a-repository-from-a-template)\nrepository,
  [**rib-sample**](https://github.com/srid/rib-sample), from Github.\n\n## Concepts\n\n###
  Directory structure\n\nLet's look at what's in the template repository:\n\n```shell\n$
  git clone https://github.com/srid/rib-sample.git mysite\n...\n$ cd mysite\n$ ls
  -F\na/  default.nix  Main.hs  README.md  rib-sample.cabal\n```\n\nThe three key
  items here are:\n\n1. `Main.hs`: Haskell source containing the DSL of the HTML/CSS
  of your site.\n1. `a/`: The source content (eg: Markdown sources and static files)\n1.
  `b/`: The target directory, excluded from the git repository, will contain\n   _generated_
  content (i.e., the HTML files, and copied over static content)\n   \nThe template
  repository comes with a few sample posts under `a/`, and a basic\nHTML layout and
  CSS style defined in `Main.hs`. \n\n### Run the site\n\nNow let's run them all.
  \n\nClone the sample repository locally, install [Nix](https://nixos.org/nix/) and\nrun
  your site as follows:\n\n```shell\nnix-shell --run 'ghcid -T main'\n```\n\n(Note
  even though the author recommends it Nix is strictly not required; you may\nsimply
  run `ghcid -T main` instead of the above command if you do not wish to\nuse Nix.)\n\nRunning
  this command gives you a local HTTP server at http://localhost:8080/\n(serving the
  generated files) that automatically reloads when either the content\n(`a/`) or the
  HTML/CSS/build-actions (`Main.hs`) changes. Hot reload, in other\nwords.\n\n###
  How Rib works\n\nHow does the aforementioned nix-shell command work?\n\n1. `nix-shell`
  will run the given command in a shell environment with all of our\ndependencies
  (notably the Haskell ones including the `rib` library itself)\ninstalled. \n\n1.
  [`ghcid`](https://github.com/ndmitchell/ghcid) will compile your `Main.hs`\n   and
  run its `main` function.\n\n1. `Main.hs:main` in turn calls `Rib.App.run` which
  takes as argument your custom Shake action that will build the static site.\n\n1.
  `Rib.App.run`: this parses the CLI arguments and runs the rib CLI \"app\" which\n
  \  can be run in one of a few modes --- generating static files, watching the\n
  \  `a/` directory for changes, starting HTTP server for the `b/` directory. By\n
  \  default---without any explicit arguments---this will run the Shake build\n   action
  passed as argument on every file change and spin up a HTTP server.\n   \nRun that
  command, and visit http://localhost:8080 to view your site.\n\n### Editing workflow\n\nNow
  try making some changes to the content, say `a/first-post.md`. You should\nsee it
  reflected when you refresh the page. Or change the HTML or CSS of your\nsite in
  `Main.hs`; this will trigger `ghcid` to rebuild the Haskell source and\nrestart
  the server.\n\n### What's next?\n\nGreat, by now you should have your static site
  generator ready and running! What\nmore can you do? Surely you may have specific
  needs; and this usually translates\nto running custom Shake actions during the build.
  Rib provides helper functions in `Rib.Shake` to make this easier. \n\nRib recommends
  writing your Shake actions in the style of being \n[forward-defined](http://hackage.haskell.org/package/shake-0.18.3/docs/Development-Shake-Forward.html)\nwhich
  adds to the simplicity of the entire thing.\n\n## Examples\n\n* [rib-sample](https://github.com/srid/rib-sample):
  Use this to get started with\n  your own site.\n\n* Author's own website. Live at
  https://www.srid.ca/ \n"
license-name: BSD-3-Clause
