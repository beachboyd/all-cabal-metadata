homepage: http://www2.tcs.ifi.lmu.de/~abel/
changelog-type: ''
hash: 3a63e2df69b6c4c5ec6ccd6326f3ef4c4a2fcdef08343cb008608add06ed6142
test-bench-deps: {}
maintainer: Andreas Abel <andreas.abel@ifi.lmu.de>
synopsis: Reduced instruction set i386 simulator
changelog: ''
basic-deps:
  base: ! '>=4.2 && <4.7'
  array: ! '>=0.3 && <0.5'
  containers: ! '>=0.3 && <0.6'
  mtl: ! '>=2.0 && <2.1 || >=2.1.1 && <2.2'
  pretty: ! '>=1.0 && <1.2'
all-versions:
- 0.0.20130624
- 0.0.20130701
- 0.0.20130718
- 0.0.20130719
author: Andreas Abel with contributions by Robert Grabowski and Ulrich Schoepp
latest: 0.0.20130719
description-type: text
description: ! "risc386 -- Restricted Instruction Set i386 simulator\n(C) 2013, Andreas
  Abel, Ludwig-Maximilians-University Munich\n\nThe main purpose of this simulator
  is to test i386 code generated by a\ncompiler before register allocation.  Therefore,
  it supports\ntemporaries, an potentially infinite amount of extra registers\nt<number>.
  \ (Of course, it can also be used to execute symbolic\nassembler after register
  allocation.)\n\nThe supported instruction set is very restricted but sufficient
  to\nwrite a compiler for MiniJava [Andrew Appel, Modern Compiler\nImplementation
  in Java].\n\nI. System requirements:\n------------------------------------------------------------------------\n\n
  \ You need a recent version of the Haskell Platform.\n\nII. Installation:\n------------------------------------------------------------------------\n\n
  \ 1. Change to a temporary directory.\n  2. Unpack the tar ball\n\n     tar xzf
  risc386-x.y.z.tar.gz\n\n  3. Change to the unpacked directory\n\n     cd risc386-x.y.z\n\n
  \ 4. Install using Haskell's packet manager cabal\n\n     cabal install\n\nIII.
  Running the simulator:\n------------------------------------------------------------------------\n\n
  \ risc386 input-file.s\n\nIV. Format of the input file:\n------------------------------------------------------------------------\n\n
  \ The input file must be symbolic assembler in Intel format.\n\n  Here is a small
  example:\n\n        .intel_syntax\n        .global Lmain\n        .type Lmain, @function\nLmain:\n
  \       #args\n        enter   0, 0\nL0:     push    8\n        call    L_halloc\n
  \       add     %esp, 4\n        mov     t1001, %eax\n        push    t1001\n        call
  \   LC$value\n        add     %esp, 4\n        mov     t1002, %eax\n        push
  \   t1002\n        call    L_println_int\n        add     %esp, 4\nL1:     leave\n
  \       ret\n\n        .global LC$value\n        .type LC$value, @function\nLC$value:\n
  \       #args LOC 0\n        enter   0, 0\nL2:     mov     t1004, DWORD PTR [%ebp+8]\n
  \       mov     DWORD PTR [t1004+4], 555\n        mov     t1003, DWORD PTR [%ebp+8]\n
  \       mov     %eax, DWORD PTR [t1003+4]\nL3:     leave\n        ret\n\n\n  Lexing
  rules:\n  (If you want to be sure, read the .x file, the lexer specification.)\n\n
  \   * White space is ignored (except as separator for alphanumeric tokens).\n\n
  \   * Lines beginning with a dot '.' are skipped.\n      These lines are pragmas
  for the symbolic assembler,\n      which risc386 ignores.\n\n    * Lines beginning
  with a hash-symbol followed by a space '# '\n      are comments, which are ignored
  as well.\n\n    * Lines beginning with a hash followed by a non-space character\n
  \     are risc386 pragmas and not ignored.\n\n      Currently, risc386 only recognizes
  the pragma '#args'.\n\n    * Valid tokens are:\n\n        #args LOC REG\n\n        [
  ] : , . + - *\n        dword ptr                    DWORD PTR\n\n        mov lea
  \                     MOV LEA\n        add sub imul                 ADD SUB IMUL\n
  \       idiv inc dec neg             IDIV INC DEC NEG\n        shl shr sal sar              SHL
  SHR SAL SAR\n        and or xor                   AND OR XOR\n        not                          NOT\n
  \       cmp                          CMP\n        je jne jl jle jge            JE
  JNE JL JLE JGE\n        jmp call ret                 JMP CALL RET\n        push
  pop enter leave         PUSH POP ENTER LEAVE\n        nop                          NOP\n\n
  \       eax ebx ecx edx esi edi ebp esp\n        %eax %ebx %ecx %edx %esi %edi %ebp
  %esp\n\n        <number>    (given by reg.ex [0-9]+)\n        t<number>   (denoting
  a temporary register)\n\n        <ident>     (given by reg.ex. [a-zA-Z][a-zA-Z0-9_'$]*)\n\n
  \     Identifiers are used for labels.\n\n\n  Parsing rules:\n  (If you want to
  know all of them, read the .y file)\n\n    1. The input file must be a sequence
  of procedures.\n\n       There must be one procedure whose name ends in 'main'.\n
  \      This one is taken as the entry point.\n\n    2. Each procedure starts with
  a label and ends with a return\n       instruction. Optionally, it can be preceded
  by a declaration\n       of its arguments\n\n                  #args REG %eax, LOC
  0, LOC 4\n         Lmyproc:\n                  ...\n                  RET\n\n       Lmyproc
  expects its first argument in register %eax,\n       its second at [%esp+0] and
  its third at [%esp+4].\n       The stack addresses are to be taken *before* the
  CALL\n       is executed (which will put the return address on the stack\n       and
  shift the relative location of the arguments by +4).\n\n    3. The body of each
  procedure is a list of i386 assembler\n       instructions in Intel syntax.  The
  supported instructions\n       are listed above.\n\n       Each instruction my be
  preceded by a label.\n\n       Conditional and unconditional jumps are only allowed
  to\n       a label, and only to one defined in the same procedure.\n       Cross-procedure
  jumps or jumps to a calculated address\n       are not supported.\n\n       CALLs
  are only defined to a procedure label.\n       risc386 assumes the cdecl calling
  convention.\n\n    4. Restrictions for individual instructions:\n\n       RET    does
  accept arguments\n       ENTER  is only supported in the form ENTER <number>, 0\n\n\n
  \ Runtime:\n\n    risc386 knows a number of predefined procedures.  They expect\n
  \   their arguments on the stack (cdecl calling convention) and\n    return the
  result in %eax.\n\n    L_halloc\n      1 Argument: number of bytes to allocate on
  the heap\n      Result    : pointer to first allocated byte.\n\n    L_println_int\n
  \     1 Argument: signed 32bit integer value to print\n      Result    : nothing\n\n
  \   L_print_char\n      1 Argument: unicode char (32bit) to print\n      Result
  \   : nothing\n\n    L_raise\n      1 Argument: error code\n      Result    : nothing,
  does not return, stops execution\n\n\n  Execution specialties:\n\n    risc386 supports
  4 different types, all of size 32 bits:\n\n      1. Signed integers.\n\n      2.
  Heap addresses.\n\n         Heap addresses consist of a base address which was obtained\n
  \        by L_halloc plus an offset.  The offset must be a multiple of 4.\n\n      3.
  Stack addresses.\n\n         %esp and %ebp may only be loaded with stack addresses.\n\n
  \     4. Return addresses.\n\n         Get pushed onto the stack by a CALL.\n\n
  \        RET checks that a return address lies on top of the stack\n         before
  returning.  The content of the return address is\n         ignored, RET jumps back
  to the procedure where the matching\n         CALL was issued.\n\n    CMP is the
  only command that sets flags.\n\n    CALL saves all temporary registers, RET restores
  them.\n\n\n\n\n\n\n"
license-name: BSD-3-Clause
