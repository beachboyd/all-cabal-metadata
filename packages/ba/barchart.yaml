homepage: http://sebfisch.github.com/haskell-barchart
changelog-type: ''
hash: 84c763d07af43a43f8c784d721365afb2d64db47857dad675c7c8d97cefdcfff
test-bench-deps: {}
maintainer: Sebastian Fischer
synopsis: Creating Bar Charts in Haskell
changelog: ''
basic-deps:
  base: ! '>=3 && <5'
  filepath: ! '>=1.1 && <1.3'
  csv: ! '>=0.1 && <1.2'
  cmdargs: ! '>=0.4 && <0.7'
  diagrams: ==0.2.*
all-versions:
- '0.1'
- 0.1.1
- 0.1.1.1
author: Sebastian Fischer
latest: 0.1.1.1
description-type: markdown
description: ! "barchart is a command-line program with associated Haskell library
  for\ngenerating bar charts from CSV files. It has special support for\ncreating
  charts from data generated by the Haskell benchmarking tools\n[criterion] and [progression].
  barchart can create PNG, SVG, PDF, and\nPS files using the Haskell [Diagrams] library
  for rendering and,\nhence, depends on a Haskell binding to Cairo which is part of\n[Gtk2Hs].\n\n#
  installation\n\nYou can install barchart from [Hackage] using `cabal-install` which
  is\npart of the [Haskell Platform] by typing:\n\n    cabal install barchart\n\n#
  usage\n\nBar charts can be created from CSV files using the `barchart`\ncommand-line
  utility. For example, if you want to track how many hours\nyou practice playing
  the guitar on each day of the week, you can\ncreate a file `guitar.csv` with the
  following contents:\n\n    Mon,1.2\n    Tue,0.3\n    Wed,2.1\n    Thu,0.9\n    Fri,1.1\n
  \   Sat,3.2\n    Sun,3.1\n\nThe call\n\n    # barchart --title=\"Practice hours\"
  guitar.csv \n\ncreates a file `guitar.png` which looks like this:\n\n![Practice
  hours][guitar]\n\nEach bar is labeled with a weekday and has an associated practice\nhour.
  The chart is scaled automatically such that the largest bar\nspans the (configurable,
  see below) height of the chart. The `--title`\nflag passed to `barchart` in the
  above call is optional. If you do not\nsupply one, then barchart uses the basename
  of the CSV file as title\nof the chart.\n\nIf you want to track practice hours over
  multiple weeks, you can\ncreate a file with a _mean_, _minimal_, and _maximal_ values
  for each\nday of the week:\n\n    Mon,1.2,0.9,1.7\n    Tue,0.3,0.1,0.5\n    Wed,2.1,1.5,2.5\n
  \   Thu,0.9,0.4,1.0\n    Fri,1.1,1.0,1.2\n    Sat,3.2,1.5,5.2\n    Sun,3.1,2.3,4.2\n\nCalling
  `barchart` in the `interval` mode\n\n    # barchart intervals --title=\"Mean practice
  hours\" guitar-mean.csv\n\nproduces the following bar chart:\n\n![Mean practice
  hours][guitar-mean]\n\nIn this chart, each bar represents the mean practice hour
  for a day\nof the week and the minimum and maximum values are depicted with\nintervals
  on the right edge of a bar.\n\nIf you want to compare your practice hours for each
  day of the week\nand split it by months, you can create a CSV file like this:\n\n
  \   Mon,1.2,2.1,1.7\n    Tue,0.6,0.7,0.8\n    Wed,2.1,1.2,2.5\n    Thu,0.9,1.5,1.7\n
  \   Fri,1.1,1.3,0.7\n    Sat,3.2,1.7,4.3\n    Sun,3.1,3.2,2.1\n\nWe can use `barchart`
  (in the default mode) \n\n    # barchart --title=\"Practice hours per month\" --division=\"Jan
  Feb Mar\" guitar-months.csv\n\nto create the following diagram:\n\n![Practice hours
  by month][guitar-months]\n\nEach bar is divided into different blocks which all
  have an associated\namount of practice hours. Green blocks represent practice hours
  in\nJanuary, red blocks in February, and blue blocks represent practice\nhours in
  March. The block labels are given to `barchart` via the\n`--division` flag. You
  can also draw multiple blocks per bar in\n`interval` mode but then three values
  (_mean_,_min_,_max_) are used\nfor each block. Hence, if you want to depict mean
  practice times with\ndeviations for January, February, and March, you must create
  a CSV\nfile where each day of the week is followed by nine practice times.\n\n##
  flags\n\nThe `barchart` program can be configured using command-line flags. We\ncan
  use the `--help` flag to print a summary:\n\n    # barchart --help\n    Bar Chart
  0.1\n    \n    barchart [blocks] [FLAG] [FILE]\n    \n    barchart intervals [FLAG]
  [FILE]\n    \n    barchart criterion [FLAG] [FILE]\n    \n         --summary               Show
  benchmark summary (default)\n      -s --summary-comparison    Compare different
  benchmark summaries\n      -b --benchmark-comparison  Compare different benchmarks\n
  \   \n    barchart progression [FLAG] [FILE]\n    \n      -s --summary-comparison
  \   Breakdown chart by benchmark summary (default)\n      -b --benchmark-comparison
  \ Breakdown chart by benchmarks\n    \n    Common flags:\n      -? --help[=FORMAT]
  \        Show usage information (optional format)\n      -V --version               Show
  version information\n      -v --verbose               Higher verbosity\n      -q
  --quiet                 Lower verbosity\n      -o --out-file=FILE         Name of
  generated file\n      -t --title=STRING          Title of bar chart\n      -x --xlabel=STRING
  \        Label of x axis\n      -y --ylabel=STRING         Label of y axis\n      -g
  --guess-file-type       Guess output file type by name (default)\n         --png
  \                  Generate .png file\n         --svg                   Generate
  .svg file\n         --pdf                   Generate .pdf file\n         --ps                    Generate
  .ps file\n      -d --division=STRINGS      Labels separated by whitespace\n      -c
  --colors=STRINGS        Color names separated by whitespace\n      -w --width=NUM
  \            Width of generated bar chart (default=600)\n      -h --height=NUM            Height
  of generated bar chart (default=300)\n      -l --label-size=NUM        Font size
  used for labels (default=12)\n      -W --bar-width=FLOAT       Bar width between
  0 and 1 (default=0.3)\n\n`barchart` can be run in different modes. We have already
  seen the\ndefault (`blocks`) mode and the `intervals` mode. The `criterion` and\n`progression`
  modes are described below. Most command-line flags are\nself explanatory. Apart
  from what we have seen in the example above,\nthe following options are particularly
  interesting:\n\n  * `--xlabel` and `--ylabel` label the axis of the coordinate system.\n\n
  \ * `--colors` change the colors of the different blocks of a bar. You\n    can
  use all color names listed in the [SVG 1.1\n    Specification][Colors]. If you specify
  fewer colors than there are\n    blocks, then colors are reused in a cyclic fashion.
  The default\n    value for this argument is `--colors=\"seagreen firebrick\n    midnightblue\"`.\n\n
  \ * `--width` and `--height` specify the dimensions of the generated\n    _chart_.
  The generated _picture_ is a little larger because of the\n    title and bar labels.
  If you want to draw a chart with many bars,\n    you should increase the width compared
  to the height or tweak the\n    bar width.\n\n  * `--bar-width` is a value between
  0.0 and 1.0 hat specifies how\n    thick the bars are compared to the bar distance.
  With a value of\n    `1.0` the bars are drawn directly next to each other, a value
  of\n    0.0 draws bars that are actually lines.\n\n## api\n\nIf the `barchart` command-line
  program is insufficient for your needs,\nyou can use the provided [API] in your
  own Haskell applications to\ngenerate custom bar charts.\n\n## criterion\n\n[criterion]
  is a Haskell tool for statistically robust benchmarking\nthat can generate graphs
  which, for example, depict the densities of\nexecution times. criterion can also
  generate a CSV file summarising\nall benchmarks but does not provide means to visualise
  these\nsummaries.\n\nWe can use `barchart` in `criterion` mode to draw graphs based
  on the\nsummary files generated by criterion. To demonstrate the criterion\nmode,
  we write a small Haskell program that benchmarks a simple\ndefinition of the [factorial]
  function:\n\n    import Criterion.Main\n    \n    main = defaultMain [bgroup \"fac\"
  [bench (show n) (nf product [1..n]) | n <- ns]]\n     where ns = [k*10^4 | k <-
  [1,2,3]] :: [Integer]\n\nWe can compile this program, generate a benchmark summary
  using\ncriterion, and visualise it using barchart as follows:\n\n    # ghc -O2 --make
  factorial\n    # ./factorial --summary=factorial.csv\n    # barchart criterion factorial.csv\n\nThese
  three calls generate a bar chart with one bar for each benchmark\nwhose size is
  proportional to the corresponding run time.\n\n![fac]\n\nWe can now modify the program
  to use an explicitly recursive\ndefinition of the fibonacci function to see whether
  this affects the\nrun times.\n\n    fac 0 = 1\n    fac n = n * fac (n-1)\n\nAfter
  generating another summary file `factorial2.csv` we could\ngenerate another bar
  chart to visualise it and view both charts side\nby side to compare the run times
  of the different implementations of\nthe fibonacci function. However, instead of
  generating two different\ncharts we can also generate a single chart that combines
  information\nfrom multiple benchmark summaries.\n\n    # barchart criterion --summary-comparison
  factorial.csv factorial2.csv\n\nWe can pass as many summary files as we like and
  barchart will draw a\nbar for each summary file with blocks representing the different\nbenchmarks.\n\n![fac-summaries]\n\nWe
  can see clearly that the original implementation using `product` is\nfaster than
  the explicitly recursive definition of the factorial\nfunction. Instead of drawing
  different bars for different summaries,\nbarchart can also draw different bars for
  the different benchmarks\nwith blocks for the summaries.\n\n![fac-benchmarks]\n\nThis
  is less useful for comparing different implementations but useful\nto compare the
  different benchmarks using all implementations at once.\n\n## progression\n\n[progression]
  is an alternative tool to depict criterion's benchmark\nresults. It generates charts
  similar to the summary comparisons\ndiscussed above but draws bars for different
  benchmarks next to each\nother rather than as boxes on top of each other in a single\nbar.
  Drawing the results of all benchmarks for a specific\nimplementation on top of each
  other lets you see immediately which\nimplementation is the fastest _in total_ because
  the total height of\nthe bar is the sum of all benchmarks for the corresponding\nimplementation.
  However, progression provides features that barchart\ndoes not provide such as normalising
  run times and show them as\npercentages. Hence, the barchart program has a `progression`
  mode to\ngenerate bar charts from CSV files generated by progression.\n\nWe can
  alter the factorial program as follows to generate\nprogression's data:\n\n    import
  Criterion\n    import Progression.Main\n    \n    main = defaultMain (bgroup \"fac\"
  [bench (show n) (nf fac n) | n <- ns])\n     where ns = [k*10^4 | k <- [1,2,3]]
  :: [Integer]\n    \n    fac 0 = 1\n    fac n = n * fac (n-1)\n\nWe do not need to
  change the fibonacci function itself because we\nwon't execute benchmarks using
  progression. We only generate a\ncomparison of the previous benchmarks:\n\n    #
  mv factorial.csv bench-factorial.csv\n    # mv factorial2.csv bench-factorial2.csv\n
  \   # ./factorial --mode=graph --compare=factorial,factorial2\n\nprogression wants
  the summary files to have specific names, hence, we\nrename them appropriately before
  generating a graph. The progression\ntool generates two files `plot.csv` and `plot.png`.
  Here, we are not\ninterested in the generated PNG file but pass the CSV file to
  the\nbarchart program in `progression` mode.\n\n    # barchart progression --division=\"product
  recursive\" plot.csv\n\nAs the CSV file generated by progression does not include
  information\nof the names of the summary files, we provide labels using the\n`--division`
  flag. The generated bar chart loooks like this:\n\n![progression-summaries]\n\nThe
  run times of the first implementation are normalised to 100 % and\nthe run times
  of the second implementation are depicted relative to\nthe first. Like in `criterion`
  mode we can also flip the axis in\n`progression` mode.\n\n    # barchart progression
  --benchmark-comparison --division=\"product recursive\" plot.csv\n\nNow the first
  benchmark is normalised to 100 % in each bar so this\ndiagram is of questionable
  use.\n\n![progression-benchmarks]\n\n# collaboration\n\nThe source code is on [GitHub]
  so you can create or vote on [issues]\nto ask for extensions or fork this project
  to write extensions\nyourself.\n\n## limitations\n\nCurrently, barchart does not
  support negative quantities and draws\nweird bars if you use them anyway. Also,
  the legend for blocks is\nsometimes drawn suboptimally. I guess I made a mistake
  but I cannot\nfind it.\n\n## thanks\n\nI would not have written this program without
  the [Diagrams] library\nby Brent Yorgey and the [CmdArgs] package by Neil Mitchell.\n\n#
  contact\n\nFor questions or feedback email [Sebastian Fischer][email].\n\n[email]:
  mailto:sebf@informatik.uni-kiel.de\n[GitHub]: http://github.com/sebfisch/haskell-barchart
  \n[issues]: http://github.com/sebfisch/haskell-barchart/issues\n\n[Hackage]: http://hackage.haskell.org/package/barchart\n[Haskell
  Platform]: http://hackage.haskell.org/platform/\n[API]: http://sebfisch.github.com/haskell-barchart/api/doc/html/barchart/index.html\n\n[guitar]:
  http://sebfisch.github.com/haskell-barchart/examples/guitar.png\n[guitar-mean]:
  http://sebfisch.github.com/haskell-barchart/examples/guitar-mean.png\n[guitar-months]:
  http://sebfisch.github.com/haskell-barchart/examples/guitar-months.png\n[fac]: http://sebfisch.github.com/haskell-barchart/examples/factorial.png\n[fac-summaries]:
  http://sebfisch.github.com/haskell-barchart/examples/fac-summaries.png\n[fac-benchmarks]:
  http://sebfisch.github.com/haskell-barchart/examples/fac-benchmarks.png\n[progression-summaries]:
  http://sebfisch.github.com/haskell-barchart/examples/progression-summaries.png\n[progression-benchmarks]:
  http://sebfisch.github.com/haskell-barchart/examples/progression-benchmarks.png\n\n[criterion]:
  http://hackage.haskell.org/package/criterion\n[progression]: http://hackage.haskell.org/package/progression\n[Diagrams]:
  http://code.haskell.org/diagrams/\n[CmdArgs]: http://community.haskell.org/~ndm/cmdargs/\n[Gtk2Hs]:
  http://www.haskell.org/gtk2hs/\n[Colors]: http://www.w3.org/TR/SVG11/types.html#ColorKeywords\n[factorial]:
  http://en.wikipedia.org/wiki/Factorial"
license-name: BSD-3-Clause
