homepage: https://github.com/ejconlon/blanks#readme
changelog-type: ''
hash: 365b8be25e16ab9528f86c59852f1c7b38867e19be664c4705be67738346b706
test-bench-deps:
  base: '>=4.12 && <5'
  text: -any
  adjunctions: '>=4.4 && <5'
  megaparsec: -any
  distributive: '>=0.6 && <1'
  containers: '>=0.6 && <1'
  mtl: '>=2.2 && <3'
  tasty-hunit: -any
  tasty: -any
  deepseq: '>=1.4 && <2'
  blanks: -any
maintainer: ejconlon@gmail.com
synopsis: Fill-in-the-blanks - A library factoring out substitution from ASTs
changelog: ''
basic-deps:
  base: '>=4.12 && <5'
  adjunctions: '>=4.4 && <5'
  distributive: '>=0.6 && <1'
  containers: '>=0.6 && <1'
  mtl: '>=2.2 && <3'
  deepseq: '>=1.4 && <2'
all-versions:
- 0.3.0
- 0.4.0
- 0.4.1
- 0.4.2
author: Eric Conlon
latest: 0.4.2
description-type: markdown
description: |
  # blanks

  [![CircleCI](https://circleci.com/gh/ejconlon/blanks/tree/master.svg?style=svg)](https://circleci.com/gh/ejconlon/blanks/tree/master)

  Fill-in-the-blanks - A library factoring out substitution from ASTs.

  It's a pain to track de Bruijn indices yourself to implement capture-avoiding subsititution,
  so this library provides some wrappers that help. One of the best libraries for this is
  [bound](https://hackage.haskell.org/package/bound), which uses a clever representation to make
  these operations safe and fast. The tradeoff is that you have to define a `Monad` instance
  for your expression functor, which in practice can be tricky. (It's even trickier to derive
  `Eq` and `Show`!)

  This library takes the simpler, slower, and rather "succ-y" free-monad-ish approach,
  but with a twist. It expects you to rewrite all name-binding constructors in your expression
  as annotations on a single "binder" constructor. This allows you to use the provided `Scope`
  type (or a variant) as a wrapper around your expression functor, which is only required to
  implement `Functor`. This representation is less safe (since you can inspect and manipulate
  bound variables), but if you stick to the provided combinators, things will work out fine.

  You'll get most of what you want by just importing this module unqualified.
  See the `Blanks` class definition and related methods to manipulate variables and abstractions.
  See `Scope` for the basic wrapper and `LocScope` for a wrapper with annotations you can use
  for source locations and the like. See the test suite for examples.
license-name: BSD-3-Clause
