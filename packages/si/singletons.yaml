homepage: http://www.github.com/goldfirere/singletons
changelog-type: markdown
hash: 558f88d376f30e8dabde9163a96d2ebcbe2fe533e08d20ab136eea91ad046da3
test-bench-deps:
  bytestring: ! '>=0.10.9'
  base: ! '>=4.14 && <4.15'
  tasty-golden: ! '>=2.2'
  text: ! '>=1.2'
  filepath: ! '>=1.3'
  process: ! '>=1.1'
  turtle: ! '>=1.5'
  singletons: -any
  tasty: ! '>=1.2'
  deepseq: ! '>=1.4.4'
maintainer: Ryan Scott <ryan.gl.scott@gmail.com>
synopsis: A framework for generating singleton types
changelog: |
  Changelog for singletons project
  ================================

  2.7
  ---
  * Require GHC 8.10.
  * Record selectors are now singled as top-level functions. For instance,
    `$(singletons [d| data T = MkT { unT :: Bool } |])` will now generate this:

    ```hs
    data ST :: T -> Type where
      SMkT :: Sing b -> Sing (MkT b)

    sUnT :: Sing (t :: T) -> Sing (UnT t :: Bool)
    sUnT (SMkT sb) = sb

    ...
    ```

    Instead of this:

    ```hs
    data ST :: T -> Type where
      SMkT :: { sUnT :: Sing b } -> Sing (MkT b)
    ```

    Note that the new type of `sUnT` is more general than the previous type
    (`Sing (MkT b) -> Sing b`).

    There are two primary reasons for this change:

    1. Singling record selectors as top-level functions is consistent with how
       promoting records works (note that `MkT` is also a top-level function). As
    2. Embedding record selectors directly into a singleton data constructor can
       result in surprising behavior. This can range from simple code using a
       record selector not typechecking to the inability to define multiple
       constructors that share the same record name.

    See [this GitHub issue](https://github.com/goldfirere/singletons/issues/364)
    for an extended discussion on the motivation behind this change.
  * The Template Haskell machinery now supports fine-grained configuration in
    the way of an `Options` data type, which lives in the new
    `Data.Singletons.TH.Options` module. Besides `Options`, this module also
    contains:
      * `Options`' record selectors. Currently, these include options to toggle
        generating quoted declarations, toggle generating `SingKind` instances,
        and configure how `singletons` generates the names of promoted or singled
        types. In the future, there may be additional options.
      * A `defaultOptions` value.
      * An `mtl`-like `OptionsMonad` class for monads that support carrying
        `Option`s. This includes `Q`, which uses `defaultOptions` if it is the
        top of the monad transformer stack.
      * An `OptionM` monad transformer that turns any `DsMonad` into an
        `OptionsMonad`.
      * A `withOptions` function which allows passing `Options` to TH functions
        (e.g., `promote` or `singletons`). See the `README` for a full example
        of how to use `withOptions`.
    Most TH functions are now polymorphic over `OptionsMonad` instead of
    `DsMonad`.
  * `singletons` now does a much better job of preserving the order of type
    variables in type signatures during promotion and singling. See the
    `Support for TypeApplications` section of the `README` for more details.

    When generating type-level declarations in particular (e.g., promoted type
    families or defunctionalization symbols), `singletons` will likely also
    generate standalone kind signatures to preserve type variable order. As a
    result, most `singletons` code that uses Template Haskell will require the
    use of the `StandaloneKindSignatures` extension (and, by extension, the
    `NoCUSKs` extension) to work.
  * `singletons` now does a more much thorough job of rejecting higher-rank types
    during promotion or singling, as `singletons` cannot support them.
    (Previously, `singletons` would sometimes accept them, often changing rank-2
    types to rank-1 types incorrectly in the process.)
  * Add the `Data.Singletons.Prelude.Proxy` module.
  * Remove the promoted versions of `genericTake`, `genericDrop`,
    `genericSplitAt`, `genericIndex`, and `genericReplicate` from
    `Data.Singletons.Prelude.List`. These definitions were subtly wrong since
    (1) they claim to work over any `Integral` type `i`, but in practice would
    only work on `Nat`s, and (2) wouldn't even typecheck if they were singled.
  * Export `ApplyTyConAux1`, `ApplyTyConAux2`, as well as the record pattern
    synonyms selector `applySing2`, `applySing3`, etc. from `Data.Singletons`.
    These were unintentionally left out in previous releases.
  * Export promoted and singled versions of the `getDown` record selector in
    `Data.Singletons.Prelude.Ord`.
  * Fix a slew of bugs related to fixity declarations:
    * Fixity declarations for data types are no longer singled, as fixity
      declarations do not serve any purpose for singled data type constructors,
      which always have exactly one argument.
    * `singletons` now promotes fixity declarations for class names.
      `genPromotions`/`genSingletons` now also handle fixity declarations for
      classes, class methods, data types, and record selectors correctly.
    * `singletons` will no longer erroneously try to single fixity declarations
      for type synonym or type family names.
    * A bug that caused fixity declarations for certain defunctionalization
      symbols not to be generated has been fixed.
    * `promoteOnly` and `singletonsOnly` will now produce fixity declarations
      for values with infix names.

  2.6
  ---
  * Require GHC 8.8.
  * `Sing` has switched from a data family to a type family. This
    [GitHub issue comment](https://github.com/goldfirere/singletons/issues/318#issuecomment-467067257)
    provides a detailed explanation for the motivation behind this change.

    This has a number of consequences:
    * Names like `SBool`, `SMaybe`, etc. are no longer type synonyms for
      particular instantiations of `Sing` but are instead the names of the
      singleton data types themselves. In other words, previous versions of
      `singletons` would provide this:

      ```haskell
      data instance Sing :: Bool -> Type where
        SFalse :: Sing False
        STrue  :: Sing True
      type SBool = (Sing :: Bool -> Type)
      ```

      Whereas with `Sing`-as-a-type-family, `singletons` now provides this:

      ```haskell
      data SBool :: Bool -> Type where
        SFalse :: SBool False
        STrue  :: SBool True
      type instance Sing @Bool = SBool
      ```
    * The `Sing` instance for `TYPE rep` in `Data.Singletons.TypeRepTYPE` is now
      directly defined as `type instance Sing @(TYPE rep) = TypeRep`, without the
      use of an intermediate newtype as before.
    * Due to limitations in the ways that quantified constraints and type
      families can interact
      (see [this GHC issue](https://gitlab.haskell.org/ghc/ghc/issues/14860)),
      the internals of `ShowSing` has to be tweaked in order to continue to
      work with `Sing`-as-a-type-family. One notable consequence of this is
      that `Show` instances for singleton types can no longer be derived—they
      must be written by hand in order to work around
      [this GHC bug](https://gitlab.haskell.org/ghc/ghc/issues/16365).
      This is unlikely to affect you unless you define 'Show' instances for
      singleton types by hand. For more information, refer to the Haddocks for
      `ShowSing'` in `Data.Singletons.ShowSing`.
    * GHC does not permit type class instances to mention type families, which
      means that it is no longer possible to define instances that mention the
      `Sing` type constructor. For this reason, a `WrappedSing` data type (which
      is a newtype around `Sing`) was introduced so that one can hang instances
      off of it.

      This had one noticeable effect in `singletons`
      itself: there are no longer `TestEquality Sing` or `TestCoercion Sing`
      instances. Instead, `singletons` now generates a separate
      `TestEquality`/`TestCoercion` instance for every data type that singles a
      derived `Eq` instance. In addition, the `Data.Singletons.Decide` module
      now provides top-level `decideEquality`/`decideCoercion` functions which
      provide the behavior of `testEquality`/`testCoercion`, but monomorphized
      to `Sing`. Finally, `TestEquality`/`TestCoercion` instances are provided
      for `WrappedSing`.
  * GHC's behavior surrounding kind inference for local definitions has changed
    in 8.8, and certain code that `singletons` generates for local definitions
    may no longer typecheck as a result. While we have taken measures to mitigate
    the issue on `singletons`' end, there still exists code that must be patched
    on the users' end in order to continue compiling. For instance, here is an
    example of code that stopped compiling with the switch to GHC 8.8:

    ```haskell
    replicateM_ :: (Applicative m) => Nat -> m a -> m ()
    replicateM_ cnt0 f =
        loop cnt0
      where
        loop cnt
            | cnt <= 0  = pure ()
            | otherwise = f *> loop (cnt - 1)
    ```

    This produces errors to the effect of:

    ```
    • Could not deduce (SNum k1) arising from a use of ‘sFromInteger’
      from the context: SApplicative m
      ...

    • Could not deduce (SOrd k1) arising from a use of ‘%<=’
      from the context: SApplicative m
      ...
    ```

    The issue is that GHC 8.8 now kind-generalizes `sLoop` (whereas it did not
    previously), explaining why the error message mentions a mysterious kind
    variable `k1` that only appeared after kind generalization. The solution is
    to give `loop` an explicit type signature like so:

    ```diff
    -replicateM_       :: (Applicative m) => Nat -> m a -> m ()
    +replicateM_       :: forall m a. (Applicative m) => Nat -> m a -> m ()
     replicateM_ cnt0 f =
         loop cnt0
       where
    +    loop :: Nat -> m ()
         loop cnt
             | cnt <= 0  = pure ()
             | otherwise = f *> loop (cnt - 1)
    ```

    This general approach should be sufficient to fix any type inference
    regressions that were introduced between GHC 8.6 and 8.8. If this isn't the
    case, please file an issue.
  * Due to [GHC Trac #16133](https://ghc.haskell.org/trac/ghc/ticket/16133) being
    fixed, `singletons`-generated code now requires explicitly enabling the
    `TypeApplications` extension. (The generated code was always using
    `TypeApplications` under the hood, but it's only now that GHC is detecting
    it.)
  * `Data.Singletons` now defines a family of `SingI` instances for `TyCon1`
    through `TyCon8`:

    ```haskell
    instance (forall a.    SingI a           => SingI (f a),   ...) => SingI (TyCon1 f)
    instance (forall a b. (SingI a, SingI b) => SingI (f a b), ...) => SingI (TyCon2 f)
    ...
    ```

    As a result, `singletons` no longer generates instances for `SingI` instances
    for applications of `TyCon{N}` to particular type constructors, as they have
    been superseded by the instances above.
  * Changes to `Data.Singletons.Sigma`:
    * `SSigma`, the singleton type for `Sigma`, is now defined.
    * New functions `fstSigma`, `sndSigma`, `FstSigma`, `SndSigma`, `currySigma`,
      and `uncurrySigma` have been added. A `Show` instance for `Sigma` has also
      been added.
    * `projSigma1` has been redefined to use continuation-passing style to more
      closely resemble its cousin `projSigma2`. The new type signature of
      `projSigma1` is:

      ```hs
      projSigma1 :: (forall (fst :: s). Sing fst -> r) -> Sigma s t -> r
      ```

      The old type signature of `projSigma1` can be found in the `fstSigma`
      function.
    * `Σ` has been redefined such that it is now a partial application of
      `Sigma`, like so:

      ```haskell
      type Σ = Sigma
      ```

      One benefit of this change is that one no longer needs defunctionalization
      symbols in order to partially apply `Σ`. As a result, `ΣSym0`, `ΣSym1`,
      and `ΣSym2` have been removed.
  * In line with corresponding changes in `base-4.13`, the `Fail`/`sFail` methods
    of `{P,S}Monad` have been removed in favor of new `{P,S}MonadFail` classes
    introduced in the `Data.Singletons.Prelude.Monad.Fail` module. These classes
    are also re-exported from `Data.Singletons.Prelude`.
  * Fix a bug where expressions with explicit signatures involving function types
    would fail to single.
  * The infix names `(.)` and `(!)` are no longer mapped to `(:.)` and `(:!)`,
    as GHC 8.8 learned to parse them at the type level.
  * The `Enum` instance for `SomeSing` now uses more efficient implementations of
    `enumFromTo` and `enumFromThenTo` that no longer require a `SingKind`
    constraint.

  2.5.1
  -----
  * `ShowSing` is now a type class (with a single instance) instead of a type
    synonym. This was changed because defining `ShowSing` as a type synonym
    prevents it from working well with recursive types due to an unfortunate GHC
    bug. For more information, see
    [issue #371](https://github.com/goldfirere/singletons/issues/371).
  * Add an `IsString` instance for `SomeSing`.

  2.5
  ---
  * The `Data.Promotion.Prelude.*` namespace has been removed. Use the
    corresponding modules in the `Data.Singletons.Prelude.*` namespace instead.

  * Fix a regression in which certain infix type families, such as `(++)`, `($)`,
    `(+)`, and others, did not have the correct fixities.

  * The default implementation of the `(==)` type in `PEq` was changed from
    `(Data.Type.Equality.==)` to a custom type family, `DefaultEq`. The reason
    for this change is that `(Data.Type.Equality.==)` is unable to conclude that
    `a == a` reduces to `True` for any `a`. (As a result, the previous version of
    `singletons` regressed in terms of type inference for the `PEq` instances
    for `Nat` and `Symbol`, which used that default.) On the other hand,
    `DefaultEq a a` _does_ reduce to `True` for all `a`.

  * Add `Enum Nat`, `Show Nat`, and `Show Symbol` instances to
    `Data.Singletons.TypeLits`.

  * Template Haskell-generated code may require `DataKinds` and `PolyKinds` in
    scenarios which did not previously require it:
    * `singletons` now explicitly quantifies all kind variables used in explicit
      `forall`s.
    * `singletons` now generates `a ~> b` instead of `TyFun a b -> Type` whenever
      possible.

  * Since `th-desugar` now desugars all data types to GADT syntax, Template
    Haskell-generated code may require `GADTs` in situations that didn't require
    it before.

  * Overhaul the way derived `Show` instances for singleton types works. Before,
    there was an awkward `ShowSing` class (which was essentially a cargo-culted
    version of `Show` specialized for `Sing`) that one had to create instances
    for separately. Now that GHC has `QuantifiedConstraints`, we can scrap this
    whole class and turn `ShowSing` into a simple type synonym:

    ```haskell
    type ShowSing k = forall z. Show (Sing (z :: k))
    ```

    Now, instead of generating a hand-written `ShowSing` and `Show` instance for
    each singleton type, we only generate a single (derived!) `Show` instance.
    As a result of this change, you will likely need to enable
    `QuantifiedConstraints` and `StandaloneDeriving` if you single any derived
    `Show` instances in your code.

  * The kind of the type parameter to `SingI` is no longer specified. This only
    affects you if you were using the `sing` method with `TypeApplications`. For
    instance, if you were using `sing @Bool @True` before, then you will now need
    to now use `sing @Bool` instead.

  * `singletons` now generates `SingI` instances for defunctionalization symbols
    through Template Haskell. As a result, you may need to enable
    `FlexibleInstances` in more places.

  * `genDefunSymbols` is now more robust with respect to types that use
    dependent quantification, such as:

    ```haskell
    type family MyProxy k (a :: k) :: Type where
      MyProxy k (a :: k) = Proxy a
    ```

    See the documentation for `genDefunSymbols` for limitations to this.

  * Rename `Data.Singletons.TypeRepStar` to `Data.Singletons.TypeRepTYPE`, and
    generalize the `Sing :: Type -> Type` instance to `Sing :: TYPE rep -> Type`,
    allowing it to work over more open kinds. Also rename `SomeTypeRepStar` to
    `SomeTypeRepTYPE`, and change its definition accordingly.

  * Promoting or singling a type synonym or type family declaration now produces
    defunctionalization symbols for it. (Previously, promoting or singling a type
    synonym did nothing whatsoever, and promoting or singling a type family
    produced an error.)

  * `singletons` now produces fixity declarations for defunctionalization
    symbols when appropriate.

  * Add `(%<=?)`, a singled version of `(<=?)` from `GHC.TypeNats`, as well as
    defunctionalization symbols for `(<=?)`, to `Data.Singletons.TypeLits`.

  * Add `Data.Singletons.Prelude.{Semigroup,Monoid}`, which define
    promoted and singled versions of the `Semigroup` and `Monoid` type classes,
    as well as various newtype modifiers.

    `Symbol` is now has promoted `Semigroup` and `Monoid` instances as well.
    As a consequence, `Data.Singletons.TypeLits` no longer exports `(<>)` or
    `(%<>)`, as they are superseded by the corresponding methods from
    `PSemigroup` and `SSemigroup`.

  * Add promoted and singled versions of the `Functor`, `Foldable`,
    `Traversable`, `Applicative`, `Alternative`, `Monad`, `MonadPlus`, and
    `MonadZip` classes. Among other things, this grants the ability to promote
    or single `do`-notation and list comprehensions.
    * `Data.Singletons.Prelude.List` now reexports more general
      `Foldable`/`Traversable` functions wherever possible, just as `Data.List`
      does.

  * Add `Data.Singletons.Prelude.{Const,Identity}`, which define
    promoted and singled version of the `Const` and `Identity` data types,
    respectively.

  * Promote and single the `Down` newtype in `Data.Singletons.Prelude.Ord`.

  * To match the `base` library, the promoted/singled versions of `comparing`
    and `thenCmp` are no longer exported from `Data.Singletons.Prelude`. (They
    continue to live in `Data.Singletons.Prelude.Ord`.)

  * Permit singling of expression and pattern signatures.

  * Permit promotion and singling of `InstanceSigs`.

  * `sError` and `sUndefined` now have `HasCallStack` constraints, like their
    counterparts `error` and `undefined`. The promoted and singled counterparts
    to `errorWithoutStackTrace` have also been added in case you do not want
    this behavior.

  * Add `Data.Singletons.TypeError`, which provides a drop-in replacement for
    `GHC.TypeLits.TypeError` which can be used at both the value- and type-level.

  2.4.1
  -----
  * Restore the `TyCon1`, `TyCon2`, etc. types. It turns out that the new
  `TyCon` doesn't work with kind-polymorphic tycons.

  2.4
  ---
  * Require GHC 8.4.

  * `Demote Nat` is now `Natural` (from `Numeric.Natural`) instead of `Integer`.
    In accordance with this change, `Data.Singletons.TypeLits` now exposes
    `GHC.TypeNats.natVal` (which returns a `Natural`) instead of
    `GHC.TypeLits.natVal` (which returns an `Integer`).

  * The naming conventions for infix identifiers (e.g., `(&*)`) have been overhauled.
    * Infix functions (that are not constructors) are no longer prepended with a
      colon when promoted to type families. For instance, the promoted version of
      `(&*)` is now called `(&*)` as well, instead of `(:&*)` as before.

      There is one exception to this rule: the `(.)` function, which is promoted
      as `(:.)`. The reason is that one cannot write `(.)` at the type level.
    * Singletons for infix functions are now always prepended with `%` instead of `%:`.
    * Singletons for infix classes are now always prepended with `%` instead of `:%`.
    * Singletons for infix datatypes are now always prepended with a `%`.

      (Before, there was an unspoken requirement that singling an infix datatype
      required that name to begin with a colon, and the singleton type would begin
      with `:%`. But now that infix datatype names can be things like `(+)`, this
      requirement became obsolete.)

    The upshot is that most infix names can now be promoted using the same name, and
    singled by simply prepending the name with `%`.

  * The suffix for defunctionalized names of symbolic functions (e.g., `(+)`) has
    changed. Before, the promoted type name would be suffixed with some number of
    dollar signs (e.g., `(+$)` and `(+$$)`) to indicate defunctionalization
    symbols. Now, the promoted type name is first suffixed with `@#@` and
    _then_ followed by dollar signs (e.g., `(+@#@$)` and `(+@#@$$)`).
    Adopting this conventional eliminates naming conflicts that could arise for
    functions that consisted of solely `$` symbols.

  * The treatment of `undefined` is less magical. Before, all uses of `undefined`
    would be promoted to `GHC.Exts.Any` and singled to `undefined`. Now, there is
    a proper `Undefined` type family and `sUndefined` singleton function.

  * As a consequence of not promoting `undefined` to `Any`, there is no need to
    have a special `any_` function to distinguish the function on lists. The
    corresponding promoted type, singleton function, and defunctionalization
    symbols are now named `Any`, `sAny`, and `AnySym{0,1,2}`.

  * Rework the treatment of empty data types:
    * Generated `SingKind` instances for empty data types now use `EmptyCase`
      instead of simply `error`ing.
    * Derived `PEq` instances for empty data types now return `True` instead of
      `False`. Derived `SEq` instances now return `True` instead of `error`ing.
    * Derived `SDecide` instances for empty data types now return `Proved bottom`,
      where `bottom` is a divergent computation, instead of `error`ing.

  * Add `Data.Singletons.Prelude.IsString` and `Data.Promotion.Prelude.IsString`
    modules. `IsString.fromString` is now used when promoting or singling
    string literals when the `-XOverloadedStrings` extension is enabled
    (similarly to how `Num.fromInteger` is currently used when promoting or
    singling numeric literals).

  * Add `Data.Singletons.Prelude.Void`.

  * Add promoted and singled versions of `div`, `mod`, `divMod`, `quot`, `rem`,
    and `quotRem` to `Data.Singletons.TypeLits` that utilize the efficient `Div`
    and `Mod` type families from `GHC.TypeNats`. Also add `sLog2` and
    defunctionalization symbols for `Log2` from `GHC.TypeNats`.

  * Add `(<>)` and `(%<>)`, the promoted and singled versions of `AppendSymbol`
    from `GHC.TypeLits`.

  * Add `(%^)`, the singleton version of `GHC.TypeLits.^`.

  * Add `unlines` and `unwords` to `Data.Singletons.Prelude.List`.

  * Add promoted and singled versions of `Show`, including `deriving` support.

  * Add a `ShowSing` class, which facilitates the ability to write `Show` instances
    for `Sing` instances.

  * Permit derived `Ord` instances for empty datatypes.

  * Permit standalone `deriving` declarations.

  * Permit `DeriveAnyClass` (through the `anyclass` keyword of `DerivingStrategies`)

  * Add a value-level `(@@)`, which is a synonym for `applySing`.

  * Add `Eq`, `Ord`, `Num`, `Enum`, and `Bounded` instances for `SomeSing`, which
    leverage the `SEq`, `SOrd`, `SNum`, `SEnum`, and `SBounded` instances,
    respectively, for the underlying `Sing`.

  * Rework the `Sing (a :: *)` instance in `Data.Singletons.TypeRepStar` such
    that it now uses type-indexed `Typeable`. The new `Sing` instance is now:

    ```haskell
    newtype instance Sing :: Type -> Type where
      STypeRep :: TypeRep a -> Sing a
    ```

    Accordingly, the `SingKind` instance has also been changed:

    ```haskell
    instance SingKind Type where
      type Demote Type = SomeTypeRepStar
      ...

    data SomeTypeRepStar where
      SomeTypeRepStar :: forall (a :: *). !(TypeRep a) -> SomeTypeRepStar
    ```

    Aside from cleaning up some implementation details, this change assures
    that `toSing` can only be called on `TypeRep`s whose kind is of kind `*`.
    The previous implementation did not enforce this, which could lead to
    segfaults if used carelessly.

  * Instead of `error`ing, the `toSing` implementation in the `SingKind (k1 ~> k2)`
    instance now works as one would expect (provided the user adheres to some
    common-sense `SingKind` laws, which are now documented).

  * Add a `demote` function, which is a convenient shorthand for `fromSing sing`.

  * Add a `Data.Singletons.Sigma` module with a `Sigma` (dependent pair) data type.

  * Export defunctionalization symbols for `Demote`, `SameKind, `KindOf`, `(~>)`,
    `Apply`, and `(@@)` from `Data.Singletons`.

  * Add an explicitly bidirectional pattern synonym `Sing`. Pattern
    matching on `Sing` brings a `SingI ty` constraint into scope from a
    singleton `Sing ty`.

  * Add an explicitly bidirectional pattern synonym `FromSing`. Pattern
    matching on any demoted (base) type gives us the corresponding
    singleton.

  * Add explicitly bidirectional pattern synonyms
    `SLambda{2..8}`. Pattern matching on any defunctionalized singleton
    yields a term-level Haskell function on singletons.

  * Remove the family of `TyCon1`, `TyCon2`, ..., in favor of just `TyCon`.
    GHC 8.4's type system is powerful enough to allow this nice simplification.

  2.3
  ---
  * Documentation clarifiation in `Data.Singletons.TypeLits`, thanks to @ivan-m.

  * `Demote` was no longer a convenient way of calling `DemoteRep` and has been
  removed. `DemoteRep` has been renamed `Demote`.

  * `DemoteRep` is now injective.

  * Demoting a `Symbol` now gives `Text`. This is motivated by making `DemoteRep`
    injective. (If `Symbol` demoted to `String`, then there would be a conflict
    between demoting `[Char]` and `Symbol`.)

  * Generating singletons also now generates fixity declarations for the singletonized
    definitions, thanks to @int-index.

  * Though more an implementation detail: singletons no longer uses kind-level proxies anywhere,
    thanks again to @int-index.

  * Support for promoting higher-kinded type variables, thanks for @int-index.

  * `Data.Singletons.TypeLits` now exports defunctionalization symbols for `KnownNat`
  and `KnownSymbol`.

  * Better type inference support around constraints, as tracked in Issue #176.

  * Type synonym definitions are now ignored, as they should be.

  * `Show` instances for `SNat` and `SSymbol`, thanks to @cumber.

  * The `singFun` and `unSingFun` functions no longer use proxies, preferring
    `TypeApplications`.

  2.2
  ---
  * With `TypeInType`, we no longer kind `KProxy`. @int-index has very helpfully
  removed the use of `KProxy` from `singletons`.

  * Drop support for GHC 7.x.

  * Remove `bugInGHC`. That function was intended to work around GHC's difficulty
  in detecting exhaustiveness of GADT pattern matches. GHC 8 comes with a much
  better exhaustiveness checker, and so this function is no longer necessary.

  2.1
  ---
  * Require `th-desugar` >= 1.6

  * Work with GHC 8. GHC 8 gives the opportunity to simplify some pieces of
  singletons, but these opportunities are not yet fully realized. For example,
  injective type families means that we no longer need `Sing` to be a data
  family; it could be a type family. This might drastically simplify the way
  functions are singletonized. But not yet!

  * `singletons` now outputs a few more type/kind annotations to help GHC do
  type inference. There may be a few more programs accepted than before.
  (This is the fix for #136.)

  2.0.1
  -----
   * Lots more functions in `Data.Singletons.Prelude.List`:
     `filter`, `find`, `elemIndex`, `elemIndices`, `findIndex`, `findIndices`,
     `intersect`, `intersectBy`, `takeWhile`, `dropWhile`, `dropWhileEnd`,
     `span`, `break`, `take`, `drop`, `splitAt`, `group`, `maximum`,
     `minimum`, `insert`, `sort`, `groupBy`, `lookup`, `partition`,
     `sum`, `product`, `length`, `replicate`, `transpose`, `(!!)`,
     `nub`, `nubBy`, `unionBy`, `union`, `genericLength`

  2.0.0.2
  -------
   * Fix fixity of `*`.

  2.0.0.1
  -------
   * Make haddock work.

  2.0
  ---

  * Instance promotion now works properly -- it was quite buggy in 1.0.

  * Classes and instances can now be singletonized.

  * Limited support for functional dependencies.

  * We now have promoted and singletonized versions of `Enum`, as well as `Bounded`.

  * Deriving `Enum` is also now supported.

  * Ditto for `Num`, which includes an instance for `Nat`, naturally.

  * Promoting a literal number now uses overloaded literals at the type level,
  using a type-level `FromInteger` in the type-level `Num` class.

  * Better support for dealing with constraints. Some previously-unsingletonizable
  functions that have constrained parameters now work.

  * No more orphan `Quasi` instances!

  * Support for functions of arity 8 (instead of the old limit, 7).

  * Full support for fixity declarations.

  * A raft of bugfixes.

  * Drop support for GHC 7.8. You must have GHC 7.10.2.

  1.1.2.1
  -------

  Fix bug #116, thus allowing locally-declared symbols to be used in GHC 7.10.

  1.1.2
  -----

  * No more GHC 7.8.2 support -- you must have GHC 7.8.3.

  1.1.1
  -----

  Update testsuite to work with th-desugar-1.5.2. No functional changes.

  1.1
  ---

  This is a maintenance release to support building (but *not* testing, due to
  GHC bug #10058) with 7.10. This release also targets th-desugar-1.5. Some
  types changed (using th-desugar's new `DsMonad` instead of `Quasi`), but
  clients generally won't need to make any changes, unless they, too, generalize
  over `Quasi`.

  1.0
  ---

  This is a complete rewrite of the package.

  * A much wider array of surface syntax is now accepted for promotion
  and singletonization, including `let`, `case`, partially-applied functions,
  and anonymous functions, `where`, sections, among others.

  * Classes and instances can be promoted (but not singletonized).

  * Derivation of promoted instances for `Ord` and `Bounded`.

  This release can be seen as a "technology preview". More features are coming
  soon.

  This version drops GHC 7.6 support.

  0.10.0
  ------

  Template Haskell names are now more hygienic. In other words, `singletons`
  won't try to gobble up something happened to be named `Sing` in your project.
  (Note that the Template Haskell names are not *completely* hygienic; names
  generated during singleton generation can still cause conflicts.)

  If a function to be promoted or singletonized is missing a type signature,
  that is now an *error*, not a warning.

  Added a new external module Data.Singletons.TypeLits, which contain the
  singletons for GHC.TypeLits. Some convenience functions are also provided.

  The extension `EmptyCase` is no longer needed. This caused pain when trying
  to support both GHC 7.6.3 and 7.8.

  0.9.3
  -----

  Fix export list of Data.Singletons.TH, again again.

  Add `SEq` instances for `Nat` and `Symbol`.

  0.9.2
  -----

  Fix export list of Data.Singletons.TH, again.

  0.9.1
  -----

  Fix export list of Data.Singletons.TH.

  0.9.0
  -----

  Make compatible with GHC HEAD, but HEAD reports core lint errors sometimes.

  Change module structure significantly. If you want to derive your own
  singletons, you should import `Data.Singletons.TH`. The module
  `Data.Singletons` now exports functions only for the *use* of singletons.

  New modules `Data.Singletons.Bool`, `...Maybe`, `...Either`, and `...List`
  are just like their equivalents from `Data.`, except for `List`, which is
  quite lacking in features.

  For singleton equality, use `Data.Singletons.Eq`.

  For propositional singleton equality, use `Data.Singletons.Decide`.

  New module `Data.Singletons.Prelude` is meant to mirror the Haskell Prelude,
  but with singleton definitions.

  Streamline representation of singletons, resulting in *exponential* speedup
  at execution. (This has not been rigorously measured, but the data structures
  are now *exponentially* smaller.)

  Add internal support for TypeLits, because the TypeLits module no longer
  exports singleton definitions.

  Add support for existential singletons, through the `toSing` method of
  `SingKind`.

  Remove the `SingE` class, bundling its functionality into `SingKind`.
  Thus, the `SingRep` synonym has also been removed.

  Name change: `KindIs` becomes `KProxy`.

  Add support for singletonizing calls to `error`.

  Add support for singletonizing empty data definitions.

  0.8.6
  -----

  Make compatible with GHC HEAD, but HEAD reports core lint errors sometimes.

  0.8.5
  -----

  Bug fix to make singletons compatible with GHC 7.6.1.

  Added git info to cabal file.

  0.8.4
  -----

  Update to work with latest version of GHC (7.7.20130114).

  Now use branched type family instances to allow for promotion of functions
  with overlapping patterns.

  Permit promotion of functions with constraints by omitting constraints.

  0.8.3
  -----

  Update to work with latest version of GHC (7.7.20121031).

  Removed use of Any to simulate kind classes; now using KindOf and OfKind
  from GHC.TypeLits.

  Made compatible with GHC.TypeLits.

  0.8.2
  -----

  Added this changelog

  Update to work with latest version of GHC (7.6.1). (There was a change to
  Template Haskell).

  Moved library into Data.Singletons.

  0.8.1
  -----

  Update to work with latest version of GHC. (There was a change to
  Template Haskell).

  Updated dependencies in cabal to include the newer version of TH.

  0.8
  ---

  Initial public release
basic-deps:
  base: ! '>=4.14 && <4.15'
  text: ! '>=1.2'
  syb: ! '>=0.4'
  containers: ! '>=0.5'
  th-desugar: ! '>=1.11 && <1.12'
  mtl: ! '>=2.2.1'
  transformers: ! '>=0.5.2'
  ghc-boot-th: -any
  pretty: -any
  template-haskell: -any
all-versions:
- '0.8'
- 0.8.1
- 0.8.2
- 0.8.3
- 0.8.4
- 0.8.5
- 0.8.6
- 0.9.0
- 0.9.1
- 0.9.2
- 0.9.3
- 0.10.0
- '1.0'
- '1.1'
- 1.1.1
- 1.1.2
- 1.1.2.1
- '2.0'
- 2.0.0.1
- 2.0.0.2
- 2.0.1
- '2.1'
- '2.2'
- '2.3'
- 2.3.1
- '2.4'
- 2.4.1
- '2.5'
- 2.5.1
- '2.6'
- '2.7'
author: Richard Eisenberg <rae@cs.brynmawr.edu>, Jan Stolarek <jan.stolarek@p.lodz.pl>
latest: '2.7'
description-type: markdown
description: "singletons 2.7\n==============\n\n[![Hackage](https://img.shields.io/hackage/v/singletons.svg)](http://hackage.haskell.org/package/singletons)\n[![Build
  Status](https://travis-ci.org/goldfirere/singletons.svg?branch=master)](https://travis-ci.org/goldfirere/singletons)\n\nThis
  is the README file for the `singletons` library. This file contains all the\ndocumentation
  for the definitions and functions in the library.\n\nThe `singletons` library was
  written by Richard Eisenberg (<rae@cs.brynmawr.edu>) and\nwith significant contributions
  by Jan Stolarek (<jan.stolarek@p.lodz.pl>) and\nRyan Scott (<ryan.gl.scott@gmail.com>).
  There\nare two papers that describe the library. Original one, _Dependently typed\nprogramming
  with singletons_, is available\n[here](https://cs.brynmawr.edu/~rae/papers/2012/singletons/paper.pdf)
  and will\nbe referenced in this documentation as the \"singletons paper\". A follow-up\npaper,
  _Promoting Functions to Type Families in Haskell_, is available\n[here](https://cs.brynmawr.edu/~rae/papers/2014/promotion/promotion.pdf)\nand
  will be referenced in this documentation as the\n\"promotion paper\".\n\nRyan Scott
  (<ryan.gl.scott@gmail.com>) is the active maintainer.\n\nPurpose of the `singletons`
  library\n-----------------------------------\n\nThe library contains a definition
  of _singleton types_, which allow programmers\nto use dependently typed techniques
  to enforce rich constraints among the types\nin their programs. See the singletons
  paper for a more thorough introduction.\n\nThe package also allows _promotion_ of
  term-level functions to type-level\nequivalents and _singling_ functions to dependently
  typed equivalents.\nAccordingly, it exports a Prelude of promoted and singled\nfunctions,
  mirroring functions and datatypes found in the `Prelude`, `Data.Bool`,\n`Data.Maybe`,
  `Data.Either`, `Data.Tuple` and `Data.List`. See the promotion\npaper for a more
  thorough introduction.\n\n[This blog series](https://blog.jle.im/entry/introduction-to-singletons-1.html),\nauthored
  by Justin Le, offers a tutorial for this library that assumes no\nknowledge of dependent
  types.\n\nCompatibility\n-------------\n\nThe `singletons` library requires GHC
  8.10.1 or greater. Any code that uses the\nsingleton generation primitives needs
  to enable a long list of GHC\nextensions. This list includes, but is not necessarily
  limited to, the\nfollowing:\n\n* `DataKinds`\n* `DefaultSignatures`\n* `EmptyCase`\n*
  `ExistentialQuantification`\n* `FlexibleContexts`\n* `FlexibleInstances`\n* `GADTs`\n*
  `InstanceSigs`\n* `KindSignatures`\n* `NoCUSKs`\n* `NoStarIsType`\n* `PolyKinds`\n*
  `RankNTypes`\n* `ScopedTypeVariables`\n* `StandaloneKindSignatures`\n* `TemplateHaskell`\n*
  `TypeApplications`\n* `TypeFamilies`\n* `TypeOperators`\n* `UndecidableInstances`\n\nIn
  particular, `NoStarIsType` is needed to use the `*` type family from the\n`PNum`
  class because with `StarIsType` enabled, GHC thinks `*` is a synonym\nfor `Type`.\n\nYou
  may also want to consider toggling various warning flags:\n\n* `-Wno-redundant-constraints`.\n
  \ The code that `singletons` generates uses redundant constraints, and there\n  seems
  to be no way, without a large library redesign, to avoid this.\n* `-fenable-th-splice-warnings`.\n
  \ By default, GHC does not run pattern-match coverage checker warnings on code\n
  \ inside of Template Haskell quotes. This is an extremely common thing to do\n  in
  `singletons`, so you may consider opting in to these warnings.\n\nModules for singleton
  types\n---------------------------\n\n`Data.Singletons` exports all the basic singletons
  definitions. Import this\nmodule if you are not using Template Haskell and wish
  only to define your\nown singletons.\n\n`Data.Singletons.TH` exports all the definitions
  needed to use the Template\nHaskell code to generate new singletons.\n\n`Data.Singletons.Prelude`
  re-exports `Data.Singletons` along with singleton\ndefinitions for various `Prelude`
  types. This module provides promoted and\nsingled equivalents of functions from
  the real `Prelude`.\nNote that not all functions from original `Prelude` could be
  promoted or\nsingled.\n\n`Data.Singletons.Prelude.*` modules provide promoted and
  singled equivalents of\ndefinitions found in several commonly used `base` library
  modules, including\n(but not limited to) `Data.Bool`, `Data.Maybe`, `Data.Either`,
  `Data.List`,\n`Data.Tuple`, `Data.Void` and `GHC.Base`. We also provide promoted
  and singled\nversions of common type classes, including (but not limited to) `Eq`,
  `Ord`,\n`Show`, `Enum`, and `Bounded`.\n\n`Data.Singletons.Decide` exports type
  classes for propositional equality.\n\n`Data.Singletons.TypeLits` exports definitions
  for working with `GHC.TypeLits`.\n\nFunctions to generate singletons\n--------------------------------\n\nThe
  top-level functions used to generate promoted or singled definitions are\ndocumented
  in the `Data.Singletons.TH` module. The most common case is just\ncalling `singletons`,
  which I'll describe here:\n\n```haskell\nsingletons :: Q [Dec] -> Q [Dec]\n```\n\nThis
  function generates singletons from the definitions given. Because\nsingleton generation
  requires promotion, this also promotes all of the\ndefinitions given to the type
  level.\n\nUsage example:\n\n```haskell\n$(singletons [d|\n  data Nat = Zero | Succ
  Nat\n  pred :: Nat -> Nat\n  pred Zero = Zero\n  pred (Succ n) = n\n  |])\n```\n\nDefinitions
  used to support singletons\n--------------------------------------\n\nPlease refer
  to the singletons paper for a more in-depth explanation of these\ndefinitions. Many
  of the definitions were developed in tandem with Iavor Diatchki.\n\n```haskell\ntype
  Sing :: k -> Type\ntype family Sing\n```\n\nThe type family of singleton types.
  A new instance of this type family is\ngenerated for every new singleton type.\n\n```haskell\nclass
  SingI a where\n  sing :: Sing a\n```\n\nA class used to pass singleton values implicitly.
  The `sing` method produces\nan explicit singleton value.\n\n```haskell\ntype SomeSing
  :: Type -> Type\ndata SomeSing k where\n  SomeSing :: Sing (a :: k) -> SomeSing
  k\n```\n\nThe `SomeSing` type wraps up an _existentially-quantified_ singleton.
  Note that\nthe type parameter `a` does not appear in the `SomeSing` type. Thus,
  this type\ncan be used when you have a singleton, but you don't know at compile
  time what\nit will be. `SomeSing Thing` is isomorphic to `Thing`.\n\n```haskell\ntype
  SingKind :: Type -> Constraint\nclass SingKind k where\n  type Demote k :: *\n  fromSing
  :: Sing (a :: k) -> Demote k\n  toSing   :: Demote k -> SomeSing k\n```\n\nThis
  class is used to convert a singleton value back to a value in the\noriginal, unrefined
  ADT. The `fromSing` method converts, say, a\nsingleton `Nat` back to an ordinary
  `Nat`. The `toSing` method produces\nan existentially-quantified singleton, wrapped
  up in a `SomeSing`.\nThe `Demote` associated\nkind-indexed type family maps the
  kind `Nat` back to the type `Nat`.\n\n```haskell\ntype SingInstance :: k -> Type\ndata
  SingInstance a where\n  SingInstance :: SingI a => SingInstance a\nsingInstance
  :: Sing a -> SingInstance a\n```\n\nSometimes you have an explicit singleton (a
  `Sing`) where you need an implicit\none (a dictionary for `SingI`). The `SingInstance`
  type simply wraps a `SingI`\ndictionary, and the `singInstance` function produces
  this dictionary from an\nexplicit singleton. The `singInstance` function runs in
  constant time, using\na little magic.\n\n\nEquality classes\n----------------\n\nThere
  are two different notions of equality applicable to singletons: Boolean\nequality
  and propositional equality.\n\n* Boolean equality is implemented in the type family
  `(==)` (in the `PEq`\n  class) and the `(%==`) method (in the `SEq` class).\n  See
  the `Data.Singletons.Prelude.Eq` module for more information.\n\n* Propositional
  equality is implemented through the constraint `(~)`, the type\n  `(:~:)`, and the
  class `SDecide`. See modules `Data.Type.Equality` and\n  `Data.Singletons.Decide`
  for more information.\n\nWhich one do you need? That depends on your application.
  Boolean equality has\nthe advantage that your program can take action when two types
  do _not_ equal,\nwhile propositional equality has the advantage that GHC can use
  the equality\nof types during type inference.\n\nInstances of `SEq`, `SDecide`,
  `TestEquality`, and `TestCoercion` are generated\nwhen `singletons` is called on
  a datatype that has `deriving Eq`. You can also\ngenerate these instances directly
  through functions exported from\n`Data.Singletons.TH`.\n\n\n`Show` classes\n--------------\n\nPromoted
  and singled versions of the `Show` class (`PShow` and `SShow`,\nrespectively) are
  provided in the `Data.Singletons.Prelude.Show` module. In\naddition, there is a
  `ShowSing` constraint synonym provided in the\n`Data.Singletons.ShowSing` module:\n\n```haskell\ntype
  ShowSing :: Type -> Constraint\ntype ShowSing k = (forall z. Show (Sing (z :: k))
  -- Approximately\n```\n\nThis facilitates the ability to write `Show` instances
  for `Sing` instances.\n\nWhat distinguishes all of these `Show`s? Let's use the
  `False` constructor as\nan example. If you used the `PShow Bool` instance, then
  the output of calling\n`Show_` on `False` is `\"False\"`, much like the value-level
  `Show Bool` instance\n(similarly for the `SShow Bool` instance). However, the `Show
  (Sing (z :: Bool))`\ninstance (i.e., `ShowSing Bool`) is intended for printing the
  value of the\n_singleton_ constructor `SFalse`, so calling `show SFalse` yields
  `\"SFalse\"`.\n\nInstance of `PShow`, `SShow`, and `Show` (for the singleton type)
  are generated\nwhen `singletons` is called on a datatype that has `deriving Show`.
  You can also\ngenerate these instances directly through functions exported from\n`Data.Singletons.TH`.\n\nA
  promoted and singled `Show` instance is provided for `Symbol`, but it is only\na
  crude approximation of the value-level `Show` instance for `String`. On the\nvalue
  level, showing `String`s escapes special characters (such as double\nquotes), but
  implementing this requires pattern-matching on character literals,\nsomething which
  is currently impossible at the type level. As a consequence, the\ntype-level `Show`
  instance for `Symbol`s does not do any character escaping.\n\nErrors\n------\n\nThe
  `singletons` library provides two different ways to handle errors:\n\n* The `Error`
  type family, from `Data.Singletons.TypeLits`:\n\n  ```haskell\n  type Error :: a
  -> k\n  type family Error str where {}\n  ```\n\n  This is simply an empty, closed
  type family, which means that it will fail\n  to reduce regardless of its input.
  The typical use case is giving it a\n  `Symbol` as an argument, so that something
  akin to\n  `Error \"This is an error message\"` appears in error messages.\n* The
  `TypeError` type family, from `Data.Singletons.TypeError`. This is a\n  drop-in
  replacement for `TypeError` from `GHC.TypeLits` which can be used\n  at both the
  type level and the value level (via the `typeError` function).\n\n  Unlike `Error`,
  `TypeError` will result in an actual compile-time error\n  message, which may be
  more desirable depending on the use case.\n\nPre-defined singletons\n----------------------\n\nThe
  `singletons` library defines a number of singleton types and functions\nby default.
  These include (but are not limited to):\n\n* `Bool`\n* `Maybe`\n* `Either`\n* `Ordering`\n*
  `()`\n* tuples up to length 7\n* lists\n\nThese are all available through `Data.Singletons.Prelude`.
  Functions that\noperate on these singletons are available from modules such as `Data.Singletons.Bool`\nand
  `Data.Singletons.Maybe`.\n\nPromoting functions\n-------------------\n\nFunction
  promotion allows to generate type-level equivalents of term-level\ndefinitions.
  Almost all Haskell source constructs are supported -- see the\n\"Supported Haskell
  constructs\" section of this README for a full list.\n\nPromoted definitions are
  usually generated by calling the `promote` function:\n\n```haskell\n$(promote [d|\n
  \ data Nat = Zero | Succ Nat\n  pred :: Nat -> Nat\n  pred Zero = Zero\n  pred (Succ
  n) = n\n  |])\n```\n\nEvery promoted function and data constructor definition comes
  with a set of\nso-called _defunctionalization symbols_. These are required to represent\npartial
  application at the type level. For more information, refer to the\n\"Promotion and
  partial application\" section below.\n\nUsers also have access to `Data.Singletons.Prelude`
  and its submodules (e.g.,\n`Base`, `Bool`, `Either`, `List`, `Maybe` and `Tuple`).
  These provide promoted\nversions of function found in GHC's `base` library.\n\nNote
  that GHC resolves variable names in Template Haskell quotes. You cannot\nthen use
  an undefined identifier in a quote, making idioms like this not\nwork:\n\n```haskell\ntype
  family Foo a where ...\n$(promote [d| ... foo x ... |])\n```\n\nIn this example,
  `foo` would be out of scope.\n\nRefer to the promotion paper for more details on
  function promotion.\n\nPromotion and partial application\n---------------------------------\n\nPromoting
  higher-order functions proves to be surprisingly tricky. Consider\nthis example:\n\n```hs\n$(promote
  [d|\n  map :: (a -> b) -> [a] -> [b]\n  map _ []     = []\n  map f (x:xs) = f x
  : map f xs\n  |])\n```\n\nA naïve attempt to promote `map` would be:\n\n```hs\ntype
  Map :: (a -> b) -> [a] -> [b]\ntype family Map f xs where\n  Map _ '[]    = '[]\n
  \ Map f (x:xs) = f x : Map f xs\n```\n\nWhile this compiles, it is much less useful
  than we would like. In particular,\ncommon idioms like `Map Id xs` will not typecheck,
  since GHC requires that all\ninvocations of type families be fully saturated. That
  is, the use of `Id` in\n`Map Id xs` is rejected since it is not applied to one argument,
  which the\nnumber of arguments that `Id` was defined with. For more information
  on this\npoint, refer to the promotion paper.\n\nNot having the ability to partially
  apply functions at the type level is rather\npainful, so we do the next best thing:
  we _defunctionalize_ all promoted\nfunctions so that we can emulate partial application.
  For example, if one were\nto promote the `id` function:\n\n```hs\n$(promote [d|\n
  \ id :: a -> a\n  id x = x\n  |]\n```\n\nThen in addition to generating the promoted
  `Id` type family, two\ndefunctionalization symbols will be generated:\n\n```hs\ntype
  IdSym0 :: a ~> a\ntype IdSym0 x = x\n\ntype IdSym1 (x :: a) = Id a\n```\n\nIn general,
  a function that accepts N arguments generates N+1 defunctionalization\nsymbols when
  promoted.\n\n`IdSym1` is a _fully saturated_ defunctionalization symbol and is usually
  only\nneeded when generating code through the Template Haskell machinery. `IdSym0`\nis
  more interesting: it has the kind `a ~> a`, which has a special arrow type\n`(~>)`.
  Defunctionalization symbols using the `(~>)` kind are type-level\nconstants that
  can be \"applied\" using a special `Apply` type family:\n\n```hs\ntype Apply ::
  (a ~> b) -> a -> b\ntype family Apply f x\n```\n\nEvery defunctionalization symbol
  comes with a corresponding `Apply` instance\n(except for fully saturated defunctionalization
  symbols). For instance, here\nis the `Apply` instance for `IdSym0`:\n\n```hs\ntype
  instance Apply IdSym0 x = IdSym1 x\n```\n\nThe `(~>)` kind is used when promoting
  higher-order functions so that partially\napplied arguments can be passed to them.
  For instance, here is our final attempt\nat promoting `map`:\n\n```hs\ntype Map
  :: (a ~> b) -> [a] -> [b]\ntype family Map f xs where\n  Map _ '[]    = '[]\n  Map
  f (x:xs) = Apply f x : Map f xs\n```\n\nNow `map id xs` can be promoted to `Map
  IdSym0 xs`, which typechecks without issue.\n\n## Defunctionalizing existing type
  families\n\nThe most common way to defunctionalize functions is by promoting them
  with the\nTemplate Haskell machinery. One can also defunctionalize existing type
  families,\nhowever, by using `genDefunSymbols`. For example:\n\n```hs\ntype MyTypeFamily
  :: Nat -> Bool\ntype family MyTypeFamily n\n\n$(genDefunSymbols [''MyTypeFamily])\n```\n\nThis
  can be especially useful if `MyTypeFamily` needs to be implemented by\nhand. Be
  aware of the following design limitations of `genDefunSymbols`:\n\n* `genDefunSymbols`
  only works for type-level declarations. Namely, it only\n  works when given the
  names of type classes, type families, type synonyms,\n  or data types. Attempting
  to pass the name of a term level function,\n  class method, data constructor, or
  record selector will throw an error.\n* Passing the name of a data type to `genDefunSymbols`
  will cause its\n  data constructors to be defunctionalized but _not_ its record
  selectors.\n* Passing the name of a type class to `genDefunSymbols` will cause the\n
  \ class itself to be defunctionalized, but /not/ its associated type families\n
  \ or methods.\n\nNote that the limitations above reflect the current design of\n`genDefunSymbols`.
  As a result, they are subject to change in the future.\n\n## Defunctionalization
  and visible dependent quantification\n\nUnlike most other parts of `singletons`,
  which disallow visible dependent\nquantification (VDQ), `genDefunSymbols` has limited
  support for VDQ.\nConsider this example:\n\n```hs\ntype MyProxy :: forall (k ::
  Type) -> k -> Type\ntype family MyProxy k (a :: k) :: Type where\n  MyProxy k (a
  :: k) = Proxy a\n\n$(genDefunSymbols [''MyProxy])\n```\n\nThis will generate the
  following defunctionalization symbols:\n\n```hs\ntype MyProxySym0 ::              Type
  \ ~> k ~> Type\ntype MyProxySym1 :: forall (k :: Type) -> k ~> Type\ntype MyProxySym2
  k (a :: k) = MyProxy k a\n```\n\nNote that `MyProxySym0` is a bit more general than
  it ought to be, since\nthere is no dependency between the first kind (`Type`) and
  the second kind\n(`k`). But this would require the ability to write something like
  this:\n\n```hs\ntype MyProxySym0 :: forall (k :: Type) ~> k ~> Type\n```\n\nThis
  currently isn't possible. So for the time being, the kind of\n`MyProxySym0` will
  be slightly more general, which means that under rare\ncircumstances, you may have
  to provide extra type signatures if you write\ncode which exploits the dependency
  in `MyProxy`'s kind.\n\nClasses and instances\n---------------------\n\nThis is
  best understood by example. Let's look at a stripped down `Ord`:\n\n```haskell\nclass
  Eq a => Ord a where\n  compare :: a -> a -> Ordering\n  (<)     :: a -> a -> Bool\n
  \ x < y = case x `compare` y of\n            LT -> True\n\t    EQ -> False\n\t    GT
  -> False\n```\n\nThis class gets promoted to a \"kind class\" thus:\n\n```haskell\nclass
  PEq a => POrd a where\n  type Compare (x :: a) (y :: a) :: Ordering\n  type (<)
  \    (x :: a) (y :: a) :: Bool\n  type x < y = ... -- promoting `case` is yucky.\n```\n\nNote
  that default method definitions become default associated type family\ninstances.
  This works out quite nicely.\n\nWe also get this singleton class:\n\n```haskell\nclass
  SEq a => SOrd a where\n  sCompare :: forall (x :: a) (y :: a). Sing x -> Sing y
  -> Sing (Compare x y)\n  (%<)     :: forall (x :: a) (y :: a). Sing x -> Sing y
  -> Sing (x < y)\n\n  default (%<) :: forall (x :: a) (y :: a).\n                  ((x
  < y) ~ {- RHS from (<) above -})\n\t\t=> Sing x -> Sing y -> Sing (x < y)\n  x %<
  y = ...  -- this is a bit yucky too\n```\n\nNote that a singled class needs to use
  `default` signatures, because\ntype-checking the default body requires that the
  default associated type\nfamily instance was used in the promoted class. The extra
  equality constraint\non the default signature asserts this fact to the type checker.\n\nInstances
  work roughly similarly.\n\n```haskell\ninstance Ord Bool where\n  compare False
  False = EQ\n  compare False True  = LT\n  compare True  False = GT\n  compare True
  \ True  = EQ\n\ninstance POrd Bool where\n  type Compare 'False 'False = 'EQ\n  type
  Compare 'False 'True  = 'LT\n  type Compare 'True  'False = 'GT\n  type Compare
  'True  'True  = 'EQ\n\ninstance SOrd Bool where\n  sCompare :: forall (x :: a) (y
  :: a). Sing x -> Sing y -> Sing (Compare x y)\n  sCompare SFalse SFalse = SEQ\n
  \ sCompare SFalse STrue  = SLT\n  sCompare STrue  SFalse = SGT\n  sCompare STrue
  \ STrue  = SEQ\n```\n\nThe only interesting bit here is the instance signature.
  It's not necessary\nin such a simple scenario, but more complicated functions need
  to refer to\nscoped type variables, which the instance signature can bring into
  scope.\nThe defaults all just work.\n\nOn names\n--------\n\nThe `singletons` library
  has to produce new names for the new constructs it\ngenerates. Here are some examples
  showing how this is done:\n\n1. original datatype: `Nat`\n\n   promoted kind: `Nat`\n\n
  \  singleton type: `SNat` (which is really a synonym for `Sing`)\n\n\n2. original
  datatype: `/\\`\n\n   promoted kind: `/\\`\n\n   singleton type: `%/\\`\n\n\n3.
  original constructor: `Succ`\n\n   promoted type: `'Succ` (you can use `Succ` when
  unambiguous)\n\n   singleton constructor: `SSucc`\n\n   symbols: `SuccSym0`, `SuccSym1`\n\n\n4.
  original constructor: `:+:`\n\n   promoted type: `':+:`\n\n   singleton constructor:
  `:%+:`\n\n   symbols: `:+:@#@$`, `:+:@#@$$`, `:+:@#@$$$`\n\n\n5. original value:
  `pred`\n\n   promoted type: `Pred`\n\n   singleton value: `sPred`\n\n   symbols:
  `PredSym0`, `PredSym1`\n\n\n6. original value: `+`\n\n   promoted type: `+`\n\n
  \  singleton value: `%+`\n\n   symbols: `+@#@$`, `+@#@$$`, `+@#@$$$`\n\n\n7. original
  class: `Num`\n\n   promoted class: `PNum`\n\n   singleton class: `SNum`\n\n\n8.
  original class: `~>`\n\n   promoted class: `#~>`\n\n   singleton class: `%~>`\n\n\nSpecial
  names\n-------------\n\nThere are some special cases, listed below (with asterisks\\*
  denoting special\ntreatment):\n\n1. original datatype: `[]`\n\n   promoted kind:
  `[]`\n\n   singleton type\\*: `SList`\n\n\n2. original constructor: `[]`\n\n   promoted
  type: `'[]`\n\n   singleton constructor\\*: `SNil`\n\n   symbols\\*: `NilSym0`\n\n\n3.
  original constructor: `:`\n\n   promoted type: `':`\n\n   singleton constructor\\*:
  `SCons`\n\n   symbols: `:@#@$`, `:@#@$$`, `:@#@$$$`\n\n\n4. original datatype: `(,)`\n\n
  \  promoted kind: `(,)`\n\n   singleton type\\*: `STuple2`\n\n\n5. original constructor:
  `(,)`\n\n   promoted type: `'(,)`\n\n   singleton constructor\\*: `STuple2`\n\n
  \  symbols\\*: `Tuple2Sym0`, `Tuple2Sym1`, `Tuple2Sym2`\n\n   All tuples (including
  the 0-tuple, unit) are treated similarly.\n\n\n6. original value: `___foo`\n\n   promoted
  type\\*: `US___foo` (\"`US`\" stands for \"underscore\")\n\n   singleton value\\*:
  `___sfoo`\n\n   symbols\\*: `US___fooSym0`\n\n   All functions that begin with leading
  underscores are treated similarly.\n\nIf desired, you can pick your own naming conventions
  by using the\n`Data.Singletons.TH.Options` module. Here is an example of how this
  module can\nbe used to prefix a singled data constructor with `MyS` instead of `S`:\n\n```hs\nimport
  Control.Monad.Trans.Class\nimport Data.Singletons.TH\nimport Data.Singletons.TH.Options\nimport
  Language.Haskell.TH (Name, mkName, nameBase)\n\n$(let myPrefix :: Name -> Name\n
  \     myPrefix name = mkName (\"MyS\" ++ nameBase name) in\n\n      withOptions
  defaultOptions{singledDataConName = myPrefix} $\n      singletons $ lift [d| data
  T = MkT |])\n```\n\nSupported Haskell constructs\n----------------------------\n\n##
  Full support\n\nThe following constructs are fully supported:\n\n* variables\n*
  tuples\n* constructors\n* if statements\n* infix expressions and types\n* `_` patterns\n*
  aliased patterns\n* lists (including list comprehensions)\n* `do`-notation\n* sections\n*
  undefined\n* error\n* class constraints (though these sometimes fail with `let`,
  `lambda`, and `case`)\n* literals (for `Nat` and `Symbol`), including overloaded
  number literals\n* unboxed tuples (which are treated as normal tuples)\n* pattern
  guards\n* case\n* let\n* lambda expressions\n* `!` and `~` patterns (silently but
  successfully ignored during promotion)\n* class and instance declarations\n* signatures
  (e.g., `(x :: Maybe a)`) in expressions\n* `InstanceSigs`\n\n## Partial support\n\nThe
  following constructs are partially supported:\n\n* `deriving`\n* finite arithmetic
  sequences\n* records\n* signatures (e.g., `(x :: Maybe a)`) in patterns\n* functional
  dependencies\n* type families\n\nSee the following sections for more details.\n\n###
  `deriving`\n\n`singletons` is slightly more conservative with respect to `deriving`
  than GHC is.\nThe only classes that `singletons` can derive without an explicit
  deriving\nstrategy are the following stock classes:\n\n* `Eq`\n* `Ord`\n* `Show`\n*
  `Bounded`\n* `Enum`\n* `Functor`\n* `Foldable`\n* `Traversable`\n\nTo do anything
  more exotic, one must explicitly indicate one's intentions by\nusing the `DerivingStrategies`
  extension. `singletons` fully supports the\n`anyclass` strategy as well as the `stock`
  strategy (at least, for the classes\nlisted above). `singletons` does not support
  the `newtype` or `via` strategies,\nas there is no equivalent of `coerce` at the
  type level.\n\n### Finite arithmetic sequences\n\n`singletons` has partial support
  for arithmetic sequences (which desugar to\nmethods from the `Enum` class under
  the hood). _Finite_ sequences (e.g.,\n[0..42]) are fully supported. However, _infinite_
  sequences (e.g., [0..]),\nwhich desugar to calls to `enumFromTo` or `enumFromThenTo`,
  are not supported,\nas these would require using infinite lists at the type level.\n\n###
  Records\n\nRecord selectors are promoted to top-level functions, as there is no
  record\nsyntax at the type level. Record selectors are also singled to top-level\nfunctions
  because embedding records directly into singleton data constructors\ncan result
  in surprising behavior (see\n[this bug report](https://github.com/goldfirere/singletons/issues/364)
  for more\ndetails on this point). TH-generated code is not affected by this limitation\nsince
  `singletons` desugars away most uses of record syntax. On the other hand,\nit is
  not possible to write out code like\n`SIdentity { sRunIdentity = SIdentity STrue
  }` by hand.\n\n### Signatures in patterns\n\n`singletons` can promote basic pattern
  signatures, such as in the following\nexamples:\n\n```hs\nf :: forall a. a -> a\nf
  (x :: a) = (x :: a)\n\ng :: forall a. a -> a\ng (x :: b) = (x :: b) -- b is the
  same as a\n```\n\nWhat does /not/ work are more advanced uses of pattern signatures
  that take\nadvantage of the fact that type variables in pattern signatures can alias
  other\ntypes. Here are some examples of functions that one cannot promote:\n\n*
  ```hs\n  h :: a -> a -> a\n  h (x :: a) (_ :: b) = x\n  ```\n\n  This typechecks
  by virtue of the fact that `b` aliases `a`. However, the same\n  trick does not
  work when `h` is promoted to a type family, as a type family\n  would consider `a`
  and `b` to be distinct type variables.\n* ```hs\n  i :: Bool -> Bool\n  i (x ::
  a) = x\n  ```\n\n  This typechecks by virtue of the fact that `a` aliases `Bool`.
  Again, this\n  would not work at the type level, as a type family would consider
  `a` to be\n  a separate type from `Bool`.\n\n### Functional dependencies\n\nInference
  dependent on functional dependencies is unpredictably bad. The\nproblem is that
  a use of an associated type family tied to a class with\nfundeps doesn't provoke
  the fundep to kick in. This is GHC's problem, in\nthe end.\n\n### Type families\n\nPromoting
  functions with types that contain type families is likely to fail due to\n[GHC#12564](https://gitlab.haskell.org/ghc/ghc/issues/12564).\nNote
  that promoting type family _declarations_ is fine\n(and often desired, since that
  produces defunctionalization symbols for them).\n\n## Support for promotion, but
  not singling\n\nThe following constructs are supported for promotion but not singleton
  generation:\n\n* data constructors with contexts\n* overlapping patterns\n* `GADTs`\n*
  instances of poly-kinded type classes\n\nSee the following sections for more details.\n\n###
  Data constructors with contexts\n\nFor example, the following datatype does not
  single:\n\n```haskell\ndata T a where\n  MkT :: Show a => a -> T a\n```\n\nConstructors
  like these do not interact well with the current design of the\n`SingKind` class.
  But see\n[this bug report](https://github.com/goldfirere/singletons/issues/150),
  which\nproposes a redesign for `SingKind` (in a future version of GHC with certain\nbugfixes)
  which could permit constructors with equality constraints.\n\n### Overlapping patterns\n\nNote
  that overlapping patterns are sometimes not obvious. For example, the\n`filter`
  function does not single due to overlapping patterns:\n\n```haskell\nfilter :: (a
  -> Bool) -> [a] -> [a]\nfilter _pred []    = []\nfilter pred (x:xs)\n  | pred x
  \        = x : filter pred xs\n  | otherwise      = filter pred xs\n```\n\nOverlap
  is caused by `otherwise` catch-all guard, which is always true and thus\noverlaps
  with `pred x` guard.\n\nAnother non-obvious source of overlapping patterns comes
  from partial pattern\nmatches in `do`-notation. For example:\n\n```haskell\nf ::
  [()]\nf = do\n  Just () <- [Nothing]\n  return ()\n```\n\nThis has overlap because
  the partial pattern match desugars to the following:\n\n```haskell\nf :: [()]\nf
  = case [Nothing] of\n      Just () -> return ()\n      _ -> fail \"Partial pattern
  match in do notation\"\n```\n\nHere, it is more evident that the catch-all pattern
  `_` overlaps with the\none above it.\n\n### `GADTs`\n\nSingling GADTs is likely
  to fail due to the generated `SingKind` instances\nnot typechecking. (See\n[#150](https://github.com/goldfirere/singletons/issues/150)).\nHowever,
  one can often work around the issue by suppressing the generation\nof `SingKind`
  instances by using custom `Options`. See the `T150` test case\nfor an example.\n\n###
  Instances of poly-kinded type classes\n\nSingling instances of poly-kinded type
  classes is likely to fail due to\n[#358](https://github.com/goldfirere/singletons/issues/358).\nHowever,
  one can often work around the issue by using `InstanceSigs`. For\ninstance, the
  following code will not single:\n\n```haskell\nclass C (f :: k -> Type) where\n
  \ method :: f a\n\ninstance C [] where\n  method = []\n```\n\nAdding a type signature
  for `method` in the `C []` is sufficient\nto work around the issue, though:\n\n```haskell\ninstance
  C [] where\n  method :: [a]\n  method = []\n```\n\n## Little to no support\n\nThe
  following constructs are either unsupported or almost never work:\n\n* scoped type
  variables\n* datatypes that store arrows, `Nat`, or `Symbol`\n* rank-n types\n*
  promoting `TypeRep`s\n* `TypeApplications`\n\nSee the following sections for more
  details.\n\n### Scoped type variables\n\nPromoting functions that rely on the behavior
  of `ScopedTypeVariables` is very\ntricky—see\n[this GitHub issue](https://github.com/goldfirere/singletons/issues/433)
  for an\nextended discussion on the topic. This is not to say that promoting functions\nthat
  rely on `ScopedTypeVariables` is guaranteed to fail, but it is rather\nfragile.
  To demonstrate how fragile this is, note that the following function\nwill promote
  successfully:\n\n```hs\nf :: forall a. a -> a\nf x = id x :: a\n```\n\nBut this
  one will not:\n\n```hs\ng :: forall a. a -> a\ng x = id (x :: a)\n```\n\nThere are
  usually workarounds one can use instead of `ScopedTypeVariables`:\n\n1. Use pattern
  signatures:\n\n   ```hs\n   g :: forall a. a -> a\n   g (x :: a) = id (x :: a)\n
  \  ```\n2. Use local definitions:\n\n   ```hs\n   g :: forall a. a -> a\n   g x
  = id' a\n     where\n       id' :: a -> a\n       id' x = x\n   ```\n\n### Arrows,
  `Nat`, `Symbol`, and literals\n\nAs described in the promotion paper, promotion
  of datatypes that store arrows is\ncurrently impossible. So if you have a declaration
  such as\n\n```haskell\ndata Foo = Bar (Bool -> Maybe Bool)\n```\n\nyou will quickly
  run into errors.\n\nLiterals are problematic because we rely on GHC's built-in support,
  which\ncurrently is limited. Functions that operate on strings will not work because\ntype
  level strings are no longer considered lists of characters. Functions\nworking over
  integer literals can be promoted by rewriting them to use\n`Nat`. Since `Nat` does
  not exist at the term level, it will only be possible to\nuse the promoted definition,
  but not the original, term-level one.\n\nThis is the same line of reasoning that
  forbids the use of `Nat` or `Symbol`\nin datatype definitions. But, see [this bug\nreport](https://github.com/goldfirere/singletons/issues/76)
  for a workaround.\n\n### Rank-n types\n\n`singletons` does not support type signatures
  that have higher-rank types.\nMore precisely, the only types that can be promoted
  or singled are\n_vanilla_ types,  where a vanilla function type is a type that:\n\n1.
  Only uses a `forall` at the top level, if used at all. That is to say, it\n   does
  not contain any nested or higher-rank `forall`s.\n\n2. Only uses a context (e.g.,
  `c => ...`) at the top level, if used at all,\n   and only after the top-level `forall`
  if one is present. That is to say,\n   it does not contain any nested or higher-rank
  contexts.\n\n3. Contains no visible dependent quantification.\n\n### Promoting `TypeRep`s\n\nThe
  built-in Haskell promotion mechanism does not yet have a full story around\nthe
  kind `*` (the kind of types that have values). Ideally, promoting some form\nof
  `TypeRep` would yield `*`, but the implementation of `TypeRep` would have to\nbe
  updated for this to really work out. In the meantime, users who wish to\nexperiment
  with this feature have two options:\n\n1) The module `Data.Singletons.TypeRepTYPE`
  has all the definitions possible for\nmaking `*` the promoted version of `TypeRep`,
  as `TypeRep` is currently implemented.\nThe singleton associated with `TypeRep`
  has one constructor:\n\n    ```haskell\n    type instance Sing @(TYPE rep) = TypeRep\n
  \   ```\n\n    (Recall that `type * = TYPE LiftedRep`.) Note that any datatypes
  that store\n`TypeRep`s will not generally work as expected; the built-in promotion\nmechanism
  will not promote `TypeRep` to `*`.\n\n2) The module `Data.Singletons.CustomStar`
  allows the programmer to define a subset\nof types with which to work. See the Haddock
  documentation for the function\n`singletonStar` for more info.\n\n### `TypeApplications`\n\n`singletons`
  currently cannot handle promoting or singling code that uses\n`TypeApplications`
  syntax, so `singletons` will simply drop any visible type\napplications. For example,
  `id @Bool True` will be promoted to `Id True` and\nsingled to `sId STrue`. See\n[#378](https://github.com/goldfirere/singletons/issues/378)
  for a discussion\nof how `singletons` may support `TypeApplications` in the future.\n\nOn
  the other hand, `singletons` does make an effort to preserve the order of\ntype
  variables when promoting and singling certain constructors. These include:\n\n*
  Kind signatures of promoted top-level functions\n* Type signatures of singled top-level
  functions\n* Kind signatures of singled data type declarations\n* Type signatures
  of singled data constructors\n* Kind signatures of singled class declarations\n*
  Type signatures of singled class methods\n\nFor example, consider this type signature:\n\n```haskell\nconst2
  :: forall b a. a -> b -> a\n```\n\nThe promoted version of `const` will have the
  following kind signature:\n\n```haskell\ntype Const2 :: forall b a. a -> b -> a\n```\n\nThe
  singled version of `const2` will have the following type signature:\n\n```haskell\nsConst2
  :: forall b a (x :: a) (y :: a). Sing x -> Sing y -> Sing (Const x y)\n```\n\nTherefore,
  writing `const2 @T1 @T2` works just as well as writing\n`Const2 @T1 @T2` or `sConst2
  @T1 @T2`, since the signatures for `const2`, `Const2`,\nand `sConst2` all begin
  with `forall b a.`, in that order. Again, it is worth\nemphasizing that the TH machinery
  does not support promoting or singling\n`const2 @T1 @T2` directly, but you can write
  the type applications by hand if\nyou so choose.\n\n`singletons` also has limited
  support for preserving the order of type variables\nfor the following constructs:\n\n*
  Kind signatures of defunctionalization symbols.\n  The order of type variables is
  only guaranteed to be preserved if:\n\n  1. The thing being defunctionalized has
  a standalone type (or kind)\n     signature.\n  2. The type (or kind) signature
  of the thing being defunctionalized is\n     a vanilla type. (See the \"Rank-n types\"
  section above for what \"vanilla\"\n     means.)\n\n  If either of these conditions
  do not hold, `singletons` will fall back to\n  a slightly different approach to
  generating defunctionalization symbols that\n  does *not* guarantee the order of
  type variables. As an example, consider the\n  following example:\n\n  ```haskell\n
  \ data T (x :: a) :: forall b. b -> Type\n  $(genDefunSymbols [''T])\n  ```\n\n
  \ The kind of `T` is `forall a. a -> forall b. b -> Type`, which is not\n  vanilla.
  Currently, `singletons` will generate the following\n  defunctionalization symbols
  for `T`:\n\n  ```haskell\n  data TSym0 :: a ~> b ~> Type\n  data TSym1 (x :: a)
  :: b ~> Type\n  ```\n\n  In both symbols, the kind starts with `forall a b.` rather
  than quantifying\n  the `b` after the visible argument of kind `a`. These symbols
  can still be\n  useful even with this flaw, so `singletons` permits generating them\n
  \ regardless. Be aware of this drawback if you try doing something similar\n  yourself!\n\n*
  Kind signatures of promoted class methods.\n  The order of type variables will often
  \"just work\" by happy coincidence, but\n  there are some situations where this
  does not happen. Consider the following\n  class:\n\n  ```haskell\n  class C (b
  :: Type) where\n    m :: forall a. a -> b -> a\n  ```\n\n  The full type of `m`
  is `forall b. C b => forall a. a -> b -> a`, which binds\n  `b` before `a`. This
  order is preserved when singling `m`, but *not* when\n  promoting `m`. This is because
  the `C` class is promoted as follows:\n\n  ```haskell\n  class PC (b :: Type) where\n
  \   type M (x :: a) (y :: b) :: a\n  ```\n\n  Due to the way GHC kind-checks associated
  type families, the kind of `M` is\n  `forall a b. a -> b -> a`, which binds `b`
  *after* `a`. Moreover, the\n  `StandaloneKindSignatures` extension does not provide
  a way to explicitly\n  declare the full kind of an associated type family, so this
  limitation is\n  not easy to work around.\n\n  The defunctionalization symbols for
  `M` will also follow a similar\n  order of type variables:\n\n  ```haskell\n  type
  MSym0 :: forall a b. a ~> b ~> a\n  type MSym1 :: forall a b. a -> b ~> a\n  ```\n"
license-name: BSD-3-Clause
