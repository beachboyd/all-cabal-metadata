homepage: http://www.github.com/goldfirere/singletons
changelog-type: markdown
hash: e8e9cea442e37f565fab8604fe54f78c776421e54ed67ac6b4c454e11991db0b
test-bench-deps:
  base: ! '>=4.13 && <4.14'
  tasty-golden: ! '>=2.2'
  text: ! '>=1.2'
  filepath: ! '>=1.3'
  process: ! '>=1.1'
  turtle: ! '>=1.5'
  singletons: -any
  tasty: ! '>=1.2'
maintainer: Ryan Scott <ryan.gl.scott@gmail.com>
synopsis: A framework for generating singleton types
changelog: |
  Changelog for singletons project
  ================================

  2.6
  ---
  * Require GHC 8.8.
  * `Sing` has switched from a data family to a type family. This has a number of
    consequences:
    * Names like `SBool`, `SMaybe`, etc. are no longer type synonyms for
      particular instantiations of `Sing` but are instead the names of the
      singleton data types themselves. In other words, previous versions of
      `singletons` would provide this:

      ```haskell
      data instance Sing :: Bool -> Type where
        SFalse :: Sing False
        STrue  :: Sing True
      type SBool = (Sing :: Bool -> Type)
      ```

      Whereas with `Sing`-as-a-type-family, `singletons` now provides this:

      ```haskell
      data SBool :: Bool -> Type where
        SFalse :: SBool False
        STrue  :: SBool True
      type instance Sing @Bool = SBool
      ```
    * The `Sing` instance for `TYPE rep` in `Data.Singletons.TypeRepTYPE` is now
      directly defined as `type instance Sing @(TYPE rep) = TypeRep`, without the
      use of an intermediate newtype as before.
    * Due to limitations in the ways that quantified constraints and type
      families can interact
      (see [this GHC issue](https://gitlab.haskell.org/ghc/ghc/issues/14860)),
      the internals of `ShowSing` has to be tweaked in order to continue to
      work with `Sing`-as-a-type-family. One notable consequence of this is
      that `Show` instances for singleton types can no longer be derived—they
      must be written by hand in order to work around
      [this GHC bug](https://gitlab.haskell.org/ghc/ghc/issues/16365).
      This is unlikely to affect you unless you define 'Show' instances for
      singleton types by hand. For more information, refer to the Haddocks for
      `ShowSing'` in `Data.Singletons.ShowSing`.
    * GHC does not permit type class instances to mention type families, which
      means that it is no longer possible to define instances that mention the
      `Sing` type constructor. For this reason, a `WrappedSing` data type (which
      is a newtype around `Sing`) was introduced so that one can hang instances
      off of it.

      This had one noticeable effect in `singletons`
      itself: there are no longer `TestEquality Sing` or `TestCoercion Sing`
      instances. Instead, `singletons` now generates a separate
      `TestEquality`/`TestCoercion` instance for every data type that singles a
      derived `Eq` instance. In addition, the `Data.Singletons.Decide` module
      now provides top-level `decideEquality`/`decideCoercion` functions which
      provide the behavior of `testEquality`/`testCoercion`, but monomorphized
      to `Sing`. Finally, `TestEquality`/`TestCoercion` instances are provided
      for `WrappedSing`.
  * GHC's behavior surrounding kind inference for local definitions has changed
    in 8.8, and certain code that `singletons` generates for local definitions
    may no longer typecheck as a result. While we have taken measures to mitigate
    the issue on `singletons`' end, there still exists code that must be patched
    on the users' end in order to continue compiling. For instance, here is an
    example of code that stopped compiling with the switch to GHC 8.8:

    ```haskell
    replicateM_ :: (Applicative m) => Nat -> m a -> m ()
    replicateM_ cnt0 f =
        loop cnt0
      where
        loop cnt
            | cnt <= 0  = pure ()
            | otherwise = f *> loop (cnt - 1)
    ```

    This produces errors to the effect of:

    ```
    • Could not deduce (SNum k1) arising from a use of ‘sFromInteger’
      from the context: SApplicative m
      ...

    • Could not deduce (SOrd k1) arising from a use of ‘%<=’
      from the context: SApplicative m
      ...
    ```

    The issue is that GHC 8.8 now kind-generalizes `sLoop` (whereas it did not
    previously), explaining why the error message mentions a mysterious kind
    variable `k1` that only appeared after kind generalization. The solution is
    to give `loop` an explicit type signature like so:

    ```diff
    -replicateM_       :: (Applicative m) => Nat -> m a -> m ()
    +replicateM_       :: forall m a. (Applicative m) => Nat -> m a -> m ()
     replicateM_ cnt0 f =
         loop cnt0
       where
    +    loop :: Nat -> m ()
         loop cnt
             | cnt <= 0  = pure ()
             | otherwise = f *> loop (cnt - 1)
    ```

    This general approach should be sufficient to fix any type inference
    regressions that were introduced between GHC 8.6 and 8.8. If this isn't the
    case, please file an issue.
  * Due to [GHC Trac #16133](https://ghc.haskell.org/trac/ghc/ticket/16133) being
    fixed, `singletons`-generated code now requires explicitly enabling the
    `TypeApplications` extension. (The generated code was always using
    `TypeApplications` under the hood, but it's only now that GHC is detecting
    it.)
  * `Data.Singletons` now defines a family of `SingI` instances for `TyCon1`
    through `TyCon8`:

    ```haskell
    instance (forall a.    SingI a           => SingI (f a),   ...) => SingI (TyCon1 f)
    instance (forall a b. (SingI a, SingI b) => SingI (f a b), ...) => SingI (TyCon2 f)
    ...
    ```

    As a result, `singletons` no longer generates instances for `SingI` instances
    for applications of `TyCon{N}` to particular type constructors, as they have
    been superseded by the instances above.
  * Changes to `Data.Singletons.Sigma`:
    * `SSigma`, the singleton type for `Sigma`, is now defined.
    * New functions `fstSigma`, `sndSigma`, `FstSigma`, `SndSigma`, `currySigma`,
      and `uncurrySigma` have been added. A `Show` instance for `Sigma` has also
      been added.
    * `projSigma1` has been redefined to use continuation-passing style to more
      closely resemble its cousin `projSigma2`. The new type signature of
      `projSigma1` is:

      ```hs
      projSigma1 :: (forall (fst :: s). Sing fst -> r) -> Sigma s t -> r
      ```

      The old type signature of `projSigma1` can be found in the `fstSigma`
      function.
    * `Σ` has been redefined such that it is now a partial application of
      `Sigma`, like so:

      ```haskell
      type Σ = Sigma
      ```

      One benefit of this change is that one no longer needs defunctionalization
      symbols in order to partially apply `Σ`. As a result, `ΣSym0`, `ΣSym1`,
      and `ΣSym2` have been removed.
  * In line with corresponding changes in `base-4.13`, the `Fail`/`sFail` methods
    of `{P,S}Monad` have been removed in favor of new `{P,S}MonadFail` classes
    introduced in the `Data.Singletons.Prelude.Monad.Fail` module. These classes
    are also re-exported from `Data.Singletons.Prelude`.
  * Fix a bug where expressions with explicit signatures involving function types
    would fail to single.
  * The infix names `(.)` and `(!)` are no longer mapped to `(:.)` and `(:!)`,
    as GHC 8.8 learned to parse them at the type level.
  * The `Enum` instance for `SomeSing` now uses more efficient implementations of
    `enumFromTo` and `enumFromThenTo` that no longer require a `SingKind`
    constraint.

  2.5.1
  -----
  * `ShowSing` is now a type class (with a single instance) instead of a type
    synonym. This was changed because defining `ShowSing` as a type synonym
    prevents it from working well with recursive types due to an unfortunate GHC
    bug. For more information, see
    [issue #371](https://github.com/goldfirere/singletons/issues/371).
  * Add an `IsString` instance for `SomeSing`.

  2.5
  ---
  * The `Data.Promotion.Prelude.*` namespace has been removed. Use the
    corresponding modules in the `Data.Singletons.Prelude.*` namespace instead.

  * Fix a regression in which certain infix type families, such as `(++)`, `($)`,
    `(+)`, and others, did not have the correct fixities.

  * The default implementation of the `(==)` type in `PEq` was changed from
    `(Data.Type.Equality.==)` to a custom type family, `DefaultEq`. The reason
    for this change is that `(Data.Type.Equality.==)` is unable to conclude that
    `a == a` reduces to `True` for any `a`. (As a result, the previous version of
    `singletons` regressed in terms of type inference for the `PEq` instances
    for `Nat` and `Symbol`, which used that default.) On the other hand,
    `DefaultEq a a` _does_ reduce to `True` for all `a`.

  * Add `Enum Nat`, `Show Nat`, and `Show Symbol` instances to
    `Data.Singletons.TypeLits`.

  * Template Haskell-generated code may require `DataKinds` and `PolyKinds` in
    scenarios which did not previously require it:
    * `singletons` now explicitly quantifies all kind variables used in explicit
      `forall`s.
    * `singletons` now generates `a ~> b` instead of `TyFun a b -> Type` whenever
      possible.

  * Since `th-desugar` now desugars all data types to GADT syntax, Template
    Haskell-generated code may require `GADTs` in situations that didn't require
    it before.

  * Overhaul the way derived `Show` instances for singleton types works. Before,
    there was an awkward `ShowSing` class (which was essentially a cargo-culted
    version of `Show` specialized for `Sing`) that one had to create instances
    for separately. Now that GHC has `QuantifiedConstraints`, we can scrap this
    whole class and turn `ShowSing` into a simple type synonym:

    ```haskell
    type ShowSing k = forall z. Show (Sing (z :: k))
    ```

    Now, instead of generating a hand-written `ShowSing` and `Show` instance for
    each singleton type, we only generate a single (derived!) `Show` instance.
    As a result of this change, you will likely need to enable
    `QuantifiedConstraints` and `StandaloneDeriving` if you single any derived
    `Show` instances in your code.

  * The kind of the type parameter to `SingI` is no longer specified. This only
    affects you if you were using the `sing` method with `TypeApplications`. For
    instance, if you were using `sing @Bool @True` before, then you will now need
    to now use `sing @Bool` instead.

  * `singletons` now generates `SingI` instances for defunctionalization symbols
    through Template Haskell. As a result, you may need to enable
    `FlexibleInstances` in more places.

  * `genDefunSymbols` is now more robust with respect to types that use
    dependent quantification, such as:

    ```haskell
    type family MyProxy k (a :: k) :: Type where
      MyProxy k (a :: k) = Proxy a
    ```

    See the documentation for `genDefunSymbols` for limitations to this.

  * Rename `Data.Singletons.TypeRepStar` to `Data.Singletons.TypeRepTYPE`, and
    generalize the `Sing :: Type -> Type` instance to `Sing :: TYPE rep -> Type`,
    allowing it to work over more open kinds. Also rename `SomeTypeRepStar` to
    `SomeTypeRepTYPE`, and change its definition accordingly.

  * Promoting or singling a type synonym or type family declaration now produces
    defunctionalization symbols for it. (Previously, promoting or singling a type
    synonym did nothing whatsoever, and promoting or singling a type family
    produced an error.)

  * `singletons` now produces fixity declarations for defunctionalization
    symbols when appropriate.

  * Add `(%<=?)`, a singled version of `(<=?)` from `GHC.TypeNats`, as well as
    defunctionalization symbols for `(<=?)`, to `Data.Singletons.TypeLits`.

  * Add `Data.Singletons.Prelude.{Semigroup,Monoid}`, which define
    promoted and singled versions of the `Semigroup` and `Monoid` type classes,
    as well as various newtype modifiers.

    `Symbol` is now has promoted `Semigroup` and `Monoid` instances as well.
    As a consequence, `Data.Singletons.TypeLits` no longer exports `(<>)` or
    `(%<>)`, as they are superseded by the corresponding methods from
    `PSemigroup` and `SSemigroup`.

  * Add promoted and singled versions of the `Functor`, `Foldable`,
    `Traversable`, `Applicative`, `Alternative`, `Monad`, `MonadPlus`, and
    `MonadZip` classes. Among other things, this grants the ability to promote
    or single `do`-notation and list comprehensions.
    * `Data.Singletons.Prelude.List` now reexports more general
      `Foldable`/`Traversable` functions wherever possible, just as `Data.List`
      does.

  * Add `Data.Singletons.Prelude.{Const,Identity}`, which define
    promoted and singled version of the `Const` and `Identity` data types,
    respectively.

  * Promote and single the `Down` newtype in `Data.Singletons.Prelude.Ord`.

  * To match the `base` library, the promoted/singled versions of `comparing`
    and `thenCmp` are no longer exported from `Data.Singletons.Prelude`. (They
    continue to live in `Data.Singletons.Prelude.Ord`.)

  * Permit singling of expression and pattern signatures.

  * Permit promotion and singling of `InstanceSigs`.

  * `sError` and `sUndefined` now have `HasCallStack` constraints, like their
    counterparts `error` and `undefined`. The promoted and singled counterparts
    to `errorWithoutStackTrace` have also been added in case you do not want
    this behavior.

  * Add `Data.Singletons.TypeError`, which provides a drop-in replacement for
    `GHC.TypeLits.TypeError` which can be used at both the value- and type-level.

  2.4.1
  -----
  * Restore the `TyCon1`, `TyCon2`, etc. types. It turns out that the new
  `TyCon` doesn't work with kind-polymorphic tycons.

  2.4
  ---
  * Require GHC 8.4.

  * `Demote Nat` is now `Natural` (from `Numeric.Natural`) instead of `Integer`.
    In accordance with this change, `Data.Singletons.TypeLits` now exposes
    `GHC.TypeNats.natVal` (which returns a `Natural`) instead of
    `GHC.TypeLits.natVal` (which returns an `Integer`).

  * The naming conventions for infix identifiers (e.g., `(&*)`) have been overhauled.
    * Infix functions (that are not constructors) are no longer prepended with a
      colon when promoted to type families. For instance, the promoted version of
      `(&*)` is now called `(&*)` as well, instead of `(:&*)` as before.

      There is one exception to this rule: the `(.)` function, which is promoted
      as `(:.)`. The reason is that one cannot write `(.)` at the type level.
    * Singletons for infix functions are now always prepended with `%` instead of `%:`.
    * Singletons for infix classes are now always prepended with `%` instead of `:%`.
    * Singletons for infix datatypes are now always prepended with a `%`.

      (Before, there was an unspoken requirement that singling an infix datatype
      required that name to begin with a colon, and the singleton type would begin
      with `:%`. But now that infix datatype names can be things like `(+)`, this
      requirement became obsolete.)

    The upshot is that most infix names can now be promoted using the same name, and
    singled by simply prepending the name with `%`.

  * The suffix for defunctionalized names of symbolic functions (e.g., `(+)`) has
    changed. Before, the promoted type name would be suffixed with some number of
    dollar signs (e.g., `(+$)` and `(+$$)`) to indicate defunctionalization
    symbols. Now, the promoted type name is first suffixed with `@#@` and
    _then_ followed by dollar signs (e.g., `(+@#@$)` and `(+@#@$$)`).
    Adopting this conventional eliminates naming conflicts that could arise for
    functions that consisted of solely `$` symbols.

  * The treatment of `undefined` is less magical. Before, all uses of `undefined`
    would be promoted to `GHC.Exts.Any` and singled to `undefined`. Now, there is
    a proper `Undefined` type family and `sUndefined` singleton function.

  * As a consequence of not promoting `undefined` to `Any`, there is no need to
    have a special `any_` function to distinguish the function on lists. The
    corresponding promoted type, singleton function, and defunctionalization
    symbols are now named `Any`, `sAny`, and `AnySym{0,1,2}`.

  * Rework the treatment of empty data types:
    * Generated `SingKind` instances for empty data types now use `EmptyCase`
      instead of simply `error`ing.
    * Derived `PEq` instances for empty data types now return `True` instead of
      `False`. Derived `SEq` instances now return `True` instead of `error`ing.
    * Derived `SDecide` instances for empty data types now return `Proved bottom`,
      where `bottom` is a divergent computation, instead of `error`ing.

  * Add `Data.Singletons.Prelude.IsString` and `Data.Promotion.Prelude.IsString`
    modules. `IsString.fromString` is now used when promoting or singling
    string literals when the `-XOverloadedStrings` extension is enabled
    (similarly to how `Num.fromInteger` is currently used when promoting or
    singling numeric literals).

  * Add `Data.Singletons.Prelude.Void`.

  * Add promoted and singled versions of `div`, `mod`, `divMod`, `quot`, `rem`,
    and `quotRem` to `Data.Singletons.TypeLits` that utilize the efficient `Div`
    and `Mod` type families from `GHC.TypeNats`. Also add `sLog2` and
    defunctionalization symbols for `Log2` from `GHC.TypeNats`.

  * Add `(<>)` and `(%<>)`, the promoted and singled versions of `AppendSymbol`
    from `GHC.TypeLits`.

  * Add `(%^)`, the singleton version of `GHC.TypeLits.^`.

  * Add `unlines` and `unwords` to `Data.Singletons.Prelude.List`.

  * Add promoted and singled versions of `Show`, including `deriving` support.

  * Add a `ShowSing` class, which facilitates the ability to write `Show` instances
    for `Sing` instances.

  * Permit derived `Ord` instances for empty datatypes.

  * Permit standalone `deriving` declarations.

  * Permit `DeriveAnyClass` (through the `anyclass` keyword of `DerivingStrategies`)

  * Add a value-level `(@@)`, which is a synonym for `applySing`.

  * Add `Eq`, `Ord`, `Num`, `Enum`, and `Bounded` instances for `SomeSing`, which
    leverage the `SEq`, `SOrd`, `SNum`, `SEnum`, and `SBounded` instances,
    respectively, for the underlying `Sing`.

  * Rework the `Sing (a :: *)` instance in `Data.Singletons.TypeRepStar` such
    that it now uses type-indexed `Typeable`. The new `Sing` instance is now:

    ```haskell
    newtype instance Sing :: Type -> Type where
      STypeRep :: TypeRep a -> Sing a
    ```

    Accordingly, the `SingKind` instance has also been changed:

    ```haskell
    instance SingKind Type where
      type Demote Type = SomeTypeRepStar
      ...

    data SomeTypeRepStar where
      SomeTypeRepStar :: forall (a :: *). !(TypeRep a) -> SomeTypeRepStar
    ```

    Aside from cleaning up some implementation details, this change assures
    that `toSing` can only be called on `TypeRep`s whose kind is of kind `*`.
    The previous implementation did not enforce this, which could lead to
    segfaults if used carelessly.

  * Instead of `error`ing, the `toSing` implementation in the `SingKind (k1 ~> k2)`
    instance now works as one would expect (provided the user adheres to some
    common-sense `SingKind` laws, which are now documented).

  * Add a `demote` function, which is a convenient shorthand for `fromSing sing`.

  * Add a `Data.Singletons.Sigma` module with a `Sigma` (dependent pair) data type.

  * Export defunctionalization symbols for `Demote`, `SameKind, `KindOf`, `(~>)`,
    `Apply`, and `(@@)` from `Data.Singletons`.

  * Add an explicitly bidirectional pattern synonym `Sing`. Pattern
    matching on `Sing` brings a `SingI ty` constraint into scope from a
    singleton `Sing ty`.

  * Add an explicitly bidirectional pattern synonym `FromSing`. Pattern
    matching on any demoted (base) type gives us the corresponding
    singleton.

  * Add explicitly bidirectional pattern synonyms
    `SLambda{2..8}`. Pattern matching on any defunctionalized singleton
    yields a term-level Haskell function on singletons.

  * Remove the family of `TyCon1`, `TyCon2`, ..., in favor of just `TyCon`.
    GHC 8.4's type system is powerful enough to allow this nice simplification.

  2.3
  ---
  * Documentation clarifiation in `Data.Singletons.TypeLits`, thanks to @ivan-m.

  * `Demote` was no longer a convenient way of calling `DemoteRep` and has been
  removed. `DemoteRep` has been renamed `Demote`.

  * `DemoteRep` is now injective.

  * Demoting a `Symbol` now gives `Text`. This is motivated by making `DemoteRep`
    injective. (If `Symbol` demoted to `String`, then there would be a conflict
    between demoting `[Char]` and `Symbol`.)

  * Generating singletons also now generates fixity declarations for the singletonized
    definitions, thanks to @int-index.

  * Though more an implementation detail: singletons no longer uses kind-level proxies anywhere,
    thanks again to @int-index.

  * Support for promoting higher-kinded type variables, thanks for @int-index.

  * `Data.Singletons.TypeLits` now exports defunctionalization symbols for `KnownNat`
  and `KnownSymbol`.

  * Better type inference support around constraints, as tracked in Issue #176.

  * Type synonym definitions are now ignored, as they should be.

  * `Show` instances for `SNat` and `SSymbol`, thanks to @cumber.

  * The `singFun` and `unSingFun` functions no longer use proxies, preferring
    `TypeApplications`.

  2.2
  ---
  * With `TypeInType`, we no longer kind `KProxy`. @int-index has very helpfully
  removed the use of `KProxy` from `singletons`.

  * Drop support for GHC 7.x.

  * Remove `bugInGHC`. That function was intended to work around GHC's difficulty
  in detecting exhaustiveness of GADT pattern matches. GHC 8 comes with a much
  better exhaustiveness checker, and so this function is no longer necessary.

  2.1
  ---
  * Require `th-desugar` >= 1.6

  * Work with GHC 8. GHC 8 gives the opportunity to simplify some pieces of
  singletons, but these opportunities are not yet fully realized. For example,
  injective type families means that we no longer need `Sing` to be a data
  family; it could be a type family. This might drastically simplify the way
  functions are singletonized. But not yet!

  * `singletons` now outputs a few more type/kind annotations to help GHC do
  type inference. There may be a few more programs accepted than before.
  (This is the fix for #136.)

  2.0.1
  -----
   * Lots more functions in `Data.Singletons.Prelude.List`:
     `filter`, `find`, `elemIndex`, `elemIndices`, `findIndex`, `findIndices`,
     `intersect`, `intersectBy`, `takeWhile`, `dropWhile`, `dropWhileEnd`,
     `span`, `break`, `take`, `drop`, `splitAt`, `group`, `maximum`,
     `minimum`, `insert`, `sort`, `groupBy`, `lookup`, `partition`,
     `sum`, `product`, `length`, `replicate`, `transpose`, `(!!)`,
     `nub`, `nubBy`, `unionBy`, `union`, `genericLength`

  2.0.0.2
  -------
   * Fix fixity of `*`.

  2.0.0.1
  -------
   * Make haddock work.

  2.0
  ---

  * Instance promotion now works properly -- it was quite buggy in 1.0.

  * Classes and instances can now be singletonized.

  * Limited support for functional dependencies.

  * We now have promoted and singletonized versions of `Enum`, as well as `Bounded`.

  * Deriving `Enum` is also now supported.

  * Ditto for `Num`, which includes an instance for `Nat`, naturally.

  * Promoting a literal number now uses overloaded literals at the type level,
  using a type-level `FromInteger` in the type-level `Num` class.

  * Better support for dealing with constraints. Some previously-unsingletonizable
  functions that have constrained parameters now work.

  * No more orphan `Quasi` instances!

  * Support for functions of arity 8 (instead of the old limit, 7).

  * Full support for fixity declarations.

  * A raft of bugfixes.

  * Drop support for GHC 7.8. You must have GHC 7.10.2.

  1.1.2.1
  -------

  Fix bug #116, thus allowing locally-declared symbols to be used in GHC 7.10.

  1.1.2
  -----

  * No more GHC 7.8.2 support -- you must have GHC 7.8.3.

  1.1.1
  -----

  Update testsuite to work with th-desugar-1.5.2. No functional changes.

  1.1
  ---

  This is a maintenance release to support building (but *not* testing, due to
  GHC bug #10058) with 7.10. This release also targets th-desugar-1.5. Some
  types changed (using th-desugar's new `DsMonad` instead of `Quasi`), but
  clients generally won't need to make any changes, unless they, too, generalize
  over `Quasi`.

  1.0
  ---

  This is a complete rewrite of the package.

  * A much wider array of surface syntax is now accepted for promotion
  and singletonization, including `let`, `case`, partially-applied functions,
  and anonymous functions, `where`, sections, among others.

  * Classes and instances can be promoted (but not singletonized).

  * Derivation of promoted instances for `Ord` and `Bounded`.

  This release can be seen as a "technology preview". More features are coming
  soon.

  This version drops GHC 7.6 support.

  0.10.0
  ------

  Template Haskell names are now more hygienic. In other words, `singletons`
  won't try to gobble up something happened to be named `Sing` in your project.
  (Note that the Template Haskell names are not *completely* hygienic; names
  generated during singleton generation can still cause conflicts.)

  If a function to be promoted or singletonized is missing a type signature,
  that is now an *error*, not a warning.

  Added a new external module Data.Singletons.TypeLits, which contain the
  singletons for GHC.TypeLits. Some convenience functions are also provided.

  The extension `EmptyCase` is no longer needed. This caused pain when trying
  to support both GHC 7.6.3 and 7.8.

  0.9.3
  -----

  Fix export list of Data.Singletons.TH, again again.

  Add `SEq` instances for `Nat` and `Symbol`.

  0.9.2
  -----

  Fix export list of Data.Singletons.TH, again.

  0.9.1
  -----

  Fix export list of Data.Singletons.TH.

  0.9.0
  -----

  Make compatible with GHC HEAD, but HEAD reports core lint errors sometimes.

  Change module structure significantly. If you want to derive your own
  singletons, you should import `Data.Singletons.TH`. The module
  `Data.Singletons` now exports functions only for the *use* of singletons.

  New modules `Data.Singletons.Bool`, `...Maybe`, `...Either`, and `...List`
  are just like their equivalents from `Data.`, except for `List`, which is
  quite lacking in features.

  For singleton equality, use `Data.Singletons.Eq`.

  For propositional singleton equality, use `Data.Singletons.Decide`.

  New module `Data.Singletons.Prelude` is meant to mirror the Haskell Prelude,
  but with singleton definitions.

  Streamline representation of singletons, resulting in *exponential* speedup
  at execution. (This has not been rigorously measured, but the data structures
  are now *exponentially* smaller.)

  Add internal support for TypeLits, because the TypeLits module no longer
  exports singleton definitions.

  Add support for existential singletons, through the `toSing` method of
  `SingKind`.

  Remove the `SingE` class, bundling its functionality into `SingKind`.
  Thus, the `SingRep` synonym has also been removed.

  Name change: `KindIs` becomes `KProxy`.

  Add support for singletonizing calls to `error`.

  Add support for singletonizing empty data definitions.

  0.8.6
  -----

  Make compatible with GHC HEAD, but HEAD reports core lint errors sometimes.

  0.8.5
  -----

  Bug fix to make singletons compatible with GHC 7.6.1.

  Added git info to cabal file.

  0.8.4
  -----

  Update to work with latest version of GHC (7.7.20130114).

  Now use branched type family instances to allow for promotion of functions
  with overlapping patterns.

  Permit promotion of functions with constraints by omitting constraints.

  0.8.3
  -----

  Update to work with latest version of GHC (7.7.20121031).

  Removed use of Any to simulate kind classes; now using KindOf and OfKind
  from GHC.TypeLits.

  Made compatible with GHC.TypeLits.

  0.8.2
  -----

  Added this changelog

  Update to work with latest version of GHC (7.6.1). (There was a change to
  Template Haskell).

  Moved library into Data.Singletons.

  0.8.1
  -----

  Update to work with latest version of GHC. (There was a change to
  Template Haskell).

  Updated dependencies in cabal to include the newer version of TH.

  0.8
  ---

  Initial public release
basic-deps:
  base: ! '>=4.13 && <4.14'
  text: ! '>=1.2'
  syb: ! '>=0.4'
  containers: ! '>=0.5'
  th-desugar: ! '>=1.10 && <1.11'
  mtl: ! '>=2.2.1'
  transformers: ! '>=0.5.2'
  ghc-boot-th: -any
  pretty: -any
  template-haskell: -any
all-versions:
- '0.8'
- 0.8.1
- 0.8.2
- 0.8.3
- 0.8.4
- 0.8.5
- 0.8.6
- 0.9.0
- 0.9.1
- 0.9.2
- 0.9.3
- 0.10.0
- '1.0'
- '1.1'
- 1.1.1
- 1.1.2
- 1.1.2.1
- '2.0'
- 2.0.0.1
- 2.0.0.2
- 2.0.1
- '2.1'
- '2.2'
- '2.3'
- 2.3.1
- '2.4'
- 2.4.1
- '2.5'
- 2.5.1
- '2.6'
author: Richard Eisenberg <rae@cs.brynmawr.edu>, Jan Stolarek <jan.stolarek@p.lodz.pl>
latest: '2.6'
description-type: markdown
description: "singletons 2.6\n==============\n\n[![Hackage](https://img.shields.io/hackage/v/singletons.svg)](http://hackage.haskell.org/package/singletons)\n[![Build
  Status](https://travis-ci.org/goldfirere/singletons.svg?branch=master)](https://travis-ci.org/goldfirere/singletons)\n\nThis
  is the README file for the singletons library. This file contains all the\ndocumentation
  for the definitions and functions in the library.\n\nThe singletons library was
  written by Richard Eisenberg, <rae@cs.brynmawr.edu>, and\nwith significant contributions
  by Jan Stolarek, <jan.stolarek@p.lodz.pl>.  There\nare two papers that describe
  the library. Original one, _Dependently typed\nprogramming with singletons_, is
  available\n[here](https://cs.brynmawr.edu/~rae/papers/2012/singletons/paper.pdf)
  and will\nbe referenced in this documentation as the \"singletons paper\". A follow-up\npaper,
  _Promoting Functions to Type Families in Haskell_, is available\n[here](https://cs.brynmawr.edu/~rae/papers/2014/promotion/promotion.pdf)\nand
  will be referenced in this documentation as the\n\"promotion paper\".\n\nRyan Scott,
  <ryan.gl.scott@gmail.com>, is an active maintainer.\n\nPurpose of the singletons
  library\n---------------------------------\n\nThe library contains a definition
  of _singleton types_, which allow programmers\nto use dependently typed techniques
  to enforce rich constraints among the types\nin their programs. See the singletons
  paper for a more thorough introduction.\n\nThe package also allows _promotion_ of
  term-level functions to type-level\nequivalents. Accordingly, it exports a Prelude
  of promoted and singletonized\nfunctions, mirroring functions and datatypes found
  in Prelude, `Data.Bool`,\n`Data.Maybe`, `Data.Either`, `Data.Tuple` and `Data.List`.
  See the promotion\npaper for a more thorough introduction.\n\n[This blog series](https://blog.jle.im/entry/introduction-to-singletons-1.html),\nauthored
  by Justin Le, offers a tutorial for this library that assumes no\nknowledge of dependent
  types.\n\nCompatibility\n-------------\n\nThe singletons library requires GHC 8.8.1
  or greater. Any code that uses the\nsingleton generation primitives needs to enable
  a long list of GHC\nextensions. This list includes, but is not necessarily limited
  to, the\nfollowing:\n\n* `DataKinds`\n* `DefaultSignatures`\n* `EmptyCase`\n* `ExistentialQuantification`\n*
  `FlexibleContexts`\n* `FlexibleInstances`\n* `GADTs`\n* `InstanceSigs`\n* `KindSignatures`\n*
  `NoStarIsType`\n* `PolyKinds`\n* `RankNTypes`\n* `ScopedTypeVariables`\n* `TemplateHaskell`\n*
  `TypeApplications`\n* `TypeFamilies`\n* `TypeOperators`\n* `UndecidableInstances`\n\nIn
  particular, `NoStarIsType` is needed to use the `*` type family from the\n`PNum`
  class because with `StarIsType` enabled, GHC thinks `*` is a synonym\nfor `Type`.\n\nYou
  may also want\n\n* `-Wno-redundant-constraints`\n\nas the code that `singletons`
  generates uses redundant constraints, and there\nseems to be no way, without a large
  library redesign, to avoid this.\n\nModules for singleton types\n---------------------------\n\n`Data.Singletons`
  exports all the basic singletons definitions. Import this\nmodule if you are not
  using Template Haskell and wish only to define your\nown singletons.\n\n`Data.Singletons.TH`
  exports all the definitions needed to use the Template\nHaskell code to generate
  new singletons.\n\n`Data.Singletons.Prelude` re-exports `Data.Singletons` along
  with singleton\ndefinitions for various Prelude types. This module provides a singletonized\nequivalent
  of the real `Prelude`. Note that not all functions from original\n`Prelude` could
  be turned into singletons.\n\n`Data.Singletons.Prelude.*` modules provide singletonized
  equivalents of\ndefinitions found in the following `base` library modules: `Data.Bool`,\n`Data.Maybe`,
  `Data.Either`, `Data.List`, `Data.Tuple`, `Data.Void` and\n`GHC.Base`. We also provide
  singletonized `Eq`, `Ord`, `Show`, `Enum`, and\n`Bounded` typeclasses.\n\n`Data.Singletons.Decide`
  exports type classes for propositional equality.\n\n`Data.Singletons.TypeLits` exports
  definitions for working with `GHC.TypeLits`.\n\nModules for function promotion\n------------------------------\n\nModules
  in `Data.Promotion` namespace provide functionality required for\nfunction promotion.
  They mostly re-export a subset of definitions from\nrespective `Data.Singletons`
  modules.\n\n`Data.Promotion.TH` exports all the definitions needed to use the Template\nHaskell
  code to generate promoted definitions.\n\n`Data.Promotion.Prelude` and `Data.Promotion.Prelude.*`
  modules re-export all\npromoted definitions from respective `Data.Singletons.Prelude`\nmodules.
  `Data.Promotion.Prelude.List` adds a significant amount of functions\nthat couldn't
  be singletonized but can be promoted. Some functions still don't\npromote - these
  are documented in the source code of the module. There is also\n`Data.Promotion.Prelude.Bounded`
  module that provides promoted `PBounded`\ntypeclass.\n\nFunctions to generate singletons\n--------------------------------\n\nThe
  top-level functions used to generate singletons are documented in the\n`Data.Singletons.TH`
  module. The most common case is just calling `singletons`,\nwhich I'll describe
  here:\n\n```haskell\nsingletons :: Q [Dec] -> Q [Dec]\n```\n\nGenerates singletons
  from the definitions given. Because singleton generation\nrequires promotion, this
  also promotes all of the definitions given to the\ntype level.\n\nUsage example:\n\n```haskell\n$(singletons
  [d|\n  data Nat = Zero | Succ Nat\n  pred :: Nat -> Nat\n  pred Zero = Zero\n  pred
  (Succ n) = n\n  |])\n```\n\nDefinitions used to support singletons\n--------------------------------------\n\nPlease
  refer to the singletons paper for a more in-depth explanation of these\ndefinitions.
  Many of the definitions were developed in tandem with Iavor Diatchki.\n\n```haskell\ntype
  family Sing :: k -> Type\n```\n\nThe type family of singleton types. A new instance
  of this type family is\ngenerated for every new singleton type.\n\n```haskell\nclass
  SingI (a :: k) where\n  sing :: Sing a\n```\n\nA class used to pass singleton values
  implicitly. The `sing` method produces\nan explicit singleton value.\n\n```haskell\ndata
  SomeSing k where\n  SomeSing :: Sing (a :: k) -> SomeSing k\n```\n\nThe `SomeSing`
  type wraps up an _existentially-quantified_ singleton. Note that\nthe type parameter
  `a` does not appear in the `SomeSing` type. Thus, this type\ncan be used when you
  have a singleton, but you don't know at compile time what\nit will be. `SomeSing
  Thing` is isomorphic to `Thing`.\n\n```haskell\nclass SingKind k where\n  type Demote
  k :: *\n  fromSing :: Sing (a :: k) -> Demote k\n  toSing   :: Demote k -> SomeSing
  k\n```\n\nThis class is used to convert a singleton value back to a value in the\noriginal,
  unrefined ADT. The `fromSing` method converts, say, a\nsingleton `Nat` back to an
  ordinary `Nat`. The `toSing` method produces\nan existentially-quantified singleton,
  wrapped up in a `SomeSing`.\nThe `Demote` associated\nkind-indexed type family maps
  the kind `Nat` back to the type `Nat`.\n\n```haskell\ndata SingInstance (a :: k)
  where\n  SingInstance :: SingI a => SingInstance a\nsingInstance :: Sing a -> SingInstance
  a\n```\n\nSometimes you have an explicit singleton (a `Sing`) where you need an
  implicit\none (a dictionary for `SingI`). The `SingInstance` type simply wraps a
  `SingI`\ndictionary, and the `singInstance` function produces this dictionary from
  an\nexplicit singleton. The `singInstance` function runs in constant time, using\na
  little magic.\n\n\nEquality classes\n----------------\n\nThere are two different
  notions of equality applicable to singletons: Boolean\nequality and propositional
  equality.\n\n* Boolean equality is implemented in the type family `(:==)` (which
  is actually\na synonym for the type family `(==)` from `Data.Type.Equality`) and
  the class\n`SEq`. See the `Data.Singletons.Prelude.Eq` module for more information.\n\n*
  Propositional equality is implemented through the constraint `(~)`, the type\n`(:~:)`,
  and the class `SDecide`. See modules `Data.Type.Equality` and\n`Data.Singletons.Decide`
  for more information.\n\nWhich one do you need? That depends on your application.
  Boolean equality has\nthe advantage that your program can take action when two types
  do _not_ equal,\nwhile propositional equality has the advantage that GHC can use
  the equality\nof types during type inference.\n\nInstances of `SEq`, `SDecide`,
  `TestEquality`, and `TestCoercion` are generated\nwhen `singletons` is called on
  a datatype that has `deriving Eq`. You can also\ngenerate these instances directly
  through functions exported from\n`Data.Singletons.TH`.\n\n\n`Show` classes\n--------------\n\nPromoted
  and singled versions of the `Show` class (`PShow` and `SShow`,\nrespectively) are
  provided in the `Data.Singletons.Prelude.Show` module. In\naddition, there is a
  `ShowSing` constraint synonym provided in the\n`Data.Singletons.ShowSing` module:\n\n```haskell\ntype
  ShowSing k = (forall z. Show (Sing (z :: k))\n```\n\nThis facilitates the ability
  to write `Show` instances for `Sing` instances.\n\nWhat distinguishes all of these
  `Show`s? Let's use the `False` constructor as\nan example. If you used the `PShow
  Bool` instance, then the output of calling\n`Show_` on `False` is `\"False\"`, much
  like the value-level `Show Bool` instance\n(similarly for the `SShow Bool` instance).
  However, the `Show (Sing (z :: Bool))`\ninstance (i.e., `ShowSing Bool`) is intended
  for printing the value of the\n_singleton_ constructor `SFalse`, so calling `show
  SFalse` yields `\"SFalse\"`.\n\nInstance of `PShow`, `SShow`, and `Show` (for the
  singleton type) are generated\nwhen `singletons` is called on a datatype that has
  `deriving Show`. You can also\ngenerate these instances directly through functions
  exported from\n`Data.Singletons.TH`.\n\nA promoted and singled `Show` instance is
  provided for `Symbol`, but it is only\na crude approximation of the value-level
  `Show` instance for `String`. On the\nvalue level, showing `String`s escapes special
  characters (such as double\nquotes), but implementing this requires pattern-matching
  on character literals,\nsomething which is currently impossible at the type level.
  As a consequence, the\ntype-level `Show` instance for `Symbol`s does not do any
  character escaping.\n\nErrors\n------\n\nThe `singletons` library provides two different
  ways to handle errors:\n\n* The `Error` type family, from `Data.Singletons.TypeLits`:\n\n
  \ ```haskell\n  type family Error (str :: a) :: k where {}\n  ```\n\n  This is simply
  an empty, closed type family, which means that it will fail\n  to reduce regardless
  of its input. The typical use case is giving it a\n  `Symbol` as an argument, so
  that something akin to\n  `Error \"This is an error message\"` appears in error
  messages.\n* The `TypeError` type family, from `Data.Singletons.TypeError`. This
  is a\n  drop-in replacement for `TypeError` from `GHC.TypeLits` which can be used\n
  \ at both the type level and the value level (via the `typeError` function).\n\n
  \ Unlike `Error`, `TypeError` will result in an actual compile-time error\n  message,
  which may be more desirable depending on the use case.\n\nPre-defined singletons\n----------------------\n\nThe
  singletons library defines a number of singleton types and functions\nby default:\n\n*
  `Bool`\n* `Maybe`\n* `Either`\n* `Ordering`\n* `()`\n* tuples up to length 7\n*
  lists\n\nThese are all available through `Data.Singletons.Prelude`. Functions that\noperate
  on these singletons are available from modules such as `Data.Singletons.Bool`\nand
  `Data.Singletons.Maybe`.\n\nPromoting functions\n-------------------\n\nFunction
  promotion allows to generate type-level equivalents of term-level\ndefinitions.
  Almost all Haskell source constructs are supported -- see last\nsection of this
  README for a full list.\n\nPromoted definitions are usually generated by calling
  `promote` function:\n\n```haskell\n$(promote [d|\n  data Nat = Zero | Succ Nat\n
  \ pred :: Nat -> Nat\n  pred Zero = Zero\n  pred (Succ n) = n\n  |])\n```\n\nEvery
  promoted function and data constructor definition comes with a set of\nso-called
  \"symbols\". These are required to represent partial application at the\ntype level.
  Each function gets N+1 symbols, where N is the arity. Symbols\nrepresent application
  of between 0 to N arguments. When calling any of the\npromoted definitions it is
  important refer to it using their symbol\nname. Moreover, there is new function
  application at the type level represented\nby `Apply` type family. Symbol representing
  arity X can have X arguments passed\nin using normal function application. All other
  parameters must be passed by\ncalling `Apply`.\n\nUsers also have access to `Data.Promotion.Prelude`
  and its submodules (`Base`,\n`Bool`, `Either`, `List`, `Maybe` and `Tuple`). These
  provide promoted versions\nof function found in GHC's base library.\n\nNote that
  GHC resolves variable names in Template Haskell quotes. You cannot\nthen use an
  undefined identifier in a quote, making idioms like this not\nwork:\n```haskell\ntype
  family Foo a where ...\n$(promote [d| ... foo x ... |])\n```\nIn this example, `foo`
  would be out of scope.\n\nRefer to the promotion paper for more details on function
  promotion.\n\nClasses and instances\n---------------------\n\nThis is best understood
  by example. Let's look at a stripped down `Ord`:\n\n```haskell\nclass Eq a => Ord
  a where\n  compare :: a -> a -> Ordering\n  (<)     :: a -> a -> Bool\n  x < y =
  case x `compare` y of\n            LT -> True\n\t    EQ -> False\n\t    GT -> False\n```\n\nThis
  class gets promoted to a \"kind class\" thus:\n\n```haskell\nclass PEq a => POrd
  a where\n  type Compare (x :: a) (y :: a) :: Ordering\n  type (:<)    (x :: a) (y
  :: a) :: Bool\n  type x :< y = ... -- promoting `case` is yucky.\n```\n\nNote that
  default method definitions become default associated type family\ninstances. This
  works out quite nicely.\n\nWe also get this singleton class:\n\n```haskell\nclass
  SEq a => SOrd a where\n  sCompare :: forall (x :: a) (y :: a). Sing x -> Sing y
  -> Sing (Compare x y)\n  (%:<)    :: forall (x :: a) (y :: a). Sing x -> Sing y
  -> Sing (x :< y)\n\n  default (%:<) :: forall (x :: a) (y :: a).\n                   ((x
  :< y) ~ {- RHS from (:<) above -})\n\t\t=> Sing x -> Sing y -> Sing (x :< y)\n  x
  %:< y = ...  -- this is a bit yucky too\n```\n\nNote that a singletonized class
  needs to use `default` signatures, because\ntype-checking the default body requires
  that the default associated type\nfamily instance was used in the promoted class.
  The extra equality constraint\non the default signature asserts this fact to the
  type checker.\n\nInstances work roughly similarly.\n\n```haskell\ninstance Ord Bool
  where\n  compare False False = EQ\n  compare False True  = LT\n  compare True  False
  = GT\n  compare True  True  = EQ\n\ninstance POrd Bool where\n  type Compare 'False
  'False = 'EQ\n  type Compare 'False 'True  = 'LT\n  type Compare 'True  'False =
  'GT\n  type Compare 'True  'True  = 'EQ\n\ninstance SOrd Bool where\n  sCompare
  :: forall (x :: a) (y :: a). Sing x -> Sing y -> Sing (Compare x y)\n  sCompare
  SFalse SFalse = SEQ\n  sCompare SFalse STrue  = SLT\n  sCompare STrue  SFalse =
  SGT\n  sCompare STrue  STrue  = SEQ\n```\n\nThe only interesting bit here is the
  instance signature. It's not necessary\nin such a simple scenario, but more complicated
  functions need to refer to\nscoped type variables, which the instance signature
  can bring into scope.\nThe defaults all just work.\n\nOn names\n--------\n\nThe
  singletons library has to produce new names for the new constructs it\ngenerates.
  Here are some examples showing how this is done:\n\n1. original datatype: `Nat`\n\n
  \  promoted kind: `Nat`\n\n   singleton type: `SNat` (which is really a synonym
  for `Sing`)\n\n\n2. original datatype: `/\\`\n\n   promoted kind: `/\\`\n\n   singleton
  type: `%/\\`\n\n\n3. original constructor: `Succ`\n\n   promoted type: `'Succ` (you
  can use `Succ` when unambiguous)\n\n   singleton constructor: `SSucc`\n\n   symbols:
  `SuccSym0`, `SuccSym1`\n\n\n4. original constructor: `:+:`\n\n   promoted type:
  `':+:`\n\n   singleton constructor: `:%+:`\n\n   symbols: `:+:@#@$`, `:+:@#@$$`,
  `:+:@#@$$$`\n\n\n5. original value: `pred`\n\n   promoted type: `Pred`\n\n   singleton
  value: `sPred`\n\n   symbols: `PredSym0`, `PredSym1`\n\n\n6. original value: `+`\n\n
  \  promoted type: `+`\n\n   singleton value: `%+`\n\n   symbols: `+@#@$`, `+@#@$$`,
  `+@#@$$$`\n\n\n7. original class: `Num`\n\n   promoted class: `PNum`\n\n   singleton
  class: `SNum`\n\n\n8. original class: `~>`\n\n   promoted class: `#~>`\n\n   singleton
  class: `%~>`\n\n\nSpecial names\n-------------\n\nThere are some special cases,
  listed below (with asterisks\\* denoting special\ntreatment):\n\n1. original datatype:
  `[]`\n\n   promoted kind: `[]`\n\n   singleton type\\*: `SList`\n\n\n2. original
  constructor: `[]`\n\n   promoted type: `'[]`\n\n   singleton constructor\\*: `SNil`\n\n
  \  symbols\\*: `NilSym0`\n\n\n3. original constructor: `:`\n\n   promoted type:
  `':`\n\n   singleton constructor\\*: `SCons`\n\n   symbols: `:@#@$`, `:@#@$$`, `:@#@$$$`\n\n\n4.
  original datatype: `(,)`\n\n   promoted kind: `(,)`\n\n   singleton type\\*: `STuple2`\n\n\n5.
  original constructor: `(,)`\n\n   promoted type: `'(,)`\n\n   singleton constructor\\*:
  `STuple2`\n\n   symbols\\*: `Tuple2Sym0`, `Tuple2Sym1`, `Tuple2Sym2`\n\n   All tuples
  (including the 0-tuple, unit) are treated similarly.\n\n\n6. original value: `___foo`\n\n
  \  promoted type\\*: `US___foo` (\"`US`\" stands for \"underscore\")\n\n   singleton
  value\\*: `___sfoo`\n\n   symbols\\*: `US___fooSym0`\n\n   All functions that begin
  with leading underscores are treated similarly.\n\nSupported Haskell constructs\n----------------------------\n\nThe
  following constructs are fully supported:\n\n* variables\n* tuples\n* constructors\n*
  if statements\n* infix expressions and types\n* `_` patterns\n* aliased patterns\n*
  lists (including list comprehensions)\n* `do`-notation\n* sections\n* undefined\n*
  error\n* deriving `Eq`, `Ord`, `Show`, `Bounded`, `Enum`, `Functor`, `Foldable`,
  and\n  `Traversable`, as well as the `stock` and `anyclass` deriving strategies\n*
  class constraints (though these sometimes fail with `let`, `lambda`, and `case`)\n*
  literals (for `Nat` and `Symbol`), including overloaded number literals\n* unboxed
  tuples (which are treated as normal tuples)\n* records\n* pattern guards\n* case\n*
  let\n* lambda expressions\n* `!` and `~` patterns (silently but successfully ignored
  during promotion)\n* class and instance declarations\n* scoped type variables\n*
  signatures (e.g., `(x :: Maybe a)`) in expressions and patterns\n* `InstanceSigs`\n*
  higher-kinded type variables (see below)\n* finite arithmetic sequences (see below)\n*
  functional dependencies (with limitations -- see below)\n* type families (with limitations
  -- see below)\n\nHigher-kinded type variables in `class`/`data` declarations must
  be annotated\nexplicitly. This is due to GHC's handling of *complete\nuser-specified
  kind signatures*, or [CUSKs](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#complete-user-supplied-kind-signatures-and-polymorphic-recursion).\nBriefly,
  `singletons` has a hard\ntime conforming to the precise rules that GHC imposes around
  CUSKs and so\nneeds a little help around kind inference here. See\n[this pull request](https://github.com/goldfirere/singletons/pull/171)
  for more\nbackground.\n\n`singletons` is slightly more conservative with respect
  to `deriving` than GHC is.\nThe stock classes listed above (`Eq`, `Ord`, `Show`,
  `Bounded`, `Enum`, `Functor`,\n`Foldable`, and `Traversable`) are the only ones
  that `singletons` will derive\nwithout an explicit deriving strategy. To do anything
  more exotic, one must\nexplicitly indicate one's intentions by using the `DerivingStrategies`
  extension.\n\n`singletons` fully supports the `anyclass` strategy as well as the
  `stock` strategy\n(at least, for the classes listed above). `singletons` does not
  support the\n`newtype` strategy, as there is not an equivalent of `coerce` at the
  type level.\n\n`singletons` has partial support for arithmetic sequences (which
  desugar to\nmethods from the `Enum` class under the hood). _Finite_ sequences (e.g.,\n[0..42])
  are fully supported. However, _infinite_ sequences (e.g., [0..]),\nwhich desugar
  to calls to `enumFromTo` or `enumFromThenTo`, are not supported,\nas these would
  require using infinite lists at the type level.\n\nThe following constructs are
  supported for promotion but not singleton generation:\n\n* datatypes with constructors
  which have contexts. For example, the following\n  datatype does not singletonize:\n\n
  \   ```haskell\n    data T a where\n      MkT :: Show a => a -> T a\n    ```\n\n
  \ Constructors like these do not interact well with the current design of the\n
  \ `SingKind` class. But see\n  [this bug report](https://github.com/goldfirere/singletons/issues/150),
  which\n  proposes a redesign for `SingKind` (in a future version of GHC with certain\n
  \ bugfixes) which could permit constructors with equality constraints.\n\n* overlapping
  patterns. Note that overlapping patterns are\n  sometimes not obvious. For example,
  the `filter` function does not\n  singletonize due\n  to overlapping patterns:\n\n
  \   ```haskell\n    filter :: (a -> Bool) -> [a] -> [a]\n    filter _pred []    =
  []\n    filter pred (x:xs)\n      | pred x         = x : filter pred xs\n      |
  otherwise      = filter pred xs\n    ```\n  Overlap is caused by `otherwise` catch-all
  guard, which is always true and thus\noverlaps with `pred x` guard.\n\n  Another
  non-obvious source of overlapping patterns comes from partial pattern\n  matches
  in `do`-notation. For example:\n\n    ```haskell\n    f :: [()]\n    f = do\n      Just
  () <- [Nothing]\n      return ()\n    ```\n\n  This has overlap because the partial
  pattern match desugars to the following:\n\n    ```haskell\n    f :: [()]\n    f
  = case [Nothing] of\n          Just () -> return ()\n          _ -> fail \"Partial
  pattern match in do notation\"\n    ```\n\n  Here, it is more evident that the catch-all
  pattern `_` overlaps with the\n  one above it.\n\nThe following constructs are not
  supported:\n\n* datatypes that store arrows, `Nat`, or `Symbol`\n* literals (limited
  support)\n\nWhy are these out of reach?\n\nAs described in the promotion paper,
  promotion of datatypes that store arrows is\ncurrently impossible. So if you have
  a declaration such as\n\n```haskell\ndata Foo = Bar (Bool -> Maybe Bool)\n```\n\nyou
  will quickly run into errors.\n\nLiterals are problematic because we rely on GHC's
  built-in support, which\ncurrently is limited. Functions that operate on strings
  will not work because\ntype level strings are no longer considered lists of characters.
  Function\nworking on integer literals can be promoted by rewriting them to use\n`Nat`.
  Since `Nat` does not exist at the term level it will only be possible to\nuse the
  promoted definition, but not the original, term-level one.\n\nThis is the same line
  of reasoning that forbids the use of `Nat` or `Symbol`\nin datatype definitions.
  But, see [this bug\nreport](https://github.com/goldfirere/singletons/issues/76)
  for a workaround.\n\nSupport for `*`\n---------------\n\nThe built-in Haskell promotion
  mechanism does not yet have a full story around\nthe kind `*` (the kind of types
  that have values). Ideally, promoting some form\nof `TypeRep` would yield `*`, but
  the implementation of `TypeRep` would have to\nbe updated for this to really work
  out. In the meantime, users who wish to\nexperiment with this feature have two options:\n\n1)
  The module `Data.Singletons.TypeRepTYPE` has all the definitions possible for\nmaking
  `*` the promoted version of `TypeRep`, as `TypeRep` is currently implemented.\nThe
  singleton associated with `TypeRep` has one constructor:\n\n    ```haskell\n    type
  instance Sing @(TYPE rep) = TypeRep\n    ```\n\n    (Recall that `type * = TYPE
  LiftedRep`.) Note that any datatypes that store\n`TypeRep`s will not generally work
  as expected; the built-in promotion\nmechanism will not promote `TypeRep` to `*`.\n\n2)
  The module `Data.Singletons.CustomStar` allows the programmer to define a subset\nof
  types with which to work. See the Haddock documentation for the function\n`singletonStar`
  for more info.\n\nKnown bugs\n----------\n\n* Record updates don't singletonize\n*
  Inference dependent on functional dependencies is unpredictably bad. The\n  problem
  is that a use of an associated type family tied to a class with\n  fundeps doesn't
  provoke the fundep to kick in. This is GHC's problem, in\n  the end.\n* Singled
  code that contains uses type families is likely to fail due to GHC\n  Trac #12564.
  Note that singling type family declarations themselves is fine\n  (and often desired,
  since that produces defunctionalization symbols for them).\n* Singling instances
  of poly-kinded type classes is likely to fail due to\n  [#358](https://github.com/goldfirere/singletons/issues/358).\n
  \ However, one can often work around the issue by using `InstanceSigs`. For\n  instance,
  the following code will not single:\n\n  ```haskell\n  class C (f :: k -> Type)
  where\n    method :: f a\n\n  instance C [] where\n    method = []\n  ```\n\n  Adding
  a type signature for `method` in the `C []` is sufficient\n  to work around the
  issue, though:\n\n  ```haskell\n  instance C [] where\n    method :: [a]\n    method
  = []\n  ```\n"
license-name: BSD-3-Clause
