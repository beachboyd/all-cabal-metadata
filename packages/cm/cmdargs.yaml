homepage: https://github.com/ndmitchell/cmdargs#readme
changelog-type: text
hash: 76cf238367e669833929dd264b4fc2278145ddf5b743624f2d5558cca16a08a9
test-bench-deps: {}
maintainer: Neil Mitchell <ndmitchell@gmail.com>
synopsis: Command line argument processing
changelog: ! "Changelog for CmdArgs\n\n0.10.20, released 2018-01-22\n    #54, use
  the getopt data types from base\n0.10.19, released 2018-01-01\n    #47, ensure Semigroup
  instance on all GHC versions\n0.10.18, released 2017-09-24\n    #47, GHC 8.4 compatibility\n0.10.17,
  released 2017-03-31\n    Add processValueIO for more controlled error messages\n
  \   #529, don't include the stack trace in processValue\n0.10.16, released 2017-03-22\n
  \   Minor improvement to error messages\n0.10.15, released 2017-03-06\n    #43,
  GHC 8.2 compatibility\n0.10.14, released 2016-02-16\n    #39, ensure correct line
  breaks in HTML help output\n    #18, preserve manual \\n in help messages\n    #25,
  reformat the README\n0.10.13, released 2015-05-22\n    #24, support Ratio in some
  places\n0.10.12, released 2014-10-27\n    GHC 7.2 compatibility\n0.10.11, released
  2014-10-12\n    #15, never put [brackets] around optional args in Explicit\n0.10.10,
  released 2014-09-18\n    #14, fix @ file arguments\n0.10.9, released 2014-07-22\n
  \   #10, fix versionArgs (broken in 0.10.8)\n0.10.8, released 2014-07-21\n    Avoid
  compilation warnings on GHC 7.8\n    #9, add --numeric-version flag\n    Update
  the copyright year\n    Change GetOpt.usageInfo to be more like GetOpt\n0.10.7,
  released 2013-12-09\n    #1, fix timestamps in .tar.gz dist file\n0.10.6, released
  2013-12-05\n    #625, more documentation about args/argPos\n    #626, ensure initial
  lists don't get reversed (fix after #610)\n0.10.5, released 2013-07-29\n    #615,
  support lists inside a newtype\n0.10.4, released 2013-06-26\n    #610, make sure
  it is O(n) to append arguments, not O(n^2)\n0.10.3, released 2013-04-05\n    Append
  list items under an enum\n    Support &= ignore on enum fields\n0.10.2, released
  2013-02-28\n    Relax upper bounds to be GHC 7.7 compatible\n0.10.1, released 2012-11-17\n
  \   #569, set the test program to off by default\n\tComplete revamp of cmdargs-browser,
  far better Javascript\n    Add a missing case for Helper marshalling FlagNone\n0.10,
  released 2012-08-09\n    Revert to 0.9.6, including modeExpandAt\n0.9.7, released
  2012-08-09\n    Revert to 0.9.5, to fix up PVP breakage\n0.9.6, released 2012-07-29\n
  \   #539, hopefully more fixes to compiling in profile mode\n    #522, add modeExpandAt
  and noAtExpand annotation\n    #522, don't @expand after --\n0.9.5, released 2012-03-25\n
  \   Don't specify TH extension unless quotation is true\n0.9.4, released 2012-03-25\n
  \   #539, specify the TH extension in the Cabal file\n    Allow transformers 0.3.*\n
  \   Correct copyright in license and cabal file\n0.9.3, released 2012-02-10\n    Add
  expandArgsAt and support for @ flag file directives\n0.9.2, released 2012-01-07\n
  \   Don't build the test program if quotation is turned off\n0.9.1, released 2012-01-05\n
  \   Improve the documentation for the Explicit module\n    #433, propagate groupname
  on modes in the Implicit code\n0.9, released 2011-11-05\n    #467, add completions
  for people running bash\n    #334, add a Quote module, to write pure in the impure
  syntax\n    #482, fix the sample in Explicit, don't use def\n    #461, fix the translation
  for enum/enum_\n    Make showHelp take an argument for the prefix bits\n    Add
  Helper interface, and initial cmdargs-browser code\n    Add splitArgs/joinArgs\n0.8,
  released 2011-08-13\n    #450, redo the manual generator so Maker example is not
  cut off\n    Support all the types in Data.Int/Data.Word\n    Make modeArgs take
  a list of arguments as well\n0.7, released 2011-05-07\n    No changes, just a version
  bump to allow requiring the GHC fix\n0.6.10, released 2011-05-07\n    Change the
  annotate module to cope better with GHC's CSE\n0.6.9, released 2011-04-03\n    #422,
  support newtype value as the underlying type\n0.6.8, released 2011-02-13\n    Allow
  versionArgs [summary] to override --version\n    Improve the documentation surrounding
  opt\n    Add modeReform to Mode\n    Add modeEmpty, to construct blank Mode values\n
  \   Improve the documentation surrounding pure annotations.\n0.6.7, released 2011-01-15\n
  \   #395, don't put two newlines after --help or --version\n0.6.6, released 2010-12-30\n
  \   #392, support helpArgs [groupname \"something\"]\n0.6.5, released 2010-12-15\n
  \   Don't fail with ambiguous enum if you exactly match a value\n    Put errors
  on stderr\n0.6.4, released 2010-11-20\n    Eliminate the filepath dependence\n0.6.3,
  released 2010-11-10\n    Switch mtl for transformers\n0.6.2, released 2010-11-10\n
  \   Build on GHC 7.0 RC2, add an extra type signature\n    Add verbosityArgs to
  customise the verbose/quiet flags\n    Add helpArg/versionArg flags to customise
  those flags\n    Support multiline summary using \\n escape codes\n0.6.1, released
  2010-10-04\n    Build on GHC 6.10, don't rely on record name disambiguation\n0.6,
  released 2010-09-18\n    Add ignore annotation for modes and flags\n    #350, make
  top-level help appear properly\n0.5, released 2010-09-15\n    #351, name/explicit
  attributes on mode were broken (regression)\n0.4, released 2010-09-05\n    #342,
  display common fields only once\n    Raise errors if annotations are placed in invalid
  places\n    Rewrite the translation of annotation to explicit modes\n    Treat anything
  after -- as an argument\n    Add a pure annotation mechanism\n    Introduce System.Console.CmdArgs.Annotate\n0.3,
  released 2010-08-23\n    Add a documentation example for the Explicit mode\n    Improve
  the purity and annotations a bit, try disabling CSE\n    Change the help format\n
  \   Rename groupHiden to groupHidden, patch from Matthew Cox\n    Bug, missing fields
  and explicit enums didn't work together\n0.2, released 2010-08-14\n    #252, add
  support for grouped flags/modes\n    #333, support missing fields\n    Add support
  for reading tuple values (including nested)\n    #292, add support for automatic
  enumerations\n    #221, make argpos work with non-string fields\n    #222, support
  opt and args together\n    #230, different modes can share short flags\n    #295,
  make verbosity flags explicit\n    #231, add support for Maybe\n    #256, add --option=false
  support\n    Complete rewrite to introduce Explicit module\n0.1, released 2009-09-12\n
  \   Start of changelog\n"
basic-deps:
  base: ! '>=4.4 && <5'
  filepath: -any
  process: ! '>=1.0'
  transformers: ! '>=0.2'
  template-haskell: -any
all-versions:
- '0.1'
- '0.2'
- '0.3'
- '0.4'
- '0.5'
- '0.6'
- '0.6.1'
- '0.6.2'
- '0.6.3'
- '0.6.4'
- '0.6.5'
- '0.6.6'
- '0.6.7'
- '0.6.8'
- '0.6.9'
- '0.6.10'
- '0.7'
- '0.8'
- '0.9'
- '0.9.1'
- '0.9.2'
- '0.9.3'
- '0.9.4'
- '0.9.5'
- '0.9.6'
- '0.9.7'
- '0.10'
- '0.10.1'
- '0.10.2'
- '0.10.3'
- '0.10.4'
- '0.10.5'
- '0.10.6'
- '0.10.7'
- '0.10.8'
- '0.10.9'
- '0.10.10'
- '0.10.11'
- '0.10.12'
- '0.10.13'
- '0.10.14'
- '0.10.15'
- '0.10.16'
- '0.10.17'
- '0.10.18'
- '0.10.19'
- '0.10.20'
author: Neil Mitchell <ndmitchell@gmail.com>
latest: '0.10.20'
description-type: markdown
description: ! "# CmdArgs: Easy Command Line Processing [![Hackage version](https://img.shields.io/hackage/v/cmdargs.svg?label=Hackage)](https://hackage.haskell.org/package/cmdargs)
  [![Build Status](https://img.shields.io/travis/ndmitchell/cmdargs.svg)](https://travis-ci.org/ndmitchell/cmdargs)\n\nCmdArgs
  is a Haskell library for defining command line parsers. The two features that make
  it a better choice than the standard [getopt library](http://haskell.org/ghc/docs/latest/html/libraries/base/System-Console-GetOpt.html)
  are:\n\n* It's very concise to use. The HLint command line handling is three times
  shorter with CmdArgs.\n* It supports programs with multiple modes, such as [darcs](http://darcs.net)
  or [Cabal](http://haskell.org/cabal/).\n\nA very simple example of a command line
  processor is:\n```haskell\ndata Sample = Sample {hello :: String} deriving (Show,
  Data, Typeable)\n\nsample = Sample{hello = def &= help \"World argument\" &= opt
  \"world\"}\n         &= summary \"Sample v1\"\n\nmain = print =<< cmdArgs sample\n```\nDespite
  being very concise, this processor is already fairly well featured:\n\n    $ runhaskell
  Sample.hs --hello=world\n    Sample {hello = \"world\"}\n\n    $ runhaskell Sample.hs
  --help\n    Sample v1, (C) Neil Mitchell 2009\n\n    sample [FLAG]\n\n      -? --help[=FORMAT]
  \ Show usage information (optional format)\n      -V --version        Show version
  information\n      -v --verbose        Higher verbosity\n      -q --quiet          Lower
  verbosity\n      -h --hello=VALUE    World argument (default=world)\n\n## User Manual\n\nThe
  rest of this document explains how to write the \"hello world\" of command line
  processors, then how to extend it with features into a complex command line processor.
  Finally this document gives three samples, which the `cmdargs` program can run.
  The three samples are:\n\n* `hlint` - the [HLint](https://github.com/ndmitchell/hlint#readme)
  program.\n* `diffy` - a program to compare the differences between directories.\n*
  `maker` - a make style program.\n\nFor each example you are encouraged to look at
  it's source (in the [repo](https://github.com/ndmitchell/cmdargs/tree/master/System/Console/CmdArgs/Test/Implicit))
  and run it (try `cmdargs hlint --help`). The HLint program is fairly standard in
  terms of it's argument processing, and previously used the [System.Console.GetOpt](http://haskell.org/ghc/docs/latest/html/libraries/base/System-Console-GetOpt.html)
  library. Using GetOpt required 90 lines and a reasonable amount of duplication.
  Using CmdArgs the code requires 30 lines, and the logic is much simpler.\n\n**Acknowledgements**
  Thanks to Kevin Quick for substantial patches, and additional code contributions
  from Sebastian Fischer and Daniel Schoepe.\n\n\n## Hello World Example\n\nThe following
  code defines a complete command line argument processor:\n```haskell\n{-# LANGUAGE
  DeriveDataTypeable #-}\n{-# OPTIONS_GHC -fno-cse #-}\nmodule Sample where\nimport
  System.Console.CmdArgs\n\ndata Sample = Sample {hello :: String}\n              deriving
  (Show, Data, Typeable)\n\nsample = Sample{hello = def}\n\nmain = print =<< cmdArgs
  sample\n```\nTo use the CmdArgs library there are three steps:\n\n* Define a record
  data type (`Sample`) that contains a field for each argument. This type needs to
  have instances for `Show`, `Data` and `Typeable`.\n* Give a value of that type (`sample`)
  with default values (`def` is a default value of any type, but I could also have
  written `\"\"`). This value is turned into a command line by calling the `cmdArgs`
  function.\n* To ensure GHC evalutes attributes the right number of times we disable
  the CSE optimisation on this module.\n\nNow we have a reasonably functional command
  line argument processor. Some sample interactions are:\n\n    $ runhaskell Sample.hs
  --hello=world\n    Sample {hello = \"world\"}\n\n    $ runhaskell Sample.hs --version\n
  \   The sample program\n\n    $ runhaskell Sample.hs --help\n    The sample program\n\n
  \   sample [OPTIONS]\n\n      -? --help        Display help message\n      -V --version
  \    Print version information\n      -h --hello=ITEM\n\nCmdArgs uses defaults to
  automatically infer a command line parser for a value, and provides annotations
  to override any of the the defaults. CmdArgs automatically supports `--help` and
  `--version` flags, and optionally supports verbosity flags.\n\n## Specifying Attributes\n\nIn
  order to control the behaviour we can add attributes. For example to add an attribute
  specifying the help text for the `--hello` argument we can write:\n```haskell\nsample
  = Sample{hello = def &= help \"Who to say hello to\"}\n```\nWe can add additional
  attributes, for example to specify the type of the value expected by hello:\n```haskell\nsample
  = Sample {hello = def &= help \"Who to say hello to\" &= typ \"WORLD\"}\n```\nNow
  when running `--help` the final line is:\n\n      -h --hello=WORLD  Who to say hello
  to\n\nThere are many more attributes, detailed in the [Haddock documentation](http://hackage.haskell.org/packages/archive/cmdargs/latest/doc/html/System-Console-CmdArgs.html#2).\n\n\n##
  Multiple Modes\n\nTo specify a program with multiple modes, similar to [darcs](http://darcs.net/),
  we can supply a data type with multiple constructors, for example:\n```haskell\ndata
  Sample = Hello {whom :: String}\n            | Goodbye\n              deriving (Show,
  Data, Typeable)\n\nhello = Hello{whom = def}\ngoodbye = Goodbye\n\nmain = print
  =<< cmdArgs (modes [hello,goodbye])\n```\nCompared to the first example, we now
  have multiple constructors, and a sample value for each constructor is passed to
  `cmdArgs`. Some sample interactions with this command line are:\n\n    $ runhaskell
  Sample.hs hello --whom=world\n    Hello {whom = \"world\"}\n\n    $ runhaskell Sample.hs
  goodbye\n    Goodbye\n\n    $ runhaskell Sample.hs --help\n    The sample program\n\n
  \   sample [OPTIONS]\n\n     Common flags\n      -? --help       Display help message\n
  \     -V --version    Print version information\n\n    sample hello [OPTIONS]\n\n
  \     -w --whom=ITEM\n\n    sample goodbye [OPTIONS]\n\nAs before, the behaviour
  can be customised using attributes.\n\n\n## Larger Examples\n\nFor each of the following
  examples we first explain the purpose of the program, then give the source code,
  and finally the output of `--help`. The programs are intended to show sample uses
  of CmdArgs, and are available to experiment with through `cmdargs progname`.\n\n###
  HLint\n\nThe [HLint](https://github.com/ndmitchell/hlint#readme) program analyses
  a list of files, using various options to control the analysis. The command line
  processing is simple, but a few interesting points are:\n\n* The `--report` flag
  can be used to output a report in a standard location, but giving the flag a value
  changes where the file is output.\n* The `color` field is assigned two flag aliases,
  `--colour` and `-c`. Assigning the `-c` short flag explicitly stops either of the
  CPP fields using it.\n* The `show_` field would clash with `show` if given the expected
  name, but CmdArgs automatically strips the trailing underscore.\n* The `cpp_define`
  field has an underscore in it's name, which is transformed into a hyphen for the
  flag name.\n\nThe code is:\n```haskell\n{-# LANGUAGE DeriveDataTypeable #-}\nmodule
  HLint where\nimport System.Console.CmdArgs\n\ndata HLint = HLint\n    {report ::
  [FilePath]\n    ,hint :: [FilePath]\n    ,color :: Bool\n    ,ignore_ :: [String]\n
  \   ,show_ :: Bool\n    ,extension :: [String]\n    ,language :: [String]\n    ,utf8
  :: Bool\n    ,encoding :: String\n    ,find :: [FilePath]\n    ,test_ :: Bool\n
  \   ,datadir :: [FilePath]\n    ,cpp_define :: [String]\n    ,cpp_include :: [FilePath]\n
  \   ,files :: [FilePath]\n    }\n    deriving (Data,Typeable,Show,Eq)\n\nhlint =
  HLint\n    {report = def &= opt \"report.html\" &= typFile &= help \"Generate a
  report in HTML\"\n    ,hint = def &= typFile &= help \"Hint/ignore file to use\"\n
  \   ,color = def &= name \"c\" &= name \"colour\" &= help \"Color the output (requires
  ANSI terminal)\"\n    ,ignore_ = def &= typ \"MESSAGE\" &= help \"Ignore a particular
  hint\"\n    ,show_ = def &= help \"Show all ignored ideas\"\n    ,extension = def
  &= typ \"EXT\" &= help \"File extensions to search (defaults to hs and lhs)\"\n
  \   ,language = def &= name \"X\" &= typ \"LANG\" &= help \"Language extension (Arrows,
  NoCPP)\"\n    ,utf8 = def &= help \"Use UTF-8 text encoding\"\n    ,encoding = def
  &= typ \"ENC\" &= help \"Choose the text encoding\"\n    ,find = def &= typFile
  &= help \"Find hints in a Haskell file\"\n    ,test_ = def &= help \"Run in test
  mode\"\n    ,datadir = def &= typDir &= help \"Override the data directory\"\n    ,cpp_define
  = def &= typ \"NAME[=VALUE]\" &= help \"CPP #define\"\n    ,cpp_include = def &=
  typDir &= help \"CPP include path\"\n    ,files = def &= args &= typ \"FILES/DIRS\"\n
  \   } &=\n    verbosity &=\n    help \"Suggest improvements to Haskell source code\"
  &=\n    summary \"HLint v0.0.0, (C) Neil Mitchell\" &=\n    details [\"Hlint gives
  hints on how to improve Haskell code\",\"\"\n            ,\"To check all Haskell
  files in 'src' and generate a report type:\",\"  hlint src --report\"]\n\nmode =
  cmdArgsMode hlint\n```\nProduces the `--help` output:\n\n    HLint v0.0.0, (C) Neil
  Mitchell\n\n    hlint [OPTIONS] [FILES/DIRS]\n    Suggest improvements to Haskell
  source code\n\n    Common flags:\n      -r --report[=FILE]            Generate a
  report in HTML\n      -h --hint=FILE                Hint/ignore file to use\n      -c
  --colour --color            Color the output (requires ANSI terminal)\n      -i
  --ignore=MESSAGE            Ignore a particular hint\n      -s --show                     Show
  all ignored ideas\n         --extension=EXT            File extensions to search
  (defaults to hs and lhs)\n      -X --language=LANG            Language extension
  (Arrows, NoCPP)\n      -u --utf8                        Use UTF-8 text encoding\n
  \        --encoding=ENC                Choose the text encoding\n      -f --find=FILE
  \               Find hints in a Haskell file\n      -t --test                        Run
  in test mode\n      -d --datadir=DIR                Override the data directory\n
  \        --cpp-define=NAME[=VALUE]  CPP #define\n         --cpp-include=DIR            CPP
  include path\n      -? --help                        Display help message\n      -V
  --version                    Print version information\n      -v --verbose                    Loud
  verbosity\n      -q --quiet                    Quiet verbosity\n\n    Hlint gives
  hints on how to improve Haskell code\n\n    To check all Haskell files in 'src'
  and generate a report type:\n      hlint src --report\n\n\n### Diffy\n\nThe Diffy
  sample is a based on the idea of creating directory listings and comparing them.
  The tool can operate in two separate modes, `create` or `diff`. This sample is fictional,
  but the ideas are drawn from a real program. A few notable features:\n\n* There
  are multiple modes of execution, creating and diffing.\n* The diff mode takes exactly
  two arguments, the old file and the new file.\n* Default values are given for the
  `out` field, which are different in both modes.\n\nThe code is:\n```haskell\n{-#
  LANGUAGE DeriveDataTypeable #-}\nmodule Diffy where\nimport System.Console.CmdArgs\n\ndata
  Diffy = Create {src :: Maybe FilePath, out :: FilePath}\n           | Diff {old
  :: FilePath, new :: FilePath, out :: FilePath}\n             deriving (Data,Typeable,Show,Eq)\n\noutFlags
  x = x &= help \"Output file\" &= typFile\n\ncreate = Create\n    {src = def &= help
  \"Source directory\" &= typDir\n    ,out = outFlags \"ls.txt\"\n    } &= help \"Create
  a fingerprint\"\n\ndiff = Diff\n    {old = def &= typ \"OLDFILE\" &= argPos 0\n
  \   ,new = def &= typ \"NEWFILE\" &= argPos 1\n    ,out = outFlags \"diff.txt\"\n
  \   } &= help \"Perform a diff\"\n\nmode = cmdArgsMode $ modes [create,diff] &=
  help \"Create and compare differences\" &= program \"diffy\" &= summary \"Diffy
  v1.0\"\n```\nAnd `--help` produces:\n\n    Diffy v1.0\n\n    diffy [COMMAND] ...
  [OPTIONS]\n      Create and compare differences\n\n    Common flags:\n      -o --out=FILE
  \    Output file\n      -? --help         Display help message\n      -V --version
  \    Print version information\n\n    diffy create [OPTIONS]\n      Create a fingerprint\n\n
  \     -s  --src=DIR  Source directory\n\n    diffy diff [OPTIONS] OLDFILE NEWFILE\n
  \     Perform a diff\n\n### Maker\n\nThe Maker sample is based around a build system,
  where we can either build a project, clean the temporary files, or run a test. Some
  interesting features are:\n\n* The build mode is the default, so `maker` on it's
  own will be interpreted as a build command.\n* The build method is an enumeration.\n*
  The `threads` field is in two of the constructors, but not all three. It is given
  the short flag `-j`, rather than the default `-t`.\n\nThe code is:\n```haskell\n{-#
  LANGUAGE DeriveDataTypeable #-}\nmodule Maker where\nimport System.Console.CmdArgs\n\ndata
  Method = Debug | Release | Profile\n              deriving (Data,Typeable,Show,Eq)\n\ndata
  Maker\n    = Wipe\n    | Test {threads :: Int, extra :: [String]}\n    | Build {threads
  :: Int, method :: Method, files :: [FilePath]}\n      deriving (Data,Typeable,Show,Eq)\n\nthreadsMsg
  x = x &= help \"Number of threads to use\" &= name \"j\" &= typ \"NUM\"\n\nwipe
  = Wipe &= help \"Clean all build objects\"\n\ntest_ = Test\n    {threads = threadsMsg
  def\n    ,extra = def &= typ \"ANY\" &= args\n    } &= help \"Run the test suite\"\n\nbuild
  = Build\n    {threads = threadsMsg def\n    ,method = enum\n        [Release &=
  help \"Release build\"\n        ,Debug &= help \"Debug build\"\n        ,Profile
  &= help \"Profile build\"]\n    ,files = def &= args\n    } &= help \"Build the
  project\" &= auto\n\nmode = cmdArgsMode $ modes [build,wipe,test_]\n     &= help
  \"Build helper program\"\n     &= program \"maker\"\n     &= summary \"Maker v1.0\\nMake
  it\"\n```\nAnd `--help` produces:\n\n    Maker v1.0\n      Make it\n\n    maker
  [COMMAND] ... [OPTIONS]\n      Build helper program\n\n    Common flags:\n      -?
  --help     Display help message\n      -V --version  Print version information\n\n
  \   maker [build] [OPTIONS] [ITEM]\n      Build the project\n\n      -j --threads=NUM
  \ Number of threads to use\n      -r --release      Release build\n      -d --debug
  \       Debug build\n      -p --profile      Profile build\n\n    maker wipe [OPTIONS]\n
  \     Clean all build objects\n\n    maker test [OPTIONS] [ANY]\n      Run the test
  suite\n\n      -j --threads=NUM  Number of threads to use\n"
license-name: BSD3
