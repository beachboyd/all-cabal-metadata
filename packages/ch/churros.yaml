homepage: http://github.com/sordina/churros
changelog-type: markdown
hash: ec984e31fafc7bec44df78955b6ec12ef7a7a129e2255af8679a1c40c44a65ad
test-bench-deps:
  stm: -any
  base: '>=4.10 && <4.15'
  time: -any
  async: -any
  doctest: -any
  containers: -any
  random: -any
maintainer: lyndon@sordina.net
synopsis: Channel/Arrow based streaming computation library.
changelog: |
  # Revision history for Churros

  ## 0.1.0.4 -- 2020-10-15

  * Transport method `flex` now returns a pair of channels to move towards support for Unagi.
  * Addition of new prelude methods such as `sources`.
  * Adding README.md to Hackage contents page.

  ## 0.1.0.3 -- 2020-10-12

  * Fixed broken changelog.
  * Added `sources` combinator.

  ## 0.1.0.2 -- 2020-10-12

  * Added new prelude functions and updated to export main library.

  ## 0.1.0.1 -- 2020-10-12

  * Updated documentation.

  ## 0.1.0.0 -- 2020-10-12

  * First version. Released on an unsuspecting world.
basic-deps:
  stm: -any
  base: '>=4.10 && <4.15'
  time: -any
  async: -any
  containers: -any
  random: -any
all-versions:
- 0.1.0.0
- 0.1.0.1
- 0.1.0.2
- 0.1.0.3
- 0.1.1.0
author: Lyndon Maydwell
latest: 0.1.1.0
description-type: markdown
description: |-
  # Churros

  > Chan + Arrow = Churro

  Simple alternative to Conduit, Pipes, Streams, Machines, etc.

  Use-case is CSP like scenarios where you need a graph of actors.

  Developed from a history of attempting to use co-routines libraries for setting up complicated asynchronous processes
  such as collections of MIDI instruments, etc, but being frustrated by not easily being able to conditionally
  consume and emit events. In these situations I'd fall back on creating a bunch of Chans and piping events manually.
  Churros just formalises that strategy to help you get it right!

  Advantages over other alternatives:

  * Focus on IO processes
  * Dynamic choice of consumption/production
  * Arrow instance
  * Choice of transport via the `Transport` class

  Disadvantages:

  * No pure interface!
  * No expressive return type encoded in the Churro datatype (could this be addressed?)
  * Limited ability to perform lock-step computation (although this is by design)

  See [Hackage](https://hackage.haskell.org/package/churros-0.1.0.0/candidate) for more info!

  ## Examples

  See `./test/` directory for more extensive examples.

  ```haskell
  import Control.Churro

  main = do
     runWaitChan        $ sourceList [1..10] >>> processDebug "after source" >>> delay 1 {- seconds -} >>> arr succ >>> sinkPrint
     wait =<< run @Chan $ sourceIO (\cb -> cb 1 >> print "Doing whatever!" >> cb 5) >>> filterC (> 3) >>> sinkIO print
  ```

  ## Testing

  Cabal test-suite including doctests:

  > cabal exec cabal test

  Or for itterative development:

  > find {src,test} | entr -- cabal exec -- doctest -isrc -itest test/Churro/Test/Examples.hs

  ## TODO

  * [x] Recovery/Retry capability
  * [x] Fix await deadlock
  * [x] Generic Chan functions, then specific newtype
  * [x] Stop using list functions
  * [x] Different transport options, buffered, etc.
  * [x] Write doctests for functionality
  * [x] Get Doctests working as part of the cabal test-suite
  * [ ] Bundle in/out channels in the Transport class to allow Unagi to implement it
  * [ ] Create profunctor instance
  * [ ] Create contravariant functor instance
  * [ ] Create ArrowChoice instance
  * [ ] Create ArrowLoop instance
  * [x] Allow returning of results from run functions
  * [x] Get haddocks rendering correctly - Including contents
  * [ ] Different transports for sections of the graph
  * [ ] Allow configurable parallelism
  * [x] Early termination if downstream consumer completes
      - [x] Ensure that infinite lists work when partially consumed
license-name: MIT
