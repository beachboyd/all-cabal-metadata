homepage: https://github.com/AJChapman/formatting/blob/master/README.md
changelog-type: markdown
hash: 5a0de1fe917b04a433c22dc71ea3f155fdc282d52c758efd0adf3bfaffb11008
test-bench-deps:
  base: '>=4.11 && <5'
  time: '>=1.5'
  hspec: -any
  text: '>=0.11.0.8'
  clock: '>=0.4'
  double-conversion: ^>=2.0.2.0
  integer-gmp: '>=0.2'
  ghc-prim: -any
  formatting: -any
  old-locale: -any
  transformers: -any
  scientific: '>=0.3.0.0'
maintainer: alex@farfromthere.net
synopsis: Combinator-based type-safe formatting (like printf() or FORMAT)
changelog: |
  7.0.0.2

  * Removed unnecessary dependencies on array and bytestring
  * Actually removed code to support GHC < 8.4

  7.0.0.1

  * Added README.md to extra-source-files so it shows up on Hackage

  7.0.0

  * Introduced `Formatting.Combinators`.
  * Fixed: #62 and #60: incorrect formatting of Integral types that do not have negative values (e.g. Word)
  * Fixed: #59 rendering of floats e.g. 0.01 as "0.01" rather than "1.0e-2"
  * Added dependency of double-conversion to provide fast and correct rendering of floating-point numbers (including the fix for #59).
  * Make compatible with bytestring-0.11.0.0
  * Removed -O2 ghc flag
  * Updated .cabal file version from 1.8 to 2.4
  * Drop support for GHC < 8.4

  6.3.7

  * Introduced instance `Buildable a => Buildable [a]`.

  6.3.6

  * Bring back `int :: Integral a => Format r (a -> r)`

  6.3.5

  * Avoid pointless conversions on Float/Double.

  6.3.3

  * The `Data.Text.Format` hierarchy was reexported as
    `Formatting.Internal.Raw`.

  6.3.1

  * Proper GHC 7.10 -> GHC 8.4 support

  6.3.0

  * Folded the `text-format` package into this package, removed the
    `double-conversion` dependency. Lost the following functions in
    this:
    * `prec`
    * `expt`
  * Added a test suite with regression tests:
    * Fixed: #31
    * Fixed: #28
    * Fixed: https://github.com/bos/text-format/issues/18

  6.2.5

  * Changed microseconds to display as "us" to avoid unicode issues.

  6.2.1

  * Added bytesDecimal

  6.2.0

  * Dropped Holey/HoleyT in favour of simpler Format type.
  * Added Monoid instance.
  * Added back Category instance.
  * Dropped Functor instance.

  6.1.1

  * Add support for GHC 7.10 (time update).

  6.1.0

  * Add formatter for TimeSpec.

  6.0.0

  * Changed the type of `Format`. Now you write `Format r (a -> r)` instead
    of `Format a`.
  * Add `formatToString` function.
basic-deps:
  base: '>=4.11 && <5'
  time: '>=1.5'
  text: '>=0.11.0.8'
  clock: '>=0.4'
  double-conversion: ^>=2.0.2.0
  integer-gmp: '>=0.2'
  ghc-prim: -any
  old-locale: -any
  transformers: -any
  scientific: '>=0.3.0.0'
all-versions:
- 3.0.0
- 3.0.1
- 3.0.2
- 3.1.0
- 3.1.1
- 3.1.2
- 3.1.3
- 3.1.4
- '4.0'
- '4.1'
- '5.0'
- '5.1'
- '5.2'
- '5.3'
- '5.4'
- 6.0.0
- 6.1.0
- 6.1.1
- 6.1.2
- 6.2.0
- 6.2.1
- 6.2.2
- 6.2.3
- 6.2.4
- 6.2.5
- 6.3.0
- 6.3.1
- 6.3.2
- 6.3.4
- 6.3.5
- 6.3.6
- 6.3.7
- 7.0.0
- 7.0.0.1
- 7.0.0.2
author: Chris Done, Shachaf Ben-Kiki, Martijn van Steenbergen, Mike Meyer, Bryan O'Sullivan,
  Alex Chapman
latest: 7.0.0.2
description-type: markdown
description: "# formatting [![Build Status](https://travis-ci.org/AJChapman/formatting.png)](https://travis-ci.org/AJChapman/formatting)
  [![Hackage](https://img.shields.io/hackage/v/formatting.svg?style=flat)](https://hackage.haskell.org/package/formatting)\n\nFormatting
  is a type-safe and flexible library for formatting text from built-in or custom
  data types.\n\n- [Hackage Documentation](https://hackage.haskell.org/package/formatting)\n-
  [The original blog post introducing the library](https://chrisdone.com/posts/formatting/),
  but note that some of the types have changed: `Holey` is no longer used, and `Format`'s
  type has changed to `newtype Format r a = Format {runFormat :: (Builder -> r) ->
  a}`\n\n## Usage\n\nYou will probably need the `OverloadedStrings` language extension,
  and to import `Formatting`:\n\n```haskell\n{-# LANGUAGE OverloadedStrings #-}\n\nimport
  Formatting\n```\n\nYou may also need some or all of these:\n\n```haskell\nimport
  qualified Data.Text as T\nimport qualified Data.Text.Lazy as TL\nimport qualified
  Data.Text.Lazy.Builder as TLB\n```\n\nNow a simple example:\n\n```haskell\n> format
  (\"Person's name is \" % text % \" and age is \" % int) \"Dave\" 54\n\"Person's
  name is Dave and age is 54\"\n```\n\nIn this example, the formatters are two string
  literals (which take no arguments), and two formatters which take arguments: `text`,
  which takes a lazy `Text`,  and `int` which takes any `Integral`, such as `Int`.\nThey
  are all joined together using the `%` operator, producing a formatter which takes
  two arguments: a lazy `Text` and an `Integral`.\nIt produces a lazy `Text`, because
  we used `format`.\nTo produce other string types, or print the result instead, refer
  to this table:\n\n| To produce a  | use              |\n| ------------- | ----------------
  |\n| `TL.Text`     | `format`         |\n| `T.Text`      | `sformat`        |\n|
  `Builder`     | `bformat`        |\n| `String`      | `formatToString` |\n\nTo print
  the values instead, refer to this table:\n\n| To print to                   | use
  \             |\n| ----------------------------- | ---------------- |\n| `stdout`
  \                     | `fprint`         |\n| `stdout`, appending a newline | `fprintLn`
  \      |\n| a handle                      | `hprint`         |\n| a handle, appending
  a newline | `hprintLn`       |\n\nApart from the `%` operator, formatters can also
  be joined using the monoid append operator (`<>`) to avoid repeating the same argument,
  they can be chained using `%.`, and there are also formatter combinators for composing
  more advanced combinators.\nMore on this below.\n\n### Formatter Quick Reference\n\nBuilt-in
  formatters:\n\n| To format a                            | e.g.                     |
  as               | use                          | short form  |\n| --------------------------------------:|
  ------------------------ | ---------------- | ---------------------------- | ----------
  \ |\n|                            lazy `Text` | `\"Hello\"`                | `\"Hello\"`
  \       | `text`                       | `t`         |\n|                          strict
  `Text` | `\"World!\"`               | `\"World!\"`       | `stext`                      |
  `st`        | \n|                               `String` | `\"Goodbye\"`              |
  `\"Goodbye\"`      | `string`                     | `s`         |\n|                              `Builder`
  | `\"Bathtub\"`              | `\"Bathtub\"`      | `builder`                    |
  \            |\n|                          `Show a => a` | `[1, 2, 3]`              |
  `\"[1, 2, 3]\"`    | `shown`                      | `sh`        |\n|                                 `Char`
  | `'!'`                    | `\"!\"`            | `char`                       |
  `c`         |\n|                      `Integral a => a` | `23`                     |
  `\"23\"`           | `int`                        | `d`         |\n|                          `Real
  a => a` | `123.32`                 | `\"123.32\"`       | `float`                      |
  `sf`        |\n|                          `Real a => a` | `123.32`                 |
  `\"123.320\"`      | `fixed 3`                    | `f`         |\n|                           `Scientific`
  | `scientific 60221409 16` | `\"6.0221409e23\"` | `sci`                        |
  \            |\n|                           `Scientific` | `scientific 60221409
  16` | `\"6.022e23\"`     | `scifmt Exponent (Just 3)`   |             |\n|         `Buildable
  n, Integral n => n` | `123456`                 | `\"12.34.56\"`     | `groupInt
  2 '.'`             |             |\n|         `Buildable n, Integral n => n` | `12000`
  \                 | `\"12,000\"`       | `commas`                     |             |\n|
  \                     `Integral n => n` | `32`                     | `\"32nd\"`
  \        | `ords`                       |             |\n|                     `Num
  a, Eq a => a` | `1`                      | `\"1 ant\"`        | `int <> plural \"ant\"
  \"ants\"` |             |\n|                     `Num a, Eq a => a` | `2`                      |
  `\"2 ants\"`       | `int <> plural \"ant\" \"ants\"` |             |\n|                          `Enum
  a => a` | `a`                      | `\"97\"`           | `asInt`                      |
  \            |\n|                      `Integral a => a` | `23`                     |
  `\"10111\"`        | `bin`                        | `b`         |\n|                      `Integral
  a => a` | `23`                     | `\"0b10111\"`      | `prefixBin`                  |
  \            |\n|                      `Integral a => a` | `23`                     |
  `\"27\"`           | `oct`                        | `o`         |\n|                      `Integral
  a => a` | `23`                     | `\"0o27\"`         | `prefixOct`                  |
  \            |\n|                      `Integral a => a` | `23`                     |
  `\"17\"`           | `hex`                        | `x`         |\n|                      `Integral
  a => a` | `23`                     | `\"0x17\"`         | `prefixHex`                  |
  \            |\n|                      `Integral a => a` | `23`                     |
  `\"13\"`           | `base 20`                    |             |\n|                     `Buildable
  a => a` | `10`                     | `\"  10\"`         | `left 4 ' '`                 |
  `l`         |\n|                     `Buildable a => a` | `10`                     |
  `\"10  \"`         | `right 4 ' '`                | `r`         |\n|                     `Buildable
  a => a` | `10`                     | `\" 10 \"`         | `center 4 ' '`               |
  \            |\n|                     `Buildable a => a` |  `123456`                |
  `\"123\"`          | `fitLeft 3`                  |             |\n|                     `Buildable
  a => a` |  `123456`                | `\"456\"`          | `fitRight 3`                 |
  \            |\n|                     `Buildable a => a` |  `True`                  |
  `\"True\"`         | `build`                      |             |\n|                                    `a`
  | `undefined`              | `\"gronk!\"`       | `fconst \"gronk!\"`            |
  \            |\n\n### Formatter Combinator Quick Reference\n\nFormatter combinators
  take a formatter and modify it somehow, e.g. by using it to format elements of a
  list, or changing its output.\n\nBuilt-in formatter combinators:\n\n\n| To format
  a                              | e.g.                      | as                                  |
  use                                  |\n| ----------------------------------------:|
  ------------------------  | ----------------------------------- | -------------------------------------|\n|
  `Foldable t => t a`                      | `[1, 2, 3]`               | `\"1st2nd3rd\"`
  \                      | `concatenated ords`                  |\n| `Foldable t =>
  t a`                      | `[123, 456, 789]`         | `\"789456123\"`                       |
  `joinedWith (mconcat . reverse) int` |\n| `Foldable t => t a`                      |
  `[1, 2, 3]`               | `\"1\\|\\|2\\|\\|3\"`                     | `intercalated
  \"\\|\\|\" int`            |\n| `Foldable t => t a`                      | `[1,
  2, 3]`               | `\"1 2 3\"`                           | `unworded int`                       |\n|
  `Foldable t => t a`                      | `[1, 2, 3]`               | `\"1\\n2\\n3\"`
  \                        | `unlined d`                          |\n| `Foldable t
  => t a`                      | `[1, 2, 3]`               | `\"1 2 3\"`                           |
  `spaced int`                         |\n| `Foldable t => t a`                      |
  `[1, 2, 3]`               | `\"1,2,3\"`                           | `commaSep int`
  \                      |\n| `Foldable t => t a`                      | `[1, 2, 3]`
  \              | `\"1st, 2nd, 3rd\"`                   | `commaSpaceSep ords`                 |\n|
  `Foldable t => t a`                      | `[\"one\", \"two\", \"three\"]` | `\"[one,
  two, three]\"`               | `list t`                             |\n| `Foldable
  t => t a`                      | `[\"one\", \"two\", \"three\"]` | `\"[\\\"one\\\",
  \\\"two\\\", \\\"three\\\"]\"`   | `qlist t`                            |\n| `[a]`
  \                                   | `[1..]`                   | `\"[1, 10, 11,
  100]\"`                | `took 4 (list bin)`                  |\n| `[a]`                                    |
  `[1..6]`                  | `\"[4, 5, 6]\"`                       | `dropped 3 (list
  int)`               |\n| `a`                                      | `\"one two\\tthree\\nfour`
  \  | `\"one, two, three, four\"`           | `splat isSpace commaSpaceSep stext`
  \ |\n| `a`                                      | `1234567890`              | `\"[123,
  456, 789, 0]\"`              | `splatWith (chunksOf 3) list int`    |\n| `a`                                      |
  `\"one,two,three\"`         | `\"one\\ntwo\\nthree\\n\"`               | `splatOn
  \",\" unlined t`              |\n| `a`                                      | `\"one
  \ two three  \"`      | `\"[one, two, three]\"`               | `worded list text`
  \                  |\n| `a`                                      | `\"one\\n\\ntwo\\nthree\\n\\n`
  \ | `\"[\"one\", \"\", \"two\", \"three\", \"\"]\"` | `lined qlist text`                   |\n|
  `a`                                      | `123456`                  | `\"654321\"`
  \                         | `alteredWith TL.reverse int`         |\n| `a`                                      |
  `\"look and boot\"`         | `\"leek and beet\"`                   | `replaced
  \"oo\" \"ee\" text`            |\n| `a`                                      | `\"look
  and boot\"`         | `\"LOOK AND BOOT\"`                   | `uppercased`                         |\n|
  `a`                                      | `\"Look and Boot\"`         | `\"look
  and boot\"`                   | `lowercased`                         |\n| `a`                                      |
  `\"look and boot\"`         | `\"Look And Boot\"`                   | `titlecased`
  \                        |\n| `a`                                      | `\"hellos\"`
  \               | `\"he...\"`                           | `ltruncated 5 text`                  |\n|
  `a`                                      | `\"hellos\"`                | `\"h...s\"`
  \                          | `ctruncated`                         |\n| `a`                                      |
  `\"hellos\"`                | `\"...os\"`                           | `rtruncated
  5 text`                  |\n| `a`                                      | `1`                       |
  `\"  1\"`                             | `lpadded 3 int`                      |\n|
  `a`                                      | `1`                       | `\"1  \"`
  \                            | `rpadded 3 int`                      |\n| `a`                                      |
  `1`                       | `\" 1 \"`                             | `cpadded 3 int`
  \                     |\n| `a`                                      | `123`                     |
  `\"123 \"`                            | `lfixed 4 int`                       |\n|
  `a`                                      | `123456`                  | `\"1...\"`
  \                           | `lfixed 4 int`                       |\n| `a`                                      |
  `123`                     | `\" 123\"`                            | `rfixed 4 int`
  \                      |\n| `a`                                      | `123456`
  \                 | `\"...6\"`                            | `rfixed 4 int`                       |\n|
  `a`                                      | `123`                     | `\"  123
  \"`                          | `cfixed 2 1 ' ' int`                 |\n| `a`                                      |
  `1234567`                 | `\"12...7\"`                          | `cfixed 2 1
  ' ' int`                 |\n| `a`                                      | `\"Goo\"`
  \                  | `\"McGoo\"`                           | `prefixed \"Mc\" t`
  \                   |\n| `a`                                      | `\"Goo\"`                   |
  `\"Goosen\"`                          | `suffixed \"sen\" t`                   |\n|
  `a`                                      | `\"Goo\"`                   | `\"McGooMc\"`
  \                        | `surrounded \"Mc\" t`                  |\n| `a`                                      |
  `\"Goo\"`                   | `\"McGoosen\"`                        | `enclosed
  \"Mc\" \"sen\" t`              |\n| `a`                                      | `\"Goo\"`
  \                  | `\"'Goo'\"`                           | `squoted t`                          |\n|
  `a`                                      | `\"Goo\"`                   | `\"\\\"Goo\\\"\"`
  \                        | `dquoted t`                          |\n| `a`                                      |
  `\"Goo\"`                   | `\"(Goo)\"`                           | `parenthesised
  t`                    |\n| `a`                                      | `\"Goo\"`
  \                  | `\"[Goo]\"`                           | `squared t`                          |\n|
  `a`                                      | `\"Goo\"`                   | `\"{Goo}\"`
  \                          | `braced t`                           |\n| `a`                                      |
  `\"Goo\"`                   | `\"<Goo>\"`                           | `angled t`
  \                          |\n| `a`                                      | `\"Goo\"`
  \                  | ``\"`Goo`\"``                         | `backticked t`                       |\n|
  `a`                                      | `\"Goo\"`                   | `\"   Goo\"`
  \                         | `indented 3 t`                       |\n| `Foldable
  t => t a`                      | `[1, 2, 3]`               | `\"  1\\n  2\\n  3\"`
  \                  | `indentedLines 2 d`                  |\n| `a`                                      |
  `\"1\\n2\\n3\"`               | `\"  1\\n  2\\n  3\"`                   | `reindented
  2 t`                     |\n| `Integral i, RealFrac d => d`            | `6.66`
  \                   | `\"7\"`                               | `roundedTo int`                      |\n|
  `Integral i, RealFrac d => d`            | `6.66`                    | `\"6\"`                               |
  `truncatedTo int`                    |\n| `Integral i, RealFrac d => d`            |
  `6.66`                    | `\"7\"`                               | `ceilingedTo
  int`                    |\n| `Integral i, RealFrac d => d`            | `6.66`                    |
  `\"6\"`                               | `flooredTo int`                      |\n|
  field through a `Lens' s a`              | `(1, \"goo\")`              | `\"goo\"`
  \                            | `viewed _2 t`                        |\n| field through
  a record accessor `s -> a` | `(1, \"goo\")`              | `\"1\"`                               |
  `accessed fst d`                     |\n| `Integral a => a`                        |
  `4097`                    | `\"0b0001000000000001\"`              | `binPrefix 16`
  \                      |\n| `Integral a => a`                        | `4097`                    |
  `\"0o0000000000010001\"`              | `octPrefix 16`                       |\n|
  `Integral a => a`                        | `4097`                    | `\"0x0000000000001001\"`
  \             | `hexPrefix 16`                       |\n| `Ord f, Integral a, Fractional
  f => a`   | `1024`                    | `\"1KB\"`                             |
  `bytes shortest`                     |\n| `Ord f, Integral a, Fractional f => a`
  \  | `1234567890`              | `\"1.15GB\"`                          | `bytes
  (fixed 2)`                    |\n\n## Composing formatters\n\n`%.` is like `%` but
  feeds one formatter into another:\n\n``` haskell\nλ> format (left 2 '0' %. hex)
  10\n\"0a\"\n```\n\n## Using more than one formatter on the same argument\n\n```
  haskell\nλ> now <- getCurrentTime\nλ> format (year % \"/\" <> month <> \"/\" % dayOfMonth)
  now\n\"2015/01/27\"\n```\n\n## The Buildable Typeclass\n\nOne of the great things
  about `formatting` is that it doesn't rely on typeclasses: you can define one or
  more formatters for each of your types.\nBut you also have the option of defining
  a 'default' formatter for a type, by implementing the `Buildable` typeclass, which
  has one method: `build :: p -> Builder`.\nOnce this is defined for a type, you can
  use the `build` formatter (which is distinct from the `build` method of `Buildable`!):\n\n```haskell\n>
  format (\"Int: \" % build % \", Text: \" % build) 23 \"hello\"\n\"Int: 23, Text:
  hello\"\n```\n\nNote that while this can be convenient, it also sacrifices some
  type-safety: there's nothing preventing you from putting the arguments in the wrong
  order, because both `Int` and `Text` have a `Buildable` instance.\nNote also that
  if a type already has a `Show` instance then you can use this instead, by using
  the `shown` formatter.\n\n## Understanding the Types\n\nFormatters generally have
  a type like this:\n\n```haskell\nFormat r (a -> r)\n```\n\nThis describes a formatter
  that will eventually produce some string type `r`, and takes an `a` as an argument.\nFor
  example:\n\n```haskell\nint :: Integral a => Format r (a -> r)\n```\n\nThis takes
  an `Integral a` argument, and eventually produces an `r`.\nLet's work through using
  this with `format`:\n\n```haskell\n-- format has this type:\nformat :: Format TL.Text
  a -> a\n\n-- so in 'format int', called with an 'Int', 'int's type specialises to:\nint
  :: Format TL.Text (Int -> TL.Text)\n\n-- and 'format's 'a' parameter specialises
  to 'Int -> TL.Text':\nformat :: Format TL.Text (Int -> TL.Text) -> Int -> TL.Text\n\n--
  so 'format int' takes an Int and produces text:\nformat int :: Int -> TL.Text\n```\n\nWhat
  can be confusing in the above is that `int`'s `a` parameter expands to `Int`, but
  `format`'s `a` parameter expands to `Int -> TL.Text`.\n\nNow let's look at what
  happens when we use the `%` operator to append formatters:\n\n```haskell\n-- Here
  are the types of the functions we will use:\n(%) :: Format r a -> Format r' r ->
  Format r' a\nint :: Format r (Int -> r) -- simplified for this use\nstext :: Format
  r (T.Text -> r)\n\n-- Within the call to '%', in the expression 'int % stext', the
  type parameters expand like this:\n-- r = T.Text -> r'\n-- a = Int -> T.Text ->
  r'\n-- and so we have these types:\nint :: Format (T.Text -> r') (Int -> T.Text
  -> r')\nstext :: Format r' (T.Text -> r')\nint % stext :: Format r' (Int -> T.Text
  -> r')\n\n-- And so when we use 'format' we get a function that takes two arguments
  and produces text:\nformat (int % stext) :: Int -> T.Text -> TL.Text\n```\n\n##
  Comparison with Other Languages\n\nExample:\n\n``` haskell\nformat (\"Person's name
  is \" % text %  \", age is \" % hex) \"Dave\" 54\n```\n\nor with short-names:\n\n```
  haskell\nformat (\"Person's name is \" % t % \", age is \" % x) \"Dave\" 54\n```\n\nSimilar
  to C's `printf`:\n\n``` c\nprintf(\"Person's name is %s, age is %x\",\"Dave\",54);\n```\n\nand
  Common Lisp's `FORMAT`:\n\n``` lisp\n(format nil \"Person's name is ~a, age is ~x\"
  \"Dave\" 54)\n```\n\n## Formatter Examples\n\n### \"Hello, World!\": Texts\n\n```
  haskell\n> format (text % \"!\") \"Hi!\"\n\"Hi!!\"\n> format (string % \"!\") \"Hi!\"\n\"Hi!!\"\n```\n\n###
  123: Integers\n\n``` haskell\n> format int 23\n\"23\"\n```\n\n### 23.4: Decimals\n\n```
  haskell\n> format (fixed 0) 23.3\n\"23\"\n> format (fixed 2) 23.3333\n\"23.33\"\n>
  format shortest 23.3333\n\"23.3333\"\n> format shortest 0.0\n\"0.0\"\n> format sci
  2.3\n\"2.3\"\n> format (scifmt Fixed (Just 0)) 2.3\n\"2\"\n```\n\n### 1,242: Commas\n\n```
  haskell\n> format commas 123456778\n\"123,456,778\"\n> format commas 1234\n\"1,234\"\n```\n\n###
  1st: Ordinals\n\n``` haskell\n> format ords 1\n\"1st\"\n> format ords 2\n\"2nd\"\n>
  format ords 3\n\"3rd\"\n> format ords 4\n\"4th\"\n```\n\n### 3F: Hex\n\n``` haskell\n>
  format hex 15\n\"f\"\n> format hex 25\n\"19\"\n```\n\n### Monday 1st June: Dates
  & times\n\n``` haskell\n> now <- getCurrentTime\n> later <- getCurrentTime\n> format
  (dayOfMonth % \"/\" % month % \"/\" % year) now now now\n\"16/06/2014\"\n> format
  day now\n\"167\"\n> format hms now\n\"08:24:41\"\n> format tz now\n\"+0000\"\n>
  format datetime now\n\"Mon Jun 16 08:24:41 UTC 2014\"\n> format century now\n\"20\"\n>
  format (dayOfMonthOrd % \" of \" % monthName) now now\n\"16th of June\"\n```\n\n###
  3 years ago: Time spans\n\n``` haskell\n> format (diff False) (diffUTCTime later
  now)\n\"2 seconds\"\n> format (diff True) (diffUTCTime later now)\n\"in 2 seconds\"\n>
  format (diff True) (diffUTCTime now later)\n\"2 seconds ago\"\n> format (seconds
  0 % \" secs\") (diffUTCTime now later)\n\"2 secs\"\n```\n\n``` haskell\n> let Just
  old = parseTime defaultTimeLocale \"%Y\" \"1980\" :: Maybe UTCTime\n> format (years
  0) (diffUTCTime now old)\n\"34\"\n> format (diff True) (diffUTCTime now old)\n\"in
  35 years\"\n> format (diff True) (diffUTCTime old now)\n\"35 years ago\"\n> format
  (days 0) (diffUTCTime old now)\n\"12585\"\n> format (days 0 % \" days\") (diffUTCTime
  old now)\n\"12585 days\"\n```\n\n### File sizes\n\n``` haskell\n> format (bytes
  shortest) 1024\n\"1KB\"\n> format (bytes (fixed 2 % \" \")) (1024*1024*5)\n\"5.00
  MB\"\n```\n\n### Scientific\n\nIf you're using a type which provides its own builder,
  like the\n`Scientific` type:\n\n``` haskell\nimport Data.Text.Lazy.Builder.Scientific\nscientificBuilder
  :: Scientific -> Builder\nformatScientificBuilder :: FPFormat -> Maybe Int -> Scientific
  -> Builder\n```\n\nThen you can use `later` easily:\n\n``` haskell\n> format (later
  scientificBuilder) 23.4\n\"23.4\"\n```\n\nActually, there are now already two handy
  combinators (`sci` and\n`scifmt`) for the `Scientific` type as shown above in the
  Decimals\nsection.\n\n## Writing your own Formatters\n\nYou can include things verbatim
  in the formatter:\n\n``` haskell\n> format (now \"This is printed now.\")\n\"This
  is printed now.\"\n```\n\nAlthough with `OverloadedStrings` you can just use string
  literals:\n\n``` haskell\n> format \"This is printed now.\"\n\"This is printed now.\"\n```\n\nYou
  can handle things later which makes the formatter accept arguments:\n\n``` haskell\n>
  format (later (const \"This is printed later.\")) ()\n\"This is printed later.\"\n```\n\nThe
  type of the function passed to `later` should return an instance\nof `Monoid`.\n\n```
  haskell\nlater :: (a -> Builder) -> Format r (a -> r)\n```\n\nThe function you format
  with (`format`, `bprint`, etc.)\nwill determine the monoid of choice. In the case
  of this library, the\ntop-level formating functions expect you to build a text `Builder`:\n\n```
  haskell\nformat :: Format Text a -> a\n```\n\nBecause builders are efficient generators.\n\nSo
  in this case we will be expected to produce Builders from arguments:\n\n``` haskell\nformat
  . later :: (a -> Builder) -> a -> Text\n```\n\nTo do that for common types you can
  just re-use the formatting library\nand use bprint:\n\n``` haskell\nλ> :t bprint\nbprint
  :: Format Builder a -> a\n> :t bprint int 23\nbprint int 23 :: Builder\n```\n\nComing
  back to `later`, we can now use it to build our own printer\ncombinators:\n\n```
  haskell\n> let mint = later (maybe \"\" (bprint int))\n> :t mint\nmint :: Integral
  a => Format r (Maybe a -> r)\n```\n\nNow `mint` is a formatter to show `Maybe Integer`:\n\n```
  haskell\n> format mint (readMaybe \"23\")\n\"23\"\n> format mint (readMaybe \"foo\")\n\"\"\n```\n\nAlthough
  a better, more general combinator might be:\n\n``` haskell\n> let mfmt x f = later
  (maybe x (bprint f))\n```\n\nNow you can use it to maybe format things:\n\n``` haskell\n>
  format (mfmt \"Nope!\" int) (readMaybe \"foo\")\n\"Nope!\"\n```\n"
license-name: BSD-3-Clause
