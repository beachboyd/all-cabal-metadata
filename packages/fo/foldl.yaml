homepage: ''
changelog-type: markdown
hash: ce87f943dfd315e6fb6941ff3d3967dd28a3a63b9c24a3efc27b44d7598133ce
test-bench-deps:
  base: -any
  criterion: -any
  foldl: -any
maintainer: Gabriel439@gmail.com
synopsis: Composable, streaming, and efficient left folds
changelog: ! "1.4.4\n\n* Increase lower bound on `base`\n* Change `mean` to be more
  numerically stable\n\n1.4.3\n\n* Add `Control.Scanl.scanr`\n* Increase upper bound
  on `mwc-random`\n\n1.4.2\n\n* Add `Semigroupoid` instance for `Fold`\n* Increase
  upper bound on `contravariant` and `profunctors`\n\n1.4.1\n\n* Add `Control.Scanl`\n*
  Drop support for GHC 7.8 and older\n\n1.4.0\n\n* BREAKING CHANGE: Change type of
  `premapM` to accept a monadic function\n\n1.3.7\n\n* Add `groupBy`\n\n1.3.6\n\n*
  Documentation improvements\n\n1.3.5\n\n* Add `Choice` instance for `Fold`\n\n1.3.4\n\n*
  Add `prefilter` and `prefilterM`\n\n1.3.3\n\n* Add back the old `vector` as `vectorM`\n\n1.3.2\n\n*
  Compatibility with `Semigroup` becoming a super-class of `Monoid`\n* Fix `asin`
  for `Fold`\n\n1.3.1\n\n* Fix `asin` for `FoldM`\n\n1.3.0\n\n* BREAKING CHANGE: Change
  `vector` to be a pure `Fold` (which is faster, too!)\n\n1.2.5\n\n* Add support for
  folding new containers: `hashSet`, `map`, and `hashMap`\n* Add `prescan`/`postscan`
  which generalize `scan` to `Traversable` types\n\n1.2.4\n\n* Add `lazy` folds for
  `Text` and `ByteString`\n* Documentation fixes and improvements\n\n1.2.3\n\n* Add
  `lookup`\n\n1.2.2\n\n* Add numerically stable `mean`, `variance`, and `std` folds\n*
  Add `Control.Foldl.{Text,ByteString}.foldM`\n* Add `foldOver`/`foldOverM`\n\n1.2.1\n\n*
  Performance improvements\n* Re-export `filtered`\n\n1.2.0\n\n* Breaking change:
  Fix `handles` to fold things in the correct order (was\n  previously folding things
  backwards and also leaking space as a result).  No\n  change to behavior of `handlesM`,
  which was folding things in the right order\n* Breaking change: Change the `Monoid`
  used by `Handler`/`HandlerM`\n* Add `folded`\n\n1.1.6\n\n* Add `maximumBy` and `minimumBy`\n\n1.1.5\n\n*
  Increase lower bound on `base` from `< 4` to `< 4.5`\n\n1.1.4\n\n* Increase upper
  bound on `comonad` from `< 5` to `< 6`\n\n1.1.3\n\n* Increase upper bound on `profunctors`
  from `< 5.2` to `< 5.3`\n* Add `mapM_`, `hoists`, `purely`, and `impurely`\n\n1.1.2\n\n*
  Add `lastN`, `randomN`, `sink`, and `duplicateM`\n* Add `Comonad` instance for `Fold`\n*
  Add `Profunctor` instance for `FoldM`\n\n1.1.1\n\n* Increase upper bound on `vector`
  from `< 0.11` to `< 0.12`\n\n1.1.0\n\n* Breaking change: Rename `pretraverse`/`pretraverseM`
  to `handles`/`handlesM`\n* Add `Handler`\n* Export `EndoM`\n\n1.0.11\n\n* Add `Profunctor`
  instance for `Fold`\n\n1.0.10\n\n* Add `random` and `_Fold1`\n\n1.0.9\n\n* Increase
  upper bound on `primitive` from `< 0.6` to `< 0.7`\n\n1.0.8\n\n* Add `revList`\n\n1.0.7\n\n*
  Add `Num` and `Fractional` instances for `Fold`/`FoldM`\n* Add `count` fold for
  `Text` and `ByteString`\n\n1.0.6\n\n* Add `pretraverse` and `pretraverseM`\n\n1.0.5\n\n*
  Add `lastDef`\n\n1.0.4\n\n* Increase upper bounds on `transformers` from `< 0.4`
  to `< 0.6`\n* Add `nub`, `eqNub`, and `set`\n\n1.0.3\n\n* Add `scan`, `generalize`,
  `simplify`, and `premapM`\n\n1.0.2\n\n* Add `list` and `vector` folds\n* Add `fold`
  function for `Text` and `ByteString`\n\n1.0.1\n\n* Add support for `ByteString`
  and `Text` folds\n* Add `Monoid` instance for `Fold`/`FoldM`\n\n1.0.0\n\n* Initial
  release\n"
basic-deps:
  semigroupoids: ! '>=1.0 && <5.4'
  bytestring: ! '>=0.9.2.1 && <0.11'
  mwc-random: ! '>=0.13.1.0 && <0.15'
  base: ! '>=4.8 && <5'
  comonad: ! '>=4.0 && <6'
  unordered-containers: <0.3
  vector-builder: <0.4
  text: ! '>=0.11.2.0 && <1.3'
  semigroups: ! '>=0.17 && <1.19'
  containers: ! '>=0.5.0.0 && <0.6'
  contravariant: <1.6
  hashable: <1.3
  transformers: ! '>=0.2.0.0 && <0.6'
  primitive: <0.7
  profunctors: <5.4
  vector: ! '>=0.7 && <0.13'
all-versions:
- '1.0.0'
- '1.0.1'
- '1.0.2'
- '1.0.3'
- '1.0.4'
- '1.0.5'
- '1.0.6'
- '1.0.7'
- '1.0.8'
- '1.0.9'
- '1.0.10'
- '1.0.11'
- '1.1.0'
- '1.1.1'
- '1.1.2'
- '1.1.3'
- '1.1.4'
- '1.1.5'
- '1.1.6'
- '1.2.0'
- '1.2.1'
- '1.2.2'
- '1.2.3'
- '1.2.4'
- '1.2.5'
- '1.3.0'
- '1.3.1'
- '1.3.2'
- '1.3.3'
- '1.3.4'
- '1.3.5'
- '1.3.7'
- '1.4.0'
- '1.4.1'
- '1.4.2'
- '1.4.3'
- '1.4.4'
author: Gabriel Gonzalez
latest: '1.4.4'
description-type: markdown
description: ! "# `foldl` v1.4.4\n\nUse this `foldl` library when you want to compute
  multiple folds over a\ncollection in one pass over the data without space leaks.\n\nFor
  example, suppose that you want to simultaneously compute the sum of the list\nand
  the length of the list.  Many Haskell beginners might write something like\nthis:\n\n```haskell\nsumAndLength
  :: Num a => [a] -> (a, Int)\nsumAndLength xs = (sum xs, length xs)\n\n```\n\nHowever,
  this solution will leak space because it goes over the list in two\npasses.  If
  you demand the result of `sum` the Haskell runtime will materialize\nthe entire
  list.  However, the runtime cannot garbage collect the list because\nthe list is
  still required for the call to `length`.\n\nUsually people work around this by hand-writing
  a strict left fold that looks\nsomething like this:\n\n```haskell\n{-# LANGUAGE
  BangPatterns #-}\n\nimport Data.List (foldl')\n\nsumAndLength :: Num a => [a] ->
  (a, Int)\nsumAndLength xs = foldl' step (0, 0) xs\n  where\n    step (x, y) n =
  (x + n, y + 1)\n```\n\nThat now goes over the list in one pass, but will still leak
  space because the\ntuple is not strict in both fields!  You have to define a strict
  `Pair` type to\nfix this:\n\n```haskell\n{-# LANGUAGE BangPatterns #-}\n\nimport
  Data.List (foldl')\n\ndata Pair a b = Pair !a !b\n\nsumAndLength :: Num a => [a]
  -> (a, Int)\nsumAndLength xs = done (foldl' step (Pair 0 0) xs)\n  where\n    step
  (Pair x y) n = Pair (x + n) (y + 1)\n\n    done (Pair x y) = (x, y)\n```\n\n\nHowever,
  this is not satisfactory because you have to reimplement the guts of\nevery fold
  that you care about and also define a custom strict data type for\nyour fold.  Hand-writing
  the step function, accumulator, and strict data type\nfor every fold that you want
  to use gets tedious fast.  For example,\nimplementing something like reservoir sampling
  over and over is very error\nprone.\n\nWhat if you just stored the step function
  and accumulator for each individual\nfold and let some high-level library do the
  combining for you?  That's exactly\nwhat this library does!  Using this library
  you can instead write:\n\n```haskell\nimport qualified Control.Foldl as Fold\n\nsumAndLength
  :: Num a => [a] -> (a, Int)\nsumAndLength xs = Fold.fold ((,) <$> Fold.sum <*> Fold.length)
  xs\n\n-- or, more concisely:\nsumAndLength = Fold.fold ((,) <$> Fold.sum <*> Fold.length)\n```\n\nTo
  see how this works, the `Fold.sum` value is just a datatype storing the step\nfunction
  and the starting state (and a final extraction function):\n\n```haskell\nsum ::
  Num a => Fold a a\nsum = Fold (+) 0 id\n```\n\nSame thing for the `Fold.length`
  value:\n\n```haskell\nlength :: Fold a Int\nlength = Fold (\\n _ -> n + 1) 0 id\n```\n\n...
  and the `Applicative` operators combine them into a new datatype storing\nthe composite
  step function and starting state:\n\n```haskell\n(,) <$> Fold.sum <*> Fold.length
  = Fold step (Pair 0 0) done\n  where\n    step (Pair x y) = Pair (x + n) (y + 1)\n\n
  \   done (Pair x y) = (x, y)\n```\n\n... and then `fold` just transforms that to
  a strict left fold:\n\n```haskell\nfold (Fold step begin done) = done (foldl' step
  begin)\n```\n\nSince we preserve the step function and accumulator, we can use the
  `Fold` type to\nfold things other than pure collections.  For example, we can fold
  a `Producer`\nfrom `pipes` using the same `Fold`:\n\n```haskell\nFold.purely Pipes.Prelude.fold
  ((,) <$> sum <*> length)\n    :: (Monad m, Num a) => Producer a m () -> m (a, Int)\n```\n\nTo
  learn more about this library, read the documentation in\n[the main `Control.Foldl`
  module](http://hackage.haskell.org/package/foldl/docs/Control-Foldl.html).\n\n##
  Quick start\n\nInstall [the `stack` tool](http://haskellstack.org/) and then run:\n\n```bash\n$
  stack setup\n$ stack ghci foldl\nPrelude> import qualified Control.Foldl as Fold\nPrelude
  Fold> Fold.fold ((,) <$> Fold.sum <*> Fold.length) [1..1000000]\n(500000500000,1000000)\n```\n\n##
  How to contribute\n\nContribute a pull request if you have a `Fold` that you believe
  other people\nwould find useful.\n\n## Development Status\n\n[![Build Status](https://travis-ci.org/Gabriel439/Haskell-Foldl-Library.png)](https://travis-ci.org/Gabriel439/Haskell-Foldl-Library)\n\nThe
  `foldl` library is pretty stable at this point.  I don't expect there to be\nbreaking
  changes to the API from this point forward unless people discover new\nbugs.\n\n##
  License (BSD 3-clause)\n\nCopyright (c) 2016 Gabriel Gonzalez\nAll rights reserved.\n\nRedistribution
  and use in source and binary forms, with or without modification,\nare permitted
  provided that the following conditions are met:\n\n* Redistributions of source code
  must retain the above copyright notice, this\n  list of conditions and the following
  disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright
  notice, this\n  list of conditions and the following disclaimer in the documentation
  and/or\n  other materials provided with the distribution.\n\n* Neither the name
  of Gabriel Gonzalez nor the names of other contributors may\n  be used to endorse
  or promote products derived from this software without\n  specific prior written
  permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
  FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA,
  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY,
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
  OF SUCH DAMAGE.\n"
license-name: BSD3
