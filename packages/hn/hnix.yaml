homepage: https://github.com/haskell-nix/hnix#readme
changelog-type: markdown
hash: beffa5fed49e811f8043f41f7056994b2a8379ee82c0ca1d87fcdabec8e3dd9d
test-bench-deps:
  exceptions: -any
  serialise: -any
  bytestring: -any
  data-fix: -any
  tasty-th: -any
  unix: -any
  split: -any
  base: '>=4.11 && <5'
  time: -any
  tasty-hedgehog: -any
  Diff: -any
  unordered-containers: '>=0.2.9 && <0.3'
  text: -any
  megaparsec: '>=7.0 && <8.1'
  filepath: -any
  criterion: -any
  process: -any
  hedgehog: -any
  containers: -any
  hnix: -any
  mtl: -any
  tasty-hunit: -any
  pretty-show: -any
  base16-bytestring: -any
  prettyprinter: -any
  transformers: -any
  optparse-applicative: -any
  tasty: -any
  deepseq: '>=1.4.3 && <1.5'
  Glob: -any
  template-haskell: -any
  neat-interpolation: -any
  directory: -any
maintainer: johnw@newartisans.com
synopsis: Haskell implementation of the Nix language
changelog: |
  # Changelog

  ## [0.9.1](https://github.com/haskell-nix/hnix/compare/0.9.0...0.9.1) (2020-07-13)

  * Additional:
    * REPL improvements
      * Better tab completion
      * Multi-line input
      * Support for passing evaluated expression result of `hnix --eval -E`
        to REPL as `input` variable.
      * Support for loading `.hnixrc` from current directory
    * `builtins.nixVersion` bumped from 2.0 to 2.3
    * Dependencies:
      * Freed from: `interpolate`, `contravariant`, `semigroups`, `generic-random`, `tasty-quickcheck`
      * `repline` now `>= 0.4.0.0 && < 0.5`

  ## [0.9.0](https://github.com/haskell-nix/hnix/compare/0.8.0...0.9.0) (2020-06-15)

  * Changelog started. Previous release was `0.8.0`. In new release:

  * Major breaking:
    * Removed instances due to migration to `haskeline >= 0.8 && < 0.9`:
      * `instance MonadException m => MonadException(StateT(HashMap FilePath NExprLoc) m)`
      * `instance MonadException m => MonadException(Fix1T StandardTF m)`

  * Additional:
    * Library: Official support for `GHC 8.4 - 8.10`

  ---

  `HNix` uses [PVP Versioning][1].

  [1]: https://pvp.haskell.org
basic-deps:
  http-client: '>=0.5.14 && <0.6 || >=0.6.4 && <0.8'
  exceptions: '>=0.10.0 && <0.11'
  free: ==5.1.*
  serialise: '>=0.2.1 && <0.3'
  semialign: '>=1 && <1.2'
  bytestring: '>=0.10.8 && <0.11'
  these: '>=1.0.1 && <1.2'
  lens-family: '>=1.2.2 && <2.2'
  logict: '>=0.6.0 && <0.7 || >=0.7.0.2 && <0.8'
  data-fix: '>=0.2.0 && <0.3'
  unix: '>=2.7.2 && <2.8'
  haskeline: '>=0.8.0.0 && <0.9'
  hashing: '>=0.1.0 && <0.2'
  split: '>=0.2.3 && <0.3'
  base: '>=4.11 && <5'
  time: '>=1.8.0 && <1.9 || >=1.9.3 && <1.10'
  comonad: '>=5.0.4 && <5.1'
  parser-combinators: '>=1.0.1 && <1.3'
  deriving-compat: '>=0.3 && <0.6'
  semialign-indexed: '>=1 && <1.2'
  unordered-containers: '>=0.2.9 && <0.3'
  text: '>=1.2.3 && <1.3'
  megaparsec: '>=7.0 && <8.1'
  syb: '>=0.7 && <0.8'
  monad-control: '>=1.0.2 && <1.1'
  filepath: '>=1.4.2 && <1.5'
  process: '>=1.6.3 && <1.7'
  ref-tf: '>=0.4.0 && <0.5'
  lens-family-th: '>=0.5.0 && <0.6'
  array: '>=0.4 && <0.6'
  lens-family-core: '>=1.2.2 && <2.2'
  repline: '>=0.4.0.0 && <0.5'
  xml: '>=1.3.14 && <1.4'
  containers: '>=0.5.11.0 && <0.7'
  some: '>=1.0.1 && <1.1'
  hnix: -any
  binary: '>=0.8.5 && <0.9'
  regex-tdfa: '>=1.2.3 && <1.4'
  http-client-tls: '>=0.3.5 && <0.4'
  mtl: '>=2.2.2 && <2.3'
  hashable: '>=1.2.5 && <1.4'
  transformers-base: '>=0.4.5 && <0.5'
  pretty-show: '>=1.9.5 && <1.11'
  base16-bytestring: '>=0.1.1 && <0.2'
  prettyprinter: '>=1.2.1 && <1.7'
  transformers: '>=0.5.5 && <0.6'
  optparse-applicative: '>=0.14.3 && <0.17'
  hnix-store-core: '>=0.1.0 && <0.3'
  deepseq: '>=1.4.3 && <1.5'
  scientific: '>=0.3.6 && <0.4'
  monadlist: '>=0.0.2 && <0.1'
  http-types: '>=0.12.2 && <0.13'
  aeson: '>=1.4.2 && <1.5.3'
  template-haskell: '>=2.13 && <2.17'
  vector: '>=0.12.0 && <0.13'
  neat-interpolation: '>=0.4 && <0.6'
  directory: '>=1.3.1 && <1.4'
all-versions:
- 0.2.0
- 0.2.1
- 0.3.2
- 0.3.3
- 0.3.4
- 0.4.0
- 0.5.0
- 0.5.1
- 0.5.2
- 0.6.0
- 0.6.1
- 0.7.0
- 0.7.1
- 0.8.0
- 0.9.0
- 0.9.1
author: John Wiegley
latest: 0.9.1
description-type: markdown
description: |
  # hnix

  [![Build Status](https://api.travis-ci.org/haskell-nix/hnix.svg)](https://travis-ci.org/haskell-nix/hnix)
  [![Chat](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/haskell-nix/Lobby)
  [![Hackage](https://img.shields.io/hackage/v/hnix?color=%235e5086&label=Latest%20release)](https://hackage.haskell.org/package/hnix)
  [![Hackage Matrix Builder](https://img.shields.io/badge/Hackage%20Matrix-Builder-%235e5086)](https://matrix.hackage.haskell.org/package/hnix)
  [![Nixpkgs Hydra CI](https://img.shields.io/badge/Nixpkgs%20Hydra-CI-%234f72bb)](https://hydra.nixos.org/job/nixpkgs/trunk/haskellPackages.hnix.x86_64-linux#tabs-status)
  [![Dependencies](https://img.shields.io/hackage-deps/v/hnix?label=Dependencies)](https://packdeps.haskellers.com/feed?needle=hnix)
  [![Repology page](https://img.shields.io/badge/Repology-page-%23005500)](https://repology.org/project/haskell:hnix/versions)

  Haskell parser, evaluator and type checker for the Nix language.

  ## Prerequisites

  Nix is installed and in your `$PATH`. This is so that `nix-store` can be used
  for interacting with store paths, until `hnix-store` is ready.

  ## Getting Started

  ```
  $ git clone --recursive https://github.com/haskell-nix/hnix.git
  ...
  $ cd hnix
  $ nix-shell
  $ cabal v2-configure --enable-tests
  $ cabal v2-build
  $ cabal v2-test
  # To run all of the tests, which takes up to a minute:
  $ env ALL_TESTS=yes cabal v2-test
  # To run only specific tests (see `tests/Main.hs` for a list)
  $ env NIXPKGS_TESTS=yes PRETTY_TESTS=1 cabal v2-test
  $ ./dist/build/hnix/hnix --help
  ```

  ## Using the REPL

  To enter the `hnix` REPL use

  ```
  hnix --repl
  ```

  To evaluate an expression and make it available in the REPL
  as the `input` variable use

  ```
  hnix --eval -E '(import <nixpkgs> {}).pkgs.hello' --repl
  ```

  Use the `:help` command for a list of all available REPL commands.

  ## Building with full debug info

  To build `hnix` for debugging, and with full tracing output and stack traces,
  use:

  ```
  $ nix-shell
  $ cabal v2-configure --enable-tests --enable-profiling --flags=profiling --flags=tracing
  $ cabal v2-build
  $ ./dist/build/hnix/hnix -v5 --trace <args> +RTS -xc
  ```

  Note that this will run quite slowly, but will give the most information as to
  what might potentially be going wrong during parsing or evaluation.

  ## Building with benchmarks enabled

  To build `hnix` with benchmarks enabled:

  ```
  $ nix-shell --arg doBenchmarks true
  $ cabal v2-configure --enable-tests --enable-benchmarks
  $ cabal v2-build
  $ cabal v2-bench
  ```

  ## Building with profiling enabled

  To build `hnix` with profiling enabled:

  ```
  $ nix-shell
  $ cabal v2-configure --enable-tests --enable-profiling --flags=profiling
  $ cabal v2-build
  $ ./dist/build/hnix/hnix <args> +RTS -p
  ```

  ## Building with GHCJS

  From the project root directory, run:

  ```
  $ NIX_CONF_DIR=$PWD/ghcjs nix-build ghcjs
  ```

  This will build an `hnix` library that can be linked to your GHCJS
  application.

  ## Using the Cachix binary cache

  If you're on macOS, you can use the binary cache at Cachix to avoid building
  the specific dependencies used by hnix. Just use these commands:

  ```
  $ nix-env -iA cachix -f https://github.com/NixOS/nixpkgs/tarball/db557aab7b690f5e0e3348459f2e4dc8fd0d9298
  $ cachix use hnix
  ```

  ## How you can help

  ### Issue Tracker Backlog

  If you're looking for a way to help out, try taking a look
  [here](https://github.com/haskell-nix/hnix/issues?q=is%3Aissue+is%3Aopen+label%3A%22help+wanted%22+no%3Aassignee).
  When you find an issue that looks interesting to you, comment on the ticket to
  let others know you're working on it; look for others who might have done the
  same. You can talk with everyone live on
  [Gitter](https://gitter.im/haskell-nix/Lobby).

  When you're ready to submit a pull request, test it with:

  ```
  $ git submodule update --init --recursive
  $ nix-shell --run "LANGUAGE_TESTS=yes cabal v2-test"
  ```

  Make sure that all the tests that were passing prior to your PR are still
  passing afterwards; it's OK if no new tests are passing.

  ### Evaluating Nixpkgs with HNix

  Currently the main high-level goal is to be able to evaluate all of nixpkgs. To
  run this yourself, first build hnix with `nix-build`, then run the following
  command:

  ```
  $ ./result/bin/hnix --eval -E "import <nixpkgs> {}" --find
  ```
license-name: BSD-3-Clause
