homepage: ''
changelog-type: markdown
hash: ffa03dec3ad6d76e20e99a951347be160de177a8f37ac2ed85688c689121e110
test-bench-deps:
  hedn: ! '>=0.2 && <1'
  base: ! '>=4.9 && <4.13'
  time: ! '>=1.6 && <2'
  text: ! '>=1.2 && <2'
  uuid: ! '>=1.3 && <2'
  megaparsec: ! '>=7.0 && <8'
  hedgehog: ! '>=0.6 && <0.7'
  containers: ! '>=0.5.7 && <0.7'
  vector: ! '>=0.11 && <1'
maintainer: aenor.realm@gmail.com
synopsis: EDN parsing and encoding
changelog: |
  # Change Log

  All notable changes to this project will be documented in this file.
  This project adheres to [Semantic Versioning](http://semver.org/).

  ## [0.2.0.0] - 2019-01-18

  ### Changed

  - Complete rewrite in Megaparsec.
  - Text types changed to, well, `Text`
  - Document  with `prettyprinter`
  - Test suite changed to Hedgehog
  - Code repository moved to GitLab

  ### Removed

  - GHC < 8.0 (Stackage LTS < 7) aren't supported due to Semigroup-Monoid changes.

  ## [0.1.9.1] - 2018-12-03

  ### Changed

  - GHC 8.4 compatibility fixes

  ## [0.1.9.0] - 2018-04-05

  ### Fixed

  - `<` and `>` are valid for symbols and keywords.

  ## [0.1.8.2] - 2016-05-14

  ### Changed

  - Use compat wrappers to handle GHC from 7.4 to 8.0.

  ### Removed

  - Drop obsolete `developer` flag.

  ## [0.1.8.1] - 2015-10-08

  ### Fixed

  - Update dependencies, fix deprecations, time-1.5 compat.

  ## [0.1.8.0] - 2013-11-29

  ### Fixed

  - Use utf8-string parsing for unicode literals.

  [0.2.0.0]: https://gitlab.com/dpwiz/hedn/tree/0.2.0.0
  [0.1.9.1]: https://gitlab.com/dpwiz/hedn/tree/0.1.9.1
  [0.1.9.0]: https://gitlab.com/dpwiz/hedn/tree/0.1.9.0
  [0.1.8.2]: https://gitlab.com/dpwiz/hedn/tree/0.1.8.2
  [0.1.8.1]: https://gitlab.com/dpwiz/hedn/tree/0.1.8.1
  [0.1.8.0]: https://gitlab.com/dpwiz/hedn/tree/0.1.8.0
basic-deps:
  base: ! '>=4.9 && <4.13'
  time: ! '>=1.6 && <2'
  parser-combinators: ! '>=1.0 && <2'
  deriving-compat: ! '>=0.3.6 && <0.6'
  text: ! '>=1.2 && <2'
  uuid: ! '>=1.3 && <2'
  megaparsec: ! '>=7.0 && <8'
  containers: ! '>=0.5.7 && <0.7'
  prettyprinter: ! '>=1.2 && <2'
  deepseq: ! '>=1.4 && <2'
  scientific: ! '>=0.3 && <0.4'
  template-haskell: ! '>=2.11 && <3'
  vector: ! '>=0.11 && <1'
all-versions:
- 0.1.3.0
- 0.1.4.1
- 0.1.5.0
- 0.1.5.1
- 0.1.5.2
- 0.1.6.0
- 0.1.7.0
- 0.1.8.1
- 0.1.8.2
- 0.1.9.0
- 0.1.9.1
- 0.2.0.0
author: Alexander Bondarenko
latest: 0.2.0.0
description-type: markdown
description: |
  # Haskell EDN

  An EDN parsing and encoding library inspired by `aeson`.

  Based on [spec] and [hints] published on GitHub.

  Hackage: https://hackage.haskell.org/package/hedn

  Stackage: https://www.stackage.org/package/hedn

  [spec]: https://github.com/edn-format/edn
  [hints]: https://github.com/wagjo/serialization-formats

  # Examples

  ## AST

  ```clojure
  (#haskell/edn example/kitchensink ; tagged symbol
   nil ; ugh..
   \space ; character
   "dynamic \"typing\"" ; string
   {:numbers ; keyword
    [42 ; integer
     42.0 ; floating
    ] ; Vector
    :bools
    #{true, false} ; Set (with optional commas)
   } ; Map
  ) ; List
  ```

  ```haskell
  import qualified Data.EDN as EDN
  import qualified Data.Text.IO as Text

  main = do
    edn <- Text.readFile "example.edn"
    value <- EDN.parseText "example.edn" edn
    print value
  ```

  ```haskell
  NoTag
    (List
       [ Tagged "haskell" "edn" (Symbol "example" "kitchensink")
       , NoTag Nil
       , NoTag (Character ' ')
       , NoTag (String "dynamic \"typing\"")
       , NoTag
           (Map
              (fromList
                 [ ( NoTag (Keyword "bools")
                   , NoTag
                       (Set (fromList [ NoTag (Boolean False) , NoTag (Boolean True) ]))
                   )
                 , ( NoTag (Keyword "numbers")
                   , NoTag (Vec [ NoTag (Integer 42) , NoTag (Floating 42.0) ])
                   )
                 ]))
       ])
  ```

  ## Conversion

  More examples in `tests/Data/EDN/Class/Test.hs`.

  ```haskell
  data Person = Person
    { personFirst :: Text
    , personLast  :: Text
    } deriving (Eq, Show)

  instance ToEDN Person where
    toEDN Person{..} =
      toEDNtagged "myapp" "Person" $ Map.fromList
        [ (EDN.Keyword "first", toEDN personFirst)
        , (EDN.Keyword "last", toEDN personLast)
        ]

  instance FromEDN Person where
    parseEDN = \case
      EDN.Tagged "myapp" "Person" v -> Person
        <$> EDN.mapGetKeyword "first" v
        <*> EDN.mapGetKeyword "last" v
      _ ->
        fail "myapp/Person expected"
  ```

  ```haskell
  import qualified Data.EDN as EDN
  import qualified Data.Text.IO as Text

  main = Text.putStrLn $
    encodeText (Person "Fred" "Mertz")
  ```

  ```clojure
  #myapp/Person {:first "Fred" :last "Mertz"}
  ```

  ## Quasiquoter

  Embed EDN AST literals with `edn`:

  ```haskell
  fredEDN = [edn|
    #myapp/Person {:first "Fred" :last "Mertz"}
  |]
  ```

  Additionally there are QQs for untagged collections.
  They simply wrap the block in appropriate symbols.

  * Lists, `()`
      ```haskell
      EDN.List (items :: [TaggedValue]) =
        [ednList|
          this is a list of symbols, commas are whitespace
        |]
      ```
  * Vectors, `[]`
      ```haskell
      EDN.Vec (items :: Vector TaggedValue) =
        [ednVec|
          42 is #the/answer true
        |]
      ```
  * Sets, `#{}`
      ```haskell
      EDN.Set (items :: Set TaggedValue) =
        [ednSet|
          badger badger badger badger
          badger badger badger badger
          mushroom mushroom
        |]
      ```
  * Maps, `{}`
      ```haskell
      EDN.Map (dict :: Map TaggedValue TaggedValue) =
        [ednMap|
          :keywords "as you like it"
          or/symbols "I won't judge"
          #uuid "d748ab62-9cb1-41fb-b8dc-e23f3ffc5f9b"
          (tagged values, collections, anything goes)
        |]
      ```

  ### EDN as DSL syntax

  You can add quasiquoters for your values by specializing `fromEDN` QuasiQuoter.

  > Usual TH shenanigans apply.
  > Define things in a separate module.
  > Either `Data.Data.Data` or `Language.Haskell.TH.Syntax.Lift` instance required to convert values to Haskell AST.

  ```haskell
  module My.Data.QQ (myData) where

  import Data.EDN.QQ (fromEDN)
  import My.Data.Types (MyData)

  myData :: QuasiQuoter
  myData = fromEDN @MyData
  ```

  ```haskell
  module Main where

  import My.Data.QQ (myData)

  main :: IO ()
  main = cobc
    [myData|
      {:identification-division
          [#program/id hello]
       :procedure-division
          ((display "Hello, world!"
            end-display)
           stop-run
          )
      }
    |]
  ```
license-name: BSD-3-Clause
