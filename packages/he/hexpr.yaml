homepage: https://github.com/Zankoku-Okuno/hexpr/
changelog-type: ''
hash: 82017c93784a727f97ea31b81e0c0832da87bf41cd05997094f109d128d48309
test-bench-deps: {}
maintainer: zankoku.okuno@gmail.com
synopsis: A framework for symbolic, homoiconic languages.
changelog: ''
basic-deps:
  data-ref: -any
  either: ==4.1.*
  base: ==4.6.*
  parsec: ==3.1.*
  mtl: ==2.1.*
  transformers: ==0.3.*
all-versions:
- 0.0.0.0
author: Zankoku Okuno
latest: 0.0.0.0
description-type: haddock
description: ! 'H-expressions are a variant of S-expressions. Where s-expressions
  are atoms or nodes grouped into lists of length at least one, h-expressions, or
  hexprs, are grouped into lists of length two. This may seem very trivial, but this
  restriction makes it possible to treat parenthesis in the concrete syntax of hexprs
  merely as a manual override to the basic precedence rules, just as in mathematics.
  In particular, a suitable hexpr interpreter is capable of understanding eta-converted
  terms, which is quite unrealistic, if not impossible in an sexpr-based syntax. Thankfully,
  hexprs retain all the advantages of sexprs with respect to homoiconic syntax.

  Hexprs on their own are fairly unhelpful, so we also have also included a configurable
  hexpr parser based on parsec. I wasn''t long before mission creep set in, and a
  series of tools were produced to aid in creating a frontend for hexpr-based languages.
  See the package ''hexpr-examples'' for some examples of the framework in action.

  I think H could stand for many things: the greek letter eta, hierarchical, happy,
  next in the alphabet after f, or perhaps hexpr == hexpr-expression. Where it comes
  from is unimportant, what is important is that we can easily the next generation
  of homoiconic languages.'
license-name: BSD-3-Clause
