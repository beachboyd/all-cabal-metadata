homepage: ''
changelog-type: markdown
hash: 64981a8a563c83206237636b55009bb0edd6abb521f4161ff627529c448704dc
test-bench-deps: {}
maintainer: sgschlesinger@gmail.com
synopsis: For when first class pattern matches are needed
changelog: |
  # Revision history for generic-match

  ## 0.1.0.0 -- 2020-08-23

  * First release to hackage, as a minimally useful implementation.
basic-deps:
  base: '>=4.12 && <4.15'
all-versions:
- 0.1.0.0
author: Samuel Schlesinger
latest: 0.1.0.0
description-type: markdown
description: |
  # generic-match

  When I'm writing Haskell code, often I write things like:

  ```haskell
  x <- doThing >>= either errorHandler pure
  y <- doOtherThing >>= maybe (throwIO Shriek) pure
  ```

  This comes up in more places than error handling, but I think this is a
  sufficient example. There is a compromise one makes with their API, where
  they either offer a specific error type, and force you to deconstruct it and
  fiddle with it on your own, but usually the names are more descriptive. On
  the other hand, with Either or Maybe, we can use all of the standard functions
  available for operating on them, such as either and maybe. This package is
  getting rid of the cost of entry for deconstructing your own types in this
  same style. Now we can write:

  ```haskell
  data DatabaseAccess a =
      ConnectionFailure String
    | InvalidRowCount Int
    | Successful a
    deriving Generic
  ...
  x <- doThing >>= match error (error . show) pure
  ```

  This is the motivating case, but there are many others! For instance, you can
  also replace your use of either and maybe with the more "Generic" (heh) match.

  ```haskell
  x <- doThing >>= match errorHandler pure
  y <- doOtherThing >>= match (throwIO Shriek) pure
  ```
license-name: MIT
