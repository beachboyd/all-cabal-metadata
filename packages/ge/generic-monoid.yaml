homepage: ''
changelog-type: markdown
hash: 372875d12742b97befaacbd08a35c2e73cc3821a3b7a09ec1b17a079d0b24ff7
test-bench-deps: {}
maintainer: lukec@themk.net
synopsis: Derive monoid instances for product types.
changelog: |
  # Revision history for generic-monoid

  ## 0.1.0.0  -- 2018-12-12

  * Initial release.
basic-deps:
  base: ! '>=4.12 && <4.14'
all-versions:
- 0.1.0.0
author: Luke Clifton
latest: 0.1.0.0
description-type: markdown
description: |
  # Generic Monoid (and Semigroup)

  This library provides a method of deriving `Semigroup` and `Monoid` instances
  for your large product types. It does this using GHC generics, and can provides
  a mechanism for using the `DerivingVia` extension to reduce boilerplate.

  It only works if each field of your product type is itself a `Semigroup`/`Monoid`.

  ```haskell
  {-# LANGUAGE DerivingStrategies #-}
  {-# LANGUAGE DerivingVia        #-}
  {-# LANGUAGE DeriveGeneric      #-}

  import GHC.Generics
  import Data.Monoid.Generic

  data BigProduct = BigProduct
      { theList   :: [Int]
      , theSum    :: Sum Double
      , theString :: String
      } deriving (Generic, Eq)
      deriving Semigroup via GenericSemigroup BigProduct
      deriving Monoid    via GenericMonoid BigProduct

  useIt :: Bool
  useIt = (mempty <> mempty) == BigProduct [] 0 ""
  ```
license-name: BSD-3-Clause
