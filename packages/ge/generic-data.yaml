homepage: https://github.com/Lysxia/generic-data#readme
changelog-type: markdown
hash: 86cac53570f45f5b1e5f54d8765d0a05f1674b3703e4dbb48a919f89c57b3cbc
test-bench-deps:
  generic-data: -any
  base: -any
  tasty-hunit: -any
  tasty: -any
maintainer: lysxia@gmail.com
synopsis: Utilities for GHC.Generics
changelog: ! "# 0.3.0.0\n\n- Add generic implementations of `enumFrom`, `enumFromThen`,
  `enumFromTo`,\n  `enumFromThenTo`. They are actually required to be explicit for
  correct\n  `Enum` instances. Thanks to Topsii.\n- Parameterize `GEnum` by a type-level
  option, and add `FiniteEnum` option\n  to allow `Enum` to be derived for composite
  types. Thanks to Topsii.\n\n# 0.2.0.0\n\n- Remove `Generic.Data.Types.Map`\n- Add
  `Generic.Data.Data.Types.toData` and `fromData`\n- Remove `Defun` module (subsumed
  by `first-class-families` package)\n\n# 0.1.1.0\n\n- Add `gconIndex`\n- Interface
  for constructor tags\n- Type-level `Meta` accessors\n- Add basic `Newtype` functions\n\n#
  0.1.0.0\n\nReleased generic-data\n"
basic-deps:
  base: ! '>=4.9 && <5'
  show-combinators: -any
  base-orphans: ! '>=0.8'
  contravariant: -any
all-versions:
- 0.1.0.0
- 0.1.1.0
- 0.2.0.0
- 0.3.0.0
author: Li-yao Xia
latest: 0.3.0.0
description-type: markdown
description: ! "# Generic data types in Haskell [![Hackage](https://img.shields.io/hackage/v/generic-data.svg)](https://hackage.haskell.org/package/generic-data)
  [![Build Status](https://travis-ci.org/Lysxia/generic-data.svg)](https://travis-ci.org/Lysxia/generic-data)\n\nUtilities
  for `GHC.Generics`.\n\n## Generic deriving for standard classes\n\nSupported classes
  that GHC currently can't derive: `Semigroup`, `Monoid`,\n`Applicative`, `Alternative`,
  `Eq1`, `Ord1`, `Show1`.\n\nOther classes from base are also supported, even though
  GHC can already derive\nthem:\n\n- `Eq`, `Ord`, `Enum`, `Bounded`, `Show` (standard);\n-
  `Functor`, `Foldable`, `Traversable` (via extensions, `DeriveFunctor`, etc.).\n\n(`Read`
  is currently not implemented.)\n\nTo derive type classes defined elsewhere, it might
  be worth taking a look at\n[one-liner](https://hackage.haskell.org/package/one-liner).\n\n##
  Type metadata\n\nExtract type names, constructor names, number and arities of constructors,
  etc..\n\n---\n\n## Related links\n\ngeneric-data aims to subsume generic deriving
  features of the following\npackages:\n\n- [semigroups](https://hackage.haskell.org/package/semigroups):
  generic\n  `Semigroup`, `Monoid`, but with a heavy dependency footprint.\n- [transformers-compat](https://hackage.haskell.org/package/transformers-compat):\n
  \ generic `Eq1`, `Ord1`, `Show1`.\n- [generic-deriving](https://hackage.haskell.org/package/generic-deriving):\n
  \ doesn't derive the classes in base (defines clones of these classes as a toy\n
  \ example); has Template Haskell code to derive `Generic`.\n\nHere are other relevant
  links.\n\n- [deriving-compat](https://hackage.haskell.org/package/deriving-compat):\n
  \ deriving with Template Haskell.\n- [one-liner](https://hackage.haskell.org/package/one-liner):
  another approach\n  to using `GHC.Generics` to derive instances of many type classes,
  including\n  but not restricted to the above classes (this is done in\n  [one-liner-instances](https://hackage.haskell.org/package/one-liner-instances)).\n-
  [singletons](https://hackage.haskell.org/package/singletons),\n  [first-class-families](https://hackage.haskell.org/package/first-class-families)\n
  \ (second one written by me)\n  libraries for dependently-typed programming in Haskell.\n\n---\n\nAll
  contributions are welcome. Open an issue or a pull request on Github!\n"
license-name: MIT
