homepage: https://github.com/Lysxia/generic-data-surgery#readme
changelog-type: ''
hash: cb42f0e4c3474172232b8a13056282d9a172c3800952a8b42cb360fe68f74daa
test-bench-deps:
  generic-data: -any
  base: -any
  generic-data-surgery: -any
  tasty-hunit: -any
  generic-lens: -any
  tasty: -any
maintainer: lysxia@gmail.com
synopsis: Surgery for generic data types
changelog: ''
basic-deps:
  generic-data: ! '>=0.2'
  first-class-families: ! '>=0.2'
  base: ! '>=4.9 && <5'
all-versions:
- 0.1.0.0
author: Li-yao Xia
latest: 0.1.0.0
description-type: markdown
description: ! "# Surgery for generic data types [![Hackage](https://img.shields.io/hackage/v/generic-data-surgery.svg)](https://hackage.haskell.org/package/generic-data-surgery)
  [![Build Status](https://travis-ci.org/Lysxia/generic-data-surgery.svg)](https://travis-ci.org/Lysxia/generic-data-surgery)\n\nModify,
  add, or remove constructors and fields in generic types, to be used\nwith generic
  implementations.\n\n## Example\n\nHere is a simple record type equipped with a `checksum`
  function:\n\n```haskell\ndata Foo = Foo { x, y, z :: Int }\n  deriving (Eq, Generic,
  Show)\n\nchecksum :: Foo -> Checksum\n```\n\nLet's encode it as a JSON object with
  an extra `\"checksum\"` key,\nlooking like this, where `X`, `Y`, `Z` are integers:\n\n```\n{
  \"x\": X\n, \"y\": Y\n, \"z\": Z\n, \"checksum\": X + Y + Z\n}\n```\n\nWe use `genericParseJSON`/`genericToJSON`
  to convert between JSON values\nand a generic 4-field record, and `removeRField`/`insertRField`
  to\nconvert between that generic 4-field record and the 3-field `Foo`.\n\n### Remove
  field\n\nWhen decoding, we check the checksum and then throw it away.\n\n```haskell\ninstance
  FromJSON Foo where\n  parseJSON v = do\n\n    r <- genericParseJSON defaultOptions
  v\n    -- r: a generic 4-field record {x,y,z,checksum} (checksum at index 3).\n\n
  \   let (cs, f) = (fmap fromOR . removeRField @\"checksum\" @3 . toOR') r\n    --
  removeRField @\"checksum\" @3: split out the checksum field\n    -- from the three
  other fields. (cs, f) :: (Checksum, Foo)\n\n    if checksum f == cs then\n      pure
  f\n    else\n      fail \"Checksum failed\"\n```\n\n### Insert field\n\nWhen encoding,
  we must compute the checksum to write it out. We put the\nchecksum in a pair `(checksum
  f, f)` with the original record, and\n`insertRField` can then wrap it into a 4-field
  record passed into\n`genericToJSON`.\n\n```haskell\ninstance ToJSON Foo where\n
  \ toJSON f =\n    (genericToJSON defaultOptions . fromOR' . insertRField @\"checksum\"
  @3 . fmap toOR)\n      (checksum f, f)\n```\n\nSee also the\n[`examples/`](https://github.com/Lysxia/generic-data-surgery/tree/master/examples)\ndirectory
  in the source repo.\n"
license-name: MIT
