homepage: ''
changelog-type: ''
hash: 1cd3ef7761e90d9755698cbf741323503af0df9f579e1e2a7529d931e080eb66
test-bench-deps:
  dvda: -any
  test-framework: -any
  base: -any
  ad: -any
  unordered-containers: -any
  test-framework-quickcheck2: -any
  process: -any
  graphviz: -any
  containers: -any
  hashtables: -any
  fgl: -any
  mtl: -any
  hashable: -any
  QuickCheck: -any
  file-location: -any
  directory: -any
maintainer: gregmainland@gmail.edu
synopsis: Efficient automatic differentiation and code generation
changelog: ''
basic-deps:
  base: ! '>=4 && <5'
  unordered-containers: ! '>=0.2'
  containers: ! '>=0.5'
  hashtables: ! '>=1.1.0'
  mtl: -any
  hashable: ! '>=1.2'
  vector: ! '>=0.10'
all-versions:
- '0.1'
- 0.1.1
- 0.2.0
- 0.2.1
- 0.2.2
- '0.3'
- 0.3.0.1
- 0.3.1
- 0.3.2
- 0.3.2.1
- '0.4'
author: Greg Horn
latest: '0.4'
description-type: haddock
description: ! 'dvda == DVDA Verifiably Differentiates Algorithmically


  This library provides a symbolic scalar type `Dvda.Expr` which is

  manipulated mathematically through its Num\/Fractional\/Floating instances.


  Automatic differentiation can be performed with `Dvda.AD`. Expressions can be turned
  into

  computational graphs (@FunGraph@s) using toFunGraph. This uses unsafe reification
  for performance reasons,

  and explicit common subexpression elimination using hashing can be performed using
  `Dvda.CSE`


  @FunGraph@s can be converted to C code and MATLAB mex functions. In the future there
  will be JIT compilation

  so you can call these functions efficiently from Haskell.


  Pretty graphviz plots!


  To get started check out the source for `Dvda.Examples`'
license-name: BSD-3-Clause
