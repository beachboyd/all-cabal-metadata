homepage: http://wiki.portal.chalmers.se/agda/
changelog-type: markdown
hash: bf647ea703a116eed71fdf26cd2bf813cc9ad94fb7793f4b9ee57237aa5c8e01
test-bench-deps: {}
maintainer: Ulf Norell <ulfn@chalmers.se>
synopsis: A dependently typed functional programming language and proof assistant
changelog: ! "Release notes for Agda version 2.5.4\n====================================\n\nInstallation
  and infrastructure\n-------------------------------\n\n* Added support for GHC 8.2.2
  and GHC 8.4.3.\n\n  Note that GHC 8.4.* requires `cabal-install` ≥ 2.2.0.0.\n\n*
  Removed support for GHC 7.8.4.\n\n* Included user manual in PDF format in `doc/user-manual.pdf`.\n\nLanguage\n--------\n\n*
  Call-by-need reduction.\n\n  Compile-time weak-head evaluation is now call-by-need,
  but each weak-head\n  reduction has a local heap, so sharing is not maintained between
  different\n  reductions.\n\n  The reduction machine has been rewritten from scratch
  and should be faster\n  than the old one in all cases, even those not exploiting
  laziness.\n\n* Compile-time inlining.\n\n  Simple definitions (that don't do any
  pattern matching) marked as INLINE are\n  now also inlined at compile time, whereas
  before they were only inlined by\n  the compiler backends. Inlining only triggers
  in function bodies and not in\n  type signatures, to preserve goal types as far
  as possible.\n\n* Automatic inlining.\n\n  Definitions satisfying the following
  criteria are now automatically inlined\n  (can be disabled using the new NOINLINE
  pragma):\n\n    - No pattern matching.\n    - Uses each argument at most once.\n
  \   - Does not use all its arguments.\n\n  Automatic inlining can be turned off
  using the flag `--no-auto-inline`. This\n  can be useful when debugging tactics
  that may be affected by whether or not\n  a particular definition is being inlined.\n\n###
  Syntax\n\n* Do-notation.\n\n  There is now builtin do-notation syntax. This means
  that `do` is a reserved\n  keyword and cannot be used as an identifier.\n\n  Do-blocks
  support lets and pattern matching binds. If the pattern in a bind\n  is non-exhaustive
  the other patterns need to be handled in a `where`-clause\n  (see example below).\n\n
  \ Example:\n\n  ```agda\n  filter : {A : Set} → (A → Bool) → List A → List A\n  filter
  p xs = do\n    x    ← xs\n    true ← return (p x)\n      where false → []\n    return
  x\n  ```\n\n  Do-blocks desugar to `_>>=_` and `_>>_` before scope checking, so
  whatever\n  definitions of these two functions are in scope of the do-block will
  be used.\n\n  More precisely:\n\n  - Simple bind\n\n    ```agda\n    do x ← m\n
  \      m'\n    ```\n    desugars to `m >>= λ x → m'`.\n\n  - Pattern bind\n\n    ```agda\n
  \   do p ← m where pᵢ → mᵢ\n       m'\n    ```\n    desugars to `m >>= λ { p → m';
  pᵢ → mᵢ }`, where `pᵢ → mᵢ` is an arbitrary\n    sequence of clauses and follows
  the usual layout rules for `where`. If `p`\n    is exhaustive the `where` clause
  can be omitted.\n\n  - Non-binding operation\n\n    ```agda\n    do m\n       m'\n
  \   ```\n    desugars to `m >> m'`.\n\n  - Let\n\n    ```agda\n    do let ds\n       m\n
  \   ```\n    desugars to `let ds in m`, where `ds` is an arbitrary sequence of valid
  let-declarations.\n\n  - The last statement in the do block must be a plain expression
  (no let or bind).\n\n  Bind statements can use either `←` or `<-`. Neither of these
  are reserved, so\n  code outside do-blocks can use identifiers with these names,
  but inside a\n  do-block they would need to be used qualified or under different
  names.\n\n* Infix let declarations. [Issue [#917](https://github.com/agda/agda/issues/917)]\n\n
  \ Let declarations can now be defined in infix (or mixfix) style. For instance:\n\n
  \ ```agda\n    f : Nat → Nat\n    f n = let _!_ : Nat → Nat → Nat\n              x
  ! y = 2 * x + y\n          in n ! n\n  ```\n\n* Overloaded pattern synonyms. [Issue
  [#2787](https://github.com/agda/agda/issues/2787)]\n\n  Pattern synonyms can now
  be overloaded if all candidates have the same\n  *shape*. Two pattern synonym definitions
  have the same shape if they are\n  equal up to variable and constructor names. Shapes
  are checked at resolution\n  time.\n\n  For instance, the following is accepted:\n\n
  \ ```agda\n    open import Agda.Builtin.Nat\n\n    data List (A : Set) : Set where\n
  \     lnil  : List A\n      lcons : A → List A → List A\n\n    data Vec (A : Set)
  : Nat → Set where\n      vnil  : Vec A 0\n      vcons : ∀ {n} → A → Vec A n → Vec
  A (suc n)\n\n    pattern [] = lnil\n    pattern [] = vnil\n\n    pattern _∷_ x xs
  = lcons x xs\n    pattern _∷_ y ys = vcons y ys\n\n    lmap : ∀ {A B} → (A → B)
  → List A → List B\n    lmap f []       = []\n    lmap f (x ∷ xs) = f x ∷ lmap f
  xs\n\n    vmap : ∀ {A B n} → (A → B) → Vec A n → Vec B n\n    vmap f []       =
  []\n    vmap f (x ∷ xs) = f x ∷ vmap f xs\n  ```\n\n* If the file has no top-level
  module header, the first module\n  cannot have the same name as the file.\n  [Issues
  [#2808](https://github.com/agda/agda/issues/2808)\n   and [#1077](https://github.com/agda/agda/issues/1077)]\n\n
  \ This means that the following file `File.agda` is rejected:\n  ```agda\n    --
  no module header\n    postulate A : Set\n    module File where -- inner module with
  the same name as the file\n  ```\n  Agda reports `Illegal declarations(s) before
  top-level module`\n  at the `postulate`.\n  This is to avoid confusing scope errors
  in similar situations.\n\n  If a top-level module header is inserted manually, the
  file is accepted:\n\n  ```agda\n    module _ where    -- user written module header\n
  \   postulate A : Set\n    module File where -- inner module with the same name
  as the file, ok\n  ```\n\n### Pattern matching\n\n* Forced constructor patterns.\n\n
  \ Constructor patterns can now be dotted to indicate that Agda should not case\n
  \ split on them but rather their value is forced by the type of the other\n  patterns.
  The difference between this and a regular dot pattern is that\n  forced constructor
  patterns can still bind variables in their arguments.\n  For example,\n\n  ```agda\n
  \   open import Agda.Builtin.Nat\n\n    data Vec (A : Set) : Nat → Set where\n      nil
  \ : Vec A zero\n      cons : (n : Nat) → A → Vec A n → Vec A (suc n)\n\n    append
  : {A : Set} (m n : Nat) → Vec A m → Vec A n → Vec A (m + n)\n    append .zero    n
  nil            ys = ys\n    append (.suc m) n (cons .m x xs) ys = cons (m + n) x
  (append m n xs ys)\n  ```\n\n* Inferring the type of a function based on its patterns\n\n
  \ Agda no longer infers the type of a function based on the patterns used in\n  its
  definition. [Issue [#2834](https://github.com/agda/agda/issues/2834)]\n\n  This
  means that the following Agda program is no longer accepted:\n  ```agda\n    open
  import Agda.Builtin.Nat\n\n    f : _ → _\n    f zero    = zero\n    f (suc n) =
  n\n  ```\n  Agda now requires the type of the argument of `f` to be given explicitly.\n\n*
  Improved constraint solving for pattern matching functions\n\n  Constraint solving
  for functions where each right-hand side has a distinct\n  rigid head has been extended
  to also cover the case where some clauses return\n  an argument of the function.
  A typical example is append on lists:\n\n  ```agda\n    _++_ : {A : Set} → List
  A → List A → List A\n    []       ++ ys = ys\n    (x ∷ xs) ++ ys = x ∷ (xs ++ ys)\n
  \ ```\n\n  Agda can now solve constraints like `?X ++ ys == 1 ∷ ys` when `ys` is
  a\n  neutral term.\n\n* Record expressions translated to copatterns\n\n  Definitions
  of the form\n\n  ```agda\n    f ps = record { f₁ = e₁; ..; fₙ = eₙ }\n  ```\n\n
  \ are translated internally to use copatterns:\n\n  ```agda\n    f ps .f₁ = e₁\n
  \   ...\n    f ps .fₙ = eₙ\n  ```\n\n  This means that `f ps` does not reduce, but
  thanks to η-equality the two\n  definitions are equivalent.\n\n  The change should
  lead to fewer big record expressions showing up in goal\n  types, and potentially
  significant performance improvement in some cases.\n\n  This may have a minor impact
  on with-abstraction and code using `--rewriting`\n  since η-equality is not used
  in these cases.\n\n* When using `with`, it is now allowed to replace any pattern
  from the parent\n  clause by a variable in the with clause. For example:\n\n  ```agda\n
  \   f : List ℕ → List ℕ\n    f [] = []\n    f (x ∷ xs) with x ≤? 10\n    f xs |
  p = {!!}\n  ```\n\n  In the with clause, `xs` is treated as a let-bound variable
  with value\n  `.x ∷ .xs` (where `.x : ℕ` and `.xs : List ℕ` are out of scope) and\n
  \ `p : Dec (.x ≤ 10)`.\n\n  Since with-abstraction may change the type of variables,
  instantiations\n  of variables in the with clause are type checked again after with-abstraction.\n\n###
  Builtins\n\n* Added support for built-in 64-bit machine words.\n\n  These are defined
  in `Agda.Builtin.Word` and come with two primitive\n  operations to convert to and
  from natural numbers.\n\n  ```agda\n    Word64 : Set\n    primWord64ToNat   : Word64
  → Nat\n    primWord64FromNat : Nat → Word64\n  ```\n\n  Converting to a natural
  number is the trivial embedding, and converting from a natural number\n  gives you
  the remainder modulo 2^64. The proofs of these theorems are not\n  primitive, but
  can be defined in a library using `primTrustMe`.\n\n  Basic arithmetic operations
  can be defined on `Word64` by converting to\n  natural numbers, peforming the corresponding
  operation, and then converting\n  back. The compiler will optimise these to use
  64-bit arithmetic. For\n  instance,\n\n  ```agda\n    addWord : Word64 → Word64
  → Word64\n    addWord a b = primWord64FromNat (primWord64ToNat a + primWord64ToNat
  b)\n\n    subWord : Word64 → Word64 → Word64\n    subWord a b = primWord64FromNat
  (primWord64ToNat a + 18446744073709551616 - primWord64ToNat b)\n  ```\n\n  These
  compiles (in the GHC backend) to addition and subtraction on\n  `Data.Word.Word64`.\n\n*
  New primitive primFloatLess and changed semantics of primFloatNumericalLess.\n\n
  \ `primFloatNumericalLess` now uses standard IEEE `<`, so for instance\n  `NaN <
  x = x < NaN = false`.\n\n  On the other hand `primFloatLess` provides a total order
  on `Float`, with\n  `-Inf < NaN < -1.0 < -0.0 < 0.0 < 1.0 < Inf`.\n\n* The `SIZEINF`
  builtin is now given the name `∞` in\n  `Agda.Builtin.Size` [Issue\n  [#2931](https://github.com/agda/agda/issues/2931)].\n\n
  \ Previously it was given the name `ω`.\n\n### Reflection\n\n* New TC primitive:
  `declarePostulate`. [Issue\n  [#2782](https://github.com/agda/agda/issues/2782)]\n\n
  \ ```agda\n    declarePostulate : Arg Name → Type → TC ⊤\n  ```\n\n  This can be
  used to declare new postulates. The Visibility of the\n  Arg must not be hidden.
  This feature fails when executed with\n  `--safe` flag from command-line.\n\nPragmas
  and options\n-------------------\n\n* The `--caching` option is ON by default and
  is also a valid pragma.\n  Caching can (sometimes) speed up re-typechecking in `--interaction`\n
  \ mode by reusing the result of the previous typechecking for the\n  prefix of the
  file that has not changed (with a granularity at the\n  level of declarations/mutual
  blocks).\n\n  It can be turned off by passing ```--no-caching``` to ```agda``` or\n
  \ with the following at the top of your file.\n\n  ```agda\n    {-# OPTIONS --no-caching
  #-}\n  ```\n\n* The `--sharing` and `--no-sharing` options have been deprecated
  and do\n  nothing.\n\n  Compile-time evaluation is now always call-by-need.\n\n*
  BUILTIN pragmas can now appear before the top-level module header\n  and in parametrized
  modules.\n  [Issue [#2824](https://github.com/agda/agda/issues/2824)]\n  ```agda\n
  \   {-# OPTIONS --rewriting #-}\n    open import Agda.Builtin.Equality\n    {-#
  BUILTIN REWRITE _≡_ #-}  -- here\n    module TopLevel (A : Set) where\n    {-# BUILTIN
  REWRITE _≡_ #-}  -- or here\n  ```\n  Note that it is still the case that built-ins
  cannot be bound if\n  they depend on module parameters from an enclosing module.
  For\n  instance, the following is illegal:\n  ```agda\n    module _ {a} {A : Set
  a} where\n      data _≡_ (x : A) : A → Set a where\n        refl : x ≡ x\n      {-#
  BUILTIN EQUALITY _≡_ #-}\n  ```\n\n* Builtin `NIL` and `CONS` have been merged with
  `LIST`.\n\n  When binding the `LIST` builtin, `NIL` and `CONS` are bound to\n  the
  appropriate constructors automatically. This means that instead\n  of writing\n\n
  \ ```agda\n  {-# BUILTIN LIST List #-}\n  {-# BUILTIN NIL  []   #-}\n  {-# BUILTIN
  CONS _∷_  #-}\n  ```\n\n  you just write\n\n  ```agda\n  {-# BUILTIN LIST List #-}\n
  \ ```\n\n  Attempting to bind `NIL` or `CONS` results in a warning and has otherwise
  no\n  effect.\n\n* The `--no-unicode` pragma prevents Agda from introducing unicode
  characters\n  when pretty printing a term. Lambda, Arrows and Forall quantifiers
  are all\n  replaced by their ascii only version. Instead of resorting to subscript\n
  \ suffixes, Agda uses ascii digit characters.\n\n* New option `--inversion-max-depth=N`.\n\n
  \ The depth is used to avoid looping due to inverting pattern matching for\n  unsatisfiable
  constraints [Issue [#431](https://github.com/agda/agda/issues/431)].\n  This option
  is only expected to be necessary in pathological cases.\n\n* New option `--no-print-pattern-synonyms`.\n\n
  \ This disables the use of pattern synonyms in output from Agda.\n  See [Issue [#2902](https://github.com/agda/agda/issues/2902)]
  for situations\n  where this might be desirable.\n\n* New fine-grained control over
  the warning machinery: ability to (en/dis)able\n  warnings on a one-by-one basis.\n\n*
  The command line option `--help` now takes an optional argument which\n  allows
  the user to request more specific usage information about particular\n  topics.
  The only one added so far is `warning`.\n\n* New pragma NOINLINE.\n\n  ```agda\n
  \ {-# NOINLINE f #-}\n  ```\n\n  Disables automatic inlining of `f`.\n\n* New pragma
  WARNING_ON_USAGE\n\n  ```\n  {-# WARNING_ON_USAGE QName Message #}\n  ```\n\n  Prints
  Message whenever QName is used.\n\nEmacs mode\n----------\n\n* Banana brackets have
  been added to the Agda input method.\n  ```\n    \\((   #x2985  LEFT  WHITE PARENTHESIS\n
  \   \\))   #x2986  RIGHT WHITE PARENTHESIS\n  ```\n\n* Result splitting will introduce
  the trailing hidden arguments,\n  if there is nothing else todo\n  [Issue [#2871](https://github.com/agda/agda/issues/2871)].\n
  \ Example:\n  ```agda\n    data Fun (A : Set) : Set where\n      mkFun : (A → A)
  → Fun A\n\n    test : {A : Set} → Fun A\n    test = ?\n\n  ```\n  Splitting on the
  result here (`C-c C-c RET`) will append\n  `{A}` to the left hand side.\n  ```agda\n
  \   test {A} = ?\n  ```\n\n* Light highlighting is performed dynamically, even if
  the file is not\n  loaded [Issue [#2794](https://github.com/agda/agda/issues/2794)].\n\n
  \ This light highlighting is based on the token stream generated by\n  Agda's lexer:
  the code is only highlighted if the file is lexically\n  correct. If the Agda backend
  is not busy with something else, then\n  the code is highlighted automatically in
  certain situations:\n\n  * When the file is saved.\n\n  * When Emacs has been idle,
  continuously, for a certain period of\n    time (by default 0.2 s) after the last
  modification of the file,\n    and the file has not been saved (or marked as being
  unmodified).\n    This functionality can be turned off, and the time period can
  be\n    customised.\n\n* Highlighting of comments is no longer handled by Font Lock
  mode\n  [Issue [#2794](https://github.com/agda/agda/issues/2794)].\n\n* The Emacs
  mode's syntax table has been changed.\n\n  Previously `_` was treated as punctuation.
  Now it is treated in the\n  same way as most other characters: if the standard syntax
  table\n  assigns it the syntax class \"whitespace\", \"open parenthesis\" or\n  \"close
  parenthesis\", then it gets that syntax class, and otherwise\n  it gets the syntax
  class \"word constituent\".\n\nCompiler backends\n-----------------\n\n* The GHC
  backend now automatically compiles BUILTIN LIST to Haskell lists.\n\n  This means
  that it's no longer necessary to give a COMPILE GHC pragma for the\n  builtin list
  type. Indeed, doing so has no effect on the compilation and\n  results in a warning.\n\n*
  The GHC backend performance improvements.\n\n  Generated Haskell code now contains
  approximate type signatures, which lets\n  GHC get rid of many of the `unsafeCoerce`s.
  This leads to performance\n  improvements of up to 50% of compiled code.\n\n* The
  GHC backend now compiles the `INFINITY`, `SHARP` and `FLAT`\n  builtins in a different
  way [Issue\n  [#2909](https://github.com/agda/agda/issues/2909)].\n\n  Previously
  these were compiled to (basically) nothing. Now the\n  `INFINITY` builtin is compiled
  to `Infinity`, available from\n  `MAlonzo.RTE`:\n\n  ```haskell\n  data Inf a            =
  Sharp { flat :: a }\n  type Infinity level a = Inf a\n  ```\n\n  The `SHARP` builtin
  is compiled to `Sharp`, and the `FLAT` builtin\n  is (by default) compiled to a
  corresponding destructor.\n\n  Note that code that interacts with Haskell libraries
  may have to be\n  updated. As an example, here is one way to print colists of\n
  \ characters using the Haskell function `putStr`:\n\n  ```agda\n  open import Agda.Builtin.Char\n
  \ open import Agda.Builtin.Coinduction\n  open import Agda.Builtin.IO\n  open import
  Agda.Builtin.Unit\n\n  data Colist {a} (A : Set a) : Set a where\n    []  : Colist
  A\n    _∷_ : A → ∞ (Colist A) → Colist A\n\n  {-# FOREIGN GHC\n    data Colist a
  \   = Nil | Cons a (MAlonzo.RTE.Inf (Colist a))\n    type Colist' l a = Colist a\n\n
  \   fromColist :: Colist a -> [a]\n    fromColist Nil         = []\n    fromColist
  (Cons x xs) = x : fromColist (MAlonzo.RTE.flat xs)\n    #-}\n\n  {-# COMPILE GHC
  Colist = data Colist' (Nil | Cons) #-}\n\n  postulate\n    putStr : Colist Char
  → IO ⊤\n\n  {-# COMPILE GHC putStr = putStr . fromColist #-}\n  ```\n\n* `COMPILE
  GHC` pragmas have been included for the size primitives\n  [Issue [#2879](https://github.com/agda/agda/issues/2879)].\n\nLaTeX
  backend\n-------------\n\n* The `code` environment can now take arguments [Issues\n
  \ [#2744](https://github.com/agda/agda/issues/2744) and\n  [#2453](https://github.com/agda/agda/issues/2453)].\n\n
  \ Everything from \\begin{code} to the end of the line is preserved in\n  the generated
  LaTeX code, and not treated as Agda code.\n\n  The default implementation of the
  `code` environment recognises one\n  optional argument, `hide`, which can be used
  for code that should be\n  type-checked, but not typeset:\n  ```latex\n  \\begin{code}[hide]\n
  \   open import Module\n  \\end{code}\n  ```\n\n  The `AgdaHide` macro has not been
  removed, but has been deprecated\n  in favour of `[hide]`.\n\n* The `AgdaSuppressSpace`
  and `AgdaMultiCode` environments no longer\n  take an argument.\n\n  Instead some
  documents need to be compiled multiple times.\n\n* The `--count-clusters` flag can
  now be given in `OPTIONS` pragmas.\n\n* The `nofontsetup` option to the LaTeX package
  `agda` was broken, and\n  has (hopefully) been fixed\n  [Issue [#2773](https://github.com/agda/agda/issues/2773)].\n\n
  \ Fewer packages than before are loaded when `nofontsetup` is used,\n  see `agda.sty`
  for details. Furthermore, if LuaLaTeX or XeLaTeX are\n  not used, then the font
  encoding is no longer changed.\n\n* The new option `noinputencodingsetup` instructs
  the LaTeX package\n  `agda` to not change the input encoding, and to not load the
  `ucs`\n  package.\n\n* Underscores are now typeset using `\\AgdaUnderscore{}`.\n\n
  \ The default implementation is `\\_` (the command that was previously\n  generated
  for underscores). Note that it is possible to override\n  this implementation.\n\n*
  OtherAspects (unsolved meta variables, catchall clauses, etc.) are\n  now correctly
  highlighted in the LaTeX backend (and the HTML one).\n  [Issue [#2474](https://github.com/agda/agda/issues/2474)]\n\nHTML
  backend\n------------\n\n* An identifier (excluding bound variables),\n  gets the
  identifier itself as an anchor,\n  _in addition_ to the file position\n  [Issue
  [#2756](https://github.com/agda/agda/issues/2756)].\n  In Agda 2.5.3, the identifier
  anchor would _replace_ the file position anchor\n  [Issue [#2604](https://github.com/agda/agda/issues/2604)].\n\n
  \ Symbolic anchors look like\n  ```html\n  <a id=\"test1\">\n  <a id=\"M.bla\">\n
  \ ```\n  while file position anchors just give the character position in the file:\n
  \ ```html\n  <a id=\"42\">\n  ```\n\n  Top-level module names do not get a symbolic
  anchor, since the position of\n  a top-level module is defined to be the beginning
  of the file.\n\n  Example:\n\n  ```agda\n  module Issue2604 where   -- Character
  position anchor\n\n  test1 : Set₁             -- Issue2604.html#test1\n  test1 =
  bla\n    where\n    bla = Set              -- Only character position anchor\n\n
  \ test2 : Set₁             -- Issue2604.html#test2\n  test2 = bla\n    where\n    bla
  = Set              -- Only character position anchor\n\n  test3 : Set₁             --
  Issue2604.html#test3\n  test3 = bla\n    module M where         -- Issue2604.html#M\n
  \   bla = Set              -- Issue2604.html#M.bla\n\n  module NamedModule where
  -- Issue2604.html#NamedModule\n    test4 : Set₁           -- Issue2604.html#NamedModule.test4\n
  \   test4 = M.bla\n\n  module _ where           -- Only character position anchor\n
  \   test5 : Set₁           -- Only character position anchor\n    test5 = M.bla\n
  \ ```\n\nList of closed issues\n---------------------\n\nFor 2.5.4, the following
  issues have been closed\n(see [bug tracker](https://github.com/agda/agda/issues)):\n\n
  \ - [#351](https://github.com/agda/agda/issues/351): Constraint solving for irrelevant
  metas\n  - [#421](https://github.com/agda/agda/issues/421): Higher order positivity\n
  \ - [#431](https://github.com/agda/agda/issues/431): Constructor-headed function
  makes type-checker diverge\n  - [#437](https://github.com/agda/agda/issues/437):
  Detect when something cannot be a function type\n  - [#488](https://github.com/agda/agda/issues/488):
  Refining on user defined syntax mixes up the order of the subgoals\n  - [#681](https://github.com/agda/agda/issues/681):
  Lack of visual state indicators in new Emacs mode\n  - [#689](https://github.com/agda/agda/issues/689):
  Contradictory constraints should yield error\n  - [#708](https://github.com/agda/agda/issues/708):
  Coverage checker not taking literal patterns into account properly\n  - [#875](https://github.com/agda/agda/issues/875):
  Nonstrict irrelevance violated by implicit inference\n  - [#964](https://github.com/agda/agda/issues/964):
  Allow unsolved metas in imported files\n  - [#987](https://github.com/agda/agda/issues/987):
  --html anchors could be more informative\n  - [#1054](https://github.com/agda/agda/issues/1054):
  Inlined Agda code in LaTeX backend\n  - [#1131](https://github.com/agda/agda/issues/1131):
  Infix definitions not allowed in let definitions\n  - [#1169](https://github.com/agda/agda/issues/1169):
  Auto fails with non-terminating function\n  - [#1268](https://github.com/agda/agda/issues/1268):
  Hard to print type of variable if the type starts with an instance argument\n  -
  [#1384](https://github.com/agda/agda/issues/1384): Order of constructor arguments
  matters for coverage checker\n  - [#1425](https://github.com/agda/agda/issues/1425):
  Instances with relevant recursive instance arguments are not considered in irrelevant
  positions\n  - [#1548](https://github.com/agda/agda/issues/1548): Confusing error
  about ambiguous definition with parametrized modules\n  - [#1884](https://github.com/agda/agda/issues/1884):
  what is the format of the libraries and defaults files\n  - [#1906](https://github.com/agda/agda/issues/1906):
  Possible performance problem\n  - [#2056](https://github.com/agda/agda/issues/2056):
  Cannot instantiate meta to solution...: Pattern checking done too early in where
  block\n  - [#2067](https://github.com/agda/agda/issues/2067): Display forms in parameterised
  module too general\n  - [#2183](https://github.com/agda/agda/issues/2183): Allow
  splitting on dotted variables\n  - [#2226](https://github.com/agda/agda/issues/2226):
  open {{...}} gets hiding wrong\n  - [#2255](https://github.com/agda/agda/issues/2255):
  Performance issue with deeply-nested lambdas\n  - [#2306](https://github.com/agda/agda/issues/2306):
  Commands in the emacs-mode get confused if we add question marks to the file\n  -
  [#2384](https://github.com/agda/agda/issues/2384): More fine-grained blocking in
  constraint solver\n  - [#2401](https://github.com/agda/agda/issues/2401): LaTeX
  backend error\n  - [#2404](https://github.com/agda/agda/issues/2404): checkType
  doesn't accept a type-checking definition checked with the same type\n  - [#2420](https://github.com/agda/agda/issues/2420):
  Failed to solve level constraints in record type with hole\n  - [#2421](https://github.com/agda/agda/issues/2421):
  After emacs starts up, Agda does not process file without restart of Agda\n  - [#2436](https://github.com/agda/agda/issues/2436):
  Agda allows coinductive records with eta-equality\n  - [#2450](https://github.com/agda/agda/issues/2450):
  Irrelevant variables are pruned too eagerly\n  - [#2474](https://github.com/agda/agda/issues/2474):
  The LaTeX and HTML backends do not highlight (all) unsolved metas\n  - [#2484](https://github.com/agda/agda/issues/2484):
  Regression related to sized types\n  - [#2526](https://github.com/agda/agda/issues/2526):
  Better documentation of record modules\n  - [#2536](https://github.com/agda/agda/issues/2536):
  UTF8 parsed incorrectly for literate agda files\n  - [#2565](https://github.com/agda/agda/issues/2565):
  Options for the interaction action give to keep the overloaded literals and sections?\n
  \ - [#2576](https://github.com/agda/agda/issues/2576): Shadowing data decl by data
  sig produces Missing type signature error\n  - [#2594](https://github.com/agda/agda/issues/2594):
  Valid partial cover rejected: \"Cannot split on argument of non-datatype\"\n  -
  [#2600](https://github.com/agda/agda/issues/2600): Stack complains about Agda.cabal\n
  \ - [#2607](https://github.com/agda/agda/issues/2607): Instance search confused
  when an instance argument is sourced from a record\n  - [#2617](https://github.com/agda/agda/issues/2617):
  Installation instructions\n  - [#2623](https://github.com/agda/agda/issues/2623):
  Incorrect indentation when \\AgdaHide is used\n  - [#2634](https://github.com/agda/agda/issues/2634):
  Fixity declaration ignored in definitions in record\n  - [#2636](https://github.com/agda/agda/issues/2636):
  The positivity checker complains when a new definition is added in the same where
  clause\n  - [#2640](https://github.com/agda/agda/issues/2640): Unifier dots the
  relevant pattern variables when it should dot the irrelevant ones\n  - [#2668](https://github.com/agda/agda/issues/2668):
  Changing the visibility of a module parameter breaks `with`\n  - [#2728](https://github.com/agda/agda/issues/2728):
  Bad interaction between caching and the warning machinery\n  - [#2738](https://github.com/agda/agda/issues/2738):
  Update Stackage LTS from 9.1 to version supporting Alex 3.2.3\n  - [#2744](https://github.com/agda/agda/issues/2744):
  It should be possible to give arguments to the code environment\n  - [#2745](https://github.com/agda/agda/issues/2745):
  Broken build with GHC 7.8.4 due to (new) version 1.2.2.0 of hashtables\n  - [#2749](https://github.com/agda/agda/issues/2749):
  Add --no-unicode cli option to Agda\n  - [#2751](https://github.com/agda/agda/issues/2751):
  Unsolved constraints, but no highlighting\n  - [#2752](https://github.com/agda/agda/issues/2752):
  Mutual blocks inside instance blocks\n  - [#2753](https://github.com/agda/agda/issues/2753):
  Unsolved constraint, related to instance arguments and sized types\n  - [#2756](https://github.com/agda/agda/issues/2756):
  HTML backend generates broken links\n  - [#2758](https://github.com/agda/agda/issues/2758):
  Relevant meta is instantiated with irrelevant solution\n  - [#2759](https://github.com/agda/agda/issues/2759):
  Empty mutual blocks should be warning rather than error\n  - [#2762](https://github.com/agda/agda/issues/2762):
  Automatically generate DISPLAY pragmas to fold pattern synonyms\n  - [#2763](https://github.com/agda/agda/issues/2763):
  Internal Error at \"src/full/Agda/TypeChecking/Abstract.hs:138\"\n  - [#2765](https://github.com/agda/agda/issues/2765):
  Inferred level expressions are often \"reversed\"\n  - [#2769](https://github.com/agda/agda/issues/2769):
  Agda prints ill-formed expression, record argument dropped\n  - [#2771](https://github.com/agda/agda/issues/2771):
  Erroneous 'with' error message\n  - [#2773](https://github.com/agda/agda/issues/2773):
  The nofontsetup option does not work as advertised\n  - [#2775](https://github.com/agda/agda/issues/2775):
  Irrelevance to be taken into account in 'with' abstraction.\n  - [#2776](https://github.com/agda/agda/issues/2776):
  Dotted variable in inferred type\n  - [#2780](https://github.com/agda/agda/issues/2780):
  Improve level constraint solving for groups of inequality constraints\n  - [#2782](https://github.com/agda/agda/issues/2782):
  Extending Agda reflection to introduce postulates\n  - [#2785](https://github.com/agda/agda/issues/2785):
  internal error @ ConcreteToAbstract.hs:721\n  - [#2787](https://github.com/agda/agda/issues/2787):
  Overloaded pattern synonyms\n  - [#2792](https://github.com/agda/agda/issues/2792):
  Safe modules can sometimes not be imported from unsafe modules\n  - [#2794](https://github.com/agda/agda/issues/2794):
  Using \\texttt{-} destroys code coloring in literate file\n  - [#2796](https://github.com/agda/agda/issues/2796):
  Overloaded (inherited) projection resolution fails with parametrized record\n  -
  [#2798](https://github.com/agda/agda/issues/2798): The LaTeX backend ignores the
  \"operator\" aspect\n  - [#2802](https://github.com/agda/agda/issues/2802): Printing
  of overloaded functions broken due to eager normalization of projections\n  - [#2803](https://github.com/agda/agda/issues/2803):
  Case splitting loses names of hidden arguments\n  - [#2808](https://github.com/agda/agda/issues/2808):
  Confusing error when inserting declaration before top-level module\n  - [#2810](https://github.com/agda/agda/issues/2810):
  Make `--caching` a pragma option\n  - [#2811](https://github.com/agda/agda/issues/2811):
  OPTION --caching allowed in file (Issue #2810)\n  - [#2819](https://github.com/agda/agda/issues/2819):
  Forcing analysis doesn't consider relevance\n  - [#2821](https://github.com/agda/agda/issues/2821):
  BUILTIN BOOL gremlin\n  - [#2824](https://github.com/agda/agda/issues/2824): Allow
  {-# BUILTIN #-} in preamble and in parametrized modules\n  - [#2826](https://github.com/agda/agda/issues/2826):
  Case splitting on earlier variable uses duplicate variable name\n  - [#2827](https://github.com/agda/agda/issues/2827):
  Variables off in with-clauses.  Parameter refinement?\n  - [#2831](https://github.com/agda/agda/issues/2831):
  NO_POSITIVITY_CHECK pragma can be written before a mutual block without data or
  record types\n  - [#2832](https://github.com/agda/agda/issues/2832): BUILTIN NIL
  and CONS are not needed\n  - [#2834](https://github.com/agda/agda/issues/2834):
  Disambiguation of type based on pattern leads to non-unique meta solution\n  - [#2836](https://github.com/agda/agda/issues/2836):
  The Emacs mode does not handle .lagda.tex files\n  - [#2840](https://github.com/agda/agda/issues/2840):
  Internal error in positivity with modules/datatype definitions\n  - [#2841](https://github.com/agda/agda/issues/2841):
  Opting out of idiom brackets\n  - [#2844](https://github.com/agda/agda/issues/2844):
  Root documentation URL redirects to version 2.5.2\n  - [#2849](https://github.com/agda/agda/issues/2849):
  Internal error at absurd pattern followed by `rewrite`\n  - [#2854](https://github.com/agda/agda/issues/2854):
  Agda worries about possibly empty type of sizes even when no builtins for size are
  active\n  - [#2855](https://github.com/agda/agda/issues/2855): Single-clause definition
  is both unreachable and incomplete\n  - [#2856](https://github.com/agda/agda/issues/2856):
  Panic: unbound variable\n  - [#2859](https://github.com/agda/agda/issues/2859):
  Error \"pattern variable shadows constructor\" caused by parameter refinement\n
  \ - [#2862](https://github.com/agda/agda/issues/2862): inconsistency from a mutual
  datatype declaration and module definition\n  - [#2867](https://github.com/agda/agda/issues/2867):
  Give does not insert parenthesis for module parameters\n  - [#2868](https://github.com/agda/agda/issues/2868):
  With --postfix-projections, record fields are printed preceded by a dot when working
  within the record\n  - [#2870](https://github.com/agda/agda/issues/2870): Lexical
  error for \\- (hyphen)\n  - [#2871](https://github.com/agda/agda/issues/2871): Introduce
  just trailing hidden arguments by result splitting\n  - [#2873](https://github.com/agda/agda/issues/2873):
  Refinement problem in presence of overloaded constructors\n  - [#2874](https://github.com/agda/agda/issues/2874):
  Internal error in src/full/Agda/TypeChecking/Coverage/Match.hs:312\n  - [#2878](https://github.com/agda/agda/issues/2878):
  Support for GHC 8.4.1\n  - [#2879](https://github.com/agda/agda/issues/2879): Include
  COMPILE GHC pragmas for size primitives\n  - [#2881](https://github.com/agda/agda/issues/2881):
  Internal error in BasicOps\n  - [#2883](https://github.com/agda/agda/issues/2883):
  \"internal error in TypeChecking/Substitute.hs:379\"\n  - [#2884](https://github.com/agda/agda/issues/2884):
  Missing PDF user manual in the tarball\n  - [#2888](https://github.com/agda/agda/issues/2888):
  Internal error caused by new forcing translation\n  - [#2894](https://github.com/agda/agda/issues/2894):
  Unifier tries to eta expand non-eta record\n  - [#2896](https://github.com/agda/agda/issues/2896):
  Unifier throws away pattern\n  - [#2897](https://github.com/agda/agda/issues/2897):
  Internal error for local modules with refined parameters\n  - [#2904](https://github.com/agda/agda/issues/2904):
  No tab completion for GHCNoMain\n  - [#2906](https://github.com/agda/agda/issues/2906):
  Confusing \"cannot be translated to a Haskell type\" error message\n  - [#2908](https://github.com/agda/agda/issues/2908):
  primForce is compiled away\n  - [#2909](https://github.com/agda/agda/issues/2909):
  Agda uses newtypes incorrectly, causing wellformed programs to loop\n  - [#2911](https://github.com/agda/agda/issues/2911):
  Inferring missing instance clause panics in refined context\n  - [#2912](https://github.com/agda/agda/issues/2912):
  Add fine-grained control over the displayed warnings\n  - [#2914](https://github.com/agda/agda/issues/2914):
  Slicing ignores as pragma?\n  - [#2916](https://github.com/agda/agda/issues/2916):
  The GHC backend generates code with an incorrect number of constructor arguments\n
  \ - [#2917](https://github.com/agda/agda/issues/2917): Very slow due to unsolved
  size?\n  - [#2919](https://github.com/agda/agda/issues/2919): Internal error in
  Agda.TypeChecking.Forcing\n  - [#2921](https://github.com/agda/agda/issues/2921):
  COMPILE data for data types with erased constructor arguments\n  - [#2923](https://github.com/agda/agda/issues/2923):
  Word.agda not included as builtin\n  - [#2925](https://github.com/agda/agda/issues/2925):
  Allow adding the same rewrite rules multiple times\n  - [#2927](https://github.com/agda/agda/issues/2927):
  Panic related to sized types\n  - [#2928](https://github.com/agda/agda/issues/2928):
  Internal error in Agda.TypeChecking.Rules.LHS\n  - [#2931](https://github.com/agda/agda/issues/2931):
  Rename Agda.Builtin.Size.ω to ∞?\n  - [#2941](https://github.com/agda/agda/issues/2941):
  \"coinductive\" record inconsistent\n  - [#2944](https://github.com/agda/agda/issues/2944):
  Regression, seemingly related to record expressions\n  - [#2945](https://github.com/agda/agda/issues/2945):
  Inversion warning in code that used to be accepted\n  - [#2947](https://github.com/agda/agda/issues/2947):
  Internal error in Agda.TypeChecking.Forcing\n  - [#2952](https://github.com/agda/agda/issues/2952):
  Wrong compilation of pattern matching to Haskell\n  - [#2953](https://github.com/agda/agda/issues/2953):
  Generated Haskell code does not typecheck\n  - [#2954](https://github.com/agda/agda/issues/2954):
  Pattern matching on string gives unexpected unreachable clause\n  - [#2957](https://github.com/agda/agda/issues/2957):
  Support for async 2.2.1\n  - [#2958](https://github.com/agda/agda/issues/2958):
  `as` names being duplicated in buffer after `with`\n  - [#2959](https://github.com/agda/agda/issues/2959):
  Repeating a successful command after revert + reload fails with caching enabled\n
  \ - [#2960](https://github.com/agda/agda/issues/2960): Uncommenting indented lines
  doesn't work\n  - [#2963](https://github.com/agda/agda/issues/2963): Extended lambdas
  bypass positivity checking in records\n  - [#2966](https://github.com/agda/agda/issues/2966):
  Internal error in Auto\n  - [#2968](https://github.com/agda/agda/issues/2968): Bad
  Interaction with copatterns and eta?, leads to ill-typed terms in error messages.\n
  \ - [#2971](https://github.com/agda/agda/issues/2971): Copattern split with `--no-irrelevant-projections`
  panics\n  - [#2974](https://github.com/agda/agda/issues/2974): Copatterns break
  canonicity\n  - [#2975](https://github.com/agda/agda/issues/2975): Termination checker
  runs too early for definitions inside record (or: positivity checker runs too late)\n
  \ - [#2976](https://github.com/agda/agda/issues/2976): Emacs mode reports errors
  in connection with highlighting comments\n  - [#2978](https://github.com/agda/agda/issues/2978):
  Double solving of meta\n  - [#2985](https://github.com/agda/agda/issues/2985): The
  termination checker accepts non-terminating code\n  - [#2989](https://github.com/agda/agda/issues/2989):
  Internal error when checking record match in let expr\n  - [#2990](https://github.com/agda/agda/issues/2990):
  Performance regression related to the abstract machine\n  - [#2994](https://github.com/agda/agda/issues/2994):
  Solution accepted in hole is subsequently rejected on reload\n  - [#2996](https://github.com/agda/agda/issues/2996):
  Internal error with -v tc.cover:20\n  - [#2997](https://github.com/agda/agda/issues/2997):
  Internal error in Agda.TypeChecking.Rules.LHS\n  - [#2998](https://github.com/agda/agda/issues/2998):
  Regression: With clause pattern x is not an instance of its parent pattern \"eta
  expansion of x\"\n  - [#3002](https://github.com/agda/agda/issues/3002): Spurious
  1 after simplification\n  - [#3004](https://github.com/agda/agda/issues/3004): Agda
  hangs on extended lambda\n  - [#3007](https://github.com/agda/agda/issues/3007):
  Internal error in Parser\n  - [#3012](https://github.com/agda/agda/issues/3012):
  Internal Error at : \"src/full/Agda/TypeChecking/Reduce/Fast.hs:1030\"\n  - [#3014](https://github.com/agda/agda/issues/3014):
  Internal error in Rules.LHS\n  - [#3020](https://github.com/agda/agda/issues/3020):
  Missing highlighting in record modules\n  - [#3023](https://github.com/agda/agda/issues/3023):
  Support for GHC 8.4.2\n  - [#3024](https://github.com/agda/agda/issues/3024): Postfix
  projection patterns not highlighted correctly with agda --latex\n  - [#3030](https://github.com/agda/agda/issues/3030):
  [ warning ] user defined warnings\n  - [#3031](https://github.com/agda/agda/issues/3031):
  Eta failure for record meta with irrelevant fields\n  - [#3033](https://github.com/agda/agda/issues/3033):
  Giving and solving don't insert parenthesis for applications in dot pattern\n  -
  [#3044](https://github.com/agda/agda/issues/3044): Internal error in src/full/Agda/TypeChecking/Substitute/Class.hs:209\n
  \ - [#3045](https://github.com/agda/agda/issues/3045): GHC backend generates type
  without enough arguments\n  - [#3046](https://github.com/agda/agda/issues/3046):
  do-notation causes parse errors in subsequent where clauses\n  - [#3049](https://github.com/agda/agda/issues/3049):
  Positivity unsoundness\n  - [#3050](https://github.com/agda/agda/issues/3050): We
  revert back to call-by-name during positivity checking\n  - [#3051](https://github.com/agda/agda/issues/3051):
  Pattern synonyms should be allowed in mutual blocks\n  - [#3052](https://github.com/agda/agda/issues/3052):
  Another recent inference change\n  - [#3062](https://github.com/agda/agda/issues/3062):
  Literal match does not respect first-match semantics\n  - [#3063](https://github.com/agda/agda/issues/3063):
  Internal error in Agda.TypeChecking.Forcing\n  - [#3064](https://github.com/agda/agda/issues/3064):
  Coverage checker bogus on literals combined with copatterns\n  - [#3065](https://github.com/agda/agda/issues/3065):
  Internal error in coverage checker triggered by literal dot pattern\n  - [#3067](https://github.com/agda/agda/issues/3067):
  checking hangs on invalid program\n  - [#3072](https://github.com/agda/agda/issues/3072):
  invalid section printing\n  - [#3074](https://github.com/agda/agda/issues/3074):
  Wrong hiding causes internal error in LHS checker\n  - [#3075](https://github.com/agda/agda/issues/3075):
  Automatic inlining and tactics\n  - [#3078](https://github.com/agda/agda/issues/3078):
  Error building with GHC 7.10.2: Missing transformers library\n  - [#3079](https://github.com/agda/agda/issues/3079):
  Wrong parameter hiding for instance open\n  - [#3080](https://github.com/agda/agda/issues/3080):
  Case splitting prints out-of-scope pattern synonyms\n  - [#3082](https://github.com/agda/agda/issues/3082):
  Emacs mode regression: a ? inserted before existing hole hijacks its interaction
  point\n  - [#3083](https://github.com/agda/agda/issues/3083): Wrong hiding in module
  application\n  - [#3084](https://github.com/agda/agda/issues/3084): Changes to mode
  line do not take effect immediately\n  - [#3085](https://github.com/agda/agda/issues/3085):
  Postpone checking a pattern let binding when type is blocked\n  - [#3090](https://github.com/agda/agda/issues/3090):
  Internal error in parser when using parentheses in BUILTIN pragma\n  - [#3096](https://github.com/agda/agda/issues/3096):
  Support GHC 8.4.3\n\n\nRelease notes for Agda version 2.5.3\n====================================\n\nInstallation
  and infrastructure\n-------------------------------\n\n* Added support for GHC 8.0.2
  and 8.2.1.\n\n* Removed support for GHC 7.6.3.\n\n* Markdown support for literate
  Agda\n  \\[PR [#2357](https://github.com/agda/agda/pull/2357)].\n\n  Files ending
  in `.lagda.md` will be parsed as literate Markdown files.\n\n  + Code blocks start
  with  ```` ``` ```` or ```` ```agda ```` in its own line, and end with\n    ````
  ``` ````, also in its own line.\n  + Code blocks which should be type-checked by
  Agda but should not be visible\n    when the Markdown is rendered may be enclosed
  in HTML comment delimiters\n    (`<!--`  and `-->`).\n  + Code blocks which should
  be ignored by Agda, but rendered in the final\n    document may be indented by four
  spaces.\n  + Note that inline code fragments are not supported due to the difficulty
  of\n    interpreting their indentation level with respect to the rest of the file.\n\nLanguage\n--------\n\n###
  Pattern matching\n\n* Dot patterns.\n\n  The dot in front of an inaccessible pattern
  can now be skipped if the\n  pattern consists entirely of constructors or literals.
  For example:\n  ```agda\n    open import Agda.Builtin.Bool\n\n    data D : Bool
  → Set where\n      c : D true\n\n    f : (x : Bool) → D x → Bool\n    f true c =
  true\n\n  ```\n  Before this change, you had to write `f .true c = true`.\n\n* With-clause
  patterns can be replaced by _\n  [Issue [#2363](https://github.com/agda/agda/issues/2363)].\n
  \ Example:\n  ```agda\n    test : Nat → Set\n    test zero    with zero\n    test
  _       | _ = Nat\n    test (suc x) with zero\n    test _       | _ = Nat\n  ```\n
  \ We do not have to spell out the pattern of the parent clause\n  (`zero` / `suc
  x`) in the with-clause if we do not need the\n  pattern variables.  Note that `x`
  is not in scope in the\n  with-clause!\n\n  A more elaborate example, which cannot
  be reduced to\n  an ellipsis `...`:\n  ```agda\n    record R : Set where\n      coinductive
  -- disallow matching\n      field f : Bool\n            n : Nat\n\n    data P (r
  : R) : Nat → Set where\n      fTrue  : R.f r ≡ true → P r zero\n      nSuc   : P
  r (suc (R.n r))\n\n    data Q : (b : Bool) (n : Nat) →  Set where\n      true! :
  Q true zero\n      suc!  : ∀{b n} → Q b (suc n)\n\n    test : (r : R) {n : Nat}
  (p : P r n) → Q (R.f r) n\n    test r nSuc       = suc!\n    test r (fTrue p)  with
  R.f r\n    test _ (fTrue ()) | false\n    test _ _          | true = true!  -- underscore
  instead of (isTrue _)\n  ```\n\n* Pattern matching lambdas (also known as extended
  lambdas) can now be\n  nullary, mirroring the behaviour for ordinary function definitions.\n
  \ [Issue [#2671](https://github.com/agda/agda/issues/2671)]\n\n  This is useful
  for case splitting on the result inside an\n  expression: given\n  ```agda\n  record
  _×_ (A B : Set) : Set where\n    field\n      π₁ : A\n      π₂ : B\n  open _×_\n
  \ ```\n  one may case split on the result (C-c C-c RET) in a hole\n  ```agda\n    λ
  { → {!!}}\n  ```\n  of type A × B to produce\n  ```agda\n    λ { .π₁ → {!!} ; .π₂
  → {!!}}\n  ```\n\n* Records with a field of an empty type are now recognized as
  empty by Agda.\n  In particular, they can be matched against with an absurd pattern
  ().\n  For example:\n  ```agda\n    data ⊥ : Set where\n\n    record Empty : Set
  where\n      field absurdity : ⊥\n\n    magic : Empty → ⊥\n    magic ()\n  ```\n\n*
  Injective pragmas.\n\n  Injective pragmas can be used to mark a definition as injective
  for the\n  pattern matching unifier. This can be used as a version of\n  `--injective-type-constructors`
  that only applies to specific datatypes.\n  For example:\n  ```agda\n    open import
  Agda.Builtin.Equality\n    data Fin : Nat → Set where\n      zero : {n : Nat} →
  Fin (suc n)\n      suc  : {n : Nat} → Fin n → Fin (suc n)\n\n    {-# INJECTIVE Fin
  #-}\n\n    Fin-injective : {m n : Nat} → Fin m ≡ Fin n → m ≡ n\n    Fin-injective
  refl = refl\n  ```\n  Aside from datatypes, this pragma can also be used to mark
  other definitions\n  as being injective (for example postulates).\n\n* Metavariables
  can no longer be instantiated during case splitting. This means\n  Agda will refuse
  to split instead of taking the first constructor it finds.\n  For example:\n  ```agda\n
  \   open import Agda.Builtin.Nat\n\n    data Vec (A : Set) : Nat → Set where\n      nil
  : Vec A 0\n      cons : {n : Nat} → A → Vec A n → Vec A (suc n)\n\n    foo : Vec
  Nat _ → Nat\n    foo x = {!x!}\n  ```\n  In Agda 2.5.2, case splitting on `x` produced
  the single clause\n  `foo nil = {!!}`, but now Agda refuses to split.\n\n### Reflection\n\n*
  New TC primitive: `debugPrint`.\n\n  ```agda\n    debugPrint : String → Nat → List
  ErrorPart → TC ⊤\n  ```\n\n  This maps to the internal function `reportSDoc`. Debug
  output is enabled with\n  the `-v` flag at the command line, or in an `OPTIONS`
  pragma. For instance,\n  giving `-v a.b.c:10` enables printing from `debugPrint
  \"a.b.c.d\" 10 msg`. In the\n  Emacs mode, debug output ends up in the `*Agda debug*`
  buffer.\n\n### Built-ins\n\n* BUILTIN REFL is now superfluous, subsumed by BUILTIN
  EQUALITY\n  [Issue [#2389](https://github.com/agda/agda/issues/2389)].\n\n* BUILTIN
  EQUALITY is now more liberal\n  [Issue [#2386](https://github.com/agda/agda/issues/2386)].\n
  \ It accepts, among others, the following new definitions of equality:\n  ```agda\n
  \   -- Non-universe polymorphic:\n    data _≡_ {A : Set} (x : A) : A → Set where\n
  \     refl : x ≡ x\n\n    -- ... with explicit argument to refl;\n    data _≡_ {A
  : Set} : (x y : A) → Set where\n      refl : {x : A} → x ≡ x\n\n    -- ... even
  visible\n    data _≡_ {A : Set} : (x y : A) → Set where\n      refl : (x : A) →
  x ≡ x\n\n    -- Equality in a different universe than domain:\n    -- (also with
  explicit argument to refl)\n    data _≡_ {a} {A : Set a} (x : A) : A → Set where\n
  \     refl : x ≡ x\n\n  ```\n  The standard definition is still:\n  ```agda\n    --
  Equality in same universe as domain:\n    data _≡_ {a} {A : Set a} (x : A) : A →
  Set a where\n      refl : x ≡ x\n  ```\n\n### Miscellaneous\n\n* Rule change for
  omitted top-level module headers.\n  [Issue [#1077](https://github.com/agda/agda/issues/1077)]\n\n
  \ If your file is named `Bla.agda`, then the following content\n  is rejected.\n
  \ ```agda\n    foo = Set\n    module Bla where\n      bar = Set\n  ```\n  Before
  the fix of this issue, Agda would add the missing module\n  header `module Bla where`
  at the top of the file.\n  However, in this particular case it is more likely the
  user\n  put the declaration `foo = Set` before the module start in error.\n  Now
  you get the error\n  ```\n    Illegal declaration(s) before top-level module\n  ```\n
  \ if the following conditions are met:\n\n    1. There is at least one non-import
  declaration or non-toplevel pragma\n       before the start of the first module.\n\n
  \   2. The module has the same name as the file.\n\n    3. The module is the only
  module at this level\n       (may have submodules, of course).\n\n  If you should
  see this error, insert a top-level module\n  before the illegal declarations, or
  move them inside the\n  existing module.\n\nEmacs mode\n----------\n\n* New warnings:\n\n
  \ - Unreachable clauses give rise to a simple warning. They are\n    highlighted
  in gray.\n\n  - Incomplete patterns are non-fatal warnings: it is possible\n    to
  keep interacting with the file (the reduction will simply\n    be stuck on arguments
  not matching any pattern).\n    The definition with incomplete patterns are highlighted
  in\n    wheat.\n\n* Clauses which do not hold definitionally are now highlighted
  in white smoke.\n\n* Fewer commands have the side effect that the buffer is saved.\n\n*
  Aborting commands.\n\n  Now one can (try to) abort an Agda command by using `C-c
  C-x C-a` or\n  a menu entry. The effect is similar to that of restarting Agda (`C-c\n
  \ C-x C-r`), but some state is preserved, which could mean that it\n  takes less
  time to reload the module.\n\n  Warning: If a command is aborted while it is writing
  data to disk\n  (for instance .agdai files or Haskell files generated by the GHC\n
  \ backend), then the resulting files may be corrupted. Note also that\n  external
  commands (like GHC) are not aborted, and their output may\n  continue to be sent
  to the Emacs mode.\n\n* New bindings for the Agda input method:\n\n  - All the bold
  digits are now available. The naming scheme is `\\Bx` for digit `x`.\n\n  - Typing
  `\\:` you can now get a whole slew of colons.\n\n    (The Agda input method originally
  only bound the standard unicode colon,\n    which looks deceptively like the normal
  colon.)\n\n* Case splitting now preserves underscores.\n  [Issue [#819](https://github.com/agda/agda/issues/819)]\n
  \ ```agda\n    data ⊥ : Set where\n\n    test : {A B : Set} → A → ⊥ → B\n    test
  _ x = {! x !}\n  ```\n  Splitting on `x` yields\n  ```agda\n    test _ ()\n  ```\n\n*
  Interactively expanding ellipsis.\n  [Issue [#2589](https://github.com/agda/agda/issues/2589)]\n
  \ An ellipsis in a with-clause can be expanded by splitting on \"variable\" \".\"
  (dot).\n  ```agda\n    test0 : Nat → Nat\n    test0 x with zero\n    ... | q = {!
  . !}  -- C-c C-c\n  ```\n  Splitting on dot here yields:\n  ```agda\n    test0 x
  | q = ?\n  ```\n\n* New command to check an expression against the type of the hole\n
  \ it is in and see what it elaborates to.\n  [Issue [#2700](https://github.com/agda/agda/issues/2700)]\n
  \ This is useful to determine e.g. what solution typeclass resolution yields.\n
  \ The command is bound to `C-c C-;` and respects the `C-u` modifier.\n\n  ```agda\n
  \   record Pointed (A : Set) : Set where\n      field point : A\n\n    it : ∀ {A
  : Set} {{x : A}} → A\n    it {{x}} = x\n\n    instance _ = record { point = 3 -
  4 }\n\n    _ : Pointed Nat\n    _ = {! it !} -- C-u C-u C-c C-;\n  ```\n  yields\n
  \ ```agda\n    Goal: Pointed Nat\n    Elaborates to: record { point = 0 }\n  ```\n\n*
  If `agda2-give` is called with a prefix, then giving is forced,\n  i.e., the safety
  checks are skipped,\n  including positivity, termination, and double type-checking.\n
  \ [Issue [#2730](https://github.com/agda/agda/issues/2730)]\n\n  Invoke forced giving
  with key sequence `C-u C-c C-SPC`.\n\n\nLibrary management\n------------------\n\n*
  The `name` field in an `.agda-lib` file is now optional.\n  [Issue [#2708](https://github.com/agda/agda/issues/2708)]\n\n
  \ This feature is convenient if you just want to specify the dependencies\n  and
  include pathes for your local project in an `.agda-lib` file.\n\n  Naturally, libraries
  without names cannot be depended on.\n\n\nCompiler backends\n-----------------\n\n*
  Unified compiler pragmas\n\n  The compiler pragmas (`COMPILED`, `COMPILED_DATA`,
  etc.) have been unified across\n  backends into two new pragmas:\n\n  ```\n    {-#
  COMPILE <Backend> <Name> <Text> #-}\n    {-# FOREIGN <Backend> <Text> #-}\n  ```\n\n
  \ The old pragmas still work, but will emit a warning if used. They will be\n  removed
  completely in Agda 2.6.\n\n  The translation of old pragmas into new ones is as
  follows:\n\n  Old | New\n  --- | ---\n  `{-# COMPILED f e #-}` | `{-# COMPILE GHC
  f = e #-}`\n  `{-# COMPILED_TYPE A T #-}` | `{-# COMPILE GHC A = type T #-}`\n  `{-#
  COMPILED_DATA A D C1 .. CN #-}` | `{-# COMPILE GHC A = data D (C1 \\| .. \\| CN)
  #-}`\n  `{-# COMPILED_DECLARE_DATA #-}` | obsolete, removed\n  `{-# COMPILED_EXPORT
  f g #-}` | `{-# COMPILE GHC f as g #-}`\n  `{-# IMPORT M #-}` | `{-# FOREIGN GHC
  import qualified M #-}`\n  `{-# HASKELL code #-}` | `{-# FOREIGN GHC code #-}`\n
  \ `{-# COMPILED_UHC f e #-}` | `{-# COMPILE UHC f = e #-}`\n  `{-# COMPILED_DATA_UHC
  A D C1 .. CN #-}` | `{-# COMPILE UHC A = data D (C1 \\| .. \\| CN) #-}`\n  `{-#
  IMPORT_UHC M #-}` | `{-# FOREIGN UHC __IMPORT__ M #-}`\n  `{-# COMPILED_JS f e #-}`
  | `{-# COMPILE JS f = e #-}`\n\n* GHC Haskell backend\n\n  The COMPILED pragma (and
  the corresponding COMPILE GHC pragma) is now also\n  allowed for functions. This
  makes it possible to have both an Agda\n  implementation and a native Haskell runtime
  implementation.\n\n  The GHC file header pragmas `LANGUAGE`, `OPTIONS_GHC`, and
  `INCLUDE`\n  inside a `FOREIGN GHC` pragma are recognized and printed correctly\n
  \ at the top of the generated Haskell file.\n  [Issue [#2712](https://github.com/agda/agda/issues/2712)]\n\n\n*
  UHC compiler backend\n\n  The UHC backend has been moved to its own repository\n
  \ [https://github.com/agda/agda-uhc] and is no longer part of the Agda\n  distribution.\n\n*
  Haskell imports are no longer transitively inherited from imported modules.\n\n
  \ The (now deprecated) IMPORT and IMPORT_UHC pragmas no longer cause import\n  statements
  in modules importing the module containing the pragma.\n\n  The same is true for
  the corresponding FOREIGN pragmas.\n\n* Support for stand-alone backends.\n\n  There
  is a new API in `Agda.Compiler.Backend` for creating stand-alone\n  backends using
  Agda as a library. This allows prospective backend writers to\n  experiment with
  new backends without having to change the Agda code base.\n\nHTML backend\n------------\n\n*
  Anchors for identifiers (excluding bound variables) are now the\n  identifiers themselves
  rather than just the file position\n  [Issue [#2604](https://github.com/agda/agda/issues/2604)].\n\n
  \ Symbolic anchors look like\n  ```html\n  <a id=\"test1\">\n  <a id=\"M.bla\">\n
  \ ```\n  while other anchors just give the character position in the file:\n  ```html\n
  \ <a id=\"42\">\n  ```\n\n  Top-level module names do not get a symbolic anchor,
  since the position of\n  a top-level module is defined to be the beginning of the
  file.\n\n  Example:\n\n  ```agda\n  module Issue2604 where   -- Character position
  anchor\n\n  test1 : Set₁             -- Issue2604.html#test1\n  test1 = bla\n    where\n
  \   bla = Set              -- Character position anchor\n\n  test2 : Set₁             --
  Issue2604.html#test2\n  test2 = bla\n    where\n    bla = Set              -- Character
  position anchor\n\n  test3 : Set₁             -- Issue2604.html#test3\n  test3 =
  bla\n    module M where         -- Issue2604.html#M\n    bla = Set              --
  Issue2604.html#M.bla\n\n  module NamedModule where -- Issue2604.html#NamedModule\n
  \   test4 : Set₁           -- Issue2604.html#NamedModule.test4\n    test4 = M.bla\n\n
  \ module _ where           -- Character position anchor\n    test5 : Set₁           --
  Character position anchor\n    test5 = M.bla\n  ```\n\n* Some generated HTML files
  now have different file names [Issue\n  [#2725](https://github.com/agda/agda/issues/2725)].\n\n
  \ Agda now uses an encoding that amounts to first converting the\n  module names
  to UTF-8, and then percent-encoding the resulting\n  bytes. For instance, HTML for
  the module `Σ` is placed in\n  `%CE%A3.html`.\n\nLaTeX backend\n-------------\n\n*
  The LaTeX backend now handles indentation in a different way [Issue\n  [#1832](https://github.com/agda/agda/issues/1832)].\n\n
  \ A constraint on the indentation of the first token *t* on a line is\n  determined
  as follows:\n  * Let *T* be the set containing every previous token (in any code\n
  \   block) that is either the initial token on its line or preceded by\n    at least
  one whitespace character.\n  * Let *S* be the set containing all tokens in *T* that
  are not\n    *shadowed* by other tokens in *T*. A token *t₁* is shadowed by\n    *t₂*
  if *t₂* is further down than *t₁* and does not start to the\n    right of *t₁*.\n
  \ * Let *L* be the set containing all tokens in *S* that start to the\n    left
  of *t*, and *E* be the set containing all tokens in *S* that\n    start in the same
  column as *t*.\n  * The constraint is that *t* must be indented further than every\n
  \   token in *L*, and aligned with every token in *E*.\n\n  Note that if any token
  in *L* or *E* belongs to a previous code\n  block, then the constraint may not be
  satisfied unless (say) the\n  `AgdaAlign` environment is used in an appropriate
  way.\n\n  If custom settings are used, for instance if `\\AgdaIndent` is\n  redefined,
  then the constraint discussed above may not be satisfied.\n  (Note that the meaning
  of the `\\AgdaIndent` command's argument has\n  changed, and that the command is
  now used in a different way in the\n  generated LaTeX files.)\n\n  Examples:\n  *
  Here `C` is indented further than `B`:\n\n    ```agda\n    postulate\n      A  B\n
  \         C : Set\n    ```\n\n  * Here `C` is not (necessarily) indented further
  than `B`, because\n    `X` shadows `B`:\n\n    ```agda\n    postulate\n      A  B
  \ : Set\n      X\n          C : Set\n    ```\n\n  The new rule is inspired by, but
  not identical to, the one used by\n  lhs2TeX's poly mode (see Section 8.4 of the
  [manual for lhs2TeX\n  version 1.17](https://www.andres-loeh.de/lhs2tex/Guide2-1.17.pdf)).\n\n*
  Some spacing issues\n  [[#2353](https://github.com/agda/agda/issues/2353),\n  [#2441](https://github.com/agda/agda/issues/2441),\n
  \ [#2733](https://github.com/agda/agda/issues/2733),\n  [#2740](https://github.com/agda/agda/issues/2740)]
  have been fixed.\n\n* The user can now control the typesetting of (certain) individual
  tokens\n  by redefining the `\\AgdaFormat` command. Example:\n  ```latex\n  \\usepackage{ifthen}\n\n
  \ % Insert extra space before some tokens.\n  \\DeclareRobustCommand{\\AgdaFormat}[2]{%\n
  \   \\ifthenelse{\n      \\equal{#1}{≡⟨} \\OR\n      \\equal{#1}{≡⟨⟩} \\OR\n      \\equal{#1}{∎}\n
  \   }{\\ }{}#2}\n  ```\n  Note the use of `\\DeclareRobustCommand`. The first argument
  to\n  `\\AgdaFormat` is the token, and the second argument the thing to\n  be typeset.\n\n*
  One can now instruct the agda package not to select any fonts.\n\n  If the `nofontsetup`
  option is used, then some font packages are\n  loaded, but specific fonts are not
  selected:\n  ```latex\n  \\usepackage[nofontsetup]{agda}\n  ```\n\n* The height
  of empty lines is now configurable\n  [[#2734](https://github.com/agda/agda/issues/2734)].\n\n
  \ The height is controlled by the length `\\AgdaEmptySkip`, which by\n  default
  is `\\baselineskip`.\n\n* The alignment feature regards the string `+̲`, containing
  `+` and a\n  combining character, as having length two. However, it seems more\n
  \ reasonable to treat it as having length one, as it occupies a single\n  column,
  if displayed \"properly\" using a monospace font. The new flag\n  `--count-clusters`
  is an attempt at fixing this. When this flag is\n  enabled the backend counts [\"extended
  grapheme\n  clusters\"](http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries)\n
  \ rather than code points.\n\n  Note that this fix is not perfect: a single extended
  grapheme\n  cluster might be displayed in different ways by different programs,\n
  \ and might, in some cases, occupy more than one column. Here are some\n  examples
  of extended grapheme clusters, all of which are treated as\n  a single character
  by the alignment algorithm:\n  ```\n  │ │\n  │+̲│\n  │Ö̂│\n  │நி│\n  │ᄀힰᇹ│\n  │ᄀᄀᄀᄀᄀᄀힰᇹᇹᇹᇹᇹᇹ│\n
  \ │ │\n  ```\n\n  Note also that the layout machinery does not count extended grapheme\n
  \ clusters, but code points. The following code is syntactically\n  correct, but
  if `--count-clusters` is used, then the LaTeX backend\n  does not align the two
  `field` keywords:\n  ```agda\n    record +̲ : Set₁ where  field A : Set\n                            field
  B : Set\n  ```\n\n  The `--count-clusters` flag is not enabled in all builds of
  Agda,\n  because the implementation depends on the\n  [ICU](http://site.icu-project.org)
  library, the installation of\n  which could cause extra trouble for some users.
  The presence of this\n  flag is controlled by the Cabal flag `enable-cluster-counting`.\n\n*
  A faster variant of the LaTeX backend: QuickLaTeX.\n\n  When this variant of the
  backend is used the top-level module is not\n  type-checked, only scope-checked.
  This implies that some\n  highlighting information is not available. For instance,
  overloaded\n  constructors are not resolved.\n\n  QuickLaTeX can be invoked from
  the Emacs mode, or using `agda\n  --latex --only-scope-checking`. If the module
  has already been\n  type-checked successfully, then this information is reused;
  in this\n  case QuickLaTeX behaves like the regular LaTeX backend.\n\n  The `--only-scope-checking`
  flag can also be used independently, but\n  it is perhaps unclear what purpose that
  would serve. (The flag can\n  currently not be combined with `--html`, `--dependency-graph`
  or\n  `--vim`.) The flag is not allowed in safe mode.\n\nPragmas and options\n-------------------\n\n*
  The `--safe` option is now a valid pragma.\n\n  This makes it possible to declare
  a module as being part of the safe\n  subset of the language by stating `{-# OPTIONS
  --safe #-}` at the top\n  of the corresponding file. Incompatibilities between the
  `--safe` option\n  and other options or language constructs are non-fatal errors.\n\n*
  The `--no-main` option is now a valid pragma.\n\n  One can now suppress the compiler
  warning about a missing main function by\n  putting\n  ```agda\n    {-# OPTIONS
  --no-main #-}\n  ```\n  on top of the file.\n\n* New command-line option and pragma
  `--warning=MODE` (or `-W MODE`) for\n  setting the warning mode. Current options
  are\n  - `warn` for displaying warnings (default)\n  - `error` for turning warnings
  into errors\n  - `ignore` for not displaying warnings\n\nList of fixed issues\n--------------------\n\nFor
  2.5.3, the following issues have been fixed\n(see [bug tracker](https://github.com/agda/agda/issues)):\n\n
  \ - [#142](https://github.com/agda/agda/issues/142): Inherited dot patterns in with
  functions are not checked\n  - [#623](https://github.com/agda/agda/issues/623):
  Error message points to importing module rather than imported module\n  - [#657](https://github.com/agda/agda/issues/657):
  Yet another display form problem\n  - [#668](https://github.com/agda/agda/issues/668):
  Ability to stop, or restart, typechecking somehow\n  - [#705](https://github.com/agda/agda/issues/705):
  confusing error message for ambiguous datatype module name\n  - [#719](https://github.com/agda/agda/issues/719):
  Error message for duplicate module definition points to external module instead
  of internal module\n  - [#776](https://github.com/agda/agda/issues/776): Unsolvable
  constraints should give error\n  - [#819](https://github.com/agda/agda/issues/819):
  Case-splitting doesn't preserve underscores\n  - [#883](https://github.com/agda/agda/issues/883):
  Rewrite loses type information\n  - [#899](https://github.com/agda/agda/issues/899):
  Instance search fails if there are several definitionally equal values in scope\n
  \ - [#1077](https://github.com/agda/agda/issues/1077): problem with module syntax,
  with parametric module import\n  - [#1126](https://github.com/agda/agda/issues/1126):
  Port optimizations from the Epic backend\n  - [#1175](https://github.com/agda/agda/issues/1175):
  Internal Error in Auto\n  - [#1544](https://github.com/agda/agda/issues/1544): Positivity
  polymorphism needed for compositional positivity analysis\n  - [#1611](https://github.com/agda/agda/issues/1611):
  Interactive splitting instantiates meta\n  - [#1664](https://github.com/agda/agda/issues/1664):
  Add Reflection primitives to expose precedence and fixity\n  - [#1817](https://github.com/agda/agda/issues/1817):
  Solvable size constraints reported as unsolvable\n  - [#1832](https://github.com/agda/agda/issues/1832):
  Insufficient indentation in LaTeX-rendered Agda code\n  - [#1834](https://github.com/agda/agda/issues/1834):
  Copattern matching: order of clauses should not matter here\n  - [#1886](https://github.com/agda/agda/issues/1886):
  Second copies of telescopes not checked?\n  - [#1899](https://github.com/agda/agda/issues/1899):
  Positivity checker does not treat datatypes and record types in the same way\n  -
  [#1975](https://github.com/agda/agda/issues/1975): Type-incorrect instantiated overloaded
  constructor accepted in pattern\n  - [#1976](https://github.com/agda/agda/issues/1976):
  Type-incorrect instantiated projection accepted in pattern\n  - [#2035](https://github.com/agda/agda/issues/2035):
  Matching on string causes solver to fail with internal error\n  - [#2146](https://github.com/agda/agda/issues/2146):
  Unicode syntax for instance arguments\n  - [#2217](https://github.com/agda/agda/issues/2217):
  Abort Agda without losing state\n  - [#2229](https://github.com/agda/agda/issues/2229):
  Absence or presence of top-level module header affects scope\n  - [#2253](https://github.com/agda/agda/issues/2253):
  Wrong scope error for abstract constructors\n  - [#2261](https://github.com/agda/agda/issues/2261):
  Internal error in Auto/CaseSplit.hs:284\n  - [#2270](https://github.com/agda/agda/issues/2270):
  Printer does not use sections.\n  - [#2329](https://github.com/agda/agda/issues/2329):
  Size solver does not use type `Size< i` to gain the necessary information\n  - [#2354](https://github.com/agda/agda/issues/2354):
  Interaction between instance search, size solver, and ordinary constraint solver.\n
  \ - [#2355](https://github.com/agda/agda/issues/2355): Literate Agda parser does
  not recognize TeX comments\n  - [#2360](https://github.com/agda/agda/issues/2360):
  With clause stripping chokes on ambiguous projection\n  - [#2362](https://github.com/agda/agda/issues/2362):
  Printing of parent patterns when with-clause does not match\n  - [#2363](https://github.com/agda/agda/issues/2363):
  Allow underscore in with-clause patterns\n  - [#2366](https://github.com/agda/agda/issues/2366):
  With-clause patterns renamed in error message\n  - [#2368](https://github.com/agda/agda/issues/2368):
  Internal error after refining a tactic @ MetaVars.hs:267\n  - [#2371](https://github.com/agda/agda/issues/2371):
  Shadowed module parameter crashes interaction\n  - [#2372](https://github.com/agda/agda/issues/2372):
  problems when instances are declared with inferred types\n  - [#2374](https://github.com/agda/agda/issues/2374):
  Ambiguous projection pattern could be disambiguated by visibility\n  - [#2376](https://github.com/agda/agda/issues/2376):
  Termination checking interacts badly with eta-contraction\n  - [#2377](https://github.com/agda/agda/issues/2377):
  open public is useless before module header\n  - [#2381](https://github.com/agda/agda/issues/2381):
  Search (`C-c C-z`) panics on pattern synonyms\n  - [#2386](https://github.com/agda/agda/issues/2386):
  Relax requirements of BUILTIN EQUALITY\n  - [#2389](https://github.com/agda/agda/issues/2389):
  BUILTIN REFL not needed\n  - [#2400](https://github.com/agda/agda/issues/2400):
  LaTeX backend error on LaTeX comments\n  - [#2402](https://github.com/agda/agda/issues/2402):
  Parameters not dropped when reporting incomplete patterns\n  - [#2403](https://github.com/agda/agda/issues/2403):
  Termination checker should reduce arguments in structural order check\n  - [#2405](https://github.com/agda/agda/issues/2405):
  instance search failing in parameterized module\n  - [#2408](https://github.com/agda/agda/issues/2408):
  DLub sorts are not serialized\n  - [#2412](https://github.com/agda/agda/issues/2412):
  Problem with checking  with sized types\n  - [#2413](https://github.com/agda/agda/issues/2413):
  Agda crashes on x@y pattern\n  - [#2415](https://github.com/agda/agda/issues/2415):
  Size solver reports \"inconsistent upper bound\" even though there is a solution\n
  \ - [#2416](https://github.com/agda/agda/issues/2416): Cannot give size as computed
  by solver\n  - [#2422](https://github.com/agda/agda/issues/2422): Overloaded inherited
  projections don't resolve\n  - [#2423](https://github.com/agda/agda/issues/2423):
  Inherited projection on lhs\n  - [#2426](https://github.com/agda/agda/issues/2426):
  On just warning about missing cases\n  - [#2429](https://github.com/agda/agda/issues/2429):
  Irrelevant lambda should be accepted when relevant lambda is expected\n  - [#2430](https://github.com/agda/agda/issues/2430):
  Another regression related to parameter refinement?\n  - [#2433](https://github.com/agda/agda/issues/2433):
  rebindLocalRewriteRules re-adds global rewrite rules\n  - [#2434](https://github.com/agda/agda/issues/2434):
  Exact split analysis is too strict when matching on eta record constructor\n  -
  [#2441](https://github.com/agda/agda/issues/2441): Incorrect alignement in latex
  using the new ACM format\n  - [#2444](https://github.com/agda/agda/issues/2444):
  Generalising compiler pragmas\n  - [#2445](https://github.com/agda/agda/issues/2445):
  The LaTeX backend is slow\n  - [#2447](https://github.com/agda/agda/issues/2447):
  Cache loaded interfaces even if a type error is encountered\n  - [#2449](https://github.com/agda/agda/issues/2449):
  Agda depends on additional C library icu\n  - [#2451](https://github.com/agda/agda/issues/2451):
  Agda panics when attempting to rewrite a typeclass Eq\n  - [#2456](https://github.com/agda/agda/issues/2456):
  Internal error when postulating instance\n  - [#2458](https://github.com/agda/agda/issues/2458):
  Regression: Agda-2.5.3 loops where Agda-2.5.2 passes\n  - [#2462](https://github.com/agda/agda/issues/2462):
  Overloaded postfix projection does not resolve\n  - [#2464](https://github.com/agda/agda/issues/2464):
  Eta contraction for irrelevant functions breaks subject reduction\n  - [#2466](https://github.com/agda/agda/issues/2466):
  Case split to make hidden variable visible does not work\n  - [#2467](https://github.com/agda/agda/issues/2467):
  REWRITE without BUILTIN REWRITE crashes\n  - [#2469](https://github.com/agda/agda/issues/2469):
  \"Partial\" pattern match causes segfault at runtime\n  - [#2472](https://github.com/agda/agda/issues/2472):
  Regression related to the auto command\n  - [#2477](https://github.com/agda/agda/issues/2477):
  Sized data type analysis brittle, does not reduce size\n  - [#2478](https://github.com/agda/agda/issues/2478):
  Multiply defined labels on the user manual (pdf)\n  - [#2479](https://github.com/agda/agda/issues/2479):
  \"Occurs check\" error in generated Haskell code\n  - [#2480](https://github.com/agda/agda/issues/2480):
  Agda accepts incorrect (?) code, subject reduction broken\n  - [#2482](https://github.com/agda/agda/issues/2482):
  Wrong counting of data parameters with new-style mutual blocks\n  - [#2483](https://github.com/agda/agda/issues/2483):
  Files are sometimes truncated to a size of 201 bytes\n  - [#2486](https://github.com/agda/agda/issues/2486):
  Imports via FOREIGN are not transitively inherited anymore\n  - [#2488](https://github.com/agda/agda/issues/2488):
  Instance search inhibits holes for instance fields\n  - [#2493](https://github.com/agda/agda/issues/2493):
  Regression: Agda seems to loop when expression is given\n  - [#2494](https://github.com/agda/agda/issues/2494):
  Instance fields sometimes have incorrect goal types\n  - [#2495](https://github.com/agda/agda/issues/2495):
  Regression: termination checker of Agda-2.5.3 seemingly loops where Agda-2.5.2 passes\n
  \ - [#2500](https://github.com/agda/agda/issues/2500): Adding fields to a record
  can cause Agda to reject previous definitions\n  - [#2510](https://github.com/agda/agda/issues/2510):
  Wrong error with --no-pattern-matching\n  - [#2517](https://github.com/agda/agda/issues/2517):
  \"Not a variable error\"\n  - [#2518](https://github.com/agda/agda/issues/2518):
  CopatternReductions in TreeLess\n  - [#2523](https://github.com/agda/agda/issues/2523):
  The documentation of `--without-K` is outdated\n  - [#2529](https://github.com/agda/agda/issues/2529):
  Unable to install Agda on Windows.\n  - [#2537](https://github.com/agda/agda/issues/2537):
  case splitting with 'with' creates {_} instead of replicating the arguments it found.\n
  \ - [#2538](https://github.com/agda/agda/issues/2538): Internal error when parsing
  as-pattern\n  - [#2543](https://github.com/agda/agda/issues/2543): Case splitting
  with ellipsis produces spurious parentheses\n  - [#2545](https://github.com/agda/agda/issues/2545):
  Race condition in api tests\n  - [#2549](https://github.com/agda/agda/issues/2549):
  Rewrite rule for higher path constructor does not fire\n  - [#2550](https://github.com/agda/agda/issues/2550):
  Internal error in Agda.TypeChecking.Substitute\n  - [#2552](https://github.com/agda/agda/issues/2552):
  Let bindings in module telescopes crash Agda.Interaction.BasicOps\n  - [#2553](https://github.com/agda/agda/issues/2553):
  Internal error in Agda.TypeChecking.CheckInternal\n  - [#2554](https://github.com/agda/agda/issues/2554):
  More flexible size-assignment in successor style\n  - [#2555](https://github.com/agda/agda/issues/2555):
  Why does the positivity checker care about non-recursive occurrences?\n  - [#2558](https://github.com/agda/agda/issues/2558):
  Internal error in Warshall Solver\n  - [#2560](https://github.com/agda/agda/issues/2560):
  Internal Error in Reduce.Fast\n  - [#2564](https://github.com/agda/agda/issues/2564):
  Non-exact-split highlighting makes other highlighting disappear\n  - [#2568](https://github.com/agda/agda/issues/2568):
  agda2-infer-type-maybe-toplevel (in hole) does not respect \"single-solution\" requirement
  of instance resolution\n  - [#2571](https://github.com/agda/agda/issues/2571): Record
  pattern translation does not eta contract\n  - [#2573](https://github.com/agda/agda/issues/2573):
  Rewrite rules fail depending on unrelated changes\n  - [#2574](https://github.com/agda/agda/issues/2574):
  No link attached to module without toplevel name\n  - [#2575](https://github.com/agda/agda/issues/2575):
  Internal error, related to caching\n  - [#2577](https://github.com/agda/agda/issues/2577):
  deBruijn fail for higher order instance problem\n  - [#2578](https://github.com/agda/agda/issues/2578):
  Catch-all clause face used incorrectly for parent with pattern\n  - [#2579](https://github.com/agda/agda/issues/2579):
  Import statements with module instantiation should not trigger an error message\n
  \ - [#2580](https://github.com/agda/agda/issues/2580): Implicit absurd match is
  NonVariant, explicit not\n  - [#2583](https://github.com/agda/agda/issues/2583):
  Wrong de Bruijn index introduced by absurd pattern\n  - [#2584](https://github.com/agda/agda/issues/2584):
  Duplicate warning printing\n  - [#2585](https://github.com/agda/agda/issues/2585):
  Definition by copatterns not modulo eta\n  - [#2586](https://github.com/agda/agda/issues/2586):
  \"λ where\" with single absurd clause not parsed\n  - [#2588](https://github.com/agda/agda/issues/2588):
  `agda --latex` produces invalid LaTeX when there are block comments\n  - [#2592](https://github.com/agda/agda/issues/2592):
  Internal Error in Agda/TypeChecking/Serialise/Instances/Common.hs\n  - [#2597](https://github.com/agda/agda/issues/2597):
  Inline record definitions confuse the reflection API\n  - [#2602](https://github.com/agda/agda/issues/2602):
  Debug output messes up AgdaInfo buffer\n  - [#2603](https://github.com/agda/agda/issues/2603):
  Internal error in MetaVars.hs\n  - [#2604](https://github.com/agda/agda/issues/2604):
  Use QNames as anchors in generated HTML\n  - [#2605](https://github.com/agda/agda/issues/2605):
  HTML backend generates anchors for whitespace\n  - [#2606](https://github.com/agda/agda/issues/2606):
  Check that LHS of a rewrite rule doesn't reduce is too strict\n  - [#2612](https://github.com/agda/agda/issues/2612):
  `exact-split` documentation is outdated and incomplete\n  - [#2613](https://github.com/agda/agda/issues/2613):
  Parametrised modules, with-abstraction and termination\n  - [#2620](https://github.com/agda/agda/issues/2620):
  Internal error in auto.\n  - [#2621](https://github.com/agda/agda/issues/2621):
  Case splitting instantiates meta\n  - [#2626](https://github.com/agda/agda/issues/2626):
  triggered internal error with sized types in MetaVars module\n  - [#2629](https://github.com/agda/agda/issues/2629):
  Exact splitting should not complain about absurd clauses\n  - [#2631](https://github.com/agda/agda/issues/2631):
  docs for auto aren't clear on how to use flags/options\n  - [#2632](https://github.com/agda/agda/issues/2632):
  some flags to auto dont seem to work in current agda 2.5.2\n  - [#2637](https://github.com/agda/agda/issues/2637):
  Internal error in Agda.TypeChecking.Pretty, possibly related to sized types\n  -
  [#2639](https://github.com/agda/agda/issues/2639): Performance regression, possibly
  related to the size solver\n  - [#2641](https://github.com/agda/agda/issues/2641):
  Required instance of FromNat when compiling imported files\n  - [#2642](https://github.com/agda/agda/issues/2642):
  Records with duplicate fields\n  - [#2644](https://github.com/agda/agda/issues/2644):
  Wrong substitution in expandRecordVar\n  - [#2645](https://github.com/agda/agda/issues/2645):
  Agda accepts postulated fields in a record\n  - [#2646](https://github.com/agda/agda/issues/2646):
  Only warn if fixities for undefined symbols are given\n  - [#2649](https://github.com/agda/agda/issues/2649):
  Empty list of \"previous definition\" in duplicate definition error\n  - [#2652](https://github.com/agda/agda/issues/2652):
  Added a new variant of the colon to the Agda input method\n  - [#2653](https://github.com/agda/agda/issues/2653):
  agda-mode: \"cannot refine\" inside instance argument even though term to be refined
  typechecks there\n  - [#2654](https://github.com/agda/agda/issues/2654): Internal
  error on result splitting without --postfix-projections\n  - [#2664](https://github.com/agda/agda/issues/2664):
  Segmentation fault with compiled programs using mutual record\n  - [#2665](https://github.com/agda/agda/issues/2665):
  Documentation: Record update syntax in wrong location\n  - [#2666](https://github.com/agda/agda/issues/2666):
  Internal error at Agda/Syntax/Abstract/Name.hs:113\n  - [#2667](https://github.com/agda/agda/issues/2667):
  Panic error on unbound variable.\n  - [#2669](https://github.com/agda/agda/issues/2669):
  Interaction: incorrect field variable name generation\n  - [#2671](https://github.com/agda/agda/issues/2671):
  Feature request: nullary pattern matching lambdas\n  - [#2679](https://github.com/agda/agda/issues/2679):
  Internal error at \"Typechecking/Abstract.hs:133\" and \"TypeChecking/Telescope.hs:68\"\n
  \ - [#2682](https://github.com/agda/agda/issues/2682): What are the rules for projections
  of abstract records?\n  - [#2684](https://github.com/agda/agda/issues/2684): Bad
  error message for abstract constructor\n  - [#2686](https://github.com/agda/agda/issues/2686):
  Abstract constructors should be ignored when resolving overloading\n  - [#2690](https://github.com/agda/agda/issues/2690):
  [regression?] Agda engages in deep search instead of immediately failing\n  - [#2700](https://github.com/agda/agda/issues/2700):
  Add a command to check against goal type (and normalise)\n  - [#2703](https://github.com/agda/agda/issues/2703):
  Regression: Internal error for underapplied indexed constructor\n  - [#2705](https://github.com/agda/agda/issues/2705):
  The GHC backend might diverge in infinite file creation\n  - [#2708](https://github.com/agda/agda/issues/2708):
  Why is the `name` field in .agda-lib files mandatory?\n  - [#2710](https://github.com/agda/agda/issues/2710):
  Type checker hangs\n  - [#2712](https://github.com/agda/agda/issues/2712): Compiler
  Pragma for headers\n  - [#2714](https://github.com/agda/agda/issues/2714): Option
  --no-main should be allowed as file-local option\n  - [#2717](https://github.com/agda/agda/issues/2717):
  internal error at DisplayForm.hs:197\n  - [#2718](https://github.com/agda/agda/issues/2718):
  Interactive 'give' doesn't insert enough parenthesis\n  - [#2721](https://github.com/agda/agda/issues/2721):
  Without-K doesn't prevent heterogeneous conflict between literals\n  - [#2723](https://github.com/agda/agda/issues/2723):
  Unreachable clauses in definition by copattern matching trip clause compiler\n  -
  [#2725](https://github.com/agda/agda/issues/2725): File names for generated HTML
  files\n  - [#2726](https://github.com/agda/agda/issues/2726): Old regression related
  to with\n  - [#2727](https://github.com/agda/agda/issues/2727): Internal errors
  related to rewrite\n  - [#2729](https://github.com/agda/agda/issues/2729): Regression:
  case splitting uses variable name variants instead of the unused original names\n
  \ - [#2730](https://github.com/agda/agda/issues/2730): Command to give in spite
  of termination errors\n  - [#2731](https://github.com/agda/agda/issues/2731): Agda
  fails to build with happy 1.19.6\n  - [#2733](https://github.com/agda/agda/issues/2733):
  Avoid some uses of \\AgdaIndent?\n  - [#2734](https://github.com/agda/agda/issues/2734):
  Make height of empty lines configurable\n  - [#2736](https://github.com/agda/agda/issues/2736):
  Segfault using Alex 3.2.2 and cpphs\n  - [#2740](https://github.com/agda/agda/issues/2740):
  Indenting every line of code should be a no-op\n\n\nRelease notes for Agda version
  2.5.2\n====================================\n\nInstallation and infrastructure\n-------------------------------\n\n*
  Modular support for literate programming\n\n  Literate programming support has been
  moved out of the lexer and into the\n  `Agda.Syntax.Parser.Literate` module.\n\n
  \ Files ending in `.lagda` are still interpreted as literate TeX.\n  The extension
  `.lagda.tex` may now also be used for literate TeX files.\n\n  Support for more
  literate code formats and extensions can be added\n  modularly.\n\n  By default,
  `.lagda.*` files are opened in the Emacs mode\n  corresponding to their last extension.
  \ One may switch to and from\n  Agda mode manually.\n\n* reStructuredText\n\n  Literate
  Agda code can now be written in reStructuredText format, using\n  the `.lagda.rst`
  extension.\n\n  As a general rule, Agda will parse code following a line ending
  in `::`,\n  as long as that line does not start with `..`. The module name must\n
  \ match the path of the file in the documentation, and must be given\n  explicitly.
  \ Several files have been converted already, for instance:\n\n  - `language/mixfix-operators.lagda.rst`\n
  \ - `tools/compilers.lagda.rst`\n\n  Note that:\n\n  - Code blocks inside an rST
  comment block will be type-checked by Agda,\n    but not rendered in the documentation.\n
  \ - Code blocks delimited by `.. code-block:: agda` will be rendered in\n    the
  final documenation, but not type-checked by Agda.\n  - All lines inside a codeblock
  must be further indented than the first line\n    of the code block.\n  - Indentation
  must be consistent between code blocks. In other\n    words, the file as a whole
  must be a valid Agda file if all the\n    literate text is replaced by white space.\n\n*
  Documentation testing\n\n  All documentation files in the `doc/user-manual` directory
  that end\n  in `.lagda.rst` can be typechecked by running `make\n  user-manual-test`,
  and also as part of the general test suite.\n\n* Support installation through Stack\n\n
  \ The Agda sources now also include a configuration for the stack install tool\n
  \ (tested through continuous integration).\n\n  It should hence be possible to repeatably
  build any future Agda version\n  (including unreleased commits) from source by checking
  out that version and\n  running `stack install` from the checkout directory.\n  By
  using repeatable builds, this should keep selecting the same dependencies\n  in
  the face of new releases on Hackage.\n\n  For further motivation, see\n  Issue [#2005](https://github.com/agda/agda/issues/2005).\n\n*
  Removed the `--test` command-line option\n\n  This option ran the internal test-suite.
  This test-suite was\n  implemented using Cabal supports for\n  test-suites. [Issue
  [#2083](https://github.com/agda/agda/issues/2083)].\n\n* The `--no-default-libraries`
  flag has been split into two flags\n  [Issue [#1937](https://github.com/agda/agda/issues/1937)]\n\n
  \ - `--no-default-libraries`: Ignore the defaults file but still look for local\n
  \   `.agda-lib` files\n  - `--no-libraries`: Don't use any `.agda-lib` files (the
  previous behaviour\n    of `--no-default-libraries`).\n\n* If `agda` was built inside
  `git` repository, then the `--version` flag\n  will display the hash of the commit
  used, and whether the tree was\n  `-dirty` (i.e. there were uncommited changes in
  the working directory).\n  Otherwise, only the version number is shown.\n\nLanguage\n--------\n\n*
  Dot patterns are now optional\n\n  Consider the following program\n\n  ```agda\n
  \ data Vec (A : Set) : Nat → Set where\n    []   : Vec A zero\n    cons : ∀ n →
  A → Vec A n → Vec A (suc n)\n\n  vmap : ∀ {A B} n → (A → B) → Vec A n → Vec B n\n
  \ vmap .zero    f []            = []\n  vmap .(suc m) f (cons m x xs) = cons m (f
  x) (vmap m f xs)\n  ```\n\n  If we don't care about the dot patterns they can (and
  could previously) be\n  replaced by wildcards:\n\n  ```agda\n  vmap : ∀ {A B} n
  → (A → B) → Vec A n → Vec B n\n  vmap _ f []            = []\n  vmap _ f (cons m
  x xs) = cons m (f x) (vmap m f xs)\n  ```\n\n  Now it is also allowed to give a
  variable pattern in place of the dot\n  pattern. In this case the variable will
  be bound to the value of the dot\n  pattern. For our example:\n\n  ```agda\n  vmap
  : ∀ {A B} n → (A → B) → Vec A n → Vec B n\n  vmap n f []            = []\n  vmap
  n f (cons m x xs) = cons m (f x) (vmap m f xs)\n  ```\n\n  In the first clause `n`
  reduces to `zero` and in the second clause\n  `n` reduces to `suc m`.\n\n* Module
  parameters can now be refined by pattern matching\n\n  Previously, pattern matches
  that would refine a variable outside the\n  current left-hand side was disallowed.
  For instance, the following\n  would give an error, since matching on the vector
  would\n  instantiate `n`.\n\n  ```agda\n  module _ {A : Set} {n : Nat} where\n    f
  : Vec A n → Vec A n\n    f []       = []\n    f (x ∷ xs) = x ∷ xs\n  ```\n\n  Now
  this is no longer disallowed. Instead `n` is bound to the\n  appropriate value in
  each clause.\n\n* With-abstraction now abstracts also in module parameters\n\n  The
  change that allows pattern matching to refine module parameters also\n  allows with-abstraction
  to abstract in them. For instance,\n\n  ```agda\n  module _ (n : Nat) (xs : Vec
  Nat (n + n)) where\n    f : Nat\n    f with n + n\n    f    | nn = ? -- xs : Vec
  Nat nn\n  ```\n\n  Note: Any function argument or lambda-bound variable bound outside
  a given\n  function counts as a module parameter.\n\n  To prevent abstraction in
  a parameter you can hide it inside a definition. In\n  the above example,\n\n  ```agda\n
  \ module _ (n : Nat) (xs : Vec Nat (n + n)) where\n\n    ys : Vec Nat (n + n)\n
  \   ys = xs\n\n    f : Nat\n    f with n + n\n    f    | nn = ? -- xs : Vec Nat
  nn, ys : Vec Nat (n + n)\n  ```\n\n* As-patterns [Issue [#78](https://github.com/agda/agda/issues/78)].\n\n
  \ As-patterns (`@`-patterns) are finally working and can be used to name a\n  pattern.
  The name has the same scope as normal pattern variables (i.e. the\n  right-hand
  side, where clause, and dot patterns). The name reduces to the\n  value of the named
  pattern. For example::\n\n  ```agda\n  module _ {A : Set} (_<_ : A → A → Bool) where\n
  \   merge : List A → List A → List A\n    merge xs [] = xs\n    merge [] ys = ys\n
  \   merge xs@(x ∷ xs₁) ys@(y ∷ ys₁) =\n      if x < y then x ∷ merge xs₁ ys\n               else
  y ∷ merge xs ys₁\n  ```\n\n* Idiom brackets.\n\n  There is new syntactic sugar for
  idiom brackets:\n\n    `(| e a1 .. an |)` expands to\n\n    `pure e <*> a1 <*> ..
  <*> an`\n\n  The desugaring takes place before scope checking and only requires
  names\n  `pure` and `_<*>_` in scope. Idiom brackets work well with operators, for\n
  \ instance\n\n    `(| if a then b else c |)` desugars to\n\n    `pure if_then_else_
  <*> a <*> b <*> c`\n\n  Limitations:\n\n    - The top-level application inside idiom
  brackets cannot include\n      implicit applications, so `(| foo {x = e} a b |)`
  is illegal. In\n      the case `e` is pure you can write `(| (foo {x = e}) a b |)`\n
  \     which desugars to\n\n        `pure (foo {x = e}) <*> a <*> b`\n\n    - Binding
  syntax and operator sections cannot appear immediately inside\n      idiom brackets.\n\n*
  Layout for pattern matching lambdas.\n\n  You can now write pattern matching lambdas
  using the syntax\n\n  ```agda\n  λ where false → true\n          true  → false\n
  \ ```\n\n  avoiding the need for explicit curly braces and semicolons.\n\n* Overloaded
  projections\n  [Issue [#1944](https://github.com/agda/agda/issues/1944)].\n\n  Ambiguous
  projections are no longer a scope error.  Instead they get\n  resolved based on
  the type of the record value they are\n  eliminating.  This corresponds to constructors,
  which can be\n  overloaded and get disambiguated based on the type they are\n  introducing.
  \ Example:\n\n  ```agda\n  module _ (A : Set) (a : A) where\n\n  record R B : Set
  where\n    field f : B\n  open R public\n\n  record S B : Set where\n    field f
  : B\n  open S public\n  ```\n\n  Exporting `f` twice from both `R` and `S` is now
  allowed.  Then,\n\n  ```agda\n  r : R A\n  f r = a\n\n  s : S A\n  f s = f r\n  ```\n\n
  \ disambiguates to:\n\n  ```agda\n  r : R A\n  R.f r = a\n\n  s : S A\n  S.f s =
  R.f r\n  ```\n\n  If the type of the projection is known, it can also be disambiguated\n
  \ unapplied.\n\n  ```agda\n  unapplied : R A -> A\n  unapplied = f\n  ```\n\n* Postfix
  projections\n  [Issue [#1963](https://github.com/agda/agda/issues/1963)].\n\n  Agda
  now supports a postfix syntax for projection application.\n  This style is more
  in harmony with copatterns.  For example:\n\n  ```agda\n  record Stream (A : Set)
  : Set where\n    coinductive\n    field head : A\n          tail : Stream A\n\n
  \ open Stream\n\n  repeat : ∀{A} (a : A) → Stream A\n  repeat a .head = a\n  repeat
  a .tail = repeat a\n\n  zipWith : ∀{A B C} (f : A → B → C) (s : Stream A) (t : Stream
  B) → Stream C\n  zipWith f s t .head = f (s .head) (t .head)\n  zipWith f s t .tail
  = zipWith f (s .tail) (t .tail)\n\n  module Fib (Nat : Set) (zero one : Nat) (plus
  : Nat → Nat → Nat) where\n\n    {-# TERMINATING #-}\n    fib : Stream Nat\n    fib
  .head = zero\n    fib .tail .head = one\n    fib .tail .tail = zipWith plus fib
  (fib .tail)\n  ```\n\n  The thing we eliminate with projection now is visibly the
  head,\n  i.e., the left-most expression of the sequence (e.g. `repeat` in\n  `repeat
  a .tail`).\n\n  The syntax overlaps with dot patterns, but for type correct left\n
  \ hand sides there is no confusion: Dot patterns eliminate function\n  types, while
  (postfix) projection patterns eliminate record types.\n\n  By default, Agda prints
  system-generated projections (such as by\n  eta-expansion or case splitting) prefix.
  \ This can be changed with\n  the new option:\n\n  ```agda\n  {-# OPTIONS --postfix-projections
  #-}\n  ```\n\n  Result splitting in extended lambdas (aka pattern lambdas) always\n
  \ produces postfix projections, as prefix projection pattern do not\n  work here:
  a prefix projection needs to go left of the head, but the\n  head is omitted in
  extended lambdas.\n\n  ```agda\n  dup : ∀{A : Set}(a : A) → A × A\n  dup = λ{ a
  → ? }\n  ```\n\n  Result splitting (`C-c C-c RET`) here will yield:\n\n  ```agda\n
  \ dup = λ{ a .proj₁ → ? ; a .proj₂ → ? }\n  ```\n\n* Projection parameters\n  [Issue
  [#1954](https://github.com/agda/agda/issues/1954)].\n\n  When copying a module,
  projection parameters will now stay hidden\n  arguments, even if the module parameters
  are visible.\n  This matches the situation we had for constructors since long.\n
  \ Example:\n\n  ```agda\n  module P (A : Set) where\n    record R : Set where\n
  \     field f : A\n\n  open module Q A = P A\n  ```\n\n  Parameter `A` is now hidden
  in `R.f`:\n\n  ```agda\n  test : ∀{A} → R A → A\n  test r = R.f r\n  ```\n\n  Note
  that a module parameter that corresponds to the record value\n  argument of a projection
  will not be hidden.\n\n  ```agda\n  module M (A : Set) (r : R A) where\n    open
  R A r public\n\n  test' : ∀{A} → R A → A\n  test' r = M.f r\n  ```\n\n* Eager insertion
  of implicit arguments\n  [Issue [#2001](https://github.com/agda/agda/issues/2001)]\n\n
  \ Implicit arguments are now (again) eagerly inserted in left-hand sides. The\n
  \ previous behaviour of inserting implicits for where blocks, but not\n  right-hand
  sides was not type safe.\n\n* Module applications can now be eta expanded/contracted
  without\n  changing their behaviour\n  [Issue #[1985](https://github.com/agda/agda/issues/1985)]\n\n
  \ Previously definitions exported using `open public` got the\n  incorrect type
  for underapplied module applications.\n\n  Example:\n\n  ```agda\n  module A where\n
  \   postulate A : Set\n\n  module B (X : Set) where\n    open A public\n\n  module
  C₁ = B\n  module C₂ (X : Set) = B X\n  ```\n\n  Here both `C₁.A` and `C₂.A` have
  type `(X : Set) → Set`.\n\n* Polarity pragmas.\n\n  Polarity pragmas can be attached
  to postulates. The polarities express\n  how the postulate's arguments are used.
  The following polarities\n  are available:\n\n  `_`:  Unused.\n\n  `++`: Strictly
  positive.\n\n  `+`:  Positive.\n\n  `-`:  Negative.\n\n  `*`:  Unknown/mixed.\n\n
  \ Polarity pragmas have the form\n\n  ```\n  {-# POLARITY name <zero or more polarities>
  #-}\n  ```\n\n  and can be given wherever fixity declarations can be given. The\n
  \ listed polarities apply to the given postulate's arguments\n  (explicit/implicit/instance),
  from left to right. Polarities\n  currently cannot be given for module parameters.
  If the postulate\n  takes n arguments (excluding module parameters), then the number
  of\n  polarities given must be between 0 and n (inclusive).\n\n  Polarity pragmas
  make it possible to use postulated type formers in\n  recursive types in the following
  way:\n\n  ```agda\n  postulate\n    ∥_∥ : Set → Set\n\n  {-# POLARITY ∥_∥ ++ #-}\n\n
  \ data D : Set where\n    c : ∥ D ∥ → D\n  ```\n\n  Note that one can use postulates
  that may seem benign, together with\n  polarity pragmas, to prove that the empty
  type is inhabited:\n\n  ```agda\n  postulate\n    _⇒_    : Set → Set → Set\n    lambda
  : {A B : Set} → (A → B) → A ⇒ B\n    apply  : {A B : Set} → A ⇒ B → A → B\n\n  {-#
  POLARITY _⇒_ ++ #-}\n\n  data ⊥ : Set where\n\n  data D : Set where\n    c : D ⇒
  ⊥ → D\n\n  not-inhabited : D → ⊥\n  not-inhabited (c f) = apply f (c f)\n\n  inhabited
  : D\n  inhabited = c (lambda not-inhabited)\n\n  bad : ⊥\n  bad = not-inhabited
  inhabited\n  ```\n\n  Polarity pragmas are not allowed in safe mode.\n\n* Declarations
  in a `where`-block are now\n  private. [Issue [#2101](https://github.com/agda/agda/issues/2101)]\n
  \ This means that\n\n  ```agda\n  f ps = body where\n    decls\n  ```\n\n  is now
  equivalent to\n\n  ```agda\n  f ps = body where\n    private\n      decls\n  ```\n\n
  \ This changes little, since the `decls` were anyway not in scope\n  outside `body`.
  \ However, it makes a difference for abstract\n  definitions, because private type
  signatures can see through\n  abstract definitions.  Consider:\n\n  ```agda\n  record
  Wrap (A : Set) : Set where\n    field unwrap : A\n\n  postulate\n    P : ∀{A : Set}
  → A → Set\n\n  abstract\n\n    unnamedWhere : (A : Set) → Set\n    unnamedWhere
  A = A\n      where  -- the following definitions are private!\n      B : Set\n      B
  = Wrap A\n\n      postulate\n        b : B\n        test : P (Wrap.unwrap b)  --
  succeeds\n  ```\n\n  The `abstract` is inherited in `where`-blocks from the parent
  (here:\n  function `unnamedWhere`).  Thus, the definition of `B` is opaque and\n
  \ the type equation `B = Wrap A` cannot be used to check type\n  signatures, not
  even of abstract definitions.  Thus, checking the\n  type  `P (Wrap.unwrap b)` would
  fail.  However, if `test` is\n  private, abstract definitions are translucent in
  its type, and\n  checking succeeds.  With the implemented change, all\n  `where`-definitions
  are private, in this case `B`, `b`, and `test`,\n  and the example succeeds.\n\n
  \ Nothing changes for the named forms of `where`,\n\n  ```agda\n  module M where\n
  \ module _ where\n  ```\n\n  For instance, this still fails:\n\n  ```agda\n  abstract\n\n
  \   unnamedWhere : (A : Set) → Set\n    unnamedWhere A = A\n      module M where\n
  \     B : Set\n      B = Wrap A\n\n      postulate\n        b : B\n        test
  : P (Wrap.unwrap b)  -- fails\n  ```\n\n* Private anonymous modules now work as
  expected\n  [Issue [#2199](https://github.com/agda/agda/issues/2199)]\n\n  Previously
  the `private` was ignored for anonymous modules causing\n  its definitions to be
  visible outside the module containing the\n  anonymous module.  This is no longer
  the case. For instance,\n\n  ```agda\n  module M where\n    private\n      module
  _ (A : Set) where\n        Id : Set\n        Id = A\n\n    foo : Set → Set\n    foo
  = Id\n\n  open M\n\n  bar : Set → Set\n  bar = Id -- Id is no longer in scope here\n
  \ ```\n\n* Pattern synonyms are now expanded on left hand sides of DISPLAY\n  pragmas
  [Issue [#2132](https://github.com/agda/agda/issues/2132)].\n  Example:\n\n  ```agda\n
  \ data D : Set where\n    C c : D\n    g : D → D\n\n  pattern C′ = C\n\n  {-# DISPLAY
  C′ = C′ #-}\n  {-# DISPLAY g C′ = c #-}\n  ```\n\n  This now behaves as:\n\n  ```agda\n
  \ {-# DISPLAY C = C′ #-}\n  {-# DISPLAY g C = c #-}\n  ```\n\n  Expected error for\n\n
  \ ```agda\n  test : C ≡ g C\n  test = refl\n  ```\n\n  is thus:\n\n  ```\n  C′ !=
  c of type D\n  ```\n\n* The built-in floats have new semantics to fix inconsistencies\n
  \ and to improve cross-platform portability.\n\n  - Float equality has been split
  into two primitives.\n    ``primFloatEquality`` is designed to establish\n    decidable
  propositional equality while\n    ``primFloatNumericalEquality`` is intended for
  numerical\n    computations. They behave as follows:\n\n    ```\n    primFloatEquality
  NaN NaN = True\n    primFloatEquality 0.0 -0.0 = False\n\n    primFloatNumericalEquality
  NaN NaN = False\n    primFloatNumericalEquality 0.0 -0.0 = True\n    ```\n\n    This
  change fixes an inconsistency, see [Issue [#2169](https://github.com/agda/agda/issues/2169)].\n
  \   For further detail see the [user manual](http://agda.readthedocs.io/en/latest/language/built-ins.html#floats).\n\n
  \ - Floats now have only one `NaN` value. This is necessary\n    for proper Float
  support in the JavaScript backend,\n    as JavaScript (and some other platforms)
  only support\n    one `NaN` value.\n\n  - The primitive function `primFloatLess`
  was renamed\n    `primFloatNumericalLess`.\n\n* Added new primitives to built-in
  floats:\n\n  - `primFloatNegate : Float → Float`\n    [Issue [#2194](https://github.com/agda/agda/issues/2194)]\n\n
  \ - Trigonometric primitives\n    [Issue [#2200](https://github.com/agda/agda/issues/2200)]:\n\n
  \   ```agda\n    primCos   : Float → Float\n    primTan   : Float → Float\n    primASin
  \ : Float → Float\n    primACos  : Float → Float\n    primATan  : Float → Float\n
  \   primATan2 : Float → Float → Float\n    ```\n\n* Anonymous declarations\n  [Issue
  [#1465](https://github.com/agda/agda/issues/1465)].\n\n  A module can contain an
  arbitrary number of declarations\n  named `_` which will scoped-checked and type-checked
  but\n  won't be made available in the scope (nor exported). They\n  cannot introduce
  arguments on the LHS (but one can use\n  lambda-abstractions on the RHS) and they
  cannot be defined\n  by recursion.\n\n  ```agda\n  _ : Set → Set\n  _ = λ x → x\n
  \ ```\n\n### Rewriting\n\n* The REWRITE pragma can now handle several names.  E.g.:\n
  \ ```agda\n  {-# REWRITE eq1 eq2 #-}\n  ```\n\n### Reflection\n\n* You can now use
  macros in reflected terms\n  [Issue [#2130](https://github.com/agda/agda/issues/2130)].\n\n
  \ For instance, given a macro\n\n  ```agda\n  macro\n    some-tactic : Term → TC
  ⊤\n    some-tactic = ...\n  ```\n\n  the term `def (quote some-tactic) []` represents
  a call to the\n  macro. This makes it a lot easier to compose tactics.\n\n* The
  reflection machinery now uses normalisation less often:\n\n  * Macros no longer
  normalise the (automatically quoted) term\n    arguments.\n\n  * The TC primitives
  `inferType`, `checkType` and `quoteTC` no longer\n    normalise their arguments.\n\n
  \ * The following deprecated constructions may also have been changed:\n    `quoteGoal`,
  `quoteTerm`, `quoteContext` and `tactic`.\n\n* New TC primitive: `withNormalisation`.\n\n
  \ To recover the old normalising behaviour of `inferType`, `checkType`,\n  `quoteTC`
  and `getContext`, you can wrap them inside a call to\n  `withNormalisation true`:\n\n
  \ ```agda\n    withNormalisation : ∀ {a} {A : Set a} → Bool → TC A → TC A\n  ```\n\n*
  New TC primitive: `reduce`.\n\n  ```agda\n  reduce : Term → TC Term\n  ```\n\n  Reduces
  its argument to weak head normal form.\n\n* Added new TC primitive: `isMacro`\n
  \ [Issue [#2182](https://github.com/agda/agda/issues/2182)]\n\n  ```agda\n  isMacro
  : Name → TC Bool\n  ```\n\n  Returns `true` if the name refers to a macro, otherwise
  `false`.\n\n* The `record-type` constructor now has an extra argument containing\n
  \ information about the record type's fields:\n  ```agda\n    data Definition :
  Set where\n      …\n      record-type : (c : Name) (fs : List (Arg Name)) → Definition\n
  \     …\n  ```\n\nType checking\n-------------\n\n* Files with open metas can be
  imported now\n  [Issue [#964](https://github.com/agda/agda/issues/964)].  This\n
  \ should make simultaneous interactive development on several modules\n  more pleasant.\n\n
  \ Requires option: `--allow-unsolved-metas`\n\n  Internally, before serialization,
  open metas are turned into postulates named\n\n  ```\n    unsolved#meta.<nnn>\n
  \ ```\n\n  where `<nnn>` is the internal meta variable number.\n\n* The performance
  of the compile-time evaluator has been greatly improved.\n\n  - Fixed a memory leak
  in evaluator\n    (Issue [#2147](https://github.com/agda/agda/issues/2147)).\n\n
  \ - Reduction speed improved by an order of magnitude and is now\n    comparable
  to the performance of GHCi. Still call-by-name though.\n\n* The detection of types
  that satisfy K added in Agda 2.5.1 has been\n  rolled back (see\n  Issue [#2003](https://github.com/agda/agda/issues/2003)).\n\n*
  Eta-equality for record types is now only on after the positivity\n  checker has
  confirmed it is safe to have it.  Eta-equality for\n  unguarded inductive records
  previously lead to looping of the type\n  checker.\n  [See Issue [#2197](https://github.com/agda/agda/issues/2197)]\n\n
  \ ```agda\n  record R : Set where\n    inductive\n    field r : R\n\n    loops :
  R\n    loops = ?\n  ```\n\n  As a consequence of this change, the following example
  does not\n  type-check any more:\n\n  ```agda\n  mutual\n    record ⊤ : Set where\n\n
  \   test : ∀ {x y : ⊤} → x ≡ y\n    test = refl\n  ```\n\n  It fails because the
  positivity checker is only run after the mutual\n  block, thus, eta-equality for
  `⊤` is not available when checking\n  test.\n\n  One can declare eta-equality explicitly,
  though, to make this\n  example work.\n\n  ```agda\n  mutual\n    record ⊤ : Set
  where\n      eta-equality\n\n    test : ∀ {x y : ⊤} → x ≡ y\n    test = refl\n  ```\n\n*
  Records with instance fields are now eta expanded before instance search.\n\n  For
  instance, assuming `Eq` and `Ord` with boolean functions `_==_` and `_<_`\n  respectively,\n\n
  \ ```agda\n    record EqAndOrd (A : Set) : Set where\n      field {{eq}}  : Eq A\n
  \           {{ord}} : Ord A\n\n\n    leq : {A : Set} {{_ : EqAndOrd A}} → A → A
  → Bool\n    leq x y = x == y || x < y\n  ```\n\n  Here the `EqAndOrd` record is
  automatically unpacked before instance search,\n  revealing the component `Eq` and
  `Ord` instances.\n\n  This can be used to simulate superclass dependencies.\n\n*
  Overlappable record instance fields.\n\n  Instance fields in records can be marked
  as overlappable using the new\n  `overlap` keyword:\n\n  ```agda\n    record Ord
  (A : Set) : Set where\n      field\n        _<_ : A → A → Bool\n        overlap
  {{eqA}} : Eq A\n  ```\n\n  When instance search finds multiple candidates for a
  given instance goal and\n  they are **all** overlappable it will pick the left-most
  candidate instead of\n  refusing to solve the instance goal.\n\n  This can be use
  to solve the problem arising from shared \"superclass\"\n  dependencies. For instance,
  if you have, in addition to `Ord` above, a `Num`\n  record that also has an `Eq`
  field and want to write a function requiring\n  both `Ord` and `Num`, any `Eq` constraint
  will be solved by the `Eq` instance\n  from whichever argument that comes first.\n\n
  \ ```agda\n    record Num (A : Set) : Set where\n      field\n        fromNat :
  Nat → A\n        overlap {{eqA}} : Eq A\n\n    lessOrEqualFive : {A : Set} {{NumA
  : Num A}} {{OrdA : Ord A}} → A → Bool\n    lessOrEqualFive x = x == fromNat 5 ||
  x < fromNat 5\n  ```\n\n  In this example the call to `_==_` will use the `eqA`
  field from `NumA`\n  rather than the one from `OrdA`. Note that these may well be
  different.\n\n* Instance fields can be left out of copattern matches\n  [Issue [#2288](https://github.com/agda/agda/issues/2288)]\n\n
  \ Missing cases for instance fields (marked `{{` `}}`) in copattern matches\n  will
  be solved using instance search. This makes defining instances with\n  superclass
  fields much nicer. For instance, we can define `Nat` instances of\n  `Eq`, `Ord`
  and `Num` from above as follows:\n\n  ```agda\n    instance\n      EqNat : Eq Nat\n
  \     _==_ {{EqNat}} n m = eqNat n m\n\n      OrdNat : Ord Nat\n      _<_ {{OrdNat}}
  n m = lessNat n m\n\n      NumNat : Num Nat\n      fromNat {{NumNat}} n = n\n  ```\n\n
  \ The `eqA` fields of `Ord` and `Num` are filled in using instance search (with\n
  \ `EqNat` in this case).\n\n* Limited instance search depth\n  [Issue [#2269](https://github.com/agda/agda/issues/2269)]\n\n
  \ To prevent instance search from looping on bad instances\n  (see [Issue #1743](https://github.com/agda/agda/issues/1743))
  the search\n  depth of instance search is now limited. The maximum depth can be
  set with\n  the `--instance-search-depth` flag and the default value is `500`.\n\nEmacs
  mode\n----------\n\n* New command `C-u C-u C-c C-n`: Use `show` to display the result
  of\n  normalisation.\n\n  Calling `C-u C-u C-c C-n` on an expression `e` (in a hole
  or at top level)\n  normalises `show e` and prints the resulting string, or an error
  message if\n  the expression does not normalise to a literal string.\n\n  This is
  useful when working with complex data structures for which you have\n  defined a
  nice `Show` instance.\n\n  Note that the name `show` is hardwired into the command.\n\n*
  Changed feature: Interactively split result.\n\n  Make-case (`C-c C-c`) with no
  variables will now *either* introduce\n  function arguments *or* do a copattern
  split (or fail).\n\n  This is as before:\n\n  ```agda\n  test : {A B : Set} (a :
  A) (b : B) → A × B\n  test a b = ?\n\n  -- expected:\n  -- proj₁ (test a b) = {!!}\n
  \ -- proj₂ (test a b) = {!!}\n\n  testFun : {A B : Set} (a : A) (b : B) → A × B\n
  \ testFun = ?\n\n  -- expected:\n  -- testFun a b = {!!}\n  ```\n\n  This is has
  changed:\n\n  ```agda\n  record FunRec A : Set where\n    field funField : A → A\n
  \ open FunRec\n\n  testFunRec : ∀{A} → FunRec A\n  testFunRec = ?\n\n  -- expected
  (since 2016-05-03):\n  -- funField testFunRec = {!!}\n\n  -- used to be:\n  -- funField
  testFunRec x = {!!}\n  ```\n\n* Changed feature: Split on hidden variables.\n\n
  \ Make-case (`C-c C-c`) will no longer split on the given hidden\n  variables, but
  only make them visible. (Splitting can then be\n  performed in a second go.)\n\n
  \ ```agda\n  test : ∀{N M : Nat} → Nat → Nat → Nat\n  test N M = {!.N N .M!}\n  ```\n\n
  \ Invoking splitting will result in:\n\n  ```agda\n  test {N} {M} zero M₁ = ?\n
  \ test {N} {M} (suc N₁) M₁ = ?\n  ```\n\n  The hidden `.N` and `.M` have been brought
  into scope, the\n  visible `N` has been split upon.\n\n* Non-fatal errors/warnings.\n\n
  \ Non-fatal errors and warnings are now displayed in the info buffer\n  and do not
  interrupt the typechecking of the file.\n\n  Currently termination errors, unsolved
  metavariables, unsolved\n  constraints, positivity errors, deprecated BUILTINs,
  and empty\n  REWRITING pragmas are non-fatal errors.\n\n* Highlighting for positivity
  check failures\n\n  Negative occurences of a datatype in its definition are now\n
  \ highlighted in a way similar to termination errors.\n\n* The abbrev for codata
  was replaced by an abbrev for code\n  environments.\n\n  If you type `c C-x '` (on
  a suitably standard setup), then Emacs\n  will insert the following text:\n\n  ```agda\n
  \ \\begin{code}<newline>  <cursor><newline>\\end{code}<newline>.\n  ```\n\n* The
  LaTeX backend can now be invoked from the Emacs mode.\n\n  Using the compilation
  command (`C-c C-x C-c`).\n\n  The flag `--latex-dir` can be used to set the output
  directory (by\n  default: `latex`). Note that if this directory is a relative path,\n
  \ then it is interpreted relative to the \"project root\". (When the\n  LaTeX backend
  is invoked from the command line the path is\n  interpreted relative to the current
  working directory.) Example: If\n  the module `A.B.C` is located in the file `/foo/A/B/C.agda`,
  then\n  the project root is `/foo/`, and the default output directory is\n  `/foo/latex/`.\n\n*
  The compilation command (`C-c C-x C-c`) now by default asks for a\n  backend.\n\n
  \ To avoid this question, set the customisation variable\n  `agda2-backend` to an
  appropriate value.\n\n* The command `agda2-measure-load-time` no longer \"touches\"
  the file,\n  and the optional argument `DONT-TOUCH` has been removed.\n\n* New command
  `C-u (C-u) C-c C-s`: Simplify or normalise the solution `C-c C-s` produces\n\n  When
  writing examples, it is nice to have the hole filled in with\n  a normalised version
  of the solution. Calling `C-c C-s` on\n\n  ```agda\n  _ : reverse (0 ∷ 1 ∷ []) ≡
  ?\n  _ = refl\n  ```\n\n  used to yield the non informative `reverse (0 ∷ 1 ∷ [])`
  when we would\n  have hopped to get `1 ∷ 0 ∷ []` instead. We can now control finely
  the\n  degree to which the solution is simplified.\n\n* Changed feature: Solving
  the hole at point\n\n  Calling `C-c C-s` inside a specific goal does not solve *all*
  the goals\n  already instantiated internally anymore: it only solves the one at
  hand\n  (if possible).\n\n* New bindings: All the blackboard bold letters are now
  available\n  [Pull Request [#2305](https://github.com/agda/agda/pull/2305)]\n\n
  \ The Agda input method only bound a handful of the blackboard bold letters\n  but
  programmers were actually using more than these. They are now all\n  available:
  lowercase and uppercase. Some previous bindings had to be\n  modified for consistency.
  The naming scheme is as follows:\n\n  * `\\bx` for lowercase blackboard bold\n  *
  `\\bX` for uppercase blackboard bold\n  * `\\bGx` for lowercase greek blackboard
  bold (similar to `\\Gx` for\n    greeks)\n  * `\\bGX` for uppercase greek blackboard
  bold (similar to `\\GX` for\n    uppercase greeks)\n\n* Replaced binding for go
  back\n\n  Use `M-,` (instead of `M-*`) for go back in Emacs ≥ 25.1 (and\n  continue
  using `M-*` with previous versions of Emacs).\n\nCompiler backends\n-----------------\n\n*
  JS compiler backend\n\n  The JavaScript backend has been (partially) rewritten.
  The\n  JavaScript backend now supports most Agda features, notably\n  copatterns
  can now be compiled to JavaScript. Furthermore, the\n  existing optimizations from
  the other backends now apply to the\n  JavaScript backend as well.\n\n* GHC, JS
  and UHC compiler backends\n\n  Added new primitives to built-in floats\n  [Issues
  [#2194](https://github.com/agda/agda/issues/2194) and\n  [#2200](https://github.com/agda/agda/issues/2200)]:\n\n
  \ ```agda\n  primFloatNegate : Float → Float\n  primCos         : Float → Float\n
  \ primTan         : Float → Float\n  primASin        : Float → Float\n  primACos
  \       : Float → Float\n  primATan        : Float → Float\n  primATan2       :
  Float → Float → Float\n  ```\n\nLaTeX backend\n-------------\n\n* Code blocks are
  now (by default) surrounded by vertical space.\n  [Issue [#2198](https://github.com/agda/agda/issues/2198)]\n\n
  \ Use `\\AgdaNoSpaceAroundCode{}` to avoid this vertical space, and\n  `\\AgdaSpaceAroundCode{}`
  to reenable it.\n\n  Note that, if `\\AgdaNoSpaceAroundCode{}` is used, then empty
  lines\n  before or after a code block will not necessarily lead to empty\n  lines
  in the generated document. However, empty lines *inside* the\n  code block do (by
  default) lead to empty lines in the output.\n\n  If you prefer the previous behaviour,
  then you can use the `agda.sty`\n  file that came with the previous version of Agda.\n\n*
  `\\AgdaHide{...}` now eats trailing spaces (using `\\ignorespaces`).\n\n* New environments:
  `AgdaAlign`, `AgdaSuppressSpace` and\n  `AgdaMultiCode`.\n\n  Sometimes one might
  want to break up a code block into multiple\n  pieces, but keep code in different
  blocks aligned with respect to\n  each other. Then one can use the `AgdaAlign` environment.
  Example\n  usage:\n  ```latex\n    \\begin{AgdaAlign}\n    \\begin{code}\n      code\n
  \       code  (more code)\n    \\end{code}\n    Explanation...\n    \\begin{code}\n
  \     aligned with \"code\"\n        code  (aligned with (more code))\n    \\end{code}\n
  \   \\end{AgdaAlign}\n  ```\n  Note that `AgdaAlign` environments should not be
  nested.\n\n  Sometimes one might also want to hide code in the middle of a code\n
  \ block. This can be accomplished in the following way:\n  ```latex\n    \\begin{AgdaAlign}\n
  \   \\begin{code}\n      visible\n    \\end{code}\n    \\AgdaHide{\n    \\begin{code}\n
  \     hidden\n    \\end{code}}\n    \\begin{code}\n      visible\n    \\end{code}\n
  \   \\end{AgdaAlign}\n  ```\n  However, the result may be ugly: extra space is perhaps
  inserted\n  around the code blocks.\n\n  The `AgdaSuppressSpace` environment ensures
  that extra space is only\n  inserted before the first code block, and after the
  last one (but\n  not if `\\AgdaNoSpaceAroundCode{}` is used).\n\n  The environment
  takes one argument, the number of wrapped code\n  blocks (excluding hidden ones).
  Example usage:\n  ```latex\n    \\begin{AgdaAlign}\n    \\begin{code}\n      code\n
  \       more code\n    \\end{code}\n    Explanation...\n    \\begin{AgdaSuppressSpace}{2}\n
  \   \\begin{code}\n      aligned with \"code\"\n        aligned with \"more code\"\n
  \   \\end{code}\n    \\AgdaHide{\n    \\begin{code}\n      hidden code\n    \\end{code}}\n
  \   \\begin{code}\n        also aligned with \"more code\"\n    \\end{code}\n    \\end{AgdaSuppressSpace}\n
  \   \\end{AgdaAlign}\n  ```\n\n  Note that `AgdaSuppressSpace` environments should
  not be nested.\n\n  There is also a combined environment, `AgdaMultiCode`, that
  combines\n  the effects of `AgdaAlign` and `AgdaSuppressSpace`.\n\nTools\n-----\n\n###
  agda-ghc-names\n\nThe `agda-ghc-names` now has its own repository at\n\n  https://github.com/agda/agda-ghc-names\n\nand
  is no longer distributed with Agda.\n\nRelease notes for Agda version 2.5.1.2\n======================================\n\n*
  Fixed broken type signatures that were incorrectly accepted due to\n  [GHC #12784](https://ghc.haskell.org/trac/ghc/ticket/12784).\n\nRelease
  notes for Agda version 2.5.1.1\n======================================\n\nInstallation
  and infrastructure\n-------------------------------\n\n* Added support for GHC 8.0.1.\n\n*
  Documentation is now built with Python >=3.3, as done by\n  [readthedocs.org](https://readthedocs.org/).\n\nBug
  fixes\n---------\n\n* Fixed a serious performance problem with instance search\n\n
  \ Issues [#1952](https://github.com/agda/agda/issues/1952) and\n  [#1998](https://github.com/agda/agda/issues/1998).
  Also related:\n  [#1955](https://github.com/agda/agda/issues/1955) and\n  [#2025](https://github.com/agda/agda/issues/2025)\n\n*
  Interactively splitting variable with `C-c C-c` no longer introduces\n  new trailing
  patterns.  This fixes\n  Issue [#1950](https://github.com/agda/agda/issues/1950).\n\n
  \ ```agda\n  data Ty : Set where\n    _⇒_ : Ty → Ty → Ty\n\n  ⟦_⟧ : Ty → Set\n  ⟦
  A ⇒ B ⟧ = ⟦ A ⟧ → ⟦ B ⟧\n\n  data Term : Ty → Set where\n    K : (A B : Ty) → Term
  (A ⇒ (B ⇒ A))\n\n  test : (A : Ty) (a : Term A) → ⟦ A ⟧\n  test A a = {!a!}\n  ```\n\n
  \ Before change, case splitting on `a` would give\n\n  ```agda\n  test .(A ⇒ (B
  ⇒ A)) (K A B) x x₁ = ?\n  ```\n\n  Now, it yields\n\n  ```agda\n  test .(A ⇒ (B
  ⇒ A)) (K A B) = ?\n  ```\n\n* In literate TeX files, `\\begin{code}` and `\\end{code}`
  can be\n  preceded (resp. followed) by TeX code on the same line. This fixes\n  Issue
  [#2077](https://github.com/agda/agda/issues/2077).\n\n* Other issues fixed (see\n
  \ [bug tracker](https://github.com/agda/agda/issues)):\n\n  [#1951](https://github.com/agda/agda/issues/1951)
  (mixfix binders\n  not working in 'syntax')\n\n  [#1967](https://github.com/agda/agda/issues/1967)
  (too eager\n  insteance search error)\n\n  [#1974](https://github.com/agda/agda/issues/1974)
  (lost constraint\n  dependencies)\n\n  [#1982](https://github.com/agda/agda/issues/1982)
  (internal error in\n  unifier)\n\n  [#2034](https://github.com/agda/agda/issues/2034)
  (function type\n  instance goals)\n\nCompiler backends\n-----------------\n\n* UHC
  compiler backend\n\n  Added support for UHC 1.1.9.4.\n\nRelease notes for Agda version
  2.5.1\n====================================\n\nDocumentation\n-------------\n\n*
  There is now an official Agda User Manual:\n  http://agda.readthedocs.org/en/stable/\n\nInstallation
  and infrastructure\n-------------------------------\n\n* Builtins and primitives
  are now defined in a new set of modules available to\n  all users, independent of
  any particular library. The modules are\n\n  ```agda\n  Agda.Builtin.Bool\n  Agda.Builtin.Char\n
  \ Agda.Builtin.Coinduction\n  Agda.Builtin.Equality\n  Agda.Builtin.Float\n  Agda.Builtin.FromNat\n
  \ Agda.Builtin.FromNeg\n  Agda.Builtin.FromString\n  Agda.Builtin.IO\n  Agda.Builtin.Int\n
  \ Agda.Builtin.List\n  Agda.Builtin.Nat\n  Agda.Builtin.Reflection\n  Agda.Builtin.Size\n
  \ Agda.Builtin.Strict\n  Agda.Builtin.String\n  Agda.Builtin.TrustMe\n  Agda.Builtin.Unit\n
  \ ```\n\n  The standard library reexports the primitives from the new modules.\n\n
  \ The `Agda.Builtin` modules are installed in the same way as\n  `Agda.Primitive`,
  but unlike `Agda.Primitive` they are not loaded\n  automatically.\n\nPragmas and
  options\n-------------------\n\n* Library management\n\n  There is a new 'library'
  concept for managing include paths. A library\n  consists of\n    - a name,\n    -
  a set of libraries it depends on, and\n    - a set of include paths.\n\n  A library
  is defined in a `.agda-lib` file using the following\n  format:\n\n  ```\n  name:
  LIBRARY-NAME  -- Comment\n  depend: LIB1 LIB2\n    LIB3\n    LIB4\n  include: PATH1\n
  \   PATH2\n    PATH3\n  ```\n\n  Dependencies are library names, not paths to `.agda-lib`
  files, and\n  include paths are relative to the location of the library-file.\n\n
  \ To be useable, a library file has to be listed (with its full path)\n  in `AGDA_DIR/libraries`
  (or `AGDA_DIR/libraries-VERSION`, for a\n  given Agda version). `AGDA_DIR` defaults
  to `~/.agda` on Unix-like\n  systems and `C:/Users/USERNAME/AppData/Roaming/agda`
  or similar on\n  Windows, and can be overridden by setting the `AGDA_DIR` environment\n
  \ variable.\n\n  Environment variables in the paths (of the form `$VAR` or `${VAR}`)\n
  \ are expanded. The location of the libraries file used can be\n  overridden using
  the `--library-file=FILE` flag, although this is\n  not expected to be very useful.\n\n
  \ You can find out the precise location of the 'libraries' file by\n  calling `agda
  -l fjdsk Dummy.agda` and looking at the error message\n  (assuming you don't have
  a library called fjdsk installed).\n\n  There are three ways a library gets used:\n\n
  \   - You supply the `--library=LIB` (or `-l LIB`) option to\n      Agda. This is
  equivalent to adding a `-iPATH` for each of the\n      include paths of `LIB` and
  its (transitive) dependencies.\n\n    - No explicit `--library` flag is given, and
  the current project\n      root (of the Agda file that is being loaded) or one of
  its\n      parent directories contains a `.agda-lib` file defining a\n      library
  `LIB`. This library is used as if a `--librarary=LIB`\n      option had been given,
  except that it is not necessary for the\n      library to be listed in the `AGDA_DIR/libraries`
  file.\n\n    - No explicit `--library` flag, and no `.agda-lib` file in the\n      project
  root. In this case the file `AGDA_DIR/defaults` is read\n      and all libraries
  listed are added to the path. The defaults\n      file should contain a list of
  library names, each on a separate\n      line. In this case the current directory
  is also added to the\n      path.\n\n      To disable default libraries, you can
  give the flag\n      `--no-default-libraries`.\n\n  Library names can end with a
  version number (for instance,\n  `mylib-1.2.3`). When resolving a library name (given
  in a `--library`\n  flag, or listed as a default library or library dependency)
  the\n  following rules are followed:\n\n    - If you don't give a version number,
  any version will do.\n\n    - If you give a version number an exact match is required.\n\n
  \   - When there are multiple matches an exact match is preferred, and\n      otherwise
  the latest matching version is chosen.\n\n  For example, suppose you have the following
  libraries installed:\n  `mylib`, `mylib-1.0`, `otherlib-2.1`, and `otherlib-2.3`.
  In this\n  case, aside from the exact matches you can also say\n  `--library=otherlib`
  to get `otherlib-2.3`.\n\n* New Pragma `COMPILED_DECLARE_DATA` for binding recursively
  defined\n  Haskell data types to recursively defined Agda data types.\n\n  If you
  have a Haskell type like\n\n  ```haskell\n  {-# LANGUAGE GADTs #-}\n\n  module Issue223
  where\n\n  data A where\n    BA :: B -> A\n\n  data B where\n    AB :: A -> B\n
  \   BB :: B\n  ```\n\n  You can now bind it to corresponding mutual Agda inductive
  data\n  types as follows:\n\n  ```agda\n  {-# IMPORT Issue223 #-}\n\n  data A :
  Set\n  {-# COMPILED_DECLARE_DATA A Issue223.A #-}\n  data B : Set\n  {-# COMPILED_DECLARE_DATA
  B Issue223.B #-}\n\n  data A where\n    BA : B → A\n\n  {-# COMPILED_DATA A Issue223.A
  Issue223.BA #-}\n  data B where\n    AB : A → B\n    BB : B\n\n  {-# COMPILED_DATA
  B Issue223.B Issue223.AB Issue223.BB #-}\n  ```\n\n  This fixes Issue [#223](https://github.com/agda/agda/issues/223).\n\n*
  New pragma `HASKELL` for adding inline Haskell code (GHC backend only)\n\n  Arbitrary
  Haskell code can be added to a module using the `HASKELL`\n  pragma. For instance,\n\n
  \ ```agda\n  {-# HASKELL\n    echo :: IO ()\n    echo = getLine >>= putStrLn\n  #-}\n\n
  \ postulate echo : IO ⊤\n  {-# COMPILED echo echo #-}\n  ```\n\n* New option `--exact-split`.\n\n
  \ The `--exact-split` flag causes Agda to raise an error whenever a\n  clause in
  a definition by pattern matching cannot be made to hold\n  definitionally (i.e.
  as a reduction rule). Specific clauses can be\n  excluded from this check by means
  of the `{-# CATCHALL #-}` pragma.\n\n  For instance, the following definition will
  be rejected as the second clause\n  cannot be made to hold definitionally:\n\n  ```agda\n
  \ min : Nat → Nat → Nat\n  min zero    y       = zero\n  min x       zero    = zero\n
  \ min (suc x) (suc y) = suc (min x y\n  ```\n\n  Catchall clauses have to be marked
  as such, for instance:\n\n  ```agda\n  eq : Nat → Nat → Bool\n  eq zero    zero
  \   = true\n  eq (suc m) (suc n) = eq m n\n  {-# CATCHALL #-}\n  eq _       _       =
  false\n  ```\n\n* New option: `--no-exact-split`.\n\n  This option can be used to
  override a global `--exact-split` in a\n  file, by adding a pragma `{-# OPTIONS
  --no-exact-split #-}`.\n\n* New options: `--sharing` and `--no-sharing`.\n\n  These
  options are used to enable/disable sharing and call-by-need\n  evaluation.  The
  default is `--no-sharing`.\n\n  Note that they cannot appear in an OPTIONS pragma,
  but have to be\n  given as command line arguments or added to the Agda Program Args\n
  \ from Emacs with `M-x customize-group agda2`.\n\n* New pragma `DISPLAY`.\n\n  ```agda\n
  \ {-# DISPLAY f e1 .. en = e #-}\n  ```\n\n  This causes `f e1 .. en` to be printed
  in the same way as `e`, where\n  `ei` can bind variables used in `e`. The expressions
  `ei` and `e`\n  are scope checked, but not type checked.\n\n  For example this can
  be used to print overloaded (instance) functions with\n  the overloaded name:\n\n
  \ ```agda\n  instance\n    NumNat : Num Nat\n    NumNat = record { ..; _+_ = natPlus
  }\n\n  {-# DISPLAY natPlus a b = a + b #-}\n  ```\n\n  Limitations\n\n  - Left-hand
  sides are restricted to variables, constructors, defined\n    functions or types,
  and literals. In particular, lambdas are not\n    allowed in left-hand sides.\n\n
  \ - Since `DISPLAY` pragmas are not type checked implicit argument\n    insertion
  may not work properly if the type of `f` computes to an\n    implicit function space
  after pattern matching.\n\n* Removed pragma `{-# ETA R #-}`\n\n  The pragma `{-#
  ETA R #-}` is replaced by the `eta-equality` directive\n  inside record declarations.\n\n*
  New option `--no-eta-equality`.\n\n  The `--no-eta-equality` flag disables eta rules
  for declared record\n  types.  It has the same effect as `no-eta-equality` inside
  each\n  declaration of a record type `R`.\n\n  If used with the OPTIONS pragma it
  will not affect records defined\n  in other modules.\n\n* The semantics of `{-#
  REWRITE r #-}` pragmas in parametrized modules\n  has changed (see\n  Issue [#1652](https://github.com/agda/agda/issues/1652)).\n\n
  \ Rewrite rules are no longer lifted to the top context. Instead, they\n  now only
  apply to terms in (extensions of) the module context. If\n  you want the old behaviour,
  you should put the `{-# REWRITE r #-}`\n  pragma outside of the module (i.e. unindent
  it).\n\n* New pragma `{-# INLINE f #-}` causes `f` to be inlined during\n  compilation.\n\n*
  The `STATIC` pragma is now taken into account during compilation.\n\n  Calls to
  a function marked `STATIC` are normalised before\n  compilation. The typical use
  case for this is to mark the\n  interpreter of an embedded language as `STATIC`.\n\n*
  Option `--type-in-type` no longer implies\n  `--no-universe-polymorphism`, thus,
  it can be used with explicit\n  universe\n  levels. [Issue [#1764](https://github.com/agda/agda/issues/1764)]
  It\n  simply turns off error reporting for any level mismatch now.\n  Examples:\n\n
  \ ```agda\n  {-# OPTIONS --type-in-type #-}\n\n  Type : Set\n  Type = Set\n\n  data
  D {α} (A : Set α) : Set where\n    d : A → D A\n\n  data E α β : Set β where\n    e
  : Set α → E α β\n  ```\n\n* New `NO_POSITIVITY_CHECK` pragma to switch off the positivity
  checker\n  for data/record definitions and mutual blocks.\n\n  The pragma must precede
  a data/record definition or a mutual block.\n\n  The pragma cannot be used in `--safe`
  mode.\n\n  Examples (see `Issue1614*.agda` and `Issue1760*.agda` in\n  `test/Succeed/`):\n\n
  \ 1. Skipping a single data definition.\n\n     ```agda\n     {-# NO_POSITIVITY_CHECK
  #-}\n     data D : Set where\n       lam : (D → D) → D\n     ```\n\n  2. Skipping
  a single record definition.\n\n     ```agda\n     {-# NO_POSITIVITY_CHECK #-}\n
  \    record U : Set where\n       field ap : U → U\n     ```\n\n  3. Skipping an
  old-style mutual block: Somewhere within a `mutual`\n     block before a data/record
  definition.\n\n     ```agda\n     mutual\n       data D : Set where\n         lam
  : (D → D) → D\n\n       {-# NO_POSITIVITY_CHECK #-}\n       record U : Set where\n
  \        field ap : U → U\n     ```\n\n  4. Skipping an old-style mutual block:
  Before the `mutual` keyword.\n\n     ```agda\n     {-# NO_POSITIVITY_CHECK #-}\n
  \    mutual\n       data D : Set where\n         lam : (D → D) → D\n\n       record
  U : Set where\n         field ap : U → U\n     ```\n\n  5. Skipping a new-style
  mutual block: Anywhere before the\n     declaration or the definition of data/record
  in the block.\n\n     ```agda\n     record U : Set\n     data D   : Set\n\n     record
  U where\n       field ap : U → U\n\n     {-# NO_POSITIVITY_CHECK #-}\n     data
  D where\n       lam : (D → D) → D\n     ```\n\n* Removed `--no-coverage-check`\n
  \ option. [Issue [#1918](https://github.com/agda/agda/issues/1918)]\n\nLanguage\n--------\n\n###
  Operator syntax\n\n* The default fixity for syntax declarations has changed from
  -666 to 20.\n\n* Sections.\n\n  Operators can be sectioned by replacing arguments
  with underscores.\n  There must not be any whitespace between these underscores
  and the\n  adjacent nameparts. Examples:\n\n  ```agda\n  pred : ℕ → ℕ\n  pred =
  _∸ 1\n\n  T : Bool → Set\n  T = if_then ⊤ else ⊥\n\n  if : {A : Set} (b : Bool)
  → A → A → A\n  if b = if b then_else_\n  ```\n\n  Sections are translated into lambda
  expressions. Examples:\n\n  ```agda\n  _∸ 1              ↦  λ section → section
  ∸ 1\n\n  if_then ⊤ else ⊥  ↦  λ section → if section then ⊤ else ⊥\n\n  if b then_else_
  \  ↦  λ section section₁ →\n                           if b then section else section₁\n
  \ ```\n\n  Operator sections have the same fixity as the underlying operator\n  (except
  in cases like `if b then_else_`, in which the section is\n  \"closed\", but the
  operator is not).\n\n  Operator sections are not supported in patterns (with the
  exception\n  of dot patterns), and notations coming from syntax declarations\n  cannot
  be sectioned.\n\n* A long-standing operator fixity bug has been fixed. As a consequence\n
  \ some programs that used to parse no longer do.\n\n  Previously each precedence
  level was (incorrectly) split up into\n  five separate ones, ordered as follows,
  with the earlier ones\n  binding less tightly than the later ones:\n\n    - Non-associative
  operators.\n\n    - Left associative operators.\n\n    - Right associative operators.\n\n
  \   - Prefix operators.\n\n    - Postfix operators.\n\n  Now this problem has been
  addressed. It is no longer possible to mix\n  operators of a given precedence level
  but different associativity.\n  However, prefix and right associative operators
  are seen as having\n  the same associativity, and similarly for postfix and left\n
  \ associative operators.\n\n  Examples\n  --------\n\n  The following code is no
  longer accepted:\n\n  ```agda\n  infixl 6 _+_\n  infix  6 _∸_\n\n  rejected : ℕ\n
  \ rejected = 1 + 0 ∸ 1\n  ```\n\n  However, the following previously rejected code
  is accepted:\n\n  ```agda\n  infixr 4 _,_\n  infix  4 ,_\n\n  ,_ : {A : Set} {B
  : A → Set} {x : A} → B x → Σ A B\n  , y = _ , y\n\n  accepted : Σ ℕ λ i → Σ ℕ λ
  j → Σ (i ≡ j) λ _ → Σ ℕ λ k → j ≡ k\n  accepted = 5 , , refl , , refl\n  ```\n\n*
  The classification of notations with binders into the categories\n  infix, prefix,
  postfix or closed has\n  changed. [Issue [#1450](https://github.com/agda/agda/issues/1450)]\n\n
  \ The difference is that, when classifying the notation, only\n  *regular* holes
  are taken into account, not *binding* ones.\n\n  Example: The notation\n\n  ```agda\n
  \ syntax m >>= (λ x → f) = x <- m , f\n  ```\n\n  was previously treated as infix,
  but is now treated as prefix.\n\n* Notation can now include wildcard binders.\n\n
  \ Example: `syntax Σ A (λ _ → B) = A × B`\n\n* If an overloaded operator is in scope
  with several distinct\n  precedence levels, then several instances of this operator
  will be\n  included in the operator grammar, possibly leading to ambiguity.\n  Previously
  the operator was given the default fixity\n  [Issue [#1436](https://github.com/agda/agda/issues/1436)].\n\n
  \ There is an exception to this rule: If there are multiple precedences,\n  but
  at most one is explicitly declared, then only one instance will be\n  included in
  the grammar. If there are no explicitly declared\n  precedences, then this instance
  will get the default precedence, and\n  otherwise it will get the declared precedence.\n\n
  \ If multiple occurrences of an operator are \"merged\" in the grammar,\n  and they
  have distinct associativities, then they are treated as\n  being non-associative.\n\n
  \ The three paragraphs above also apply to identical notations (coming\n  from syntax
  declarations) for a given overloaded name.\n\n  Examples:\n\n  ```agda\n  module
  A where\n\n    infixr 5 _∷_\n    infixr 5 _∙_\n    infixl 3 _+_\n    infix  1 bind\n\n
  \   syntax bind c (λ x → d) = x ← c , d\n\n  module B where\n\n    infix  5 _∷_\n
  \   infixr 4 _∙_\n    -- No fixity declaration for _+_.\n    infixl 2 bind\n\n    syntax
  bind c d = c ∙ d\n\n  module C where\n\n    infixr 2 bind\n\n    syntax bind c d
  = c ∙ d\n\n  open A\n  open B\n  open C\n\n  -- _∷_ is infix 5.\n  -- _∙_ has two
  fixities: infixr 4 and infixr 5.\n  -- _+_ is infixl 3.\n  -- A.bind's notation
  is infix 1.\n  -- B.bind and C.bind's notations are infix 2.\n\n  -- There is one
  instance of \"_ ∷ _\" in the grammar, and one\n  -- instance of \"_ + _\".\n\n  --
  There are three instances of \"_ ∙ _\" in the grammar, one\n  -- corresponding to
  A._∙_, one corresponding to B._∙_, and one\n  -- corresponding to both B.bind and
  C.bind.\n  ```\n\n### Reflection\n\n* The reflection framework has received a massive
  overhaul.\n\n  A new type of reflected type checking computations supplants most
  of\n  the old reflection primitives. The `quoteGoal`, `quoteContext` and\n  tactic
  primitives are deprecated and will be removed in the future,\n  and the `unquoteDecl`
  and `unquote` primitives have changed\n  behaviour. Furthermore the following primitive
  functions have been\n  replaced by builtin type checking computations:\n\n  ```agda\n
  \ - primQNameType              --> AGDATCMGETTYPE\n  - primQNameDefinition        -->
  AGDATCMGETDEFINITION\n  - primDataConstructors       --> subsumed by AGDATCMGETDEFINITION\n
  \ - primDataNumberOfParameters --> subsumed by AGDATCMGETDEFINITION\n  ```\n\n  See
  below for details.\n\n* Types are no longer packaged with a sort.\n\n  The `AGDATYPE`
  and `AGDATYPEEL` built-ins have been\n  removed. Reflected types are now simply
  terms.\n\n* Reflected definitions have more information.\n\n  The type for reflected
  definitions has changed to\n\n  ```agda\n  data Definition : Set where\n    fun-def
  \    : List Clause  → Definition\n    data-type   : Nat → List Name → Definition
  -- parameters and constructors\n    record-type : Name → Definition            --
  name of the data/record type\n    data-con    : Name → Definition            --
  name of the constructor\n    axiom       : Definition\n    prim-fun    : Definition\n
  \ ```\n\n  Correspondingly the built-ins for function, data and record\n  definitions
  (`AGDAFUNDEF`, `AGDAFUNDEFCON`, `AGDADATADEF`,\n  `AGDARECORDDEF`) have been removed.\n\n*
  Reflected type checking computations.\n\n  There is a primitive `TC` monad representing
  type checking\n  computations. The `unquote`, `unquoteDecl`, and the new `unquoteDef`\n
  \ all expect computations in this monad (see below). The interface to\n  the monad
  is the following\n\n  ```agda\n  -- Error messages can contain embedded names and
  terms.\n  data ErrorPart : Set where\n    strErr  : String → ErrorPart\n    termErr
  : Term → ErrorPart\n    nameErr : Name → ErrorPart\n\n  {-# BUILTIN AGDAERRORPART
  \      ErrorPart #-}\n  {-# BUILTIN AGDAERRORPARTSTRING strErr    #-}\n  {-# BUILTIN
  AGDAERRORPARTTERM   termErr   #-}\n  {-# BUILTIN AGDAERRORPARTNAME   nameErr   #-}\n\n
  \ postulate\n    TC         : ∀ {a} → Set a → Set a\n    returnTC   : ∀ {a} {A :
  Set a} → A → TC A\n    bindTC     : ∀ {a b} {A : Set a} {B : Set b} → TC A → (A
  → TC B) → TC B\n\n    -- Unify two terms, potentially solving metavariables in the
  process.\n    unify      : Term → Term → TC ⊤\n\n    -- Throw a type error. Can
  be caught by catchTC.\n    typeError  : ∀ {a} {A : Set a} → List ErrorPart → TC
  A\n\n    -- Block a type checking computation on a metavariable. This will abort\n
  \   -- the computation and restart it (from the beginning) when the\n    -- metavariable
  is solved.\n    blockOnMeta : ∀ {a} {A : Set a} → Meta → TC A\n\n    -- Backtrack
  and try the second argument if the first argument throws a\n    -- type error.\n
  \   catchTC    : ∀ {a} {A : Set a} → TC A → TC A → TC A\n\n    -- Infer the type
  of a given term\n    inferType  : Term → TC Type\n\n    -- Check a term against
  a given type. This may resolve implicit arguments\n    -- in the term, so a new
  refined term is returned. Can be used to create\n    -- new metavariables: newMeta
  t = checkType unknown t\n    checkType  : Term → Type → TC Term\n\n    -- Compute
  the normal form of a term.\n    normalise  : Term → TC Term\n\n    -- Get the current
  context.\n    getContext : TC (List (Arg Type))\n\n    -- Extend the current context
  with a variable of the given type.\n    extendContext : ∀ {a} {A : Set a} → Arg
  Type → TC A → TC A\n\n    -- Set the current context.\n    inContext     : ∀ {a}
  {A : Set a} → List (Arg Type) → TC A → TC A\n\n    -- Quote a value, returning the
  corresponding Term.\n    quoteTC : ∀ {a} {A : Set a} → A → TC Term\n\n    -- Unquote
  a Term, returning the corresponding value.\n    unquoteTC : ∀ {a} {A : Set a} →
  Term → TC A\n\n    -- Create a fresh name.\n    freshName  : String → TC QName\n\n
  \   -- Declare a new function of the given type. The function must be defined\n
  \   -- later using 'defineFun'. Takes an Arg Name to allow declaring instances\n
  \   -- and irrelevant functions. The Visibility of the Arg must not be hidden.\n
  \   declareDef : Arg QName → Type → TC ⊤\n\n    -- Define a declared function. The
  function may have been declared using\n    -- 'declareDef' or with an explicit type
  signature in the program.\n    defineFun  : QName → List Clause → TC ⊤\n\n    --
  Get the type of a defined name. Replaces 'primQNameType'.\n    getType    : QName
  → TC Type\n\n    -- Get the definition of a defined name. Replaces 'primQNameDefinition'.\n
  \   getDefinition : QName → TC Definition\n\n  {-# BUILTIN AGDATCM                   TC
  \                #-}\n  {-# BUILTIN AGDATCMRETURN             returnTC           #-}\n
  \ {-# BUILTIN AGDATCMBIND               bindTC             #-}\n  {-# BUILTIN AGDATCMUNIFY
  \             unify              #-}\n  {-# BUILTIN AGDATCMNEWMETA            newMeta
  \           #-}\n  {-# BUILTIN AGDATCMTYPEERROR          typeError          #-}\n
  \ {-# BUILTIN AGDATCMBLOCKONMETA        blockOnMeta        #-}\n  {-# BUILTIN AGDATCMCATCHERROR
  \        catchTC            #-}\n  {-# BUILTIN AGDATCMINFERTYPE          inferType
  \         #-}\n  {-# BUILTIN AGDATCMCHECKTYPE          checkType          #-}\n
  \ {-# BUILTIN AGDATCMNORMALISE          normalise          #-}\n  {-# BUILTIN AGDATCMGETCONTEXT
  \        getContext         #-}\n  {-# BUILTIN AGDATCMEXTENDCONTEXT      extendContext
  \     #-}\n  {-# BUILTIN AGDATCMINCONTEXT          inContext          #-}\n  {-#
  BUILTIN AGDATCMQUOTETERM          quoteTC            #-}\n  {-# BUILTIN AGDATCMUNQUOTETERM
  \       unquoteTC          #-}\n  {-# BUILTIN AGDATCMFRESHNAME          freshName
  \         #-}\n  {-# BUILTIN AGDATCMDECLAREDEF         declareDef         #-}\n
  \ {-# BUILTIN AGDATCMDEFINEFUN          defineFun          #-}\n  {-# BUILTIN AGDATCMGETTYPE
  \           getType            #-}\n  {-# BUILTIN AGDATCMGETDEFINITION      getDefinition
  \     #-}\n  ```\n\n* Builtin type for metavariables\n\n  There is a new builtin
  type for metavariables used by the new reflection\n  framework. It is declared as
  follows and comes with primitive equality,\n  ordering and show.\n\n  ```agda\n
  \ postulate Meta : Set\n  {-# BUILTIN AGDAMETA Meta #-}\n  primitive primMetaEquality
  : Meta → Meta → Bool\n  primitive primMetaLess : Meta → Meta → Bool\n  primitive
  primShowMeta : Meta → String\n  ```\n\n  There are corresponding new constructors
  in the `Term` and `Literal`\n  data types:\n\n  ```agda\n  data Term : Set where\n
  \   ...\n    meta : Meta → List (Arg Term) → Term\n\n  {-# BUILTIN AGDATERMMETA
  meta #-}\n\n  data Literal : Set where\n    ...\n    meta : Meta → Literal\n\n  {-#
  BUILTIN AGDALITMETA meta #-}\n  ```\n\n* Builtin unit type\n\n  The type checker
  needs to know about the unit type, which you can\n  allow by\n\n  ```agda\n  record
  ⊤ : Set where\n  {-# BUILTIN UNIT ⊤ #-}\n  ```\n\n* Changed behaviour of `unquote`\n\n
  \ The `unquote` primitive now expects a type checking computation\n  instead of
  a pure term. In particular `unquote e` requires\n\n  ```agda\n  e : Term → TC ⊤\n
  \ ```\n\n  where the argument is the representation of the hole in which the\n  result
  should go. The old `unquote` behaviour (where `unquote`\n  expected a `Term` argument)
  can be recovered by\n\n  ```agda\n  OLD: unquote v\n  NEW: unquote λ hole → unify
  hole v\n  ```\n\n* Changed behaviour of `unquoteDecl`\n\n  The `unquoteDecl` primitive
  now expects a type checking computation\n  instead of a pure function definition.
  It is possible to define\n  multiple (mutually recursive) functions at the same
  time. More\n  specifically\n\n  ```agda\n  unquoteDecl x₁ .. xₙ = m\n  ```\n\n  requires
  `m : TC ⊤` and that `x₁ .. xₙ` are defined (using\n  `declareDef` and `defineFun`)
  after executing `m`. As before `x₁\n  .. xₙ : QName` in `m`, but have their declared
  types outside the\n  `unquoteDecl`.\n\n* New primitive `unquoteDef`\n\n  There is
  a new declaration\n\n  ```agda\n  unquoteDef x₁ .. xₙ = m\n  ```\n\n  This works
  exactly as `unquoteDecl` (see above) with the exception\n  that `x₁ ..  xₙ` are
  required to already be declared.\n\n  The main advantage of `unquoteDef` over `unquoteDecl`
  is that\n  `unquoteDef` is allowed in mutual blocks, allowing mutually\n  recursion
  between generated definitions and hand-written\n  definitions.\n\n* The reflection
  interface now exposes the name hint (as a string)\n  for variables. As before, the
  actual binding structure is with\n  de Bruijn indices. The String value is just
  a hint used as a prefix\n  to help display the variable. The type `Abs` is a new
  builtin type used\n  for the constructors `Term.lam`, `Term.pi`, `Pattern.var`\n
  \ (bultins `AGDATERMLAM`, `AGDATERMPI` and `AGDAPATVAR`).\n\n  ```agda\n  data Abs
  (A : Set) : Set where\n    abs : (s : String) (x : A) → Abs A\n  {-# BUILTIN ABS
  \   Abs #-}\n  {-# BUILTIN ABSABS abs #-}\n  ```\n\n  Updated constructor types:\n\n
  \ ```agda\n  Term.lam    : Hiding   → Abs Term → Term\n  Term.pi     : Arg Type
  → Abs Type → Term\n  Pattern.var : String   → Pattern\n  ```\n\n* Reflection-based
  macros\n\n  Macros are functions of type `t1 → t2 → .. → Term → TC ⊤` that are\n
  \ defined in a `macro` block. Macro application is guided by the type\n  of the
  macro, where `Term` arguments desugar into the `quoteTerm`\n  syntax and `Name`
  arguments into the `quote` syntax. Arguments of\n  any other type are preserved
  as-is. The last `Term` argument is the\n  hole term given to `unquote` computation
  (see above).\n\n  For example, the macro application `f u v w` where the macro `f`
  has\n  the type `Term → Name → Bool → Term → TC ⊤` desugars into `unquote\n  (f
  (quoteTerm u) (quote v) w)`\n\n  Limitations:\n\n    - Macros cannot be recursive.
  This can be worked around by defining the\n      recursive function outside the
  macro block and have the macro call the\n      recursive function.\n\n  Silly example:\n\n
  \ ```agda\n  macro\n    plus-to-times : Term → Term → TC ⊤\n    plus-to-times (def
  (quote _+_) (a ∷ b ∷ [])) hole = unify hole (def (quote _*_) (a ∷ b ∷ []))\n    plus-to-times
  v hole = unify hole v\n\n  thm : (a b : Nat) → plus-to-times (a + b) ≡ a * b\n  thm
  a b = refl\n  ```\n\n  Macros are most useful when writing tactics, since they let
  you hide the\n  reflection machinery. For instance, suppose you have a solver\n\n
  \ ```agda\n  magic : Type → Term\n  ```\n\n  that takes a reflected goal and outputs
  a proof (when successful). You can\n  then define the following macro\n\n  ```agda\n
  \ macro\n    by-magic : Term → TC ⊤\n    by-magic hole =\n      bindTC (inferType
  hole) λ goal →\n      unify hole (magic goal)\n  ```\n\n  This lets you apply the
  magic tactic without any syntactic noise at all:\n\n  ```agda\n  thm : ¬ P ≡ NP\n
  \ thm = by-magic\n  ```\n\n### Literals and built-ins\n\n* Overloaded number literals.\n\n
  \ You can now overload natural number literals using the new builtin\n  `FROMNAT`:\n\n
  \ ```agda\n  {-# BUILTIN FROMNAT fromNat #-}\n  ```\n\n  The target of the builtin
  should be a defined name. Typically you would do\n  something like\n\n  ```agda\n
  \ record Number (A : Set) : Set where\n    field fromNat : Nat → A\n\n  open Number
  {{...}} public\n\n  {-# BUILTIN FROMNAT fromNat #-}\n  ```\n\n  This will cause
  number literals `n` to be desugared to `fromNat n`\n  before type checking.\n\n*
  Negative number literals.\n\n  Number literals can now be negative. For floating
  point literals it\n  works as expected. For integer literals there is a new builtin\n
  \ `FROMNEG` that enables negative integer literals:\n\n  ```agda\n  {-# BUILTIN
  FROMNEG fromNeg #-}\n  ```\n\n  This causes negative literals `-n` to be desugared
  to `fromNeg n`.\n\n* Overloaded string literals.\n\n  String literals can be overladed
  using the `FROMSTRING` builtin:\n\n  ```agda\n  {-# BUILTIN FROMSTRING fromString
  #-}\n  ```\n\n  The will cause string literals `s` to be desugared to `fromString
  s`\n  before type checking.\n\n* Change to builtin integers.\n\n  The `INTEGER`
  builtin now needs to be bound to a datatype with two\n  constructors that should
  be bound to the new builtins `INTEGERPOS`\n  and `INTEGERNEGSUC` as follows:\n\n
  \ ```agda\n  data Int : Set where\n    pos    : Nat -> Int\n    negsuc : Nat ->
  Int\n  {-# BUILTIN INTEGER       Int    #-}\n  {-# BUILTIN INTEGERPOS    pos    #-}\n
  \ {-# BUILTIN INTEGERNEGSUC negsuc #-}\n  ```\n\n  where `negsuc n` represents the
  integer `-n - 1`. For instance, `-5`\n  is represented as `negsuc 4`. All primitive
  functions on integers\n  except `primShowInteger` have been removed, since these
  can be\n  defined without too much trouble on the above representation using\n  the
  corresponding functions on natural numbers.\n\n  The primitives that have been removed
  are\n\n  ```agda\n  primIntegerPlus\n  primIntegerMinus\n  primIntegerTimes\n  primIntegerDiv\n
  \ primIntegerMod\n  primIntegerEquality\n  primIntegerLess\n  primIntegerAbs\n  primNatToInteger\n
  \ ```\n\n* New primitives for strict evaluation\n\n  ```agda\n  primitive\n    primForce
  \     : ∀ {a b} {A : Set a} {B : A → Set b} (x : A) → (∀ x → B x) → B x\n    primForceLemma
  : ∀ {a b} {A : Set a} {B : A → Set b} (x : A) (f : ∀ x → B x) → primForce x f ≡
  f x\n  ```\n\n  `primForce x f` evaluates to `f x` if x is in weak head normal form,\n
  \ and `primForceLemma x f` evaluates to `refl` in the same\n  situation. The following
  values are considered to be in weak head\n  normal form:\n\n    - constructor applications\n
  \   - literals\n    - lambda abstractions\n    - type constructor (data/record types)
  applications\n    - function types\n    - Set a\n\n### Modules\n\n* Modules in import
  directives\n\n  When you use `using`/`hiding`/`renaming` on a name it now\n  automatically
  applies to any module of the same name, unless you\n  explicitly mention the module.
  For instance,\n\n  ```agda\n  open M using (D)\n  ```\n\n  is equivalent to\n\n
  \ ```agda\n  open M using (D; module D)\n  ```\n\n  if `M` defines a module `D`.
  This is most useful for record and data\n  types where you always get a module of
  the same name as the type.\n\n  With this feature there is no longer useful to be
  able to qualify a\n  constructor (or field) by the name of the data type even when
  it\n  differs from the name of the corresponding module. The follow\n  (weird) code
  used to work, but doesn't work anymore:\n\n  ```agda\n  module M where\n    data
  D where\n      c : D\n  open M using (D) renaming (module D to MD)\n  foo : D\n
  \ foo = D.c\n  ```\n\n  If you want to import only the type name and not the module
  you have to hide\n  it explicitly:\n\n  ```agda\n  open M using (D) hiding (module
  D)\n  ```\n\n  See discussion on\n  Issue [#836](https://github.com/agda/agda/issues/836).\n\n*
  Private definitions of a module are no longer in scope at the Emacs\n  mode top-level.\n\n
  \ The reason for this change is that `.agdai-files` are stripped of\n  unused private
  definitions (which can yield significant performance\n  improvements for module-heavy
  code).\n\n  To test private definitions you can create a hole at the bottom of\n
  \ the module, in which private definitions will be visible.\n\n### Records\n\n*
  New record directives `eta-equality`/`no-eta-equality`\n\n  The keywords `eta-equality`/`no-eta-equality`
  enable/disable eta\n  rules for the (inductive) record type being declared.\n\n
  \ ```agda\n  record Σ (A : Set) (B : A -> Set) : Set where\n    no-eta-equality\n
  \   constructor _,_\n    field\n      fst : A\n      snd : B fst\n  open Σ\n\n  --
  fail : ∀ {A : Set}{B : A -> Set} → (x : Σ A B) → x ≡ (fst x , snd x)\n  -- fail
  x = refl\n  --\n  -- x != fst x , snd x of type Σ .A .B\n  -- when checking that
  the expression refl has type x ≡ (fst x , snd x)\n  ```\n\n* Building records from
  modules.\n\n  The `record { <fields> }` syntax is now extended to accept module\n
  \ names as well. Fields are thus defined using the corresponding\n  definitions
  from the given module.\n\n  For instance assuming this record type `R` and module
  `M`:\n\n  ```agda\n  record R : Set where\n    field\n      x : X\n      y : Y\n
  \     z : Z\n\n  module M where\n    x = {! ... !}\n    y = {! ... !}\n\n  r : R\n
  \ r = record { M; z = {! ... !} }\n  ```\n\n  Previously one had to write `record
  { x = M.x; y = M.y; z = {! ... !} }`.\n\n  More precisely this construction now
  supports any combination of explicit\n  field definitions and applied modules.\n\n
  \ If a field is both given explicitly and available in one of the modules,\n  then
  the explicit one takes precedence.\n\n  If a field is available in more than one
  module then this is ambiguous\n  and therefore rejected. As a consequence the order
  of assignments does\n  not matter.\n\n  The modules can be both applied to arguments
  and have import directives\n  such as `hiding`, `using`, and `renaming`. In particular
  this construct\n  subsumes the record update construction.\n\n  Here is an example
  of record update:\n\n  ```agda\n  -- Record update. Same as: record r { y = {! ...
  !} }\n  r2 : R\n  r2 = record { R r; y = {! ... !} }\n  ```\n\n  A contrived example
  showing the use of `hiding`/`renaming`:\n\n  ```agda\n  module M2 (a : A) where\n
  \   w = {! ... !}\n    z = {! ... !}\n\n  r3 : A → R\n  r3 a = record { M hiding
  (y); M2 a renaming (w to y) }\n  ```\n\n* Record patterns are now accepted.\n\n
  \ Examples:\n\n  ```agda\n  swap : {A B : Set} (p : A × B) → B × A\n  swap record{
  proj₁ = a; proj₂ = b } = record{ proj₁ = b; proj₂ = a }\n\n  thd3 : ...\n  thd3
  record{ proj₂ = record { proj₂ = c }} = c\n  ```\n\n* Record modules now properly
  hide all their parameters\n  [Issue [#1759](https://github.com/agda/agda/issues/1759)]\n\n
  \ Previously parameters to parent modules were not hidden in the record\n  module,
  resulting in different behaviour between\n\n  ```agda\n  module M (A : Set) where\n
  \   record R (B : Set) : Set where\n  ```\n\n  and\n\n  ```agda\n  module M where\n
  \   record R (A B : Set) : Set where\n  ```\n\n  where in the former case, `A` would
  be an explicit argument to the module\n  `M.R`, but implicit in the latter case.
  Now `A` is implicit in both cases.\n\n### Instance search\n\n* Performance has been
  improved, recursive instance search which was\n  previously exponential in the depth
  is now only quadratic.\n\n* Constructors of records and datatypes are not anymore
  automatically\n  considered as instances, you have to do so explicitely, for\n  instance:\n\n
  \ ```agda\n  -- only [b] is an instance of D\n  data D : Set where\n    a : D\n
  \   instance\n      b : D\n    c : D\n\n  -- the constructor is now an instance\n
  \ record tt : Set where\n    instance constructor tt\n  ```\n\n* Lambda-bound variables
  are no longer automatically considered\n  instances.\n\n  Lambda-bound variables
  need to be bound as instance arguments to be\n  considered for instance search.
  For example,\n\n  ```agda\n  _==_ : {A : Set} {{_ : Eq A}} → A → A → Bool\n\n  fails
  : {A : Set} → Eq A → A → Bool\n  fails eqA x = x == x\n\n  works : {A : Set} {{_
  : Eq A}} → A → Bool\n  works x = x == x\n  ```\n\n* Let-bound variables are no longer
  automatically considered\n  instances.\n\n  To make a let-bound variable available
  as an instance it needs to be\n  declared with the `instance` keyword, just like
  top-level\n  instances. For example,\n\n  ```agda\n  mkEq : {A : Set} → (A → A →
  Bool) → Eq A\n\n  fails : {A : Set} → (A → A → Bool) → A → Bool\n  fails eq x =
  let eqA = mkEq eq in x == x\n\n  works : {A : Set} → (A → A → Bool) → A → Bool\n
  \ works eq x = let instance eqA = mkEq eq in x == x\n  ```\n\n* Record fields can
  be declared instances.\n\n  For example,\n\n  ```agda\n  record EqSet : Set₁ where\n
  \   field\n      set : Set\n      instance eq : Eq set\n  ```\n\n  This causes the
  projection function `eq : (E : EqSet) → Eq (set E)`\n  to be considered for instance
  search.\n\n* Instance search can now find arguments in variable types (but such\n
  \ candidates can only be lambda-bound variables, they can’t be\n  declared as instances)\n\n
  \ ```agda\n  module _ {A : Set} (P : A → Set) where\n\n    postulate\n      bla
  : {x : A} {{_ : P x}} → Set → Set\n\n    -- Works, the instance argument is found
  in the context\n    test :  {x : A} {{_ : P x}} → Set → Set\n    test B = bla B\n\n
  \   -- Still forbidden, because [P] could be instantiated later to anything\n    instance\n
  \    postulate\n      forbidden : {x : A} → P x\n  ```\n\n* Instance search now
  refuses to solve constraints with unconstrained\n  metavariables, since this can
  lead to non-termination.\n\n  See [Issue [#1532](https://github.com/agda/agda/issues/1523)]
  for an\n  example.\n\n* Top-level instances are now only considered if they are
  in\n  scope. [Issue [#1913](https://github.com/agda/agda/issues/1913)]\n\n  Note
  that lambda-bound instances need not be in scope.\n\n### Other changes\n\n* Unicode
  ellipsis character is allowed for the ellipsis token `...`\n  in `with` expressions.\n\n*
  `Prop` is no longer a reserved word.\n\nType checking\n-------------\n\n* Large
  indices.\n\n  Force constructor arguments no longer count towards the size of a
  datatype.\n  For instance, the definition of equality below is accepted.\n\n  ```agda\n
  \ data _≡_ {a} {A : Set a} : A → A → Set where\n    refl : ∀ x → x ≡ x\n  ```\n\n
  \ This gets rid of the asymmetry that the version of equality which indexes\n  only
  on the second argument could be small, but not the version above which\n  indexes
  on both arguments.\n\n* Detection of datatypes that satisfy K (i.e. sets)\n\n  Agda
  will now try to detect datatypes that satisfy K when\n  `--without-K` is enabled.
  A datatype satisfies K when it follows\n  these three rules:\n\n  - The types of
  all non-recursive constructor arguments should satisfy K.\n\n  - All recursive constructor
  arguments should be first-order.\n\n  - The types of all indices should satisfy
  K.\n\n  For example, the types `Nat`, `List Nat`, and `x ≡ x` (where `x :\n  Nat`)
  are all recognized by Agda as satisfying K.\n\n* New unifier for case splitting\n\n
  \ The unifier used by Agda for case splitting has been completely\n  rewritten.
  The new unifier takes a much more type-directed approach\n  in order to avoid the
  problems in issues\n  [#1406](https://github.com/agda/agda/issues/1406),\n  [#1408](https://github.com/agda/agda/issues/1408),\n
  \ [#1427](https://github.com/agda/agda/issues/1427), and\n  [#1435](https://github.com/agda/agda/issues/1435).\n\n
  \ The new unifier also has eta-equality for record types\n  built-in. This should
  avoid unnecessary case splitting on record\n  constructors and improve the performance
  of Agda on code that\n  contains deeply nested record patterns (see issues\n  [#473](https://github.com/agda/agda/issues/473),\n
  \ [#635](https://github.com/agda/agda/issues/635),\n  [#1575](https://github.com/agda/agda/issues/1575),\n
  \ [#1603](https://github.com/agda/agda/issues/1603),\n  [#1613](https://github.com/agda/agda/issues/1613),
  and\n  [#1645](https://github.com/agda/agda/issues/1645)).\n\n  In some cases, the
  locations of the dot patterns computed by the\n  unifier did not correspond to the
  locations given by the user (see\n  Issue [#1608](https://github.com/agda/agda/issues/1608)).
  This has\n  now been fixed by adding an extra step after case splitting that\n  checks
  whether the user-written patterns are compatible with the\n  computed ones.\n\n
  \ In some rare cases, the new unifier is still too restrictive when\n  `--without-K`
  is enabled because it cannot generalize over the\n  datatype indices (yet). For
  example, the following code is rejected:\n\n  ```agda\n  data Bar : Set₁ where\n
  \   bar : Bar\n    baz : (A : Set) → Bar\n\n  data Foo : Bar → Set where\n    foo
  : Foo bar\n\n  test : foo ≡ foo → Set₁\n  test refl = Set\n  ```\n\n* The aggressive
  behaviour of `with` introduced in 2.4.2.5 has been\n  rolled back\n  [Issue [#1692](https://github.com/agda/agda/issues/1692)].
  With no\n  longer abstracts in the types of variables appearing in the\n  with-expressions.
  [Issue [#745](https://github.com/agda/agda/issues/745)]\n\n  This means that the
  following example no longer works:\n\n  ```agda\n  fails : (f : (x : A) → a ≡ x)
  (b : A) → b ≡ a\n  fails f b with a | f b\n  fails f b | .b | refl = f b\n  ```\n\n
  \ The `with` no longer abstracts the type of `f` over `a`, since `f`\n  appears
  in the second with-expression `f b`. You can use a nested\n  `with` to make this
  example work.\n\n  This example does work again:\n\n  ```agda\n  test : ∀{A : Set}{a
  : A}{f : A → A} (p : f a ≡ a) → f (f a) ≡ a\n  test p rewrite p = p\n  ```\n\n  After
  `rewrite p` the goal has changed to `f a ≡ a`, but the type\n  of `p` has not been
  rewritten, thus, the final `p` solves the goal.\n\n  The following, which worked
  in 2.4.2.5, no longer works:\n\n  ```agda\n  fails : (f : (x : A) → a ≡ x) (b :
  A) → b ≡ a\n  fails f b rewrite f b = f b\n  ```\n\n  The rewrite with `f b : a
  ≡ b` is not applied to `f` as\n  the latter is part of the rewrite expression `f
  b`.  Thus,\n  the type of `f` remains untouched, and the changed goal\n  `b ≡ b`
  is not solved by `f b`.\n\n* When using `rewrite` on a term `eq` of type `lhs ≡
  rhs`, the `lhs`\n  is no longer abstracted in `rhs`\n  [Issue [#520](https://github.com/agda/agda/issues/520)].
  \ This means\n  that\n\n  ```agda\n  f pats rewrite eq = body\n  ```\n\n  is more
  than syntactic sugar for\n\n  ```agda\n  f pats with lhs | eq\n  f pats | _ | refl
  = body\n  ```\n\n  In particular, the following application of `rewrite` is now\n
  \ possible\n\n  ```agda\n  id : Bool → Bool\n  id true  = true\n  id false = false\n\n
  \ is-id : ∀ x → x ≡ id x\n  is-id true  = refl\n  is-id false = refl\n\n  postulate\n
  \   P : Bool → Set\n    b : Bool\n    p : P (id b)\n\n  proof : P b\n  proof rewrite
  is-id b = p\n  ```\n\n  Previously, this was desugared to\n\n  ```agda\n  proof
  with b | is-id b\n  proof | _ | refl = p\n  ```\n\n  which did not type check as
  `refl` does not have type `b ≡ id b`.\n  Now, Agda gets the task of checking `refl
  : _ ≡ id b` leading to\n  instantiation of `_` to `id b`.\n\nCompiler backends\n-----------------\n\n*
  Major Bug Fixes:\n\n  - Function clauses with different arities are now always compiled\n
  \   correctly by the GHC/UHC\n    backends. (Issue [#727](https://github.com/agda/agda/issues/727))\n\n*
  Co-patterns\n\n  - The GHC/UHC backends now support co-patterns. (Issues\n    [#1567](https://github.com/agda/agda/issues/1567),\n
  \   [#1632](https://github.com/agda/agda/issues/1632))\n\n* Optimizations\n\n  -
  Builtin naturals are now represented as arbitrary-precision\n    Integers. See the
  user manual, section\n    \"Agda Compilers -> Optimizations\" for details.\n\n*
  GHC Haskell backend (MAlonzo)\n\n  - Pragmas\n\n    Since builtin naturals are compiled
  to `Integer` you can no longer\n    give a `{-# COMPILED_DATA #-}` pragma for `Nat`.
  The same goes for\n    builtin booleans, integers, floats, characters and strings
  which\n    are now hard-wired to appropriate Haskell types.\n\n* UHC compiler backend\n\n
  \ A new backend targeting the Utrecht Haskell Compiler (UHC) is\n  available.  It
  targets the UHC Core language, and it's design is\n  inspired by the Epic backend.
  See the user manual, section \"Agda\n  Compilers -> UHC Backend\" for installation
  instructions.\n\n  - FFI\n\n    The UHC backend has a FFI to Haskell similar to
  MAlonzo's. The\n    target Haskell code also needs to be compilable using UHC, which\n
  \   does not support the Haskell base library version 4.*.\n\n    FFI pragmas for
  the UHC backend are not checked in any way. If the\n    pragmas are wrong, bad things
  will happen.\n\n  - Imports\n\n    Additional Haskell modules can be brought into
  scope with the\n    `IMPORT_UHC` pragma:\n\n    ```agda\n    {-# IMPORT_UHC Data.Char
  #-}\n    ```\n\n    The Haskell modules `UHC.Base` and `UHC.Agda.Builtins` are always
  in\n    scope and don't need to be imported explicitly.\n\n  - Datatypes\n\n    Agda
  datatypes can be bound to Haskell datatypes as follows:\n\n    Haskell:\n    ```haskell\n
  \   data HsData a = HsCon1 | HsCon2 (HsData a)\n    ```\n\n    Agda:\n    ```agda\n
  \   data AgdaData (A : Set) : Set where\n      AgdaCon1 : AgdaData A\n      AgdaCon2
  : AgdaData A -> AgdaData A\n    {-# COMPILED_DATA_UHC AgdaData HsData HsCon1 HsCon2
  #-}\n    ```\n\n    The mapping has to cover all constructors of the used Haskell\n
  \   datatype, else runtime behavior is undefined!\n\n    There are special reserved
  names to bind Agda datatypes to certain\n    Haskell datatypes. For example, this
  binds an Agda datatype to\n    Haskell's list datatype:\n\n    Agda:\n    ```agda\n
  \   data AgdaList (A : Set) : Set where\n      Nil : AgdaList A\n      Cons : A
  -> AgdaList A -> AgdaList A\n    {-# COMPILED_DATA_UHC AgdaList __LIST__ __NIL__
  __CONS__ #-}\n    ```\n\n    The following \"magic\" datatypes are available:\n\n
  \   ```\n    HS Datatype | Datatype Pragma | HS Constructor | Constructor Pragma\n
  \   ()            __UNIT__          ()               __UNIT__\n    List          __LIST__
  \         (:)              __CONS__\n                                    []               __NIL__\n
  \   Bool          __BOOL__          True             __TRUE__\n                                    False
  \           __FALSE__\n    ```\n\n  - Functions\n\n    Agda postulates can be bound
  to Haskell functions. Similar as in\n    MAlonzo, all arguments of type `Set` need
  to be dropped before\n    calling Haskell functions. An example calling the return
  function:\n\n    Agda:\n    ```agda\n    postulate hs-return : {A : Set} -> A ->
  IO A\n    {-# COMPILED_UHC hs-return (\\_ -> UHC.Agda.Builtins.primReturn) #-}\n
  \   ```\n\nEmacs mode and interaction\n--------------------------\n\n* Module contents
  (`C-c C-o`) now also works for\n  records. [See Issue [#1926](https://github.com/agda/agda/issues/1926) ]\n
  \ If you have an inferable expression of record type in an interaction\n  point,
  you can invoke `C-c C-o` to see its fields and types.\n  Example\n\n  ```agda\n
  \ record R : Set where\n    field f : A\n\n  test : R → R\n  test r = {!r!}  --
  C-c C-o here\n  ```\n\n* Less aggressive error notification.\n\n  Previously Emacs
  could jump to the position of an error even if the\n  type-checking process was
  not initiated in the current buffer. Now\n  this no longer happens: If the type-checking
  process was initiated\n  in another buffer, then the cursor is moved to the position
  of the\n  error in the buffer visiting the file (if any) and in every window\n  displaying
  the file, but focus should not change from one file to\n  another.\n\n  In the cases
  where focus does change from one file to another, one\n  can now use the go-back
  functionality to return to the previous\n  position.\n\n* Removed the `agda-include-dirs`
  customization parameter.\n\n  Use `agda-program-args` with `-iDIR` or `-lLIB` instead,
  or add\n  libraries to `~/.agda/defaults`\n  (`C:/Users/USERNAME/AppData/Roaming/agda/defaults`
  or similar on\n  Windows). See Library management, above, for more information.\n\nTools\n-----\n\n###
  LaTeX-backend\n\n* The default font has been changed to XITS (which is part of TeX
  Live):\n\n    http://www.ctan.org/tex-archive/fonts/xits/\n\n  This font is more
  complete with respect to Unicode.\n\n### agda-ghc-names\n\n* New tool: The command\n\n
  \ ```\n  agda-ghc-names fixprof <compile-dir> <ProgName>.prof\n  ```\n\n  converts
  `*.prof` files obtained from profiling runs of\n  MAlonzo-compiled code to `*.agdaIdents.prof`,
  with the original Agda\n  identifiers replacing the MAlonzo-generated Haskell identifiers.\n\n
  \ For usage and more details, see `src/agda-ghc-names/README.txt`.\n\nHighlighting
  and textual backends\n---------------------------------\n\n* Names in import directives
  are now highlighted and are clickable.\n  [Issue [#1714](https://github.com/agda/agda/issues/1714)]
  This leads\n  also to nicer printing in the LaTeX and html backends.\n\nFixed issues\n------------\n\nSee\n[bug
  tracker (milestone 2.5.1)](https://github.com/agda/agda/issues?q=milestone%3A2.5.1+is%3Aclosed)\n\nRelease
  notes for Agda version 2.4.2.5\n======================================\n\nInstallation
  and infrastructure\n-------------------------------\n\n* Added support for GHC 7.10.3.\n\n*
  Added `cpphs` Cabal flag\n\n  Turn on/off this flag to choose cpphs/cpp as the C
  preprocessor.\n\n  This flag is turn on by default.\n\n  (This flag was added in
  Agda 2.4.2.1 but it was not documented)\n\nPragmas and options\n-------------------\n\n*
  Termination pragmas are no longer allowed inside `where` clauses\n  [Issue [#1137](https://github.com/agda/agda/issues/1137)].\n\nType
  checking\n-------------\n\n* `with`-abstraction is more aggressive, abstracts also
  in types of\n  variables that are used in the `with`-expressions, unless they are\n
  \ also used in the types of the\n  `with`-expressions. [Issue [#1692](https://github.com/agda/agda/issues/1692)]\n\n
  \ Example:\n\n  ```agda\n  test : (f : (x : A) → a ≡ x) (b : A) → b ≡ a\n  test
  f b with a | f b\n  test f b | .b | refl = f b\n  ```\n\n  Previously, `with` would
  not abstract in types of variables that\n  appear in the `with`-expressions, in
  this case, both `f` and `b`,\n  leaving their types unchanged.  Now, it tries to
  abstract in `f`, as\n  only `b` appears in the types of the `with`-expressions which
  are\n  `A` (of `a`) and `a ≡ b` (of `f b`).  As a result, the type of `f`\n  changes
  to `(x : A) → b ≡ x` and the type of the goal to `b ≡ b` (as\n  previously).\n\n
  \ This also affects `rewrite`, which is implemented in terms of\n  `with`.\n\n  ```agda\n
  \ test : (f : (x : A) → a ≡ x) (b : A) → b ≡ a\n  test f b rewrite f b = f b\n  ```\n\n
  \ As the new `with` is not fully backwards-compatible, some parts of\n  your Agda
  developments using `with` or `rewrite` might need\n  maintenance.\n\nFixed issues\n------------\n\nSee
  [bug tracker](https://github.com/agda/agda/issues)\n\n[#1407](https://github.com/agda/agda/issues/1497)\n\n[#1518](https://github.com/agda/agda/issues/1518)\n\n[#1670](https://github.com/agda/agda/issues/1670)\n\n[#1677](https://github.com/agda/agda/issues/1677)\n\n[#1698](https://github.com/agda/agda/issues/1698)\n\n[#1701](https://github.com/agda/agda/issues/1701)\n\n[#1710](https://github.com/agda/agda/issues/1710)\n\n[#1718](https://github.com/agda/agda/issues/1718)\n\nRelease
  notes for Agda version 2.4.2.4\n======================================\n\nInstallation
  and infrastructure\n-------------------------------\n\n* Removed support for GHC
  7.4.2.\n\nPragmas and options\n-------------------\n\n* Option `--copatterns` is
  now on by default.  To switch off\n  parsing of copatterns, use:\n\n  ```agda\n
  \ {-# OPTIONS --no-copatterns #-}\n  ```\n\n* Option `--rewriting` is now needed
  to use `REWRITE` pragmas and\n  rewriting during reduction.  Rewriting is not `--safe`.\n\n
  \ To use rewriting, first specify a relation symbol `R` that will\n  later be used
  to add rewrite rules.  A canonical candidate would be\n  propositional equality\n\n
  \ ```agda\n  {-# BUILTIN REWRITE _≡_ #-}\n  ```\n\n  but any symbol `R` of type
  `Δ → A → A → Set i` for some `A` and `i`\n  is accepted.  Then symbols `q` can be
  added to rewriting provided\n  their type is of the form `Γ → R ds l r`.  This will
  add a rewrite\n  rule\n\n  ```\n  Γ ⊢ l ↦ r : A[ds/Δ]\n  ```\n\n  to the signature,
  which fires whenever a term is an instance of `l`.\n  For example, if\n\n  ```agda\n
  \ plus0 : ∀ x → x + 0 ≡ x\n  ```\n\n  (ideally, there is a proof for `plus0`, but
  it could be a\n  postulate), then\n\n  ```agda\n  {-# REWRITE plus0 #-}\n  ```\n\n
  \ will prompt Agda to rewrite any well-typed term of the form `t + 0`\n  to `t`.\n\n
  \ Some caveats: Agda accepts and applies rewrite rules naively, it is\n  very easy
  to break consistency and termination of type checking.\n  Some examples of rewrite
  rules that should *not* be added:\n\n  ```agda\n  refl     : ∀ x → x ≡ x             --
  Agda loops\n  plus-sym : ∀ x y → x + y ≡ y + x   -- Agda loops\n  absurd   : true
  ≡ false            -- Breaks consistency\n  ```\n\n  Adding only proven equations
  should at least preserve consistency,\n  but this is only a conjecture, so know
  what you are doing!  Using\n  rewriting, you are entering into the wilderness, where
  you are on\n  your own!\n\nLanguage\n--------\n\n* `forall` / `∀` now parses like
  `λ`, i.e., the following parses now\n  [Issue [#1583](https://github.com/agda/agda/issues/1538)]:\n\n
  \ ```agda\n  ⊤ × ∀ (B : Set) → B → B\n  ```\n\n* The underscore pattern `_` can
  now also stand for an inaccessible\n  pattern (dot pattern). This alleviates the
  need for writing `._`.\n  [Issue #[1605](https://github.com/agda/agda/issues/1605)]
  Instead of\n\n  ```agda\n  transVOld : ∀{A : Set} (a b c : A) → a ≡ b → b ≡ c →
  a ≡ c\n  transVOld _ ._ ._ refl refl = refl\n  ```\n\n  one can now write\n\n  ```agda\n
  \   transVNew : ∀{A : Set} (a b c : A) → a ≡ b → b ≡ c → a ≡ c\n    transVNew _
  _ _ refl refl = refl\n  ```\n\n  and let Agda decide where to put the dots.  This
  was always possible\n  by using hidden arguments\n\n  ```agda\n  transH : ∀{A :
  Set}{a b c : A} → a ≡ b → b ≡ c → a ≡ c\n  transH refl refl = refl\n  ```\n\n  which
  is now equivalent to\n\n  ```agda\n  transHNew : ∀{A : Set}{a b c : A} → a ≡ b →
  b ≡ c → a ≡ c\n  transHNew {a = _}{b = _}{c = _} refl refl = refl\n  ```\n\n  Before,
  underscore `_` stood for an unnamed variable that could not\n  be instantiated by
  an inaccessible pattern.  If one no wants to\n  prevent Agda from instantiating,
  one needs to use a variable name\n  other than underscore (however, in practice
  this situation seems\n  unlikely).\n\nType checking\n-------------\n\n* Polarity
  of phantom arguments to data and record types has\n  changed. [Issue [#1596](https://github.com/agda/agda/issues/1596)]\n
  \ Polarity of size arguments is Nonvariant (both monotone and\n  antitone).  Polarity
  of other arguments is Covariant (monotone).\n  Both were Invariant before (neither
  monotone nor antitone).\n\n  The following example type-checks now:\n\n  ```agda\n
  \ open import Common.Size\n\n  -- List should be monotone in both arguments\n  --
  (even when `cons' is missing).\n\n  data List (i : Size) (A : Set) : Set where\n
  \   [] : List i A\n\n  castLL : ∀{i A} → List i (List i A) → List ∞ (List ∞ A)\n
  \ castLL x = x\n\n  -- Stream should be antitone in the first and monotone in the
  second argument\n  -- (even with field `tail' missing).\n\n  record Stream (i :
  Size) (A : Set) : Set where\n    coinductive\n    field\n      head : A\n\n  castSS
  : ∀{i A} → Stream ∞ (Stream ∞ A) → Stream i (Stream i A)\n  castSS x = x\n  ```\n\n*
  `SIZELT` lambdas must be consistent\n  [Issue [#1523](https://github.com/agda/agda/issues/1523),
  see Abel\n  and Pientka, ICFP 2013].  When lambda-abstracting over type (`Size<\n
  \ size`) then `size` must be non-zero, for any valid instantiation of\n  size variables.\n\n
  \ - The good:\n\n    ```agda\n    data Nat (i : Size) : Set where\n      zero :
  ∀ (j : Size< i) → Nat i\n      suc  : ∀ (j : Size< i) → Nat j → Nat i\n\n    {-#
  TERMINATING #-}\n    -- This definition is fine, the termination checker is too
  strict at the moment.\n    fix : ∀ {C : Size → Set}\n       → (∀ i → (∀ (j : Size<
  i) → Nat j -> C j) → Nat i → C i)\n       → ∀ i → Nat i → C i\n    fix t i (zero
  j)  = t i (λ (k : Size< i) → fix t k) (zero j)\n    fix t i (suc j n) = t i (λ (k
  : Size< i) → fix t k) (suc j n)\n    ```\n\n    The `λ (k : Size< i)` is fine in
  both cases, as context\n\n    ```agda\n    i : Size, j : Size< i\n    ```\n\n    guarantees
  that `i` is non-zero.\n\n  - The bad:\n\n    ```agda\n    record Stream {i : Size}
  (A : Set) : Set where\n      coinductive\n      constructor _∷ˢ_\n      field\n
  \       head  : A\n        tail  : ∀ {j : Size< i} → Stream {j} A\n    open Stream
  public\n\n    _++ˢ_ : ∀ {i A} → List A → Stream {i} A → Stream {i} A\n    []        ++ˢ
  s = s\n    (a ∷ as)  ++ˢ s = a ∷ˢ (as ++ˢ s)\n    ```\n\n    This fails, maybe unjustified,
  at\n\n    ```agda\n    i : Size, s : Stream {i} A\n      ⊢\n        a ∷ˢ (λ {j :
  Size< i} → as ++ˢ s)\n    ```\n\n    Fixed by defining the constructor by copattern
  matching:\n\n    ```agda\n    record Stream {i : Size} (A : Set) : Set where\n      coinductive\n
  \     field\n        head  : A\n        tail  : ∀ {j : Size< i} → Stream {j} A\n
  \   open Stream public\n\n    _∷ˢ_ : ∀ {i A} → A → Stream {i} A → Stream {↑ i} A\n
  \   head  (a ∷ˢ as) = a\n    tail  (a ∷ˢ as) = as\n\n    _++ˢ_ : ∀ {i A} → List
  A → Stream {i} A → Stream {i} A\n    []        ++ˢ s = s\n    (a ∷ as)  ++ˢ s =
  a ∷ˢ (as ++ˢ s)\n    ```\n\n  - The ugly:\n\n    ```agda\n    fix : ∀ {C : Size
  → Set}\n       → (∀ i → (∀ (j : Size< i) → C j) → C i)\n       → ∀ i → C i\n    fix
  t i = t i λ (j : Size< i) → fix t j\n    ```\n\n    For `i=0`, there is no such
  `j` at runtime, leading to looping\n    behavior.\n\nInteraction\n-----------\n\n*
  Issue [#635](https://github.com/agda/agda/issues/635) has been\n  fixed.  Case splitting
  does not spit out implicit record patterns\n  any more.\n\n  ```agda\n  record Cont
  : Set₁ where\n    constructor _◃_\n    field\n      Sh  : Set\n      Pos : Sh →
  Set\n\n  open Cont\n\n  data W (C : Cont) : Set where\n    sup : (s : Sh C) (k :
  Pos C s → W C) → W C\n\n  bogus : {C : Cont} → W C → Set\n  bogus w = {!w!}\n  ```\n\n
  \ Case splitting on `w` yielded, since the fix of\n  Issue [#473](https://github.com/agda/agda/issues/473),\n\n
  \ ```agda\n  bogus {Sh ◃ Pos} (sup s k) = ?\n  ```\n\n  Now it gives, as expected,\n\n
  \ ```agda\n  bogus (sup s k) = ?\n  ```\n\nPerformance\n-----------\n\n* As one
  result of the 21st Agda Implementor's Meeting (AIM XXI),\n  serialization of the
  standard library is 50% faster (time reduced by\n  a third), without using additional
  disk space for the interface\n  files.\n\n\nBug fixes\n---------\n\nIssues fixed
  (see [bug tracker](https://github.com/agda/agda/issues)):\n\n[#1546](https://github.com/agda/agda/issues/1546)
  (copattern matching\nand with-clauses)\n\n[#1560](https://github.com/agda/agda/issues/1560)
  (positivity checker\ninefficiency)\n\n[#1584](https://github.com/agda/agda/issues/1548)
  (let pattern with\ntrailing implicit)\n\nRelease notes for Agda version 2.4.2.3\n======================================\n\nInstallation
  and infrastructure\n-------------------------------\n\n* Added support for GHC 7.10.1.\n\n*
  Removed support for GHC 7.0.4.\n\nLanguage\n--------\n\n* `_ `is no longer a valid
  name for a definition.  The following fails\n  now: [Issue [#1465](https://github.com/agda/agda/issues/1465)]\n\n
  \ ```agda\n  postulate _ : Set\n  ```\n\n* Typed bindings can now contain hiding
  information\n  [Issue [#1391](https://github.com/agda/agda/issues/1391)].  This\n
  \ means you can now write\n\n  ```agda\n  assoc : (xs {ys zs} : List A) → ((xs ++
  ys) ++ zs) ≡ (xs ++ (ys ++ zs))\n  ```\n\n  instead of the longer\n\n  ```agda\n
  \ assoc : (xs : List A) {ys zs : List A} → ...\n  ```\n\n  It also works with irrelevance\n\n
  \ ```agda\n  .(xs {ys zs} : List A) → ...\n  ```\n\n  but of course does not make
  sense if there is hiding information already.\n  Thus, this is (still) a parse error:\n\n
  \ ```agda\n  {xs {ys zs} : List A} → ...\n  ```\n\n* The builtins for sized types
  no longer need accompanying postulates.\n  The BUILTIN pragmas for size stuff now
  also declare the identifiers\n  they bind to.\n\n  ```agda\n  {-# BUILTIN SIZEUNIV
  SizeUniv #-}  --  SizeUniv : SizeUniv\n  {-# BUILTIN SIZE     Size     #-}  --  Size
  \    : SizeUniv\n  {-# BUILTIN SIZELT   Size<_   #-}  --  Size<_   : ..Size → SizeUniv\n
  \ {-# BUILTIN SIZESUC  ↑_       #-}  --  ↑_       : Size → Size\n  {-# BUILTIN SIZEINF
  \ ∞        #-}  --  ∞       : Size\n  ```\n\n  `Size` and `Size<` now live in the
  new universe `SizeUniv`.  It is\n  forbidden to build function spaces in this universe,
  in order to\n  prevent the malicious assumption of a size predecessor\n\n  ```agda\n
  \ pred : (i : Size) → Size< i\n  ```\n\n  [Issue [#1428](https://github.com/agda/agda/issues/1428)].\n\n*
  Unambiguous notations (coming from syntax declarations) that resolve\n  to ambiguous
  names are now parsed unambiguously\n  [Issue [#1194](https://github.com/agda/agda/issues/1194)].\n\n*
  If only some instances of an overloaded name have a given associated\n  notation
  (coming from syntax declarations), then this name can only\n  be resolved to the
  given instances of the name, not to other\n  instances [Issue [#1194](https://github.com/agda/agda/issues/1194)].\n\n
  \ Previously, if different instances of an overloaded name had\n  *different* associated
  notations, then none of the notations could\n  be used. Now all of them can be used.\n\n
  \ Note that notation identity does not only involve the right-hand\n  side of the
  syntax declaration. For instance, the following\n  notations are not seen as identical,
  because the implicit argument\n  names are different:\n\n  ```agda\n  module A where\n\n
  \   data D : Set where\n      c : {x y : D} → D\n\n    syntax c {x = a} {y = b}
  = a ∙ b\n\n  module B where\n\n    data D : Set where\n      c : {y x : D} → D\n\n
  \   syntax c {y = a} {x = b} = a ∙ b\n  ```\n\n* If an overloaded operator is in
  scope with at least two distinct\n  fixities, then it gets the default fixity\n
  \ [Issue [#1436](https://github.com/agda/agda/issues/1436)].\n\n  Similarly, if
  two or more identical notations for a given overloaded\n  name are in scope, and
  these notations do not all have the\n  same fixity, then they get the default fixity.\n\nType
  checking\n-------------\n\n* Functions of varying arity can now have with-clauses
  and use rewrite.\n\n  Example:\n\n  ```agda\n  NPred : Nat → Set\n  NPred 0       =
  Bool\n  NPred (suc n) = Nat → NPred n\n\n  const : Bool → ∀{n} → NPred n\n  const
  b {0}       = b\n  const b {suc n} m = const b {n}\n\n  allOdd : ∀ n → NPred n\n
  \ allOdd 0 = true\n  allOdd (suc n) m with even m\n  ... | true  = const false\n
  \ ... | false = allOdd n\n  ```\n\n* Function defined by copattern matching can
  now have `with`-clauses\n  and use `rewrite`.\n\n  Example:\n\n  ```agda\n  {-#
  OPTIONS --copatterns #-}\n\n  record Stream (A : Set) : Set where\n    coinductive\n
  \   constructor delay\n    field\n      force : A × Stream A\n  open Stream\n\n
  \ map : ∀{A B} → (A → B) → Stream A → Stream B\n  force (map f s) with force s\n
  \ ... | a , as = f a , map f as\n\n  record Bisim {A B} (R : A → B → Set) (s : Stream
  A) (t : Stream B) : Set where\n    coinductive\n    constructor ~delay\n    field\n
  \     ~force : let a , as = force s\n                   b , bs = force t\n               in
  \ R a b × Bisim R as bs\n  open Bisim\n\n  SEq : ∀{A} (s t : Stream A) → Set\n  SEq
  = Bisim (_≡_)\n\n  -- Slightly weird definition of symmetry to demonstrate rewrite.\n\n
  \ ~sym' : ∀{A} {s t : Stream A} → SEq s t → SEq t s\n  ~force (~sym' {s = s} {t}
  p) with force s | force t | ~force p\n  ... | a , as | b , bs | r , q rewrite r
  = refl , ~sym' q\n  ```\n\n* Instances can now be defined by copattern\n  matching.
  [Issue [#1413](https://github.com/agda/agda/issues/1413)]\n  The following example
  extends the one in\n  [Abel, Pientka, Thibodeau, Setzer, POPL 2013, Section 2.2]:\n\n
  \ ```agda\n  {-# OPTIONS --copatterns #-}\n\n  -- The Monad type class\n\n  record
  Monad (M : Set → Set) : Set1 where\n    field\n      return : {A : Set}   → A →
  M A\n      _>>=_  : {A B : Set} → M A → (A → M B) → M B\n  open Monad {{...}}\n\n
  \ -- The State newtype\n\n  record State (S A : Set) : Set where\n    field\n      runState
  : S → A × S\n  open State\n\n  -- State is an instance of Monad\n\n  instance\n
  \   stateMonad : {S : Set} → Monad (State S)\n    runState (return {{stateMonad}}
  a  ) s  = a , s    -- NEW\n    runState (_>>=_  {{stateMonad}} m k) s₀ =          --
  NEW\n      let a , s₁ = runState m s₀\n      in  runState (k a) s₁\n\n  -- stateMonad
  fulfills the monad laws\n\n  leftId : {A B S : Set}(a : A)(k : A → State S B) →\n
  \   (return a >>= k) ≡ k a\n  leftId a k = refl\n\n  rightId : {A B S : Set}(m :
  State S A) →\n    (m >>= return) ≡ m\n  rightId m = refl\n\n  assoc : {A B C S :
  Set}(m : State S A)(k : A → State S B)(l : B → State S C) →\n     ((m >>= k) >>=
  l) ≡ (m >>= λ a → k a >>= l)\n  assoc m k l = refl\n  ```\n\nEmacs mode\n----------\n\n*
  The new menu option `Switch to another version of Agda` tries to do\n  what it says.\n\n*
  Changed feature: Interactively split result.\n\n  [ This is as before: ]\n  Make-case
  (`C-c C-c`) with no variables given tries to split on the\n  result to introduce
  projection patterns.  The hole needs to be of\n  record type, of course.\n\n  ```agda\n
  \ test : {A B : Set} (a : A) (b : B) → A × B\n  test a b = ?\n  ```\n\n  Result-splitting
  `?` will produce the new clauses:\n\n  ```agda\n  proj₁ (test a b) = ?\n  proj₂
  (test a b) = ?\n  ```\n\n  [ This has changed: ]\n  If hole is of function type,
  `make-case` will introduce only pattern\n  variables (as much as it can).\n\n  ```agda\n
  \ testFun : {A B : Set} (a : A) (b : B) → A × B\n  testFun = ?\n  ```\n\n  Result-splitting
  `?` will produce the new clause:\n\n  ```agda\n  testFun a b = ?\n  ```\n\n  A second
  invocation of `make-case` will then introduce projection\n  patterns.\n\nError messages\n--------------\n\n*
  Agda now suggests corrections of misspelled options, e.g.\n\n  ```agda\n  {-# OPTIONS\n
  \   --dont-termination-check\n    --without-k\n    --senf-gurke\n    #-}\n  ```\n\n
  \ Unrecognized options:\n\n  ```\n  --dont-termination-check (did you mean --no-termination-check
  ?)\n  --without-k (did you mean --without-K ?)\n  --senf-gurke\n  ```\n\n  Nothing
  close to `--senf-gurke`, I am afraid.\n\nCompiler backends\n-----------------\n\n*
  The Epic backend has been removed\n  [Issue [#1481](https://github.com/agda/agda/issues/1481)].\n\nBug
  fixes\n---------\n\n* Fixed bug with `unquoteDecl` not working in instance blocks\n
  \ [Issue [#1491](https://github.com/agda/agda/issues/1491)].\n\n* Other issues fixed
  (see\n  [bug tracker](https://github.com/agda/agda/issues)\n\n  [#1497](https://github.com/agda/agda/issues/1497)\n\n
  \ [#1500](https://github.com/agda/agda/issues/1500)\n\nRelease notes for Agda version
  2.4.2.2\n======================================\n\nBug fixes\n---------\n\n* Compilation
  on Windows fixed.\n\n* Other issues fixed (see\n  [bug tracker](https://github.com/agda/agda/issues))\n\n
  \ [#1332](https://github.com/agda/agda/issues/1322)\n\n  [#1353](https://github.com/agda/agda/issues/1353)\n\n
  \ [#1360](https://github.com/agda/agda/issues/1360)\n\n  [#1366](https://github.com/agda/agda/issues/1366)\n\n
  \ [#1369](https://github.com/agda/agda/issues/1369)\n\nRelease notes for Agda version
  2.4.2.1\n======================================\n\nPragmas and options\n-------------------\n\n*
  New pragma `{-# TERMINATING #-}` replacing\n  `{-# NO_TERMINATION_CHECK #-}`\n\n
  \ Complements the existing pragma `{-# NON_TERMINATING #-}`.  Skips\n  termination
  check for the associated definitions and marks them as\n  terminating.  Thus, it
  is a replacement for `{-#\n  NO_TERMINATION_CHECK #-}` with the same semantics.\n\n
  \ You can no longer use pragma `{-# NO_TERMINATION_CHECK #-}` to skip\n  the termination
  check, but must label your definitions as either\n  `{-# TERMINATING #-}` or `{-#
  NON_TERMINATING #-}` instead.\n\n  Note: `{-# OPTION --no-termination-check #-}`
  labels all your\n  definitions as `{-# TERMINATING #-}`, putting you in the danger
  zone\n  of a loop in the type checker.\n\nLanguage\n--------\n\n* Referring to a
  local variable shadowed by module opening is now an\n  error.  Previous behavior
  was preferring the local over the imported\n  definitions. [Issue [#1266](https://github.com/agda/agda/issues/1266)]\n\n
  \ Note that module parameters are locals as well as variables bound by\n  λ, dependent
  function type, patterns, and let.\n\n  Example:\n\n  ```agda\n  module M where\n
  \   A = Set1\n\n  test : (A : Set) → let open M in A\n  ```\n\n  The last `A` produces
  an error, since it could refer to the local\n  variable `A` or to the definition
  imported from module `M`.\n\n* `with` on a variable bound by a module telescope
  or a pattern of a\n  parent function is now forbidden.\n  [Issue [#1342](https://github.com/agda/agda/issues/1342)]\n\n
  \ ```agda\n  data Unit : Set where\n    unit : Unit\n\n  id : (A : Set) → A → A\n
  \ id A a = a\n\n  module M (x : Unit) where\n\n    dx : Unit → Unit\n    dx unit
  = x\n\n    g : ∀ u → x ≡ dx u\n    g with x\n    g | unit  = id (∀ u → unit ≡ dx
  u) ?\n  ```\n\n  Even though this code looks right, Agda complains about the type\n
  \ expression `∀ u → unit ≡ dx u`.  If you ask Agda what should go\n  there instead,
  it happily tells you that it wants `∀ u → unit ≡ dx\n  u`. In fact what you do not
  see and Agda will never show you is that\n  the two expressions actually differ
  in the invisible first argument\n  to `dx`, which is visible only outside module
  `M`.  What Agda wants\n  is an invisible `unit` after `dx`, but all you can write
  is an\n  invisible `x` (which is inserted behind the scenes).\n\n  To avoid those
  kinds of paradoxes, `with` is now outlawed on module\n  parameters.  This should
  ensure that the invisible arguments are\n  always exactly the module parameters.\n\n
  \ Since a `where` block is desugared as module with pattern variables\n  of the
  parent clause as module parameters, the same strikes you for\n  uses of `with` on
  pattern variables of the parent function.\n\n  ```agda\n  f : Unit → Unit\n  f x
  = unit\n    where\n      dx : Unit → Unit\n      dx unit = x\n\n      g : ∀ u →
  x ≡ dx u\n      g with x\n      g | unit  = id ((u : Unit) → unit ≡ dx u) ?\n  ```\n\n
  \ The `with` on pattern variable `x` of the parent clause `f x = unit`\n  is outlawed
  now.\n\nType checking\n-------------\n\n* Termination check failure is now a proper
  error.\n\n  We no longer continue type checking after termination check\n  failures.
  \ Use pragmas `{-# NON_TERMINATING #-}` and `{-#\n  NO_TERMINATION_CHECK #-}` near
  the offending definitions if you want\n  to do so.  Or switch off the termination
  checker altogether with\n  `{-# OPTIONS --no-termination-check #-}` (at your own
  risk!).\n\n* (Since Agda 2.4.2): Termination checking `--without-K` restricts\n
  \ structural descent to arguments ending in data types or `Size`.\n  Likewise, guardedness
  is only tracked when result type is data or\n  record type.\n\n  ```agda\n  mutual\n
  \   data WOne : Set where wrap : FOne → WOne\n    FOne = ⊥ → WOne\n\n  noo : (X
  : Set) → (WOne ≡ X) → X → ⊥\n  noo .WOne refl (wrap f) = noo FOne iso f\n  ```\n\n
  \ `noo` is rejected since at type `X` the structural descent\n  `f < wrap f` is
  discounted `--without-K`.\n\n  ```agda\n  data Pandora : Set where\n    C : ∞ ⊥
  → Pandora\n\n  loop : (A : Set) → A ≡ Pandora → A\n  loop .Pandora refl = C (♯ (loop
  ⊥ foo))\n  ```\n\n  `loop` is rejected since guardedness is not tracked at type
  `A`\n  `--without-K`.\n\n  See issues [#1023](https://github.com/agda/agda/issues/1023),\n
  \ [#1264](https://github.com/agda/agda/issues/1264),\n  [#1292](https://github.com/agda/agda/issues/1292).\n\nTermination
  checking\n--------------------\n\n* The termination checker can now recognize simple
  subterms in dot\n  patterns.\n\n  ```agda\n  data Subst : (d : Nat) → Set where\n
  \   c₁ : ∀ {d} → Subst d → Subst d\n    c₂ : ∀ {d₁ d₂} → Subst d₁ → Subst d₂ → Subst
  (suc d₁ + d₂)\n\n  postulate\n    comp : ∀ {d₁ d₂} → Subst d₁ → Subst d₂ → Subst
  (d₁ + d₂)\n\n  lookup : ∀ d → Nat → Subst d → Set₁\n  lookup d             zero
  \   (c₁ ρ)             = Set\n  lookup d             (suc v) (c₁ ρ)             =
  lookup d v ρ\n  lookup .(suc d₁ + d₂) v      (c₂ {d₁} {d₂} ρ σ) = lookup (d₁ + d₂)
  v (comp ρ σ)\n  ```\n\n  The dot pattern here is actually normalized, so it is\n\n
  \ ```agda\n  suc (d₁ + d₂)\n  ```\n\n  and the corresponding recursive call argument
  is `(d₁ + d₂)`.  In\n  such simple cases, Agda can now recognize that the pattern
  is\n  constructor applied to call argument, which is valid descent.\n\n  Note however,
  that Agda only looks for syntactic equality when\n  identifying subterms, since
  it is not allowed to normalize terms on\n  the rhs during termination checking.\n\n
  \ Actually writing the dot pattern has no effect, this works as well,\n  and looks
  pretty magical... ;-)\n\n  ```agda\n  hidden : ∀{d} → Nat → Subst d → Set₁\n  hidden
  zero    (c₁ ρ)   = Set\n  hidden (suc v) (c₁ ρ)   = hidden v ρ\n  hidden v       (c₂
  ρ σ) = hidden v (comp ρ σ)\n  ```\n\nTools\n-----\n\n### LaTeX-backend\n\n* Fixed
  the issue of identifiers containing operators being typeset with\n  excessive math
  spacing.\n\nBug fixes\n---------\n\n* Issue [#1194](https://github.com/agda/agda/issues/1194)\n\n*
  Issue [#836](https://github.com/agda/agda/issues/836): Fields and\n  constructors
  can be qualified by the record/data *type* as well as\n  by their record/data module.
  \ This now works also for record/data\n  type imported from parametrized modules:\n\n
  \ ```agda\n  module M (_ : Set₁) where\n\n    record R : Set₁ where\n      field\n
  \       X : Set\n\n  open M Set using (R)  -- rather than using (module R)\n\n  X
  : R → Set\n  X = R.X\n  ```\n\nRelease notes for Agda version 2.4.2\n====================================\n\nPragmas
  and options\n-------------------\n\n* New option: `--with-K`\n\n  This can be used
  to override a global `--without-K` in a file, by\n  adding a pragma `{-# OPTIONS
  --with-K #-}`.\n\n* New pragma `{-# NON_TERMINATING #-}`\n\n  This is a safer version
  of `NO_TERMINATION_CHECK` which doesn't\n  treat the affected functions as terminating.
  This means that\n  `NON_TERMINATING` functions do not reduce during type checking.
  They\n  do reduce at run-time and when invoking `C-c C-n` at top-level (but\n  not
  in a hole).\n\nLanguage\n--------\n\n* Instance search is now more efficient and
  recursive (see\n  Issue [#938](https://github.com/agda/agda/issues/938)) (but without\n
  \ termination check yet).\n\n  A new keyword `instance` has been introduced (in
  the style of\n  `abstract` and `private`) which must now be used for every\n  definition/postulate
  that has to be taken into account during\n  instance resolution. For example:\n\n
  \ ```agda\n  record RawMonoid (A : Set) : Set where\n    field\n      nil  : A\n
  \     _++_ : A -> A -> A\n\n  open RawMonoid {{...}}\n\n  instance\n    rawMonoidList
  : {A : Set} -> RawMonoid (List A)\n    rawMonoidList = record { nil = []; _++_ =
  List._++_ }\n\n    rawMonoidMaybe : {A : Set} {{m : RawMonoid A}} -> RawMonoid (Maybe
  A)\n    rawMonoidMaybe {A} = record { nil = nothing ; _++_ = catMaybe }\n      where\n
  \       catMaybe : Maybe A -> Maybe A -> Maybe A\n        catMaybe nothing mb =
  mb\n        catMaybe ma nothing = ma\n        catMaybe (just a) (just b) = just
  (a ++ b)\n  ```\n\n  Moreover, each type of an instance must end in (something that
  reduces\n  to) a named type (e.g. a record, a datatype or a postulate). This\n  allows
  us to build a simple index structure\n\n  ```\n  data/record name  -->  possible
  instances\n  ```\n\n  that speeds up instance search.\n\n  Instance search takes
  into account all local bindings and all global\n  `instance` bindings and the search
  is recursive. For instance,\n  searching for\n\n  ```agda\n  ? : RawMonoid (Maybe
  (List A))\n  ```\n\n  will consider the candidates {`rawMonoidList`, `rawMonoidMaybe`},
  fail to\n  unify the first one, succeeding with the second one\n\n  ```agda\n  ?
  = rawMonoidMaybe {A = List A} {{m = ?m}} : RawMonoid (Maybe (List A))\n  ```\n\n
  \ and continue with goal\n\n  ```agda\n  ?m : RawMonoid (List A)\n  ```\n\n  This
  will then find\n\n  ```agda\n  ?m = rawMonoidList {A = A}\n  ```\n\n  and putting
  together we have the solution.\n\n  Be careful that there is no termination check
  for now, you can\n  easily make Agda loop by declaring the identity function as
  an\n  instance. But it shouldn’t be possible to make Agda loop by only\n  declaring
  structurally recursive instances (whatever that means).\n\n  Additionally:\n\n  -
  Uniqueness of instances is up to definitional equality (see\n    Issue [#899](https://github.com/agda/agda/issues/899)).\n\n
  \ - Instances of the following form are allowed:\n\n    ```agda\n    EqSigma : {A
  : Set} {B : A → Set} {{EqA : Eq A}}\n              {{EqB : {a : A} → Eq (B a)}}\n
  \             → Eq (Σ A B)\n    ```\n\n    When searching recursively for an instance
  of type `{a : A} → Eq\n    (B a)`, a lambda will automatically be introduced and
  instance\n    search will search for something of type `Eq (B a)` in the context\n
  \   extended by `a : A`. When searching for an instance, the `a`\n    argument does
  not have to be implicit, but in the definition of\n    `EqSigma`, instance search
  will only be able to use `EqB` if `a`\n    is implicit.\n\n  - There is no longer
  any attempt to solve irrelevant metas by instance\n    search.\n\n  - Constructors
  of records and datatypes are automatically added to the\n    instance table.\n\n*
  You can now use `quote` in patterns.\n\n  For instance, here is a function that
  unquotes a (closed) natural\n  number term.\n\n  ```agda\n  unquoteNat : Term →
  Maybe Nat\n  unquoteNat (con (quote Nat.zero) [])            = just zero\n  unquoteNat
  (con (quote Nat.suc) (arg _ n ∷ [])) = fmap suc (unquoteNat n)\n  unquoteNat _                                    =
  nothing\n  ```\n\n* The builtin constructors `AGDATERMUNSUPPORTED` and\n  `AGDASORTUNSUPPORTED`
  are now translated to meta variables when\n  unquoting.\n\n* New syntactic sugar
  `tactic e` and `tactic e | e1 | .. | en`.\n\n  It desugars as follows and makes
  it less unwieldy to call\n  reflection-based tactics.\n\n  ```agda\n  tactic e                -->
  quoteGoal g in unquote (e g)\n  tactic e | e1 | .. | en --> quoteGoal g in unquote
  (e g) e1 .. en\n  ```\n\n  Note that in the second form the tactic function should
  generate a\n  function from a number of new subgoals to the original goal. The\n
  \ type of `e` should be `Term -> Term` in both cases.\n\n* New reflection builtins
  for literals.\n\n  The term data type `AGDATERM` now needs an additional constructor\n
  \  `AGDATERMLIT` taking a reflected literal defined as follows (with\n   appropriate
  builtin bindings for the types `Nat`, `Float`, etc).\n\n  ```agda\n  data Literal
  : Set where\n    nat    : Nat    → Literal\n    float  : Float  → Literal\n    char
  \  : Char   → Literal\n    string : String → Literal\n    qname  : QName  → Literal\n\n
  \ {-# BUILTIN AGDALITERAL   Literal #-}\n  {-# BUILTIN AGDALITNAT    nat     #-}\n
  \ {-# BUILTIN AGDALITFLOAT  float   #-}\n  {-# BUILTIN AGDALITCHAR   char    #-}\n
  \ {-# BUILTIN AGDALITSTRING string  #-}\n  {-# BUILTIN AGDALITQNAME  qname   #-}\n
  \ ```\n\n  When quoting (`quoteGoal` or `quoteTerm`) literals will be mapped to\n
  \ the `AGDATERMLIT` constructor. Previously natural number literals\n  were quoted
  to `suc`/`zero` application and other literals were\n  quoted to `AGDATERMUNSUPPORTED`.\n\n*
  New reflection builtins for function definitions.\n\n  `AGDAFUNDEF` should now map
  to a data type defined as follows\n\n  (with\n  ```agda\n  {-# BUILTIN QNAME       QName
  \  #-}\n  {-# BUILTIN ARG         Arg     #-}\n  {-# BUILTIN AGDATERM    Term    #-}\n
  \ {-# BUILTIN AGDATYPE    Type    #-}\n  {-# BUILTIN AGDALITERAL Literal #-}\n  ```\n
  \ ).\n\n  ```agda\n  data Pattern : Set where\n    con    : QName → List (Arg Pattern)
  → Pattern\n    dot    : Pattern\n    var    : Pattern\n    lit    : Literal → Pattern\n
  \   proj   : QName → Pattern\n    absurd : Pattern\n\n  {-# BUILTIN AGDAPATTERN
  \  Pattern #-}\n  {-# BUILTIN AGDAPATCON    con     #-}\n  {-# BUILTIN AGDAPATDOT
  \   dot     #-}\n  {-# BUILTIN AGDAPATVAR    var     #-}\n  {-# BUILTIN AGDAPATLIT
  \   lit     #-}\n  {-# BUILTIN AGDAPATPROJ   proj    #-}\n  {-# BUILTIN AGDAPATABSURD
  absurd  #-}\n\n  data Clause : Set where\n    clause        : List (Arg Pattern)
  → Term → Clause\n    absurd-clause : List (Arg Pattern) → Clause\n\n  {-# BUILTIN
  AGDACLAUSE       Clause        #-}\n  {-# BUILTIN AGDACLAUSECLAUSE clause        #-}\n
  \ {-# BUILTIN AGDACLAUSEABSURD absurd-clause #-}\n\n  data FunDef : Set where\n
  \   fun-def : Type → List Clause → FunDef\n\n  {-# BUILTIN AGDAFUNDEF    FunDef
  \ #-}\n  {-# BUILTIN AGDAFUNDEFCON fun-def #-}\n  ```\n\n* New reflection builtins
  for extended (pattern-matching) lambda.\n\n  The `AGDATERM` data type has been augmented
  with a constructor\n\n  ```agda\n  AGDATERMEXTLAM : List AGDACLAUSE → List (ARG
  AGDATERM) → AGDATERM\n  ```\n\n  Absurd lambdas (`λ ()`) are quoted to extended
  lambdas with an\n  absurd clause.\n\n* Unquoting declarations.\n\n  You can now
  define (recursive) functions by reflection using the new\n  `unquoteDecl` declaration\n\n
  \ ```agda\n  unquoteDecl x = e\n  ```\n\n  Here e should have type `AGDAFUNDEF`
  and evaluate to a closed\n  value. This value is then spliced in as the definition
  of `x`. In\n  the body `e`, `x` has type `QNAME` which lets you splice in\n  recursive
  definitions.\n\n  Standard modifiers, such as fixity declarations, can be applied
  to `x` as\n  expected.\n\n* Quoted levels\n\n  Universe levels are now quoted properly
  instead of being quoted to\n  `AGDASORTUNSUPPORTED`. `Setω` still gets an unsupported
  sort,\n  however.\n\n* Module applicants can now be operator applications.\n\n  Example:\n\n
  \ ```agda\n  postulate\n    [_] : A -> B\n\n  module M (b : B) where\n\n  module
  N (a : A) = M [ a ]\n  ```\n\n  [See Issue [#1245](https://github.com/agda/agda/issues/1245)]\n\n*
  Minor change in module application\n  semantics. [Issue [#892](https://github.com/agda/agda/issues/892)]\n\n
  \ Previously re-exported functions were not redefined when\n  instantiating a module.
  For instance\n\n  ```agda\n  module A where f = ...\n  module B (X : Set) where\n
  \   open A public\n  module C = B Nat\n  ```\n\n  In this example `C.f` would be
  an alias for `A.f`, so if both `A`\n  and `C` were opened `f` would not be ambiguous.
  However, this\n  behaviour is not correct when `A` and `B` share some module\n  parameters\n
  \ (Issue [#892](https://github.com/agda/agda/issues/892)). To fix this\n  `C` now
  defines its own copy of `f` (which evaluates to `A.f`),\n  which means that opening
  `A` and `C` results in an ambiguous `f`.\n\nType checking\n-------------\n\n* Recursive
  records need to be declared as either `inductive` or\n  `coinductive`.  `inductive`
  is no longer default for recursive\n  records. Examples:\n\n  ```agda\n  record
  _×_ (A B : Set) : Set where\n    constructor _,_\n    field\n      fst : A\n      snd
  : B\n\n  record Tree (A : Set) : Set where\n    inductive\n    constructor tree\n
  \   field\n      elem     : A\n      subtrees : List (Tree A)\n\n  record Stream
  (A : Set) : Set where\n    coinductive\n    constructor _::_\n    field\n      head
  : A\n      tail : Stream A\n  ```\n\n  If you are using old-style (musical) coinduction,
  a record may have\n  to be declared as inductive, paradoxically.\n\n  ```agda\n
  \ record Stream (A : Set) : Set where\n    inductive -- YES, THIS IS INTENDED !\n
  \   constructor _∷_\n    field\n      head : A\n      tail : ∞ (Stream A)\n  ```\n\n
  \ This is because the \"coinduction\" happens in the use of `∞` and not\n  in the
  use of `record`.\n\nTools\n-----\n\n### Emacs mode\n\n* A new menu option `Display`
  can be used to display the version of\n  the running Agda process.\n\n### LaTeX-backend\n\n*
  New experimental option `references` has been added. When specified,\n  i.e.:\n\n
  \ ```latex\n  \\usepackage[references]{agda}\n  ```\n\n  a new command called `\\AgdaRef`
  is provided, which lets you\n  reference previously typeset commands, e.g.:\n\n
  \ Let us postulate `\\AgdaRef{apa}`.\n\n  ```agda\n  \\begin{code}\n  postulate\n
  \   apa : Set\n  \\end{code}\n  ```\n\n  Above `apa` will be typeset (highlighted)
  the same in the text as in\n  the code, provided that the LaTeX output is post-processed
  using\n  `src/data/postprocess-latex.pl`, e.g.:\n\n  ```\n  cp $(dirname $(dirname
  $(agda-mode locate)))/postprocess-latex.pl .\n  agda -i. --latex Example.lagda\n
  \ cd latex/\n  perl ../postprocess-latex.pl Example.tex > Example.processed\n  mv
  Example.processed Example.tex\n  xelatex Example.tex\n  ```\n\n  Mix-fix and Unicode
  should work as expected (Unicode requires\n  XeLaTeX/LuaLaTeX), but there are limitations:\n\n
  \ - Overloading identifiers should be avoided, if multiples exist\n    `\\AgdaRef`
  will typeset according to the first it finds.\n\n  - Only the current module is
  used, should you need to reference\n    identifiers in other modules then you need
  to specify which other\n    module manually, i.e. `\\AgdaRef[module]{identifier}`.\n\nRelease
  notes for Agda 2 version 2.4.0.2\n========================================\n\n*
  The Agda input mode now supports alphabetical super and subscripts,\n  in addition
  to the numerical ones that were already present.\n  [Issue [#1240](https://github.com/agda/agda/issues/1240)]\n\n*
  New feature: Interactively split result.\n\n  Make case (`C-c C-c`) with no variables
  given tries to split on the\n  result to introduce projection patterns.  The hole
  needs to be of\n  record type, of course.\n\n  ```agda\n  test : {A B : Set} (a
  : A) (b : B) → A × B\n  test a b = ?\n  ```\n\n  Result-splitting `?` will produce
  the new clauses:\n\n  ```agda\n  proj₁ (test a b) = ?\n  proj₂ (test a b) = ?\n
  \ ```\n\n  If hole is of function type ending in a record type, the necessary\n
  \ pattern variables will be introduced before the split.  Thus, the\n  same result
  can be obtained by starting from:\n\n  ```agda\n  test : {A B : Set} (a : A) (b
  : B) → A × B\n  test = ?\n  ```\n\n* The so far undocumented `ETA` pragma now throws
  an error if applied to\n  definitions that are not records.\n\n  `ETA` can be used
  to force eta-equality at recursive record types,\n  for which eta is not enabled
  automatically by Agda.  Here is such an\n  example:\n\n  ```agda\n  mutual\n    data
  Colist (A : Set) : Set where\n      [] : Colist A\n      _∷_ : A → ∞Colist A → Colist
  A\n\n    record ∞Colist (A : Set) : Set where\n      coinductive\n      constructor
  delay\n      field       force : Colist A\n\n  open ∞Colist\n\n  {-# ETA ∞Colist
  #-}\n\n  test : {A : Set} (x : ∞Colist A) → x ≡ delay (force x)\n  test x = refl\n
  \ ```\n\n  Note: Unsafe use of `ETA` can make Agda loop, e.g. by triggering\n  infinite
  eta expansion!\n\n* Bugs fixed (see [bug tracker](https://github.com/agda/agda/issues)):\n\n
  \ [#1203](https://github.com/agda/agda/issues/1203)\n\n  [#1205](https://github.com/agda/agda/issues/1205)\n\n
  \ [#1209](https://github.com/agda/agda/issues/1209)\n\n  [#1213](https://github.com/agda/agda/issues/1213)\n\n
  \ [#1214](https://github.com/agda/agda/issues/1214)\n\n  [#1216](https://github.com/agda/agda/issues/1216)\n\n
  \ [#1225](https://github.com/agda/agda/issues/1225)\n\n  [#1226](https://github.com/agda/agda/issues/1226)\n\n
  \ [#1231](https://github.com/agda/agda/issues/1231)\n\n  [#1233](https://github.com/agda/agda/issues/1233)\n\n
  \ [#1239](https://github.com/agda/agda/issues/1239)\n\n  [#1241](https://github.com/agda/agda/issues/1241)\n\n
  \ [#1243](https://github.com/agda/agda/issues/1243)\n\nRelease notes for Agda 2
  version 2.4.0.1\n========================================\n\n* The option `--compile-no-main`
  has been renamed to `--no-main`.\n\n* `COMPILED_DATA` pragmas can now be given for
  records.\n\n* Various bug fixes.\n\nRelease notes for Agda 2 version 2.4.0\n======================================\n\nInstallation
  and infrastructure\n-------------------------------\n\n* A new module called `Agda.Primitive`
  has been introduced. This\n  module is available to all users, even if the standard
  library is\n  not used.  Currently the module contains level primitives and their\n
  \ representation in Haskell when compiling with MAlonzo:\n\n  ```agda\n  infixl
  6 _⊔_\n\n  postulate\n    Level : Set\n    lzero : Level\n    lsuc  : (ℓ : Level)
  → Level\n    _⊔_   : (ℓ₁ ℓ₂ : Level) → Level\n\n  {-# COMPILED_TYPE Level ()      #-}\n
  \ {-# COMPILED lzero ()           #-}\n  {-# COMPILED lsuc  (\\_ -> ())   #-}\n
  \ {-# COMPILED _⊔_   (\\_ _ -> ()) #-}\n\n  {-# BUILTIN LEVEL     Level  #-}\n  {-#
  BUILTIN LEVELZERO lzero  #-}\n  {-# BUILTIN LEVELSUC  lsuc   #-}\n  {-# BUILTIN
  LEVELMAX  _⊔_    #-}\n  ```\n\n  To bring these declarations into scope you can
  use a declaration\n  like the following one:\n\n  ```agda\n  open import Agda.Primitive
  using (Level; lzero; lsuc; _⊔_)\n  ```\n\n  The standard library reexports these
  primitives (using the names\n  `zero` and `suc` instead of `lzero` and `lsuc`) from
  the `Level`\n  module.\n\n  Existing developments using universe polymorphism might
  now trigger\n  the following error message:\n\n  ```\n  Duplicate binding for built-in
  thing LEVEL, previous binding to\n    .Agda.Primitive.Level\n  ```\n\n  To fix this
  problem, please remove the duplicate bindings.\n\n  Technical details (perhaps relevant
  to those who build Agda\n  packages):\n\n  The include path now always contains
  a directory\n  `<DATADIR>/lib/prim`, and this directory is supposed to contain a\n
  \ subdirectory Agda containing a file `Primitive.agda`.\n\n  The standard location
  of `<DATADIR>` is system- and\n  installation-specific.  E.g., in a Cabal `--user`
  installation of\n  Agda-2.3.4 on a standard single-ghc Linux system it would be\n
  \ `$HOME/.cabal/share/Agda-2.3.4` or something similar.\n\n  The location of the
  `<DATADIR>` directory can be configured at\n  compile-time using Cabal flags (`--datadir`
  and `--datasubdir`).\n  The location can also be set at run-time, using the `Agda_datadir`\n
  \ environment variable.\n\nPragmas and options\n-------------------\n\n* Pragma
  `NO_TERMINATION_CHECK` placed within a mutual block is now\n  applied to the whole
  mutual block (rather than being discarded\n  silently).  Adding to the uses 1.-4.
  outlined in the release notes\n  for 2.3.2 we allow:\n\n  3a. Skipping an old-style
  mutual block: Somewhere within `mutual`\n      block before a type signature or
  first function clause.\n\n   ```agda\n   mutual\n     {-# NO_TERMINATION_CHECK #-}\n
  \    c : A\n     c = d\n\n     d : A\n     d = c\n   ```\n\n* New option `--no-pattern-matching`\n\n
  \ Disables all forms of pattern matching (for the current file).\n  You can still
  import files that use pattern matching.\n\n* New option `-v profile:7`\n\n  Prints
  some stats on which phases Agda spends how much time.\n  (Number might not be very
  reliable, due to garbage collection\n  interruptions, and maybe due to laziness
  of Haskell.)\n\n* New option `--no-sized-types`\n\n  Option `--sized-types` is now
  default.  `--no-sized-types` will turn\n  off an extra (inexpensive) analysis on
  data types used for subtyping\n  of sized types.\n\nLanguage\n--------\n\n* Experimental
  feature: `quoteContext`\n\n  There is a new keyword `quoteContext` that gives users
  access to the\n  list of names in the current local context. For instance:\n\n  ```agda\n
  \ open import Data.Nat\n  open import Data.List\n  open import Reflection\n\n  foo
  : ℕ → ℕ → ℕ\n  foo 0 m = 0\n  foo (suc n) m = quoteContext xs in ?\n  ```\n\n  In
  the remaining goal, the list `xs` will consist of two names, `n`\n  and `m`, corresponding
  to the two local variables. At the moment it\n  is not possible to access let bound
  variables (this feature may be\n  added in the future).\n\n* Experimental feature:
  Varying arity.\n  Function clauses may now have different arity, e.g.,\n\n  ```agda\n
  \ Sum : ℕ → Set\n  Sum 0       = ℕ\n  Sum (suc n) = ℕ → Sum n\n\n  sum : (n : ℕ)
  → ℕ → Sum n\n  sum 0       acc   = acc\n  sum (suc n) acc m = sum n (m + acc)\n
  \ ```\n\n  or,\n\n  ```agda\n  T : Bool → Set\n  T true  = Bool\n  T false = Bool
  → Bool\n\n  f : (b : Bool) → T b\n  f false true  = false\n  f false false = true\n
  \ f true = true\n  ```\n\n  This feature is experimental.  Yet unsupported:\n  -
  Varying arity and `with`.\n\n  - Compilation of functions with varying arity to
  Haskell, JS, or Epic.\n\n* Experimental feature: copatterns.  (Activated with option
  `--copatterns`)\n\n  We can now define a record by explaining what happens if you
  project\n  the record.  For instance:\n\n  ```agda\n  {-# OPTIONS --copatterns #-}\n\n
  \ record _×_ (A B : Set) : Set where\n    constructor _,_\n    field\n      fst
  : A\n      snd : B\n  open _×_\n\n  pair : {A B : Set} → A → B → A × B\n  fst (pair
  a b) = a\n  snd (pair a b) = b\n\n  swap : {A B : Set} → A × B → B × A\n  fst (swap
  p) = snd p\n  snd (swap p) = fst p\n\n  swap3 : {A B C : Set} → A × (B × C) → C
  × (B × A)\n  fst (swap3 t)       = snd (snd t)\n  fst (snd (swap3 t)) = fst (snd
  t)\n  snd (snd (swap3 t)) = fst t\n  ```\n\n  Taking a projection on the left hand
  side (lhs) is called a\n  projection pattern, applying to a pattern is called an
  application\n  pattern.  (Alternative terms: projection/application copattern.)\n\n
  \ In the first example, the symbol `pair`, if applied to variable\n  patterns `a`
  and `b` and then projected via `fst`, reduces to\n  `a`. `pair` by itself does not
  reduce.\n\n  A typical application are coinductive records such as streams:\n\n
  \ ```agda\n  record Stream (A : Set) : Set where\n    coinductive\n    field\n      head
  : A\n      tail : Stream A\n  open Stream\n\n  repeat : {A : Set} (a : A) -> Stream
  A\n  head (repeat a) = a\n  tail (repeat a) = repeat a\n  ```\n\n  Again, `repeat
  a` by itself will not reduce, but you can take a\n  projection (head or tail) and
  then it will reduce to the respective\n  rhs.  This way, we get the lazy reduction
  behavior necessary to\n  avoid looping corecursive programs.\n\n  Application patterns
  do not need to be trivial (i.e., variable\n  patterns), if we mix with projection
  patterns.  E.g., we can have\n\n  ```agda\n  nats : Nat -> Stream Nat\n  head (nats
  zero) = zero\n  tail (nats zero) = nats zero\n  head (nats (suc x)) = x\n  tail
  (nats (suc x)) = nats x\n  ```\n\n  Here is an example (not involving coinduction)
  which demostrates\n  records with fields of function type:\n\n  ```agda\n  -- The
  State monad\n\n  record State (S A : Set) : Set where\n    constructor state\n    field\n
  \     runState : S → A × S\n  open State\n\n  -- The Monad type class\n\n  record
  Monad (M : Set → Set) : Set1 where\n    constructor monad\n    field\n      return
  : {A : Set}   → A → M A\n      _>>=_  : {A B : Set} → M A → (A → M B) → M B\n\n\n
  \ -- State is an instance of Monad\n  -- Demonstrates the interleaving of projection
  and application patterns\n\n  stateMonad : {S : Set} → Monad (State S)\n  runState
  (Monad.return stateMonad a  ) s  = a , s\n  runState (Monad._>>=_  stateMonad m
  k) s₀ =\n    let a , s₁ = runState m s₀\n    in  runState (k a) s₁\n\n  module MonadLawsForState
  {S : Set} where\n\n    open Monad (stateMonad {S})\n\n    leftId : {A B : Set}(a
  : A)(k : A → State S B) →\n      (return a >>= k) ≡ k a\n    leftId a k = refl\n\n
  \   rightId : {A B : Set}(m : State S A) →\n      (m >>= return) ≡ m\n    rightId
  m = refl\n\n    assoc : {A B C : Set}(m : State S A)(k : A → State S B)(l : B →
  State S C) →\n      ((m >>= k) >>= l) ≡ (m >>= λ a → (k a >>= l))\n    assoc m k
  l = refl\n  ```\n\n  Copatterns are yet experimental and the following does not
  work:\n\n  - Copatterns and `with` clauses.\n\n  - Compilation of copatterns to
  Haskell, JS, or Epic.\n\n  - Projections generated by\n\n    ```agda\n    open R
  {{...}}\n    ```\n\n    are not handled properly on lhss yet.\n\n  - Conversion
  checking is slower in the presence of copatterns, since\n    stuck definitions of
  record type do no longer count as neutral,\n    since they can become unstuck by
  applying a projection. Thus,\n    comparing two neutrals currently requires comparing
  all they\n    projections, which repeats a lot of work.\n\n* Top-level module no
  longer required.\n\n  The top-level module can be omitted from an Agda file. The
  module\n  name is then inferred from the file name by dropping the path and\n  the
  `.agda` extension. So, a module defined in `/A/B/C.agda` would get\n  the name `C`.\n\n
  \ You can also suppress only the module name of the top-level module\n  by writing\n\n
  \ ```agda\n  module _ where\n  ```\n\n  This works also for parameterised modules.\n\n*
  Module parameters are now always hidden arguments in projections.\n  For instance:\n\n
  \ ```agda\n  module M (A : Set) where\n\n    record Prod (B : Set) : Set where\n
  \     constructor _,_\n      field\n        fst : A\n        snd : B\n    open Prod
  public\n\n  open M\n  ```\n\n  Now, the types of `fst` and `snd` are\n\n  ```agda\n
  \ fst : {A : Set}{B : Set} → Prod A B → A\n  snd : {A : Set}{B : Set} → Prod A B
  → B\n  ```\n\n  Until 2.3.2, they were\n\n  ```agda\n  fst : (A : Set){B : Set}
  → Prod A B → A\n  snd : (A : Set){B : Set} → Prod A B → B\n  ```\n\n  This change
  is a step towards symmetry of constructors and projections.\n  (Constructors always
  took the module parameters as hidden arguments).\n\n* Telescoping lets: Local bindings
  are now accepted in telescopes\n  of modules, function types, and lambda-abstractions.\n\n
  \ The syntax of telescopes as been extended to support `let`:\n\n  ```agda\n  id
  : (let ★ = Set) (A : ★) → A → A\n  id A x = x\n  ```\n\n  In particular one can
  now `open` modules inside telescopes:\n\n  ```agda\n  module Star where\n    ★ :
  Set₁\n    ★ = Set\n\n\n  module MEndo (let open Star) (A : ★) where\n    Endo :
  ★\n    Endo = A → A\n  ```\n\n  Finally a shortcut is provided for opening modules:\n\n
  \ ```agda\n  module N (open Star) (A : ★) (open MEndo A) (f : Endo) where\n    ...\n
  \ ```\n\n  The semantics of the latter is\n\n  ```agda\n  module _ where\n    open
  Star\n    module _ (A : ★) where\n      open MEndo A\n      module N (f : Endo)
  where\n        ...\n  ```\n\n  The semantics of telescoping lets in function types
  and lambda\n  abstractions is just expanding them into ordinary lets.\n\n* More
  liberal left-hand sides in lets\n  [Issue [#1028](https://github.com/agda/agda/issues/1028)]:\n\n
  \ You can now write left-hand sides with arguments also for let\n  bindings without
  a type signature. For instance,\n\n  ```agda\n  let f x = suc x in f zero\n  ```\n\n
  \ Let bound functions still can't do pattern matching though.\n\n* Ambiguous names
  in patterns are now optimistically resolved in favor\n  of constructors. [Issue
  [#822](https://github.com/agda/agda/issues/822)]\n  In particular, the following
  succeeds now:\n\n  ```agda\n  module M where\n\n    data D : Set₁ where\n      [_]
  : Set → D\n\n  postulate [_] : Set → Set\n\n  open M\n\n  Foo : _ → Set\n  Foo [
  A ] = A\n  ```\n\n* Anonymous `where`-modules are opened\n  public. [Issue [#848](https://github.com/agda/agda/issues/848)]\n\n
  \ ```\n  <clauses>\n  f args = rhs\n    module _ telescope where\n      body\n  <more
  clauses>\n  ```\n\n  means the following (not proper Agda code, since you cannot
  put a\n  module in-between clauses)\n\n  ```\n  <clauses>\n  module _ {arg-telescope}
  telescope where\n    body\n\n  f args = rhs\n  <more clauses>\n  ```\n\n  Example:\n\n
  \ ```agda\n  A : Set1\n  A = B module _ where\n    B : Set1\n    B = Set\n\n  C
  : Set1\n  C = B\n  ```\n\n* Builtin `ZERO` and `SUC` have been merged with `NATURAL`.\n\n
  \ When binding the `NATURAL` builtin, `ZERO` and `SUC` are bound to\n  the appropriate
  constructors automatically. This means that instead\n  of writing\n\n  ```agda\n
  \ {-# BUILTIN NATURAL Nat #-}\n  {-# BUILTIN ZERO zero #-}\n  {-# BUILTIN SUC suc
  #-}\n  ```\n\n  you just write\n\n  ```agda\n  {-# BUILTIN NATURAL Nat #-}\n  ```\n\n*
  Pattern synonym can now have implicit\n  arguments. [Issue [#860](https://github.com/agda/agda/issues/860)]\n\n
  \ For example,\n\n  ```agda\n  pattern tail=_ {x} xs = x ∷ xs\n\n  len : ∀ {A} →
  List A → Nat\n  len []         = 0\n  len (tail= xs) = 1 + len xs\n  ```\n\n* Syntax
  declarations can now have implicit\n  arguments. [Issue [#400](https://github.com/agda/agda/issues/400)]\n\n
  \ For example\n\n  ```agda\n  id : ∀ {a}{A : Set a} -> A -> A\n  id x = x\n\n  syntax
  id {A} x = x ∈ A\n  ```\n\n* Minor syntax changes\n\n  - `-}` is now parsed as end-comment
  even if no comment was begun. As\n    a consequence, the following definition gives
  a parse error\n\n    ```agda\n    f : {A- : Set} -> Set\n    f {A-} = A-\n    ```\n\n
  \   because Agda now sees `ID(f) LBRACE ID(A) END-COMMENT`, and no\n    longer `ID(f)
  LBRACE ID(A-) RBRACE`.\n\n    The rational is that the previous lexing was to context-sensitive,\n
  \   attempting to comment-out `f` using `{-` and `-}` lead to a parse\n    error.\n\n
  \ - Fixities (binding strengths) can now be negative numbers as\n    well. [Issue
  [#1109](https://github.com/agda/agda/issues/1109)]\n\n    ```agda\n    infix -1
  _myop_\n    ```\n\n  - Postulates are now allowed in mutual\n    blocks. [Issue
  [#977](https://github.com/agda/agda/issues/977)]\n\n  - Empty where blocks are now\n
  \   allowed. [Issue [#947](https://github.com/agda/agda/issues/947)]\n\n  - Pattern
  synonyms are now allowed in parameterised\n    modules. [Issue [#941](https://github.com/agda/agda/issues/941)]\n\n
  \ - Empty hiding and renaming lists in module directives are now allowed.\n\n  -
  Module directives `using`, `hiding`, `renaming` and `public` can\n    now appear
  in arbitrary order. Multiple\n    `using`/`hiding`/`renaming` directives are allowed,
  but you still\n    cannot have both using and `hiding` (because that doesn't make\n
  \   sense). [Issue [#493](https://github.com/agda/agda/issues/493)]\n\nGoal and
  error display\n----------------------\n\n* The error message `Refuse to construct
  infinite term` has been\n  removed, instead one gets unsolved meta variables.  Reason:
  the\n  error was thrown over-eagerly.\n  [Issue [#795](https://github.com/agda/agda/issues/795)]\n\n*
  If an interactive case split fails with message\n\n  ```\n    Since goal is solved,
  further case distinction is not supported;\n    try `Solve constraints' instead\n
  \ ```\n\n  then the associated interaction meta is assigned to a solution.\n  Press
  `C-c C-=` (Show constraints) to view the solution and `C-c\n  C-s` (Solve constraints)
  to apply it.\n  [Issue [#289](https://github.com/agda/agda/issues/289)]\n\nType
  checking\n-------------\n\n* [ Issue [#376](https://github.com/agda/agda/issues/376)
  ]\n  Implemented expansion of bound record variables during meta\n  assignment.
  \ Now Agda can solve for metas X that are applied to\n  projected variables, e.g.:\n\n
  \ ```agda\n  X (fst z) (snd z) = z\n\n  X (fst z)         = fst z\n  ```\n\n  Technically,
  this is realized by substituting `(x , y)` for `z` with fresh\n  bound variables
  `x` and `y`.  Here the full code for the examples:\n\n  ```agda\n  record Sigma
  (A : Set)(B : A -> Set) : Set where\n    constructor _,_\n    field\n      fst :
  A\n      snd : B fst\n  open Sigma\n\n  test : (A : Set) (B : A -> Set) ->\n    let
  X : (x : A) (y : B x) -> Sigma A B\n        X = _\n    in  (z : Sigma A B) -> X
  (fst z) (snd z) ≡ z\n  test A B z = refl\n\n  test' : (A : Set) (B : A -> Set) ->\n
  \   let X : A -> A\n        X = _\n    in  (z : Sigma A B) -> X (fst z) ≡ fst z\n
  \ test' A B z = refl\n  ```\n\n  The fresh bound variables are named `fst(z)` and
  `snd(z)` and can appear\n  in error messages, e.g.:\n\n  ```agda\n  fail : (A :
  Set) (B : A -> Set) ->\n    let X : A -> Sigma A B\n        X = _\n    in  (z :
  Sigma A B) -> X (fst z) ≡ z\n  fail A B z = refl\n  ```\n\n  results in error:\n\n
  \ ```\n  Cannot instantiate the metavariable _7 to solution fst(z) , snd(z)\n  since
  it contains the variable snd(z) which is not in scope of the\n  metavariable or
  irrelevant in the metavariable but relevant in the\n  solution\n  when checking
  that the expression refl has type _7 A B (fst z) ≡ z\n  ```\n\n* Dependent record
  types and definitions by copatterns require\n  reduction with previous function
  clauses while checking the current\n  clause. [Issue [#907](https://github.com/agda/agda/issues/907)]\n\n
  \ For a simple example, consider\n\n  ```agda\n  test : ∀ {A} → Σ Nat λ n → Vec
  A n\n  proj₁ test = zero\n  proj₂ test = []\n  ```\n\n  For the second clause, the
  lhs and rhs are typed as\n\n  ```agda\n  proj₂ test : Vec A (proj₁ test)\n  []         :
  Vec A zero\n  ```\n\n  In order for these types to match, we have to reduce the
  lhs type\n  with the first function clause.\n\n  Note that termination checking
  comes after type checking, so be\n  careful to avoid non-termination!  Otherwise,
  the type checker\n  might get into an infinite loop.\n\n* The implementation of
  the primitive `primTrustMe` has changed.  It\n  now only reduces to `REFL` if the
  two arguments `x` and `y` have the\n  same computational normal form.  Before, it
  reduced when `x` and `y`\n  were definitionally equal, which included type-directed
  equality\n  laws such as eta-equality.  Yet because reduction is untyped,\n  calling
  conversion from reduction lead to Agda crashes\n  [Issue [#882](https://github.com/agda/agda/issues/882)].\n\n
  \ The amended description of `primTrustMe` is (cf. release notes\n  for 2.2.6):\n\n
  \ ```agda\n  primTrustMe : {A : Set} {x y : A} → x ≡ y\n  ```\n\n  Here `_≡_` is
  the builtin equality (see BUILTIN hooks for equality,\n  above).\n\n  If `x` and
  `y` have the same computational normal form, then\n  `primTrustMe {x = x} {y = y}`
  reduces to `refl`.\n\n  A note on `primTrustMe`'s runtime behavior: The MAlonzo
  compiler\n  replaces all uses of `primTrustMe` with the `REFL` builtin, without\n
  \ any check for definitional equality. Incorrect uses of `primTrustMe`\n  can potentially
  lead to segfaults or similar problems of the\n  compiled code.\n\n* Implicit patterns
  of record type are now only eta-expanded if there\n  is a record constructor.\n
  \ [Issues [#473](https://github.com/agda/agda/issues/473),\n  [#635](https://github.com/agda/agda/issues/635)]\n\n
  \ ```agda\n  data D : Set where\n    d : D\n\n  data P : D → Set where\n    p :
  P d\n\n  record Rc : Set where\n    constructor c\n    field f : D\n\n  works :
  {r : Rc} → P (Rc.f r) → Set\n  works p = D\n  ```\n\n  This works since the implicit
  pattern `r` is eta-expanded to `c x`\n  which allows the type of `p` to reduce to
  `P x` and `x` to be\n  unified with `d`. The corresponding explicit version is:\n\n
  \ ```agda\n  works' : (r : Rc) → P (Rc.f r) → Set\n  works' (c .d) p = D\n  ```\n\n
  \ However, if the record constructor is removed, the same example will\n  fail:\n\n
  \ ```agda\n  record R : Set where\n    field f : D\n\n  fails : {r : R} → P (R.f
  r) → Set\n  fails p = D\n\n  -- d != R.f r of type D\n  -- when checking that the
  pattern p has type P (R.f r)\n  ```\n\n  The error is justified since there is no
  pattern we could write down\n  for `r`.  It would have to look like\n\n  ```agda\n
  \ record { f = .d }\n  ```\n\n  but anonymous record patterns are not part of the
  language.\n\n* Absurd lambdas at different source locations are no longer\n  different.
  [Issue [#857](https://github.com/agda/agda/issues/857)]\n  In particular, the following
  code type-checks now:\n\n  ```agda\n  absurd-equality : _≡_ {A = ⊥ → ⊥} (λ()) λ()\n
  \ absurd-equality = refl\n  ```\n\n  Which is a good thing!\n\n* Printing of named
  implicit function types.\n\n  When printing terms in a context with bound variables
  Agda renames\n  new bindings to avoid clashes with the previously bound names. For\n
  \ instance, if `A` is in scope, the type `(A : Set) → A` is printed as\n  `(A₁ :
  Set) → A₁`. However, for implicit function types the name of\n  the binding matters,
  since it can be used when giving implicit\n  arguments.\n\n  For this situation,
  the following new syntax has been introduced:\n  `{x = y : A} → B` is an implicit
  function type whose bound variable\n  (in scope in `B`) is `y`, but where the name
  of the argument is `x`\n  for the purposes of giving it explicitly. For instance,
  with `A` in\n  scope, the type `{A : Set} → A` is now printed as `{A = A₁ : Set}
  →\n  A₁`.\n\n  This syntax is only used when printing and is currently not being
  parsed.\n\n* Changed the semantics of `--without-K`.\n  [Issue [#712](https://github.com/agda/agda/issues/712),\n
  \ Issue [#865](https://github.com/agda/agda/issues/865),\n  Issue [#1025](https://github.com/agda/agda/issues/1025)]\n\n
  \ New specification of `--without-K`:\n\n  When `--without-K` is enabled, the unification
  of indices for\n  pattern matching is restricted in two ways:\n\n  1. Reflexive
  equations of the form `x == x` are no longer solved,\n     instead Agda gives an
  error when such an equation is encountered.\n\n  2. When unifying two same-headed
  constructor forms `c us` and `c vs`\n     of type `D pars ixs`, the datatype indices
  `ixs` (but not the\n     parameters) have to be *self-unifiable*, i.e. unification
  of\n     `ixs` with itself should succeed positively. This is a nontrivial\n     requirement
  because of point 1.\n\n  Examples:\n\n  - The J rule is accepted.\n\n    ```agda\n
  \   J : {A : Set} (P : {x y : A} → x ≡ y → Set) →\n        (∀ x → P (refl x)) →\n
  \       ∀ {x y} (x≡y : x ≡ y) → P x≡y\n    J P p (refl x) = p x\n    ```agda\n\n
  \   This definition is accepted since unification of `x` with `y`\n    doesn't require
  deletion or injectivity.\n\n  - The K rule is rejected.\n\n    ```agda\n    K :
  {A : Set} (P : {x : A} → x ≡ x → Set) →\n        (∀ x → P (refl {x = x})) →\n       ∀
  {x} (x≡x : x ≡ x) → P x≡x\n    K P p refl = p _\n    ```\n\n    Definition is rejected
  with the following error:\n\n    ```\n    Cannot eliminate reflexive equation x
  = x of type A because K has\n    been disabled.\n    when checking that the pattern
  refl has type x ≡ x\n    ```\n\n  - Symmetry of the new criterion.\n\n    ```agda\n
  \   test₁ : {k l m : ℕ} → k + l ≡ m → ℕ\n    test₁ refl = zero\n\n    test₂ : {k
  l m : ℕ} → k ≡ l + m → ℕ\n    test₂ refl = zero\n    ```\n\n    Both versions are
  now accepted (previously only the first one was).\n\n  - Handling of parameters.\n\n
  \   ```agda\n    cons-injective : {A : Set} (x y : A) → (x ∷ []) ≡ (y ∷ []) → x
  ≡ y\n    cons-injective x .x refl = refl\n    ```\n\n    Parameters are not unified,
  so they are ignored by the new criterion.\n\n  - A larger example: antisymmetry
  of ≤.\n\n    ```agda\n    data _≤_ : ℕ → ℕ → Set where\n      lz : (n : ℕ) → zero
  ≤ n\n      ls : (m n : ℕ) → m ≤ n → suc m ≤ suc n\n\n    ≤-antisym : (m n : ℕ) →
  m ≤ n → n ≤ m → m ≡ n\n    ≤-antisym .zero    .zero    (lz .zero) (lz .zero)   =
  refl\n    ≤-antisym .(suc m) .(suc n) (ls m n p) (ls .n .m q) =\n                 cong
  suc (≤-antisym m n p q)\n    ```\n\n  - [ Issue [#1025](https://github.com/agda/agda/issues/1025)
  ]\n\n    ```agda\n    postulate mySpace : Set\n    postulate myPoint : mySpace\n\n
  \   data Foo : myPoint ≡ myPoint → Set where\n      foo : Foo refl\n\n    test :
  (i : foo ≡ foo) → i ≡ refl\n    test refl = {!!}\n    ```\n\n    When applying injectivity
  to the equation `foo ≡ foo` of type `Foo\n    refl`, it is checked that the index
  `refl` of type `myPoint ≡\n    myPoint` is self-unifiable. The equation `refl ≡
  refl` again\n    requires injectivity, so now the index `myPoint` is checked for\n
  \   self-unifiability, hence the error:\n\n    ```\n    Cannot eliminate reflexive
  equation myPoint = myPoint of type\n    mySpace because K has been disabled.\n    when
  checking that the pattern refl has type foo ≡ foo\n    ```\n\nTermination checking\n--------------------\n\n*
  A buggy facility coined \"matrix-shaped orders\" that supported\n  uncurried functions
  (which take tuples of arguments instead of one\n  argument after another) has been
  removed from the termination\n  checker. [Issue [#787](https://github.com/agda/agda/issues/787)]\n\n*
  Definitions which fail the termination checker are not unfolded any\n  longer to
  avoid loops or stack overflows in Agda.  However, the\n  termination checker for
  a mutual block is only invoked after\n  type-checking, so there can still be loops
  if you define a\n  non-terminating function.  But termination checking now happens\n
  \ before the other supplementary checks: positivity, polarity,\n  injectivity and
  projection-likeness.  Note that with the pragma `{-#\n  NO_TERMINATION_CHECK #-}`
  you can make Agda treat any function as\n  terminating.\n\n* Termination checking
  of functions defined by `with` has been improved.\n\n  Cases which previously required
  `--termination-depth` to pass the\n  termination checker (due to use of `with`)
  no longer need the\n  flag. For example\n\n  ```agda\n  merge : List A → List A
  → List A\n  merge [] ys = ys\n  merge xs [] = xs\n  merge (x ∷ xs) (y ∷ ys) with
  x ≤ y\n  merge (x ∷ xs) (y ∷ ys)    | false = y ∷ merge (x ∷ xs) ys\n  merge (x
  ∷ xs) (y ∷ ys)    | true  = x ∷ merge xs (y ∷ ys)\n  ```\n\n  This failed to termination
  check previously, since the `with`\n  expands to an auxiliary function `merge-aux`:\n\n
  \ ```agda\n  merge-aux x y xs ys false = y ∷ merge (x ∷ xs) ys\n  merge-aux x y
  xs ys true  = x ∷ merge xs (y ∷ ys)\n  ```\n\n  This function makes a call to `merge`
  in which the size of one of\n  the arguments is increasing. To make this pass the
  termination\n  checker now inlines the definition of `merge-aux` before checking,\n
  \ thus effectively termination checking the original source program.\n\n  As a result
  of this transformation doing `with` on a variable no longer\n  preserves termination.
  For instance, this does not termination check:\n\n  ```agda\n  bad : Nat → Nat\n
  \ bad n with n\n  ... | zero  = zero\n  ... | suc m = bad m\n  ```\n\n* The performance
  of the termination checker has been improved.  For\n  higher `--termination-depth`
  the improvement is significant.  While\n  the default `--termination-depth` is still
  1, checking with higher\n  `--termination-depth` should now be feasible.\n\nCompiler
  backends\n-----------------\n\n* The MAlonzo compiler backend now has support for
  compiling modules\n  that are not full programs (i.e. don't have a main function).
  The\n  goal is that you can write part of a program in Agda and the rest in\n  Haskell,
  and invoke the Agda functions from the Haskell code. The\n  following features were
  added for this reason:\n\n  - A new command-line option `--compile-no-main`: the
  command\n\n    ```\n    agda --compile-no-main Test.agda\n    ```\n\n    will compile
  `Test.agda` and all its dependencies to Haskell and\n    compile the resulting Haskell
  files with `--make`, but (unlike\n    `--compile`) not tell GHC to treat `Test.hs`
  as the main\n    module. This type of compilation can be invoked from Emacs by\n
  \   customizing the `agda2-backend` variable to value `MAlonzoNoMain` and\n    then
  calling `C-c C-x C-c` as before.\n\n  - A new pragma `COMPILED_EXPORT` was added
  as part of the MAlonzo\n    FFI. If we have an Agda file containing the following:\n\n
  \   ```agda\n     module A.B where\n\n     test : SomeType\n     test = someImplementation\n\n
  \    {-# COMPILED_EXPORT test someHaskellId #-}\n    ```\n\n    then test will be
  compiled to a Haskell function called\n    `someHaskellId` in module `MAlonzo.Code.A.B`
  that can be invoked\n    from other Haskell code. Its type will be translated according
  to\n    the normal MAlonzo rules.\n\nTools\n-----\n\n### Emacs mode\n\n* A new goal
  command `Helper Function Type` (`C-c C-h`) has been added.\n\n  If you write an
  application of an undefined function in a goal, the\n  `Helper Function Type` command
  will print the type that the function\n  needs to have in order for it to fit the
  goal. The type is also\n  added to the Emacs kill-ring and can be pasted into the
  buffer using\n  `C-y`.\n\n  The application must be of the form `f args` where `f`
  is the name of the\n  helper function you want to create. The arguments can use
  all the normal\n  features like named implicits or instance arguments.\n\n  Example:\n\n
  \ Here's a start on a naive reverse on vectors:\n\n  ```agda\n  reverse : ∀ {A n}
  → Vec A n → Vec A n\n  reverse [] = []\n  reverse (x ∷ xs) = {!snoc (reverse xs)
  x!}\n  ```\n\n  Calling `C-c C-h` in the goal prints\n\n  ```agda\n  snoc : ∀ {A}
  {n} → Vec A n → A → Vec A (suc n)\n  ```\n\n* A new command `Explain why a particular
  name is in scope` (`C-c\n  C-w`) has been added.\n  [Issue [#207](https://github.com/agda/agda/issues/207)]\n\n
  \ This command can be called from a goal or from the top-level and will as the\n
  \ name suggests explain why a particular name is in scope.\n\n  For each definition
  or module that the given name can refer to a trace is\n  printed of all open statements
  and module applications leading back to the\n  original definition of the name.\n\n
  \ For example, given\n\n  ```agda\n  module A (X : Set₁) where\n    data Foo : Set
  where\n      mkFoo : Foo\n  module B (Y : Set₁) where\n    open A Y public\n  module
  C = B Set\n  open C\n  ```\n\n  Calling `C-c C-w` on `mkFoo` at the top-level prints\n\n
  \ ```\n  mkFoo is in scope as\n  * a constructor Issue207.C._.Foo.mkFoo brought
  into scope by\n    - the opening of C at Issue207.agda:13,6-7\n    - the application
  of B at Issue207.agda:11,12-13\n    - the application of A at Issue207.agda:9,8-9\n
  \   - its definition at Issue207.agda:6,5-10\n  ```\n\n  This command is useful
  if Agda complains about an ambiguous name and\n  you need to figure out how to hide
  the undesired interpretations.\n\n* Improvements to the `make case` command (`C-c
  C-c`)\n\n  - One can now also split on hidden variables, using the name\n    (starting
  with `.`) with which they are printed.  Use `C-c C-`, to\n    see all variables
  in context.\n\n  - Concerning the printing of generated clauses:\n\n    * Uses named
  implicit arguments to improve readability.\n\n    * Picks explicit occurrences over
  implicit ones when there is a\n      choice of binding site for a variable.\n\n
  \   * Avoids binding variables in implicit positions by replacing dot\n      patterns
  that uses them by wildcards (`._`).\n\n* Key bindings for lots of \"mathematical\"
  characters (examples: \U0001D434\U0001D468\U0001D49C\U0001D4D0\U0001D504)\n  have
  been added to the Agda input method.  Example: type\n  `\\MiA\\MIA\\McA\\MCA\\MfA`
  to get \U0001D434\U0001D468\U0001D49C\U0001D4D0\U0001D504.\n\n  Note: `\\McB` does
  not exist in Unicode (as well as others in that style),\n  but the `\\MC` (bold)
  alphabet is complete.\n\n* Key bindings for \"blackboard bold\" B (\U0001D539) and
  0-9 (\U0001D7D8-\U0001D7E1) have been\n  added to the Agda input method (`\\bb`
  and `\\b[0-9]`).\n\n* Key bindings for controlling simplification/normalisation:\n\n
  \ Commands like `Goal type and context` (`C-c C-,`) could previously\n  be invoked
  in two ways. By default the output was normalised, but if\n  a prefix argument was
  used (for instance via `C-u C-c C-,`), then no\n  explicit normalisation was performed.
  Now there are three options:\n\n  - By default (`C-c C-,`) the output is simplified.\n\n
  \ - If `C-u` is used exactly once (`C-u C-c C-,`), then the result is\n    neither
  (explicitly) normalised nor simplified.\n\n  - If `C-u` is used twice (`C-u C-u C-c C-,`),
  then the result is\n    normalised.\n\n### LaTeX-backend\n\n* Two new color scheme
  options were added to `agda.sty`:\n\n  `\\usepackage[bw]{agda}`, which highlights
  in black and white;\n  `\\usepackage[conor]{agda}`, which highlights using Conor's
  colors.\n\n  The default (no options passed) is to use the standard colors.\n\n*
  If `agda.sty` cannot be found by the LateX environment, it is now\n  copied into
  the LateX output directory (`latex` by default) instead\n  of the working directory.
  This means that the commands needed to\n  produce a PDF now is\n\n  ```\n  agda
  --latex -i . <file>.lagda\n  cd latex\n  pdflatex <file>.tex\n  ```\n\n* The LaTeX-backend
  has been made more tool agnostic, in particular\n  XeLaTeX and LuaLaTeX should now
  work. Here is a small example\n  (`test/LaTeXAndHTML/succeed/UnicodeInput.lagda`):\n\n
  \ ```latex\n  \\documentclass{article}\n  \\usepackage{agda}\n  \\begin{document}\n\n
  \ \\begin{code}\n  data αβγδεζθικλμνξρστυφχψω : Set₁ where\n\n  postulate\n    →⇒⇛⇉⇄↦⇨↠⇀⇁
  : Set\n  \\end{code}\n\n  \\[\n  ∀X [ ∅ ∉ X ⇒ ∃f:X ⟶  ⋃ X\\ ∀A ∈ X (f(A) ∈ A) ]\n
  \ \\]\n  \\end{document}\n  ```\n\n  Compiled as follows, it should produce a nice
  looking PDF (tested with\n  TeX Live 2012):\n\n  ```\n  agda --latex <file>.lagda\n
  \ cd latex\n  xelatex <file>.tex (or lualatex <file>.tex)\n  ```\n\n  If symbols
  are missing or XeLaTeX/LuaLaTeX complains about the font\n  missing, try setting
  a different font using:\n\n  ```latex\n  \\setmathfont{<math-font>}\n  ```\n\n  Use
  the `fc-list` tool to list available fonts.\n\n* Add experimental support for hyperlinks
  to identifiers\n\n  If the `hyperref` LateX package is loaded before the Agda package\n
  \ and the links option is passed to the Agda package, then the Agda\n  package provides
  a function called `\\AgdaTarget`. Identifiers which\n  have been declared targets,
  by the user, will become clickable\n  hyperlinks in the rest of the document. Here
  is a small example\n  (`test/LaTeXAndHTML/succeed/Links.lagda`):\n\n  ```latex\n
  \ \\documentclass{article}\n  \\usepackage{hyperref}\n  \\usepackage[links]{agda}\n
  \ \\begin{document}\n\n  \\AgdaTarget{ℕ}\n  \\AgdaTarget{zero}\n  \\begin{code}\n
  \ data ℕ : Set where\n    zero  : ℕ\n    suc   : ℕ → ℕ\n  \\end{code}\n\n  See next
  page for how to define \\AgdaFunction{two} (doesn't turn into a\n  link because
  the target hasn't been defined yet). We could do it\n  manually though; \\hyperlink{two}{\\AgdaDatatype{two}}.\n\n
  \ \\newpage\n\n  \\AgdaTarget{two}\n  \\hypertarget{two}{}\n  \\begin{code}\n  two
  : ℕ\n  two = suc (suc zero)\n  \\end{code}\n\n  \\AgdaInductiveConstructor{zero}
  is of type\n  \\AgdaDatatype{ℕ}. \\AgdaInductiveConstructor{suc} has not been defined
  to\n  be a target so it doesn't turn into a link.\n\n  \\newpage\n\n  Now that the
  target for \\AgdaFunction{two} has been defined the link\n  works automatically.\n\n
  \ \\begin{code}\n  data Bool : Set where\n    true false : Bool\n  \\end{code}\n\n
  \ The AgdaTarget command takes a list as input, enabling several\n  targets to be
  specified as follows:\n\n  \\AgdaTarget{if, then, else, if\\_then\\_else\\_}\n  \\begin{code}\n
  \ if_then_else_ : {A : Set} → Bool → A → A → A\n  if true  then t else f = t\n  if
  false then t else f = f\n  \\end{code}\n\n  \\newpage\n\n  Mixfix identifier need
  their underscores escaped:\n  \\AgdaFunction{if\\_then\\_else\\_}.\n\n  \\end{document}\n
  \ ```\n\n  The boarders around the links can be suppressed using hyperref's\n  hidelinks
  option:\n\n  ```latex\n    \\usepackage[hidelinks]{hyperref}\n  ```\n\n  Note that
  the current approach to links does not keep track of scoping\n  or types, and hence
  overloaded names might create links which point to\n  the wrong place. Therefore
  it is recommended to not overload names\n  when using the links option at the moment,
  this might get fixed in the\n  future.\n\nRelease notes for Agda 2 version 2.3.2.2\n========================================\n\n*
  Fixed a bug that sometimes made it tricky to use the Emacs mode on\n  Windows [Issue
  [#757](https://github.com/agda/agda/issues/757)].\n\n* Made Agda build with newer
  versions of some libraries.\n\n* Fixed a bug that caused ambiguous parse error messages\n
  \ [Issue [#147](https://github.com/agda/agda/issues/147)].\n\nRelease notes for
  Agda 2 version 2.3.2.1\n========================================\n\nInstallation\n------------\n\n*
  Made it possible to compile Agda with more recent versions of\n  hashable, QuickCheck
  and Win32.\n\n* Excluded mtl-2.1.\n\nType checking\n-------------\n\n* Fixed bug
  in the termination checker\n  (Issue [#754](https://github.com/agda/agda/issues/754)).\n\nRelease
  notes for Agda 2 version 2.3.2\n======================================\n\nInstallation\n------------\n\n*
  The Agda-executable package has been removed.\n\n  The executable is now provided
  as part of the Agda package.\n\n* The Emacs mode no longer depends on haskell-mode
  or GHCi.\n\n* Compilation of Emacs mode Lisp files.\n\n  You can now compile the
  Emacs mode Lisp files by running `agda-mode\n  compile`. This command is run by
  `make install`.\n\n  Compilation can, in some cases, give a noticeable speedup.\n\n
  \ WARNING: If you reinstall the Agda mode without recompiling the\n  Emacs Lisp
  files, then Emacs may continue using the old, compiled\n  files.\n\nPragmas and
  options\n-------------------\n\n* The `--without-K` check now reconstructs constructor
  parameters.\n\n  New specification of `--without-K`:\n\n  If the flag is activated,
  then Agda only accepts certain\n  case-splits. If the type of the variable to be
  split is\n  `D pars ixs`, where `D` is a data (or record) type, `pars` stands\n
  \ for the parameters, and `ixs` the indices, then the following\n  requirements
  must be satisfied:\n\n  - The indices `ixs` must be applications of constructors
  (or\n    literals) to distinct variables. Constructors are usually not\n    applied
  to parameters, but for the purposes of this check\n    constructor parameters are
  treated as other arguments.\n\n  - These distinct variables must not be free in
  pars.\n\n* Irrelevant arguments are printed as `_` by default now.  To turn on\n
  \ printing of irrelevant arguments, use option\n\n  ```\n  --show-irrelevant\n  ```\n\n*
  New: Pragma `NO_TERMINATION_CHECK` to switch off termination checker\n  for individual
  function definitions and mutual blocks.\n\n  The pragma must precede a function
  definition or a mutual block.\n  Examples (see `test/Succeed/NoTerminationCheck.agda`):\n\n
  \ 1. Skipping a single definition: before type signature.\n\n     ```agda\n     {-#
  NO_TERMINATION_CHECK #-}\n     a : A\n     a = a\n     ```\n\n  2. Skipping a single
  definition: before first clause.\n\n     ```agda\n     b : A\n     {-# NO_TERMINATION_CHECK
  #-}\n     b = b\n     ```\n\n  3. Skipping an old-style mutual block: Before `mutual`
  keyword.\n\n     ```agda\n     {-# NO_TERMINATION_CHECK #-}\n     mutual\n       c
  : A\n       c = d\n\n       d : A\n       d = c\n     ```\n\n  4. Skipping a new-style
  mutual block: Anywhere before a type\n     signature or first function clause in
  the block\n\n     ```agda\n     i : A\n     j : A\n\n     i = j\n     {-# NO_TERMINATION_CHECK
  #-}\n     j = i\n     ```\n\n  The pragma cannot be used in `--safe` mode.\n\nLanguage\n--------\n\n*
  Let binding record patterns\n\n  ```agda\n  record _×_ (A B : Set) : Set where\n
  \   constructor _,_\n    field\n      fst : A\n      snd : B\n  open _×_\n\n  let
  (x , (y , z)) = t\n  in  u\n  ```\n\n  will now be interpreted as\n\n  ```agda\n
  \ let x = fst t\n      y = fst (snd t)\n      z = snd (snd t)\n  in  u\n  ```\n\n
  \ Note that the type of `t` needs to be inferable. If you need to\n  provide a type
  signature, you can write the following:\n\n  ```agda\n  let a : ...\n      a = t\n
  \     (x , (y , z)) = a\n  in  u\n  ```\n\n* Pattern synonyms\n\n  A pattern synonym
  is a declaration that can be used on the left hand\n  side (when pattern matching)
  as well as the right hand side (in\n  expressions). For example:\n\n  ```agda\n
  \ pattern z    = zero\n  pattern ss x = suc (suc x)\n\n  f : ℕ -> ℕ\n  f z       =
  z\n  f (suc z) = ss z\n  f (ss n)  = n\n  ```\n\n  Pattern synonyms are implemented
  by substitution on the abstract\n  syntax, so definitions are scope-checked but
  not type-checked. They\n  are particularly useful for universe constructions.\n\n*
  Qualified mixfix operators\n\n  It is now possible to use a qualified mixfix operator
  by qualifying\n  the first part of the name. For instance\n\n  ```agda\n  import
  Data.Nat as Nat\n  import Data.Bool as Bool\n\n  two = Bool.if true then 1 Nat.+
  1 else 0\n  ```\n\n* Sections [Issue [#735](https://github.com/agda/agda/issues/735)].\n
  \ Agda now parses anonymous modules as sections:\n\n  ```agda\n  module _ {a} (A
  : Set a) where\n\n    data List : Set a where\n      []  : List\n      _∷_ : (x
  : A) (xs : List) → List\n\n  module _ {a} {A : Set a} where\n\n    _++_ : List A
  → List A → List A\n    []       ++ ys = ys\n    (x ∷ xs) ++ ys = x ∷ (xs ++ ys)\n\n
  \ test : List Nat\n  test = (5 ∷ []) ++ (3 ∷ [])\n  ```\n\n  In general, now the
  syntax\n\n  ```agda\n  module _ parameters where\n    declarations\n  ```\n\n  is
  accepted and has the same effect as\n\n  ```agda\n  private\n    module M parameters
  where\n      declarations\n  open M public\n  ```\n\n  for a fresh name `M`.\n\n*
  Instantiating a module in an open import statement\n  [Issue [#481](https://github.com/agda/agda/issues/481)].
  Now\n  accepted:\n\n  ```agda\n  open import Path.Module args [using/hiding/renaming
  (...)]\n  ```\n\n  This only brings the imported identifiers from `Path.Module`
  into scope,\n  not the module itself!  Consequently, the following is pointless,
  and raises\n  an error:\n\n  ```agda\n    import Path.Module args [using/hiding/renaming
  (...)]\n  ```\n\n  You can give a private name `M` to the instantiated module via\n\n
  \ ```agda\n  import Path.Module args as M [using/hiding/renaming (...)]\n  open
  import Path.Module args as M [using/hiding/renaming (...)]\n  ```\n\n  Try to avoid
  `as` as part of the arguments.  `as` is not a keyword;\n  the following can be legal,
  although slightly obfuscated Agda code:\n\n  ```agda\n  open import as as as as
  as as\n  ```\n\n* Implicit module parameters can be given by name. E.g.\n\n  ```agda\n
  \ open M {namedArg = bla}\n  ```\n\n  This feature has been introduced in Agda 2.3.0
  already.\n\n* Multiple type signatures sharing a same type can now be written as
  a single\n  type signature.\n\n  ```agda\n  one two : ℕ\n  one = suc zero\n  two
  = suc one\n  ```\n\nGoal and error display\n----------------------\n\n* Meta-variables
  that were introduced by hidden argument `arg` are now\n  printed as `_arg_number`
  instead of just `_number`.\n  [Issue [#526](https://github.com/agda/agda/issues/526)]\n\n*
  Agda expands identifiers in anonymous modules when printing.  Should\n  make some
  goals nicer to read.\n  [Issue [#721](https://github.com/agda/agda/issues/721)]\n\n*
  When a module identifier is ambiguous, Agda tells you if one of them\n  is a data
  type module.\n  [Issues [#318](https://github.com/agda/agda/issues/318),\n  [#705](https://github.com/agda/agda/issues/705)]\n\nType
  checking\n-------------\n\n* Improved coverage checker. The coverage checker splits
  on arguments\n  that have constructor or literal pattern, committing to the\n  left-most
  split that makes progress.  Consider the lookup function\n  for vectors:\n\n  ```agda\n
  \ data Fin : Nat → Set where\n    zero : {n : Nat} → Fin (suc n)\n    suc  : {n
  : Nat} → Fin n → Fin (suc n)\n\n  data Vec (A : Set) : Nat → Set where\n    []  :
  Vec A zero\n    _∷_ : {n : Nat} → A → Vec A n → Vec A (suc n)\n\n  _!!_ : {A : Set}{n
  : Nat} → Vec A n → Fin n → A\n  (x ∷ xs) !! zero  = x\n  (x ∷ xs) !! suc i = xs
  !! i\n  ```\n\n  In Agda up to 2.3.0, this definition is rejected unless we add\n
  \ an absurd clause\n\n  ```agda\n  [] !! ()\n  ```\n\n  This is because the coverage
  checker committed on splitting on the\n  vector argument, even though this inevitably
  lead to failed\n  coverage, because a case for the empty vector `[]` is missing.\n\n
  \ The improvement to the coverage checker consists on committing only\n  on splits
  that have a chance of covering, since all possible\n  constructor patterns are present.
  \ Thus, Agda will now split first\n  on the `Fin` argument, since cases for both
  `zero` and `suc` are\n  present.  Then, it can split on the `Vec` argument, since
  the empty\n  vector is already ruled out by instantiating `n` to a `suc _`.\n\n*
  Instance arguments resolution will now consider candidates which\n  still expect
  hidden arguments. For example:\n\n  ```agda\n  record Eq (A : Set) : Set where\n
  \   field eq : A → A → Bool\n\n  open Eq {{...}}\n\n  eqFin : {n : ℕ} → Eq (Fin
  n)\n  eqFin = record { eq = primEqFin }\n\n  testFin : Bool\n  testFin = eq fin1
  fin2\n  ```\n\n  The type-checker will now resolve the instance argument of the
  `eq`\n  function to `eqFin {_}`. This is only done for hidden arguments, not\n  instance
  arguments, so that the instance search stays non-recursive.\n\n* Constraint solving:
  Upgraded Miller patterns to record patterns.\n  [Issue [#456](https://github.com/agda/agda/issues/456)]\n\n
  \ Agda now solves meta-variables that are applied to record patterns.\n  A typical
  (but here, artificial) case is:\n\n  ```agda\n  record Sigma (A : Set)(B : A ->
  Set) : Set where\n    constructor _,_\n    field\n      fst : A\n      snd : B fst\n\n
  \ test : (A : Set)(B : A -> Set) ->\n    let X : Sigma A B -> Sigma A B\n        X
  = _\n    in  (x : A)(y : B x) -> X (x , y) ≡ (x , y)\n  test A B x y = refl\n  ```\n\n
  \ This yields a constraint of the form\n\n  ```\n  _X A B (x , y) := t[x,y]\n  ```\n\n
  \ (with `t[x,y] = (x, y)`) which is not a Miller pattern.\n  However, Agda now solves
  this as\n\n  ```\n  _X A B z := t[fst z,snd z].\n  ```\n\n* Changed: solving recursive
  constraints.\n  [Issue [#585](https://github.com/agda/agda/issues/585)]\n\n  Until
  2.3.0, Agda sometimes inferred values that did not pass the\n  termination checker
  later, or would even make Agda loop. To prevent\n  this, the occurs check now also
  looks into the definitions of the\n  current mutual block, to avoid constructing
  recursive solutions. As\n  a consequence, also terminating recursive solutions are
  no longer\n  found automatically.\n\n  This effects a programming pattern where
  the recursively computed\n  type of a recursive function is left to Agda to solve.\n\n
  \ ```agda\n  mutual\n\n    T : D -> Set\n    T pattern1 = _\n    T pattern2 = _\n\n
  \   f : (d : D) -> T d\n    f pattern1 = rhs1\n    f pattern2 = rhs2\n  ```\n\n
  \ This might no longer work from now on. See examples\n  `test/Fail/Issue585*.agda`.\n\n*
  Less eager introduction of implicit parameters.\n  [Issue [#679](https://github.com/agda/agda/issues/679)]\n\n
  \ Until Agda 2.3.0, trailing hidden parameters were introduced eagerly\n  on the
  left hand side of a definition.  For instance, one could not\n  write\n\n  ```agda\n
  \ test : {A : Set} -> Set\n  test = \\ {A} -> A\n  ```\n\n  because internally,
  the hidden argument `{A : Set}` was added to the\n  left-hand side, yielding\n\n
  \ ```agda\n  test {_} = \\ {A} -> A\n  ```\n\n  which raised a type error.  Now,
  Agda only introduces the trailing\n  implicit parameters it has to, in order to
  maintain uniform function\n  arity.  For instance, in\n\n  ```agda\n  test : Bool
  -> {A B C : Set} -> Set\n  test true {A}      = A\n  test false {B = B} = B\n  ```\n\n
  \ Agda will introduce parameters `A` and `B` in all clauses, but not\n  `C`, resulting
  in\n\n  ```agda\n  test : Bool -> {A B C : Set} -> Set\n  test true  {A} {_}     =
  A\n  test false {_} {B = B} = B\n  ```\n\n  Note that for checking `where`-clauses,
  still all hidden trailing\n  parameters are in scope.  For instance:\n\n  ```agda\n
  \ id : {i : Level}{A : Set i} -> A -> A\n  id = myId\n    where myId : forall {A}
  -> A -> A\n          myId x = x\n  ```\n\n  To be able to fill in the meta variable
  `_1` in\n\n  ```agda\n  myId : {A : Set _1} -> A -> A\n  ```\n\n  the hidden parameter
  `{i : Level}` needs to be in scope.\n\n  As a result of this more lazy introduction
  of implicit parameters,\n  the following code now passes.\n\n  ```agda\n  data Unit
  : Set where\n    unit : Unit\n\n  T : Unit → Set\n  T unit = {u : Unit} → Unit\n\n
  \ test : (u : Unit) → T u\n  test unit with unit\n  ... | _ = λ {v} → v\n  ```\n\n
  \ Before, Agda would eagerly introduce the hidden parameter `{v}` as\n  unnamed
  left-hand side parameter, leaving no way to refer to it.\n\n  The related Issue
  [#655](https://github.com/agda/agda/issues/655)\n  has also been addressed.  It
  is now possible to make `synonym'\n  definitions\n\n  ```\n  name = expression\n
  \ ```\n\n  even when the type of expression begins with a hidden quantifier.\n  Simple
  example:\n\n  ```\n  id2 = id\n  ```\n\n  That resulted in unsolved metas until
  2.3.0.\n\n* Agda detects unused arguments and ignores them during equality\n  checking.
  [Issue [#691](https://github.com/agda/agda/issues/691),\n  solves also Issue [#44](https://github.com/agda/agda/issues/44)]\n\n
  \ Agda's polarity checker now assigns 'Nonvariant' to arguments that\n  are not
  actually used (except for absurd matches).  If `f`'s first\n  argument is Nonvariant,
  then `f x` is definitionally equal to `f y`\n  regardless of `x` and `y`.  It is
  similar to irrelevance, but does\n  not require user annotation.\n\n  For instance,
  unused module parameters do no longer get in the way:\n\n  ```agda\n  module M (x
  : Bool) where\n\n    not : Bool → Bool\n    not true  = false\n    not false = true\n\n
  \ open M true\n  open M false renaming (not to not′)\n\n  test : (y : Bool) → not
  y ≡ not′ y\n  test y = refl\n  ```\n\n  Matching against record or absurd patterns
  does not count as `use',\n  so we get some form of proof irrelevance:\n\n  ```agda\n
  \ data ⊥ : Set where\n  record ⊤ : Set where\n    constructor trivial\n\n  data
  Bool : Set where\n    true false : Bool\n\n  True : Bool → Set\n  True true  = ⊤\n
  \ True false = ⊥\n\n  fun : (b : Bool) → True b → Bool\n  fun true  trivial = true\n
  \ fun false ()\n\n  test : (b : Bool) → (x y : True b) → fun b x ≡ fun b y\n  test
  b x y = refl\n  ```\n\n  More examples in `test/Succeed/NonvariantPolarity.agda`.\n\n
  \ Phantom arguments:  Parameters of record and data types are considered\n  `used'
  even if they are not actually used.  Consider:\n\n  ```agda\n  False : Nat → Set\n
  \ False zero    = ⊥\n  False (suc n) = False n\n\n  module Invariant where\n    record
  Bla (n : Nat)(p : False n) : Set where\n\n  module Nonvariant where\n    Bla : (n
  : Nat) → False n → Set\n    Bla n p = ⊤\n  ```\n\n  Even though record `Bla` does
  not use its parameters `n` and `p`,\n  they are considered as used, allowing \"phantom
  type\" techniques.\n\n  In contrast, the arguments of function `Bla` are recognized
  as\n  unused.  The following code type-checks if we open `Invariant` but\n  leaves
  unsolved metas if we open `Nonvariant`.\n\n  ```agda\n  drop-suc : {n : Nat}{p :
  False n} → Bla (suc n) p → Bla n p\n  drop-suc _ = _\n\n  bla : (n : Nat) → {p :
  False n} → Bla n p → ⊥\n  bla zero {()} b\n  bla (suc n) b = bla n (drop-suc b)\n
  \ ```\n\n  If `Bla` is considered invariant, the hidden argument in the\n  recursive
  call can be inferred to be `p`.  If it is considered\n  non-variant, then `Bla n
  X = Bla n p` does not entail `X = p` and\n  the hidden argument remains unsolved.
  \ Since `bla` does not actually\n  use its hidden argument, its value is not important
  and it could be\n  searched for.  Unfortunately, polarity analysis of `bla` happens\n
  \ only after type checking, thus, the information that `bla` is\n  non-variant in
  `p` is not available yet when meta-variables are\n  solved.  (See\n  `test/Fail/BrokenInferenceDueToNonvariantPolarity.agda`)\n\n*
  Agda now expands simple definitions (one clause, terminating) to\n  check whether
  a function is constructor\n  headed. [Issue [#747](https://github.com/agda/agda/issues/747)]
  For\n  instance, the following now also works:\n\n  ```agda\n  MyPair : Set -> Set
  -> Set\n  MyPair A B = Pair A B\n\n  Vec : Set -> Nat -> Set\n  Vec A zero    =
  Unit\n  Vec A (suc n) = MyPair A (Vec A n)\n  ```\n\n  Here, `Unit` and `Pair` are
  data or record types.\n\nCompiler backends\n-----------------\n\n* `-Werror` is
  now overridable.\n\n  To enable compilation of Haskell modules containing warnings,
  the\n  `-Werror` flag for the MAlonzo backend has been made\n  overridable. If,
  for example, `--ghc-flag=-Wwarn` is passed when\n  compiling, one can get away with
  things like:\n\n  ```agda\n  data PartialBool : Set where\n    true : PartialBool\n\n
  \ {-# COMPILED_DATA PartialBool Bool True #-}\n  ```\n\n  The default behavior remains
  as it used to be and rejects the above\n  program.\n\nTools\n-----\n\n### Emacs
  mode\n\n* Asynchronous Emacs mode.\n\n  One can now use Emacs while a buffer is
  type-checked. If the buffer\n  is edited while the type-checker runs, then syntax
  highlighting will\n  not be updated when type-checking is complete.\n\n* Interactive
  syntax highlighting.\n\n  The syntax highlighting is updated while a buffer is type-checked:\n\n
  \ - At first the buffer is highlighted in a somewhat crude way\n    (without go-to-definition
  information for overloaded\n    constructors).\n\n  - If the highlighting level
  is \"interactive\", then the piece of code\n    that is currently being type-checked
  is highlighted as such. (The\n    default is \"non-interactive\".)\n\n  - When a
  mutual block has been type-checked it is highlighted\n    properly (this highlighting
  includes warnings for potential\n    non-termination).\n\n  The highlighting level
  can be controlled via the new configuration\n  variable `agda2-highlight-level`.\n\n*
  Multiple case-splits can now be performed in one go.\n\n  Consider the following
  example:\n\n  ```agda\n  _==_ : Bool → Bool → Bool\n  b₁ == b₂ = {!!}\n  ```\n\n
  \ If you split on `b₁ b₂`, then you get the following code:\n\n  ```agda\n  _==_
  : Bool → Bool → Bool\n  true == true = {!!}\n  true == false = {!!}\n  false ==
  true = {!!}\n  false == false = {!!}\n  ```\n\n  The order of the variables matters.
  Consider the following code:\n\n  ```agda\n  lookup : ∀ {a n} {A : Set a} → Vec
  A n → Fin n → A\n  lookup xs i = {!!}\n  ```\n\n  If you split on `xs i`, then you
  get the following code:\n\n  ```agda\n  lookup : ∀ {a n} {A : Set a} → Vec A n →
  Fin n → A\n  lookup [] ()\n  lookup (x ∷ xs) zero = {!!}\n  lookup (x ∷ xs) (suc
  i) = {!!}\n  ```\n\n  However, if you split on `i xs`, then you get the following
  code\n  instead:\n\n  ```agda\n  lookup : ∀ {a n} {A : Set a} → Vec A n → Fin n
  → A\n  lookup (x ∷ xs) zero = ?\n  lookup (x ∷ xs) (suc i) = ?\n  ```\n\n  This
  code is rejected by Agda 2.3.0, but accepted by 2.3.2 thanks\n  to improved coverage
  checking (see above).\n\n* The Emacs mode now presents information about which module
  is\n  currently being type-checked.\n\n* New global menu entry: `Information about
  the character at point`.\n\n  If this entry is selected, then information about
  the character at\n  point is displayed, including (in many cases) information about
  how\n  to type the character.\n\n* Commenting/uncommenting the rest of the buffer.\n\n
  \ One can now comment or uncomment the rest of the buffer by typing\n  `C-c C-x M-;`
  or by selecting the menu entry `Comment/uncomment` the\n  rest of the buffer\".\n\n*
  The Emacs mode now uses the Agda executable instead of GHCi.\n\n  The `*ghci*` buffer
  has been renamed to `*agda2*`.\n\n  A new configuration variable has been introduced:\n
  \ `agda2-program-name`, the name of the Agda executable (by default\n  `agda`).\n\n
  \ The variable `agda2-ghci-options` has been replaced by\n  `agda2-program-args`:
  extra arguments given to the Agda executable\n  (by default `none`).\n\n  If you
  want to limit Agda's memory consumption you can add some\n  arguments to `agda2-program-args`,
  for instance `+RTS -M1.5G -RTS`.\n\n* The Emacs mode no longer depends on haskell-mode.\n\n
  \ Users who have customised certain haskell-mode variables (such as\n  `haskell-ghci-program-args`)
  may want to update their configuration.\n\n### LaTeX-backend\n\nAn experimental
  LaTeX-backend which does precise highlighting a la the\nHTML-backend and code alignment
  a la lhs2TeX has been added.\n\nHere is a sample input literate Agda file:\n\n  ```latex\n
  \ \\documentclass{article}\n\n  \\usepackage{agda}\n\n  \\begin{document}\n\n  The
  following module declaration will be hidden in the output.\n\n  \\AgdaHide{\n  \\begin{code}\n
  \ module M where\n  \\end{code}\n  }\n\n  Two or more spaces can be used to make
  the backend align stuff.\n\n  \\begin{code}\n  data ℕ : Set where\n    zero  : ℕ\n
  \   suc   : ℕ → ℕ\n\n  _+_ : ℕ → ℕ → ℕ\n  zero   + n = n\n  suc m  + n = suc (m
  + n)\n  \\end{code}\n\n  \\end{document}\n  ```\n\nTo produce an output PDF issue
  the following commands:\n\n  ```\n  agda --latex -i . <file>.lagda\n  pdflatex latex/<file>.tex\n
  \ ```\n\nOnly the top-most module is processed, like with lhs2tex and unlike\nwith
  the HTML-backend. If you want to process imported modules you\nhave to call `agda
  --latex` manually on each of those modules.\n\nThere are still issues related to
  formatting, see the bug tracker for\nmore information:\n\n  https://code.google.com/p/agda/issues/detail?id=697\n\nThe
  default `agda.sty` might therefore change in backwards-incompatible\nways, as work
  proceeds in trying to resolve those problems.\n\nImplemented features:\n\n* Two
  or more spaces can be used to force alignment of things, like\n  with lhs2tex. See
  example above.\n\n* The highlighting information produced by the type checker is
  used to\n  generate the output. For example, the data declaration in the\n  example
  above, produces:\n\n  ```agda\n  \\AgdaKeyword{data} \\AgdaDatatype{ℕ} \\AgdaSymbol{:}\n
  \     \\AgdaPrimitiveType{Set} \\AgdaKeyword{where}\n  ```\n\n  These LaTeX commands
  are defined in `agda.sty` (which is imported by\n  `\\usepackage{agda}`) and cause
  the highlighting.\n\n* The LaTeX-backend checks if `agda.sty` is found by the LaTeX\n
  \ environment, if it isn't a default `agda.sty` is copied from Agda's\n  `data-dir`
  into the working directory (and thus made available to\n  the LaTeX environment).\n\n
  \ If the default `agda.sty` isn't satisfactory (colors, fonts,\n  spacing, etc)
  then the user can modify it and make put it somewhere\n  where the LaTeX environment
  can find it. Hopefully most aspects\n  should be modifiable via `agda.sty` rather
  than having to tweak the\n  implementation.\n\n* `--latex-dir` can be used to change
  the default output directory.\n\nRelease notes for Agda 2 version 2.3.0\n======================================\n\nLanguage\n--------\n\n*
  New more liberal syntax for mutually recursive definitions.\n\n  It is no longer
  necessary to use the `mutual` keyword to define\n  mutually recursive functions
  or datatypes. Instead, it is enough to\n  declare things before they are used. Instead
  of\n\n  ```agda\n  mutual\n    f : A\n    f = a[f, g]\n\n    g : B[f]\n    g = b[f,
  g]\n  ```\n\n  you can now write\n\n  ```agda\n  f : A\n  g : B[f]\n  f = a[f, g]\n
  \ g = b[f, g].\n  ```\n\n  With the new style you have more freedom in choosing
  the order in\n  which things are type checked (previously type signatures were\n
  \ always checked before definitions). Furthermore you can mix\n  arbitrary declarations,
  such as modules and postulates, with\n  mutually recursive definitions.\n\n  For
  data types and records the following new syntax is used to\n  separate the declaration
  from the definition:\n\n  ```agda\n  -- Declaration.\n  data Vec (A : Set) : Nat
  → Set  -- Note the absence of 'where'.\n\n  -- Definition.\n  data Vec A where\n
  \   []   : Vec A zero\n    _::_ : {n : Nat} → A → Vec A n → Vec A (suc n)\n\n  --
  Declaration.\n  record Sigma (A : Set) (B : A → Set) : Set\n\n  -- Definition.\n
  \ record Sigma A B where\n    constructor _,_\n    field fst : A\n          snd
  : B fst\n  ```\n\n  When making separated declarations/definitions private or abstract\n
  \ you should attach the `private` keyword to the declaration and the\n  `abstract`
  keyword to the definition. For instance, a private,\n  abstract function can be
  defined as\n\n  ```agda\n  private\n    f : A\n  abstract\n    f = e\n  ```\n\n
  \ Finally it may be worth noting that the old style of mutually\n  recursive definitions
  is still supported (it basically desugars into\n  the new style).\n\n* Pattern matching
  lambdas.\n\n  Anonymous pattern matching functions can be defined using the syntax\n\n
  \ ```\n  \\ { p11 .. p1n -> e1 ; ... ; pm1 .. pmn -> em }\n  ```\n\n  (where, as
  usual, `\\` and `->` can be replaced by `λ` and\n  `→`). Internally this is translated
  into a function definition of\n  the following form:\n\n  ```\n  .extlam p11 ..
  p1n = e1\n  ...\n  .extlam pm1 .. pmn = em\n  ```\n\n  This means that anonymous
  pattern matching functions are generative.\n  For instance, `refl` will not be accepted
  as an inhabitant of the type\n\n  ```agda\n  (λ { true → true ; false → false })
  ≡\n  (λ { true → true ; false → false }),\n  ```\n\n  because this is equivalent
  to `extlam1 ≡ extlam2` for some distinct\n  fresh names `extlam1` and `extlam2`.\n\n
  \ Currently the `where` and `with` constructions are not allowed in\n  (the top-level
  clauses of) anonymous pattern matching functions.\n\n  Examples:\n\n  ```agda\n
  \ and : Bool → Bool → Bool\n  and = λ { true x → x ; false _ → false }\n\n  xor
  : Bool → Bool → Bool\n  xor = λ { true  true  → false\n          ; false false →
  false\n          ; _     _     → true\n          }\n\n  fst : {A : Set} {B : A →
  Set} → Σ A B → A\n  fst = λ { (a , b) → a }\n\n  snd : {A : Set} {B : A → Set} (p
  : Σ A B) → B (fst p)\n  snd = λ { (a , b) → b }\n  ```\n\n* Record update syntax.\n\n
  \ Assume that we have a record type and a corresponding value:\n\n  ```agda\n  record
  MyRecord : Set where\n    field\n      a b c : ℕ\n\n  old : MyRecord\n  old = record
  { a = 1; b = 2; c = 3 }\n  ```\n\n  Then we can update (some of) the record value's
  fields in the\n  following way:\n\n  ```agda\n  new : MyRecord\n  new = record old
  { a = 0; c = 5 }\n  ```\n\n  Here new normalises to `record { a = 0; b = 2; c =
  5 }`. Any\n  expression yielding a value of type `MyRecord` can be used instead
  of\n  old.\n\n  Record updating is not allowed to change types: the resulting value\n
  \ must have the same type as the original one, including the record\n  parameters.
  Thus, the type of a record update can be inferred if the\n  type of the original
  record can be inferred.\n\n  The record update syntax is expanded before type checking.
  When the\n  expression\n\n  ```agda\n  record old { upd-fields }\n  ```\n\n  is
  checked against a record type `R`, it is expanded to\n\n  ```agda\n  let r = old
  in record { new-fields },\n  ```\n\n  where old is required to have type `R` and
  new-fields is defined as\n  follows: for each field `x` in `R`,\n\n    - if `x =
  e` is contained in `upd-fields` then `x = e` is included in\n      `new-fields`,
  and otherwise\n\n    - if `x` is an explicit field then `x = R.x r` is included
  in\n      `new-fields`, and\n\n    - if `x` is an implicit or instance field, then
  it is omitted from\n      `new-fields`.\n\n  (Instance arguments are explained below.)
  The reason for treating\n  implicit and instance fields specially is to allow code
  like the\n  following:\n\n  ```agda\n  record R : Set where\n    field\n      {length}
  : ℕ\n      vec      : Vec ℕ length\n      -- More fields…\n\n  xs : R\n  xs = record
  { vec = 0 ∷ 1 ∷ 2 ∷ [] }\n\n  ys = record xs { vec = 0 ∷ [] }\n  ```\n\n  Without
  the special treatment the last expression would need to\n  include a new binding
  for length (for instance `length = _`).\n\n* Record patterns which do not contain
  data type patterns, but which\n  do contain dot patterns, are no longer rejected.\n\n*
  When the `--without-K` flag is used literals are now treated as\n  constructors.\n\n*
  Under-applied functions can now reduce.\n\n  Consider the following definition:\n\n
  \ ```agda\n  id : {A : Set} → A → A\n  id x = x\n  ```\n\n  Previously the expression
  `id` would not reduce. This has been\n  changed so that it now reduces to `λ x → x`.
  Usually this makes\n  little difference, but it can be important in conjunction
  with\n  `with`. See Issue [#365](https://github.com/agda/agda/issues/365)\n  for
  an example.\n\n* Unused AgdaLight legacy syntax `(x y : A; z v : B)` for telescopes\n
  \ has been removed.\n\n### Universe polymorphism\n\n* Universe polymorphism is now
  enabled by default.  Use\n  `--no-universe-polymorphism` to disable it.\n\n* Universe
  levels are no longer defined as a data type.\n\n  The basic level combinators can
  be introduced in the following way:\n\n  ```agda\n  postulate\n    Level : Set\n
  \   zero  : Level\n    suc   : Level → Level\n    max   : Level → Level → Level\n\n
  \ {-# BUILTIN LEVEL     Level #-}\n  {-# BUILTIN LEVELZERO zero  #-}\n  {-# BUILTIN
  LEVELSUC  suc   #-}\n  {-# BUILTIN LEVELMAX  max   #-}\n  ```\n\n* The BUILTIN equality
  is now required to be universe-polymorphic.\n\n* `trustMe` is now universe-polymorphic.\n\n###
  Meta-variables and unification\n\n* Unsolved meta-variables are now frozen after
  every mutual block.\n  This means that they cannot be instantiated by subsequent
  code. For\n  instance,\n\n  ```agda\n  one : Nat\n  one = _\n\n  bla : one ≡ suc
  zero\n  bla = refl\n  ```\n\n  leads to an error now, whereas previously it lead
  to the\n  instantiation of `_` with `suc zero`. If you want to make use of the\n
  \ old behaviour, put the two definitions in a mutual block.\n\n  All meta-variables
  are unfrozen during interactive editing, so that\n  the user can fill holes interactively.
  Note that type-checking of\n  interactively given terms is not perfect: Agda sometimes
  refuses to\n  load a file, even though no complaints were raised during the\n  interactive
  construction of the file. This is because certain checks\n  (for instance, positivity)
  are only invoked when a file is loaded.\n\n* Record types can now be inferred.\n\n
  \ If there is a unique known record type with fields matching the\n  fields in a
  record expression, then the type of the expression will\n  be inferred to be the
  record type applied to unknown parameters.\n\n  If there is no known record type
  with the given fields the type\n  checker will give an error instead of producing
  lots of unsolved\n  meta-variables.\n\n  Note that \"known record type\" refers
  to any record type in any\n  imported module, not just types which are in scope.\n\n*
  The occurrence checker distinguishes rigid and strongly rigid\n  occurrences [Reed,
  LFMTP 2009; Abel & Pientka, TLCA 2011].\n\n  The completeness checker now accepts
  the following code:\n\n  ```agda\n  h : (n : Nat) → n ≡ suc n → Nat\n  h n ()\n
  \ ```\n\n  Internally this generates a constraint `_n = suc _n` where the\n  meta-variable
  `_n` occurs strongly rigidly, i.e. on a constructor\n  path from the root, in its
  own defining term tree. This is never\n  solvable.\n\n  Weakly rigid recursive occurrences
  may have a solution [Jason Reed's\n  PhD thesis, page 106]:\n\n  ```agda\n  test
  : (k : Nat) →\n         let X : (Nat → Nat) → Nat\n             X = _\n         in\n
  \        (f : Nat → Nat) → X f ≡ suc (f (X (λ x → k)))\n  test k f = refl\n  ```\n\n
  \ The constraint `_X k f = suc (f (_X k (λ x → k)))` has the solution\n  `_X k f
  = suc (f (suc k))`, despite the recursive occurrence of\n  `_X`.  Here `_X` is not
  strongly rigid, because it occurs under the\n  bound variable `f`. Previously Agda
  rejected this code; now it instead\n  complains about an unsolved meta-variable.\n\n*
  Equation constraints involving the same meta-variable in the head\n  now trigger
  pruning [Pientka, PhD, Sec. 3.1.2; Abel & Pientka, TLCA\n  2011]. Example:\n\n  ```agda\n
  \ same : let X : A → A → A → A × A\n             X = _\n         in {x y z : A}
  → X x y y ≡ (x , y)\n                        × X x x y ≡ X x y y\n  same = refl
  , refl\n  ```\n\n  The second equation implies that `X` cannot depend on its second\n
  \ argument. After pruning the first equation is linear and can be\n  solved.\n\n*
  Instance arguments.\n\n  A new type of hidden function arguments has been added:
  instance\n  arguments. This new feature is based on influences from Scala's\n  implicits
  and Agda's existing implicit arguments.\n\n  Plain implicit arguments are marked
  by single braces: `{…}`. Instance\n  arguments are instead marked by double braces:
  `{{…}}`. Example:\n\n  ```agda\n  postulate\n    A : Set\n    B : A → Set\n    a
  : A\n    f : {{a : A}} → B a\n  ```\n\n  Instead of the double braces you can use
  the symbols `⦃` and `⦄`,\n  but these symbols must in many cases be surrounded by\n
  \ whitespace. (If you are using Emacs and the Agda input method, then\n  you can
  conjure up the symbols by typing `\\{{` and `\\}}`,\n  respectively.)\n\n  Instance
  arguments behave as ordinary implicit arguments, except for\n  one important aspect:
  resolution of arguments which are not provided\n  explicitly. For instance, consider
  the following code:\n\n  ```agda\n    test = f\n  ```\n\n  Here Agda will notice
  that `f`'s instance argument was not provided\n  explicitly, and try to infer it.
  All definitions in scope at `f`'s\n  call site, as well as all variables in the
  context, are considered.\n  If exactly one of these names has the required type
  `A`, then the\n  instance argument will be instantiated to this name.\n\n  This
  feature can be used as an alternative to Haskell type classes.\n  If we define\n\n
  \ ```agda\n  record Eq (A : Set) : Set where\n    field equal : A → A → Bool,\n
  \ ```\n\n  then we can define the following projection:\n\n  ```agda\n  equal :
  {A : Set} {{eq : Eq A}} → A → A → Bool\n  equal {{eq}} = Eq.equal eq\n  ```\n\n
  \ Now consider the following expression:\n\n  ```agda\n  equal false false ∨ equal
  3 4\n  ```\n\n  If the following `Eq` \"instances\" for `Bool` and `ℕ` are in scope,
  and no\n  others, then the expression is accepted:\n\n  ```agda\n  eq-Bool : Eq
  Bool\n  eq-Bool = record { equal = … }\n\n  eq-ℕ : Eq ℕ\n  eq-ℕ = record { equal
  = … }\n  ```\n\n  A shorthand notation is provided to avoid the need to define\n
  \ projection functions manually:\n\n  ```agda\n  module Eq-with-implicits = Eq {{...}}\n
  \ ```\n\n  This notation creates a variant of `Eq`'s record module, where the\n
  \ main `Eq` argument is an instance argument instead of an explicit one.\n  It is
  equivalent to the following definition:\n\n  ```agda\n  module Eq-with-implicits
  {A : Set} {{eq : Eq A}} = Eq eq\n  ```\n\n  Note that the short-hand notation allows
  you to avoid naming the\n  \"-with-implicits\" module:\n\n  ```agda\n  open Eq {{...}}\n
  \ ```\n\n  Instance argument resolution is not recursive. As an example,\n  consider
  the following \"parametrised instance\":\n\n  ```agda\n  eq-List : {A : Set} → Eq
  A → Eq (List A)\n  eq-List {A} eq = record { equal = eq-List-A }\n    where\n    eq-List-A
  : List A → List A → Bool\n    eq-List-A []       []       = true\n    eq-List-A
  (a ∷ as) (b ∷ bs) = equal a b ∧ eq-List-A as bs\n    eq-List-A _        _        =
  false\n  ```\n\n  Assume that the only `Eq` instances in scope are `eq-List` and\n
  \ `eq-ℕ`.  Then the following code does not type-check:\n\n  ```agda\n  test = equal
  (1 ∷ 2 ∷ []) (3 ∷ 4 ∷ [])\n  ```\n\n  However, we can make the code work by constructing
  a suitable\n  instance manually:\n\n  ```agda\n  test′ = equal (1 ∷ 2 ∷ []) (3 ∷
  4 ∷ [])\n    where eq-List-ℕ = eq-List eq-ℕ\n  ```\n\n  By restricting the \"instance
  search\" to be non-recursive we avoid\n  introducing a new, compile-time-only evaluation
  model to Agda.\n\n  For more information about instance arguments, see Devriese
  &\n  Piessens [ICFP 2011]. Some examples are also available in the\n  examples/instance-arguments
  subdirectory of the Agda distribution.\n\n### Irrelevance\n\n* Dependent irrelevant
  function types.\n\n  Some examples illustrating the syntax of dependent irrelevant\n
  \ function types:\n\n  ```\n  .(x y : A) → B    .{x y z : A} → B\n  ∀ x .y → B        ∀
  x .{y} {z} .v → B\n  ```\n\n  The declaration\n\n  ```\n  f : .(x : A) → B[x]\n
  \ f x = t[x]\n  ```\n\n  requires that `x` is irrelevant both in `t[x]` and in `B[x]`.
  This\n  is possible if, for instance, `B[x] = B′ x`, with `B′ : .A → Set`.\n\n  Dependent
  irrelevance allows us to define the eliminator for the\n  `Squash` type:\n\n  ```agda\n
  \ record Squash (A : Set) : Set where\n    constructor squash\n    field\n      .proof
  : A\n\n  elim-Squash : {A : Set} (P : Squash A → Set)\n                (ih : .(a
  : A) → P (squash a)) →\n                (a⁻ : Squash A) → P a⁻\n  elim-Squash P
  ih (squash a) = ih a\n  ```\n\n  Note that this would not type-check with\n\n  ```agda\n
  \ (ih : (a : A) -> P (squash a)).\n  ```\n\n* Records with only irrelevant fields.\n\n
  \ The following now works:\n\n  ```agda\n  record IsEquivalence {A : Set} (_≈_ :
  A → A → Set) : Set where\n    field\n      .refl  : Reflexive _≈_\n      .sym   :
  Symmetric _≈_\n      .trans : Transitive _≈_\n\n  record Setoid : Set₁ where\n    infix
  4 _≈_\n    field\n      Carrier        : Set\n      _≈_            : Carrier → Carrier
  → Set\n      .isEquivalence : IsEquivalence _≈_\n\n    open IsEquivalence isEquivalence
  public\n  ```\n\n  Previously Agda complained about the application\n  `IsEquivalence isEquivalence`,
  because `isEquivalence` is irrelevant\n  and the `IsEquivalence` module expected
  a relevant argument. Now,\n  when record modules are generated for records consisting
  solely of\n  irrelevant arguments, the record parameter is made irrelevant:\n\n
  \  ```agda\n  module IsEquivalence {A : Set} {_≈_ : A → A → Set}\n                       .(r
  : IsEquivalence {A = A} _≈_) where\n    …\n  ```\n\n* Irrelevant things are no longer
  erased internally. This means that\n  they are printed as ordinary terms, not as
  `_` as before.\n\n* The new flag `--experimental-irrelevance` enables irrelevant\n
  \ universe levels and matching on irrelevant data when only one\n  constructor is
  available. These features are very experimental and\n  likely to change or disappear.\n\n###
  Reflection\n\n* The reflection API has been extended to mirror features like\n  irrelevance,
  instance arguments and universe polymorphism, and to\n  give (limited) access to
  definitions. For completeness all the\n  builtins and primitives are listed below:\n\n
  \ ```agda\n  -- Names.\n\n  postulate Name : Set\n\n  {-# BUILTIN QNAME Name #-}\n\n
  \ primitive\n    -- Equality of names.\n    primQNameEquality : Name → Name → Bool\n\n
  \ -- Is the argument visible (explicit), hidden (implicit), or an\n  -- instance
  argument?\n\n  data Visibility : Set where\n    visible hidden instance : Visibility\n\n
  \ {-# BUILTIN HIDING   Visibility #-}\n  {-# BUILTIN VISIBLE  visible    #-}\n  {-#
  BUILTIN HIDDEN   hidden     #-}\n  {-# BUILTIN INSTANCE instance   #-}\n\n  -- Arguments
  can be relevant or irrelevant.\n\n  data Relevance : Set where\n    relevant irrelevant
  : Relevance\n\n  {-# BUILTIN RELEVANCE  Relevance  #-}\n  {-# BUILTIN RELEVANT   relevant
  \  #-}\n  {-# BUILTIN IRRELEVANT irrelevant #-}\n\n  -- Arguments.\n\n  data Arg
  A : Set where\n    arg : (v : Visibility) (r : Relevance) (x : A) → Arg A\n\n  {-#
  BUILTIN ARG    Arg #-}\n  {-# BUILTIN ARGARG arg #-}\n\n  -- Terms.\n\n  mutual\n
  \   data Term : Set where\n      -- Variable applied to arguments.\n      var     :
  (x : ℕ) (args : List (Arg Term)) → Term\n      -- Constructor applied to arguments.\n
  \     con     : (c : Name) (args : List (Arg Term)) → Term\n      -- Identifier
  applied to arguments.\n      def     : (f : Name) (args : List (Arg Term)) → Term\n
  \     -- Different kinds of λ-abstraction.\n      lam     : (v : Visibility) (t
  : Term) → Term\n      -- Pi-type.\n      pi      : (t₁ : Arg Type) (t₂ : Type) →
  Term\n      -- A sort.\n      sort    : Sort → Term\n      -- Anything else.\n      unknown
  : Term\n\n    data Type : Set where\n      el : (s : Sort) (t : Term) → Type\n\n
  \   data Sort : Set where\n      -- A Set of a given (possibly neutral) level.\n
  \     set     : (t : Term) → Sort\n      -- A Set of a given concrete level.\n      lit
  \    : (n : ℕ) → Sort\n      -- Anything else.\n      unknown : Sort\n\n  {-# BUILTIN
  AGDASORT            Sort    #-}\n  {-# BUILTIN AGDATYPE            Type    #-}\n
  \ {-# BUILTIN AGDATERM            Term    #-}\n  {-# BUILTIN AGDATERMVAR         var
  \    #-}\n  {-# BUILTIN AGDATERMCON         con     #-}\n  {-# BUILTIN AGDATERMDEF
  \        def     #-}\n  {-# BUILTIN AGDATERMLAM         lam     #-}\n  {-# BUILTIN
  AGDATERMPI          pi      #-}\n  {-# BUILTIN AGDATERMSORT        sort    #-}\n
  \ {-# BUILTIN AGDATERMUNSUPPORTED unknown #-}\n  {-# BUILTIN AGDATYPEEL          el
  \     #-}\n  {-# BUILTIN AGDASORTSET         set     #-}\n  {-# BUILTIN AGDASORTLIT
  \        lit     #-}\n  {-# BUILTIN AGDASORTUNSUPPORTED unknown #-}\n\n  postulate\n
  \   -- Function definition.\n    Function  : Set\n    -- Data type definition.\n
  \   Data-type : Set\n    -- Record type definition.\n    Record    : Set\n\n  {-#
  BUILTIN AGDAFUNDEF    Function  #-}\n  {-# BUILTIN AGDADATADEF   Data-type #-}\n
  \ {-# BUILTIN AGDARECORDDEF Record    #-}\n\n  -- Definitions.\n\n  data Definition
  : Set where\n    function     : Function  → Definition\n    data-type    : Data-type
  → Definition\n    record′      : Record    → Definition\n    constructor′ : Definition\n
  \   axiom        : Definition\n    primitive′   : Definition\n\n  {-# BUILTIN AGDADEFINITION
  \               Definition   #-}\n  {-# BUILTIN AGDADEFINITIONFUNDEF          function
  \    #-}\n  {-# BUILTIN AGDADEFINITIONDATADEF         data-type    #-}\n  {-# BUILTIN
  AGDADEFINITIONRECORDDEF       record′      #-}\n  {-# BUILTIN AGDADEFINITIONDATACONSTRUCTOR
  constructor′ #-}\n  {-# BUILTIN AGDADEFINITIONPOSTULATE       axiom        #-}\n
  \ {-# BUILTIN AGDADEFINITIONPRIMITIVE       primitive′   #-}\n\n  primitive\n    --
  The type of the thing with the given name.\n    primQNameType        : Name → Type\n
  \   -- The definition of the thing with the given name.\n    primQNameDefinition
  \ : Name → Definition\n    -- The constructors of the given data type.\n    primDataConstructors
  : Data-type → List Name\n  ```\n\n  As an example the expression\n\n  ```agda\n
  \ primQNameType (quote zero)\n  ```\n\n  is definitionally equal to\n\n  ```agda\n
  \ el (lit 0) (def (quote ℕ) [])\n  ```\n\n  (if `zero` is a constructor of the data
  type `ℕ`).\n\n* New keyword: `unquote`.\n\n  The construction `unquote t` converts
  a representation of an Agda term\n  to actual Agda code in the following way:\n\n
  \ 1. The argument `t` must have type `Term` (see the reflection API above).\n\n
  \ 2. The argument is normalised.\n\n  3. The entire construction is replaced by
  the normal form, which is\n     treated as syntax written by the user and type-checked
  in the\n     usual way.\n\n  Examples:\n\n  ```agda\n  test : unquote (def (quote
  ℕ) []) ≡ ℕ\n  test = refl\n\n  id : (A : Set) → A → A\n  id = unquote (lam visible
  (lam visible (var 0 [])))\n\n  id-ok : id ≡ (λ A (x : A) → x)\n  id-ok = refl\n
  \ ```\n\n* New keyword: `quoteTerm`.\n\n  The construction `quoteTerm t` is similar
  to `quote n`, but whereas\n  `quote` is restricted to names `n`, `quoteTerm` accepts
  terms\n  `t`. The construction is handled in the following way:\n\n  1. The type
  of `t` is inferred. The term `t` must be type-correct.\n\n  2. The term `t` is normalised.\n\n
  \ 3. The construction is replaced by the Term representation (see the\n     reflection
  API above) of the normal form. Any unsolved metavariables\n     in the term are
  represented by the `unknown` term constructor.\n\n  Examples:\n\n  ```agda\n  test₁
  : quoteTerm (λ {A : Set} (x : A) → x) ≡\n          lam hidden (lam visible (var
  0 []))\n  test₁ = refl\n\n  -- Local variables are represented as de Bruijn indices.\n
  \ test₂ : (λ {A : Set} (x : A) → quoteTerm x) ≡ (λ x → var 0 [])\n  test₂ = refl\n\n
  \ -- Terms are normalised before being quoted.\n  test₃ : quoteTerm (0 + 0) ≡ con
  (quote zero) []\n  test₃ = refl\n  ```\n\nCompiler backends\n-----------------\n\n###
  MAlonzo\n\n* The MAlonzo backend's FFI now handles universe polymorphism in a\n
  \ better way.\n\n  The translation of Agda types and kinds into Haskell now supports\n
  \ universe-polymorphic postulates. The core changes are that the\n  translation
  of function types has been changed from\n\n  ```\n  T[[ Pi (x : A) B ]] =\n    if
  A has a Haskell kind then\n      forall x. () -> T[[ B ]]\n    else if x in fv B
  then\n      undef\n    else\n      T[[ A ]] -> T[[ B ]]\n  ```\n\n  into\n\n  ```\n
  \ T[[ Pi (x : A) B ]] =\n    if x in fv B then\n      forall x. T[[ A ]] -> T[[
  B ]]  -- Note: T[[A]] not Unit.\n    else\n      T[[ A ]] -> T[[ B ]],\n  ```\n\n
  \ and that the translation of constants (postulates, constructors and\n  literals)
  has been changed from\n\n  ```\n  T[[ k As ]] =\n    if COMPILED_TYPE k T then\n
  \     T T[[ As ]]\n    else\n      undef\n  ```\n\n  into\n\n  ```\n  T[[ k As ]]
  =\n    if COMPILED_TYPE k T then\n      T T[[ As ]]\n    else if COMPILED k E then\n
  \     ()\n    else\n      undef.\n  ```\n\n  For instance, assuming a Haskell definition\n\n
  \ ```haskell\n    type AgdaIO a b = IO b,\n  ```\n\n  we can set up universe-polymorphic
  `IO` in the following way:\n\n  ```agda\n  postulate\n    IO     : ∀ {ℓ} → Set ℓ
  → Set ℓ\n    return : ∀ {a} {A : Set a} → A → IO A\n    _>>=_  : ∀ {a b} {A : Set
  a} {B : Set b} →\n             IO A → (A → IO B) → IO B\n\n  {-# COMPILED_TYPE IO
  AgdaIO              #-}\n  {-# COMPILED return  (\\_ _ -> return)    #-}\n  {-#
  COMPILED _>>=_   (\\_ _ _ _ -> (>>=)) #-}\n  ```\n\n  This is accepted because (assuming
  that the universe level type is\n  translated to the Haskell unit type `()`)\n\n
  \ ```haskell\n  (\\_ _ -> return)\n    : forall a. () -> forall b. () -> b -> AgdaIO
  a b\n    = T [[ ∀ {a} {A : Set a} → A → IO A ]]\n  ```\n\n  and\n\n  ```haskell\n
  \ (\\_ _ _ _ -> (>>=))\n    : forall a. () -> forall b. () ->\n        forall c.
  () -> forall d. () ->\n          AgdaIO a c -> (c -> AgdaIO b d) -> AgdaIO b d\n
  \   = T [[ ∀ {a b} {A : Set a} {B : Set b} →\n             IO A → (A → IO B) → IO
  B ]].\n  ```\n\n### Epic\n\n* New Epic backend pragma: `STATIC`.\n\n  In the Epic
  backend, functions marked with the `STATIC` pragma will be\n  normalised before
  compilation. Example usage:\n\n  ```\n  {-# STATIC power #-}\n\n  power : ℕ → ℕ
  → ℕ\n  power 0       x = 1\n  power 1       x = x\n  power (suc n) x = power n x
  * x\n  ```\n\n  Occurrences of `power 4 x` will be replaced by `((x * x) * x) *
  x`.\n\n* Some new optimisations have been implemented in the Epic backend:\n\n  -
  Removal of unused arguments.\n\n  A worker/wrapper transformation is performed so
  that unused\n  arguments can be removed by Epic's inliner. For instance, the map\n
  \ function is transformed in the following way:\n\n  ```agda\n  map_wrap : (A B
  : Set) → (A → B) → List A → List B\n  map_wrap A B f xs = map_work f xs\n\n  map_work
  f []       = []\n  map_work f (x ∷ xs) = f x ∷ map_work f xs\n  ```\n\n  If `map_wrap`
  is inlined (which it will be in any saturated call),\n  then `A` and `B` disappear
  in the generated code.\n\n  Unused arguments are found using abstract interpretation.
  The bodies\n  of all functions in a module are inspected to decide which variables\n
  \ are used. The behaviour of postulates is approximated based on their\n  types.
  Consider `return`, for instance:\n\n  ```agda\n  postulate return : {A : Set} →
  A → IO A\n  ```\n\n  The first argument of `return` can be removed, because it is
  of type\n  Set and thus cannot affect the outcome of a program at runtime.\n\n  -
  Injection detection.\n\n  At runtime many functions may turn out to be inefficient
  variants of\n  the identity function. This is especially true after forcing.\n  Injection
  detection replaces some of these functions with more\n  efficient versions. Example:\n\n
  \ ```agda\n  inject : {n : ℕ} → Fin n → Fin (1 + n)\n  inject {suc n} zero    =
  zero\n  inject {suc n} (suc i) = suc (inject {n} i)\n  ```\n\n  Forcing removes
  the `Fin` constructors' `ℕ` arguments, so this\n  function is an inefficient identity
  function that can be replaced by\n  the following one:\n\n  ```agda\n  inject {_}
  x = x\n  ```\n\n  To actually find this function, we make the induction hypothesis\n
  \ that inject is an identity function in its second argument and look\n  at the
  branches of the function to decide if this holds.\n\n  Injection detection also
  works over data type barriers. Example:\n\n  ```agda\n  forget : {A : Set} {n :
  ℕ} → Vec A n → List A\n  forget []       = []\n  forget (x ∷ xs) = x ∷ forget xs\n
  \ ```\n\n  Given that the constructor tags (in the compiled Epic code) for\n  `Vec.[]`
  and `List.[]` are the same, and that the tags for `Vec._∷_`\n  and `List._∷_` are
  also the same, this is also an identity\n  function. We can hence replace the definition
  with the following\n  one:\n\n  ```agda\n  forget {_} xs = xs\n  ```\n\n  To get
  this to apply as often as possible, constructor tags are\n  chosen *after* injection
  detection has been run, in a way to make as\n  many functions as possible injections.\n\n
  \ Constructor tags are chosen once per source file, so it may be\n  advantageous
  to define conversion functions like forget in the same\n  module as one of the data
  types. For instance, if `Vec.agda` imports\n  `List.agda`, then the forget function
  should be put in `Vec.agda` to\n  ensure that vectors and lists get the same tags
  (unless some other\n  injection function, which puts different constraints on the
  tags, is\n  prioritised).\n\n  - Smashing.\n\n  This optimisation finds types whose
  values are inferable at runtime:\n\n    * A data type with only one constructor
  where all fields are\n      inferable is itself inferable.\n\n    * `Set ℓ` is inferable
  (as it has no runtime representation).\n\n  A function returning an inferable data
  type can be smashed, which\n  means that it is replaced by a function which simply
  returns the\n  inferred value.\n\n  An important example of an inferable type is
  the usual propositional\n  equality type (`_≡_`). Any function returning a propositional\n
  \ equality can simply return the reflexivity constructor directly\n  without computing
  anything.\n\n  This optimisation makes more arguments unused. It also makes the\n
  \ Epic code size smaller, which in turn speeds up compilation.\n\n### JavaScript\n\n*
  ECMAScript compiler backend.\n\n  A new compiler backend is being implemented, targetting
  ECMAScript\n  (also known as JavaScript), with the goal of allowing Agda programs\n
  \ to be run in browsers or other ECMAScript environments.\n\n  The backend is still
  at an experimental stage: the core language is\n  implemented, but many features
  are still missing.\n\n  The ECMAScript compiler can be invoked from the command
  line using\n  the flag `--js`:\n\n  ```\n  agda --js --compile-dir=<DIR> <FILE>.agda\n
  \ ```\n\n  Each source `<FILE>.agda` is compiled into an ECMAScript target\n  `<DIR>/jAgda.<TOP-LEVEL
  MODULE NAME>.js`. The compiler can also be\n  invoked using the Emacs mode (the
  variable `agda2-backend` controls\n  which backend is used).\n\n  Note that ECMAScript
  is a strict rather than lazy language. Since\n  Agda programs are total, this should
  not impact program semantics,\n  but it may impact their space or time usage.\n\n
  \ ECMAScript does not support algebraic datatypes or pattern-matching.\n  These
  features are translated to a use of the visitor pattern. For\n  instance, the standard
  library's `List` data type and `null`\n  function are translated into the following
  code:\n\n  ```javascript\n  exports[\"List\"] = {};\n  exports[\"List\"][\"[]\"]
  = function (x0) {\n      return x0[\"[]\"]();\n    };\n  exports[\"List\"][\"_∷_\"]
  = function (x0) {\n      return function (x1) {\n        return function (x2) {\n
  \         return x2[\"_∷_\"](x0, x1);\n        };\n      };\n    };\n\n  exports[\"null\"]
  = function (x0) {\n      return function (x1) {\n        return function (x2) {\n
  \         return x2({\n            \"[]\": function () {\n              return jAgda_Data_Bool[\"Bool\"][\"true\"];\n
  \           },\n            \"_∷_\": function (x3, x4) {\n              return jAgda_Data_Bool[\"Bool\"][\"false\"];\n
  \           }\n          });\n        };\n      };\n    };\n  ```\n\n  Agda records
  are translated to ECMAScript objects, preserving field\n  names.\n\n  Top-level
  Agda modules are translated to ECMAScript modules,\n  following the `common.js`
  module specification. A top-level Agda\n  module `Foo.Bar` is translated to an ECMAScript
  module\n  `jAgda.Foo.Bar`.\n\n  The ECMAScript compiler does not compile to Haskell,
  so the pragmas\n  related to the Haskell FFI (`IMPORT`, `COMPILED_DATA` and\n  `COMPILED`)
  are not used by the ECMAScript backend. Instead, there\n  is a `COMPILED_JS` pragma
  which may be applied to any\n  declaration. For postulates, primitives, functions
  and values, it\n  gives the ECMAScript code to be emitted by the compiler. For data\n
  \ types, it gives a function which is applied to a value of that type,\n  and a
  visitor object. For instance, a binding of natural numbers to\n  ECMAScript integers
  (ignoring overflow errors) is:\n\n  ```agda\n  data ℕ : Set where\n    zero : ℕ\n
  \   suc  : ℕ → ℕ\n\n  {-# COMPILED_JS ℕ function (x,v) {\n      if (x < 1) { return
  v.zero(); } else { return v.suc(x-1); }\n    } #-}\n  {-# COMPILED_JS zero 0 #-}\n
  \ {-# COMPILED_JS suc function (x) { return x+1; } #-}\n\n  _+_ : ℕ → ℕ → ℕ\n  zero
  \ + n = n\n  suc m + n = suc (m + n)\n\n  {-# COMPILED_JS _+_ function (x) { return
  function (y) {\n                        return x+y; };\n    } #-}\n  ```\n\n  To
  allow FFI code to be optimised, the ECMAScript in a `COMPILED_JS`\n  declaration
  is parsed, using a simple parser that recognises a pure\n  functional subset of
  ECMAScript, consisting of functions, function\n  applications, return, if-statements,
  if-expressions,\n  side-effect-free binary operators (no precedence, left associative),\n
  \ side-effect-free prefix operators, objects (where all member names\n  are quoted),
  field accesses, and string and integer literals.\n  Modules may be imported using
  the require (`<module-id>`) syntax: any\n  impure code, or code outside the supported
  fragment, can be placed\n  in a module and imported.\n\nTools\n-----\n\n* New flag
  `--safe`, which can be used to type-check untrusted code.\n\n  This flag disables
  postulates, `primTrustMe`, and \"unsafe\" OPTION\n  pragmas, some of which are known
  to make Agda inconsistent.\n\n  Rejected pragmas:\n\n  ```\n  --allow-unsolved-metas\n
  \ --experimental-irrelevance\n  --guardedness-preserving-type-construtors\n  --injective-type-constructors\n
  \ --no-coverage-check\n  --no-positivity-check\n  --no-termination-check\n  --sized-types\n
  \ --type-in-type\n  ```\n\n  Note that, at the moment, it is not possible to define
  the universe\n  level or coinduction primitives when `--safe` is used (because they\n
  \ must be introduced as postulates). This can be worked around by\n  type-checking
  trusted files in a first pass, without using `--safe`,\n  and then using `--saf`e
  in a second pass. Modules which have already\n  been type-checked are not re-type-checked
  just because `--safe` is\n  used.\n\n* Dependency graphs.\n\n  The new flag `--dependency-graph=FILE`
  can be used to generate a DOT\n  file containing a module dependency graph. The
  generated file (FILE)\n  can be rendered using a tool like dot.\n\n* The `--no-unreachable-check`
  flag has been removed.\n\n* Projection functions are highlighted as functions instead
  of as\n  fields. Field names (in record definitions and record values) are\n  still
  highlighted as fields.\n\n* Support for jumping to positions mentioned in the information\n
  \ buffer has been added.\n\n* The `make install` command no longer installs Agda
  globally (by\n  default).\n\nRelease notes for Agda 2 version 2.2.10\n=======================================\n\nLanguage\n--------\n\n*
  New flag: `--without-K`.\n\n  This flag makes pattern matching more restricted.
  If the flag is\n  activated, then Agda only accepts certain case-splits. If the
  type\n  of the variable to be split is `D pars ixs`, where `D` is a data (or\n  record)
  type, pars stands for the parameters, and `ixs` the indices,\n  then the following
  requirements must be satisfied:\n\n  - The indices `ixs` must be applications of
  constructors to distinct\n    variables.\n\n  - These variables must not be free
  in pars.\n\n  The intended purpose of `--without-K` is to enable experiments with\n
  \ a propositional equality without the K rule. Let us define\n  propositional equality
  as follows:\n\n  ```agda\n  data _≡_ {A : Set} : A → A → Set where\n    refl : ∀
  x → x ≡ x\n  ```\n\n  Then the obvious implementation of the J rule is accepted:\n\n
  \ ```agda\n  J : {A : Set} (P : {x y : A} → x ≡ y → Set) →\n      (∀ x → P (refl
  x)) →\n      ∀ {x y} (x≡y : x ≡ y) → P x≡y\n  J P p (refl x) = p x\n  ```\n\n  The
  same applies to Christine Paulin-Mohring's version of the J rule:\n\n  ```agda\n
  \ J′ : {A : Set} {x : A} (P : {y : A} → x ≡ y → Set) →\n       P (refl x) →\n       ∀
  {y} (x≡y : x ≡ y) → P x≡y\n  J′ P p (refl x) = p\n  ```\n\n  On the other hand,
  the obvious implementation of the K rule is not\n  accepted:\n\n  ```agda\n  K :
  {A : Set} (P : {x : A} → x ≡ x → Set) →\n      (∀ x → P (refl x)) →\n      ∀ {x}
  (x≡x : x ≡ x) → P x≡x\n  K P p (refl x) = p x\n  ```\n\n  However, we have *not*
  proved that activation of `--without-K`\n  ensures that the K rule cannot be proved
  in some other way.\n\n* Irrelevant declarations.\n\n  Postulates and functions can
  be marked as irrelevant by prefixing\n  the name with a dot when the name is declared.
  Example:\n\n  ```agda\n  postulate\n    .irrelevant : {A : Set} → .A → A\n  ```\n\n
  \ Irrelevant names may only be used in irrelevant positions or in\n  definitions
  of things which have been declared irrelevant.\n\n  The axiom irrelevant above can
  be used to define a projection from\n  an irrelevant record field:\n\n  ```agda\n
  \ data Subset (A : Set) (P : A → Set) : Set where\n    _#_ : (a : A) → .(P a) →
  Subset A P\n\n  elem : ∀ {A P} → Subset A P → A\n  elem (a # p) = a\n\n  .certificate
  : ∀ {A P} (x : Subset A P) → P (elem x)\n  certificate (a # p) = irrelevant p\n
  \ ```\n\n  The right-hand side of certificate is relevant, so we cannot define\n\n
  \ ```agda\n  certificate (a # p) = p\n  ```\n\n  (because `p` is irrelevant). However,
  certificate is declared to be\n  irrelevant, so it can use the axiom irrelevant.
  Furthermore the\n  first argument of the axiom is irrelevant, which means that\n
  \ irrelevant `p` is well-formed.\n\n  As shown above the axiom irrelevant justifies
  irrelevant\n  projections. Previously no projections were generated for irrelevant\n
  \ record fields, such as the field certificate in the following\n  record type:\n\n
  \ ```agda\n  record Subset (A : Set) (P : A → Set) : Set where\n    constructor
  _#_\n    field\n      elem         : A\n      .certificate : P elem\n  ```\n\n  Now
  projections are generated automatically for irrelevant fields\n  (unless the flag
  `--no-irrelevant-projections` is used). Note that\n  irrelevant projections are
  highly experimental.\n\n* Termination checker recognises projections.\n\n  Projections
  now preserve sizes, both in patterns and expressions.\n  Example:\n\n  ```agda\n
  \ record Wrap (A : Set) : Set where\n    constructor wrap\n    field\n      unwrap
  : A\n\n  open Wrap public\n\n  data WNat : Set where\n    zero : WNat\n    suc  :
  Wrap WNat → WNat\n\n  id : WNat → WNat\n  id zero    = zero\n  id (suc w) = suc
  (wrap (id (unwrap w)))\n  ```\n\n  In the structural ordering `unwrap w` ≤ `w`.
  This means that\n\n  ```agda\n    unwrap w ≤ w < suc w,\n  ```\n\n  and hence the
  recursive call to id is accepted.\n\n  Projections also preserve guardedness.\n\nTools\n-----\n\n*
  Hyperlinks for top-level module names now point to the start of the\n  module rather
  than to the declaration of the module name. This\n  applies both to the Emacs mode
  and to the output of `agda --html`.\n\n* Most occurrences of record field names
  are now highlighted as\n  \"fields\". Previously many occurrences were highlighted
  as\n  \"functions\".\n\n* Emacs mode: It is no longer possible to change the behaviour
  of the\n  `TAB` key by customising `agda2-indentation`.\n\n* Epic compiler backend.\n\n
  \ A new compiler backend is being implemented. This backend makes use\n  of Edwin
  Brady's language Epic\n  (http://www.cs.st-andrews.ac.uk/~eb/epic.php) and its compiler.
  The\n  backend should handle most Agda code, but is still at an\n  experimental
  stage: more testing is needed, and some things written\n  below may not be entirely
  true.\n\n  The Epic compiler can be invoked from the command line using the\n  flag
  `--epic`:\n\n  ```\n  agda --epic --epic-flag=<EPIC-FLAG> --compile-dir=<DIR> <FILE>.agda\n
  \ ```\n\n  The `--epic-flag` flag can be given multiple times; each flag is\n  given
  verbatim to the Epic compiler (in the given order). The\n  resulting executable
  is named after the main module and placed in\n  the directory specified by the `--compile-dir`
  flag (default: the\n  project root). Intermediate files are placed in a subdirectory\n
  \ called `Epic`.\n\n  The backend requires that there is a definition named main.
  This\n  definition should be a value of type `IO Unit`, but at the moment\n  this
  is not checked (so it is easy to produce a program which\n  segfaults).  Currently
  the backend represents actions of type `IO A`\n  as functions from `Unit` to `A`,
  and main is applied to the unit\n  value.\n\n  The Epic compiler compiles via C,
  not Haskell, so the pragmas\n  related to the Haskell FFI (`IMPORT`, `COMPILED_DATA`
  and\n  `COMPILED`) are not used by the Epic backend. Instead there is a new\n  pragma
  `COMPILED_EPIC`. This pragma is used to give Epic code for\n  postulated definitions
  (Epic code can in turn call C code). The form\n  of the pragma is `{-# COMPILED_EPIC def code #-}`,
  where `def` is\n  the name of an Agda postulate and `code` is some Epic code which\n
  \ should include the function arguments, return type and function\n  body. As an
  example the `IO` monad can be defined as follows:\n\n  ```agda\n  postulate\n    IO
  \    : Set → Set\n    return : ∀ {A} → A → IO A\n    _>>=_  : ∀ {A B} → IO A → (A
  → IO B) → IO B\n\n  {-# COMPILED_EPIC return (u : Unit, a : Any) -> Any =\n                      ioreturn(a)
  #-}\n  {-# COMPILED_EPIC\n        _>>=_ (u1 : Unit, u2 : Unit, x : Any, f : Any)
  -> Any =\n          iobind(x,f) #-}\n  ```\n\n  Here `ioreturn` and `iobind` are
  Epic functions which are defined in\n  the file `AgdaPrelude.e` which is always
  included.\n\n  By default the backend will remove so-called forced constructor\n
  \ arguments (and case-splitting on forced variables will be\n  rewritten). This
  optimisation can be disabled by using the flag\n  `--no-forcing`.\n\n  All data
  types which look like unary natural numbers after forced\n  constructor arguments
  have been removed (i.e. types with two\n  constructors, one nullary and one with
  a single recursive argument)\n  will be represented as \"BigInts\". This applies
  to the standard `Fin`\n  type, for instance.\n\n  The backend supports Agda's primitive
  functions and the BUILTIN\n  pragmas. If the BUILTIN pragmas for unary natural numbers
  are used,\n  then some operations, like addition and multiplication, will use\n
  \ more efficient \"BigInt\" operations.\n\n  If you want to make use of the Epic
  backend you need to install some\n  dependencies, see the README.\n\n* The Emacs
  mode can compile using either the MAlonzo or the Epic\n  backend. The variable `agda2-backend`
  controls which backend is\n  used.\n\nRelease notes for Agda 2 version 2.2.8\n======================================\n\nLanguage\n--------\n\n*
  Record pattern matching.\n\n  It is now possible to pattern match on named record
  constructors.\n  Example:\n\n  ```agda\n  record Σ (A : Set) (B : A → Set) : Set
  where\n    constructor _,_\n    field\n      proj₁ : A\n      proj₂ : B proj₁\n\n
  \ map : {A B : Set} {P : A → Set} {Q : B → Set}\n        (f : A → B) → (∀ {x} →
  P x → Q (f x)) →\n        Σ A P → Σ B Q\n  map f g (x , y) = (f x , g y)\n  ```\n\n
  \ The clause above is internally translated into the following one:\n\n  ```agda\n
  \ map f g p = (f (Σ.proj₁ p) , g (Σ.proj₂ p))\n  ```\n\n  Record patterns containing
  data type patterns are not translated.\n  Example:\n\n  ```agda\n  add : ℕ × ℕ →
  ℕ\n  add (zero  , n) = n\n  add (suc m , n) = suc (add (m , n))\n  ```\n\n  Record
  patterns which do not contain data type patterns, but which\n  do contain dot patterns,
  are currently rejected. Example:\n\n  ```agda\n  Foo : {A : Set} (p₁ p₂ : A × A)
  → proj₁ p₁ ≡ proj₁ p₂ → Set₁\n  Foo (x , y) (.x , y′) refl = Set\n  ```\n\n* Proof
  irrelevant function types.\n\n  Agda now supports irrelevant non-dependent function
  types:\n\n  ```agda\n  f : .A → B\n  ```\n\n  This type implies that `f` does not
  depend computationally on its\n  argument. One intended use case is data structures
  with embedded\n  proofs, like sorted lists:\n\n  ```agda\n  postulate\n    _≤_ :
  ℕ → ℕ → Set\n    p₁  : 0 ≤ 1\n    p₂  : 0 ≤ 1\n\n  data SList (bound : ℕ) : Set
  where\n    []    : SList bound\n    scons : (head : ℕ) →\n            .(head ≤ bound)
  →\n            (tail : SList head) →\n            SList bound\n  ```\n\n  The effect
  of the irrelevant type in the signature of `scons` is\n  that `scons`'s second argument
  is never inspected after Agda has\n  ensured that it has the right type. It is even
  thrown away, leading\n  to smaller term sizes and hopefully some gain in efficiency.
  The\n  type-checker ignores irrelevant arguments when checking equality, so\n  two
  lists can be equal even if they contain different proofs:\n\n  ```agda\n  l₁ : SList
  1\n  l₁ = scons 0 p₁ []\n\n  l₂ : SList 1\n  l₂ = scons 0 p₂ []\n\n  l₁≡l₂ : l₁
  ≡ l₂\n  l₁≡l₂ = refl\n  ```\n\n  Irrelevant arguments can only be used in irrelevant
  contexts.\n  Consider the following subset type:\n\n  ```agda\n  data Subset (A
  : Set) (P : A → Set) : Set where\n    _#_ : (elem : A) → .(P elem) → Subset A P\n
  \ ```\n\n  The following two uses are fine:\n\n  ```agda\n  elimSubset : ∀ {A C
  : Set} {P} →\n               Subset A P → ((a : A) → .(P a) → C) → C\n  elimSubset
  (a # p) k = k a p\n\n  elem : {A : Set} {P : A → Set} → Subset A P → A\n  elem (x
  # p) = x\n  ```\n\n  However, if we try to project out the proof component, then
  Agda\n  complains that `variable p is declared irrelevant, so it cannot be\n  used
  here`:\n\n  ```agda\n  prjProof : ∀ {A P} (x : Subset A P) → P (elem x)\n  prjProof
  (a # p) = p\n  ```\n\n  Matching against irrelevant arguments is also forbidden,
  except in\n  the case of irrefutable matches (record constructor patterns which\n
  \ have been translated away). For instance, the match against the\n  pattern `(p , q)`
  here is accepted:\n\n  ```agda\n  elim₂ : ∀ {A C : Set} {P Q : A → Set} →\n          Subset
  A (λ x → Σ (P x) (λ _ → Q x)) →\n          ((a : A) → .(P a) → .(Q a) → C) → C\n
  \ elim₂ (a # (p , q)) k = k a p q\n  ```\n\n  Absurd matches `()` are also allowed.\n\n
  \ Note that record fields can also be irrelevant. Example:\n\n  ```agda\n  record
  Subset (A : Set) (P : A → Set) : Set where\n    constructor _#_\n    field\n      elem
  \  : A\n      .proof : P elem\n  ```\n\n  Irrelevant fields are never in scope,
  neither inside nor outside the\n  record. This means that no record field can depend
  on an irrelevant\n  field, and furthermore projections are not defined for such
  fields.\n  Irrelevant fields can only be accessed using pattern matching, as in\n
  \ `elimSubset` above.\n\n  Irrelevant function types were added very recently, and
  have not\n  been subjected to much experimentation yet, so do not be surprised\n
  \ if something is changed before the next release. For instance,\n  dependent irrelevant
  function spaces (`.(x : A) → B`) might be added\n  in the future.\n\n* Mixfix binders.\n\n
  \ It is now possible to declare user-defined syntax that binds\n  identifiers. Example:\n\n
  \ ```agda\n  postulate\n    State  : Set → Set → Set\n    put    : ∀ {S} → S → State
  S ⊤\n    get    : ∀ {S} → State S S\n    return : ∀ {A S} → A → State S A\n    bind
  \  : ∀ {A B S} → State S B → (B → State S A) → State S A\n\n  syntax bind e₁ (λ
  x → e₂) = x ← e₁ , e₂\n\n  increment : State ℕ ⊤\n  increment = x ← get ,\n              put
  (1 + x)\n  ```\n\n  The syntax declaration for `bind` implies that `x` is in scope
  in\n  `e₂`, but not in `e₁`.\n\n  You can give fixity declarations along with syntax
  declarations:\n\n  ```agda\n  infixr 40 bind\n  syntax bind e₁ (λ x → e₂) = x ←
  e₁ , e₂\n  ```\n\n  The fixity applies to the syntax, not the name; syntax declarations\n
  \ are also restricted to ordinary, non-operator names. The following\n  declaration
  is disallowed:\n\n  ```agda\n  syntax _==_ x y = x === y\n  ```agda\n\n  Syntax
  declarations must also be linear; the following declaration\n  is disallowed:\n\n
  \ ```agda\n  syntax wrong x = x + x\n  ```\n\n  Syntax declarations were added very
  recently, and have not been\n  subjected to much experimentation yet, so do not
  be surprised if\n  something is changed before the next release.\n\n* `Prop` has
  been removed from the language.\n\n  The experimental sort `Prop` has been disabled.
  Any program using\n  `Prop` should typecheck if `Prop` is replaced by `Set₀`. Note
  that\n  `Prop` is still a keyword.\n\n* Injective type constructors off by default.\n\n
  \ Automatic injectivity of type constructors has been disabled (by\n  default).
  To enable it, use the flag\n  `--injective-type-constructors`, either on the command
  line or in an\n  OPTIONS pragma. Note that this flag makes Agda anti-classical and\n
  \ possibly inconsistent:\n\n    Agda with excluded middle is inconsistent\n    http://thread.gmane.org/gmane.comp.lang.agda/1367\n\n
  \ See `test/Succeed/InjectiveTypeConstructors.agda` for an example.\n\n* Termination
  checker can count.\n\n  There is a new flag `--termination-depth=N` accepting values
  `N >=\n  1` (with `N = 1` being the default) which influences the behavior of\n
  \ the termination checker. So far, the termination checker has only\n  distinguished
  three cases when comparing the argument of a recursive\n  call with the formal parameter
  of the callee.\n\n  `<`: the argument is structurally smaller than the parameter\n\n
  \ `=`: they are equal\n\n  `?`: the argument is bigger or unrelated to the parameter\n\n
  \ This behavior, which is still the default (`N = 1`), will not\n  recognise the
  following functions as terminating.\n\n   ```agda\n   mutual\n\n      f : ℕ → ℕ\n
  \     f zero          = zero\n      f (suc zero)    = zero\n      f (suc (suc n))
  = aux n\n\n      aux : ℕ → ℕ\n      aux m = f (suc m)\n  ```\n\n  The call graph\n\n
  \ ```\n  f --(<)--> aux --(?)--> f\n  ```\n\n  yields a recursive call from `f`
  to `f` via `aux` where the relation\n  of call argument to callee parameter is computed
  as \"unrelated\"\n  (composition of `<` and `?`).\n\n  Setting `N >= 2` allows a
  finer analysis: `n` has two constructors\n  less than `suc (suc n)`, and `suc m`
  has one more than `m`, so we get the\n  call graph:\n\n  ```\n  f --(-2)--> aux
  --(+1)--> f\n  ```\n\n  The indirect call `f --> f` is now labeled with `(-1)`,
  and the\n  termination checker can recognise that the call argument is\n  decreasing
  on this path.\n\n  Setting the termination depth to `N` means that the termination\n
  \ checker counts decrease up to `N` and increase up to `N-1`. The\n  default, `N=1`,
  means that no increase is counted, every increase\n  turns to \"unrelated\".\n\n
  \ In practice, examples like the one above sometimes arise when `with`\n  is used.
  As an example, the program\n\n  ```agda\n  f : ℕ → ℕ\n  f zero          = zero\n
  \ f (suc zero)    = zero\n  f (suc (suc n)) with zero\n  ... | _ = f (suc n)\n  ```\n\n
  \ is internally represented as\n\n  ```agda\n  mutual\n\n    f : ℕ → ℕ\n    f zero
  \         = zero\n    f (suc zero)    = zero\n    f (suc (suc n)) = aux n zero\n\n
  \   aux : ℕ → ℕ → ℕ\n    aux m k = f (suc m)\n  ```\n\n  Thus, by default, the definition
  of `f` using `with` is not accepted\n  by the termination checker, even though it
  looks structural (`suc n`\n  is a subterm of `suc suc n`). Now, the termination
  checker is\n  satisfied if the option `--termination-depth=2` is used.\n\n  Caveats:\n\n
  \ - This is an experimental feature, hopefully being replaced by\n    something
  smarter in the near future.\n\n  - Increasing the termination depth will quickly
  lead to very long\n    termination checking times. So, use with care. Setting termination\n
  \   depth to `100` by habit, just to be on the safe side, is not a good\n    idea!\n\n
  \ - Increasing termination depth only makes sense for linear data\n    types such
  as `ℕ` and `Size`. For other types, increase cannot be\n    recognised. For instance,
  consider a similar example with lists.\n\n    ```agda\n    data List : Set where\n
  \     nil  : List\n      cons : ℕ → List → List\n\n    mutual\n      f : List →
  List\n      f nil                  = nil\n      f (cons x nil)         = nil\n      f
  (cons x (cons y ys)) = aux y ys\n\n      aux : ℕ → List → List\n      aux z zs =
  f (cons z zs)\n    ```\n\n    Here the termination checker compares `cons z zs`
  to `z` and also\n    to `zs`. In both cases, the result will be \"unrelated\", no
  matter\n    how high we set the termination depth. This is because when\n    comparing
  `cons z zs` to `zs`, for instance, `z` is unrelated to\n    `zs`, thus, `cons z zs`
  is also unrelated to `zs`. We cannot say\n    it is just \"one larger\" since `z`
  could be a very large term. Note\n    that this points to a weakness of untyped
  termination checking.\n\n    To regain the benefit of increased termination depth,
  we need to\n    index our lists by a linear type such as `ℕ` or `Size`. With\n    termination
  depth `2`, the above example is accepted for vectors\n    instead of lists.\n\n*
  The `codata` keyword has been removed. To use coinduction, use the\n  following
  new builtins: `INFINITY`, `SHARP` and `FLAT`. Example:\n\n  ```agda\n  {-# OPTIONS
  --universe-polymorphism #-}\n\n  module Coinduction where\n\n  open import Level\n\n
  \ infix 1000 ♯_\n\n  postulate\n    ∞  : ∀ {a} (A : Set a) → Set a\n    ♯_ : ∀ {a}
  {A : Set a} → A → ∞ A\n    ♭  : ∀ {a} {A : Set a} → ∞ A → A\n\n  {-# BUILTIN INFINITY
  ∞  #-}\n  {-# BUILTIN SHARP    ♯_ #-}\n  {-# BUILTIN FLAT     ♭  #-}\n  ```\n\n
  \ Note that (non-dependent) pattern matching on `SHARP` is no longer\n  allowed.\n\n
  \ Note also that strange things might happen if you try to combine the\n  pragmas
  above with `COMPILED_TYPE`, `COMPILED_DATA` or `COMPILED`\n  pragmas, or if the
  pragmas do not occur right after the postulates.\n\n  The compiler compiles the
  `INFINITY` builtin to nothing (more or\n  less), so that the use of coinduction
  does not get in the way of FFI\n  declarations:\n\n  ```agda\n  data Colist (A :
  Set) : Set where\n    []  : Colist A\n    _∷_ : (x : A) (xs : ∞ (Colist A)) → Colist
  A\n\n  {-# COMPILED_DATA Colist [] [] (:) #-}\n  ```\n\n* Infinite types.\n\n  If
  the new flag `--guardedness-preserving-type-constructors` is\n  used, then type
  constructors are treated as inductive constructors\n  when we check productivity
  (but only in parameters, and only if they\n  are used strictly positively or not
  at all). This makes examples\n  such as the following possible:\n\n  ```agda\n  data
  Rec (A : ∞ Set) : Set where\n    fold : ♭ A → Rec A\n\n  -- Σ cannot be a record
  type below.\n\n  data Σ (A : Set) (B : A → Set) : Set where\n    _,_ : (x : A) →
  B x → Σ A B\n\n  syntax Σ A (λ x → B) = Σ[ x ∶ A ] B\n\n  -- Corecursive definition
  of the W-type.\n\n  W : (A : Set) → (A → Set) → Set\n  W A B = Rec (♯ (Σ[ x ∶ A
  ] (B x → W A B)))\n\n  syntax W A (λ x → B) = W[ x ∶ A ] B\n\n  sup : {A : Set}
  {B : A → Set} (x : A) (f : B x → W A B) → W A B\n  sup x f = fold (x , f)\n\n  W-rec
  : {A : Set} {B : A → Set}\n          (P : W A B → Set) →\n          (∀ {x} {f :
  B x → W A B} → (∀ y → P (f y)) → P (sup x f)) →\n          ∀ x → P x\n  W-rec P
  h (fold (x , f)) = h (λ y → W-rec P h (f y))\n\n  -- Induction-recursion encoded
  as corecursion-recursion.\n\n  data Label : Set where\n    ′0 ′1 ′2 ′σ ′π ′w : Label\n\n
  \ mutual\n\n    U : Set\n    U = Σ Label U′\n\n    U′ : Label → Set\n    U′ ′0 =
  ⊤\n    U′ ′1 = ⊤\n    U′ ′2 = ⊤\n    U′ ′σ = Rec (♯ (Σ[ a ∶ U ] (El a → U)))\n    U′
  ′π = Rec (♯ (Σ[ a ∶ U ] (El a → U)))\n    U′ ′w = Rec (♯ (Σ[ a ∶ U ] (El a → U)))\n\n
  \   El : U → Set\n    El (′0 , _)            = ⊥\n    El (′1 , _)            = ⊤\n
  \   El (′2 , _)            = Bool\n    El (′σ , fold (a , b)) = Σ[ x ∶ El a ]  El
  (b x)\n    El (′π , fold (a , b)) =   (x : El a) → El (b x)\n    El (′w , fold (a
  , b)) = W[ x ∶ El a ]  El (b x)\n\n  U-rec : (P : ∀ u → El u → Set) →\n          P
  (′1 , _) tt →\n          P (′2 , _) true →\n          P (′2 , _) false →\n          (∀
  {a b x y} →\n           P a x → P (b x) y → P (′σ , fold (a , b)) (x , y)) →\n          (∀
  {a b f} →\n           (∀ x → P (b x) (f x)) → P (′π , fold (a , b)) f) →\n          (∀
  {a b x f} →\n           (∀ y → P (′w , fold (a , b)) (f y)) →\n           P (′w
  , fold (a , b)) (sup x f)) →\n          ∀ u (x : El u) → P u x\n  U-rec P P1 P2t
  P2f Pσ Pπ Pw = rec\n    where\n    rec : ∀ u (x : El u) → P u x\n    rec (′0 , _)
  \           ()\n    rec (′1 , _)            _              = P1\n    rec (′2 , _)
  \           true           = P2t\n    rec (′2 , _)            false          = P2f\n
  \   rec (′σ , fold (a , b)) (x , y)        = Pσ (rec _ x) (rec _ y)\n    rec (′π
  , fold (a , b)) f              = Pπ (λ x → rec _ (f x))\n    rec (′w , fold (a ,
  b)) (fold (x , f)) = Pw (λ y → rec _ (f y))\n  ```\n\n  The `--guardedness-preserving-type-constructors`
  extension is based\n  on a rather operational understanding of `∞`/`♯_`; it's not
  yet\n  clear if this extension is consistent.\n\n* Qualified constructors.\n\n  Constructors
  can now be referred to qualified by their data type.\n  For instance, given\n\n
  \ ```agda\n  data Nat : Set where\n    zero : Nat\n    suc  : Nat → Nat\n\n  data
  Fin : Nat → Set where\n    zero : ∀ {n} → Fin (suc n)\n    suc  : ∀ {n} → Fin n
  → Fin (suc n)\n  ```\n\n  you can refer to the constructors unambiguously as `Nat.zero`,\n
  \ `Nat.suc`, `Fin.zero`, and `Fin.suc` (`Nat` and `Fin` are modules\n  containing
  the respective constructors). Example:\n\n  ```agda\n  inj : (n m : Nat) → Nat.suc
  n ≡ suc m → n ≡ m\n  inj .m m refl = refl\n  ```\n\n  Previously you had to write
  something like\n\n  ```agda\n  inj : (n m : Nat) → _≡_ {Nat} (suc n) (suc m) → n
  ≡ m\n  ```\n\n  to make the type checker able to figure out that you wanted the\n
  \ natural number suc in this case.\n\n* Reflection.\n\n  There are two new constructs
  for reflection:\n\n    - `quoteGoal x in e`\n\n      In `e` the value of `x` will
  be a representation of the goal type\n      (the type expected of the whole expression)
  as an element in a\n      datatype of Agda terms (see below). For instance,\n\n
  \     ```agda\n      example : ℕ\n      example = quoteGoal x in {! at this point
  x = def (quote ℕ) [] !}\n      ```\n\n    - `quote x : Name`\n\n      If `x` is
  the name of a definition (function, datatype, record,\n      or a constructor),
  `quote x` gives you the representation of `x`\n      as a value in the primitive
  type `Name` (see below).\n\n  Quoted terms use the following BUILTINs and primitives
  (available\n  from the standard library module `Reflection`):\n\n  ```agda\n  --
  The type of Agda names.\n\n  postulate Name : Set\n\n  {-# BUILTIN QNAME Name #-}\n\n
  \ primitive primQNameEquality : Name → Name → Bool\n\n  -- Arguments.\n\n  Explicit?
  = Bool\n\n  data Arg A : Set where\n    arg : Explicit? → A → Arg A\n\n  {-# BUILTIN
  ARG    Arg #-}\n  {-# BUILTIN ARGARG arg #-}\n\n  -- The type of Agda terms.\n\n
  \ data Term : Set where\n    var     : ℕ → List (Arg Term) → Term\n    con     :
  Name → List (Arg Term) → Term\n    def     : Name → List (Arg Term) → Term\n    lam
  \    : Explicit? → Term → Term\n    pi      : Arg Term → Term → Term\n    sort    :
  Term\n    unknown : Term\n\n  {-# BUILTIN AGDATERM            Term    #-}\n  {-#
  BUILTIN AGDATERMVAR         var     #-}\n  {-# BUILTIN AGDATERMCON         con     #-}\n
  \ {-# BUILTIN AGDATERMDEF         def     #-}\n  {-# BUILTIN AGDATERMLAM         lam
  \    #-}\n  {-# BUILTIN AGDATERMPI          pi      #-}\n  {-# BUILTIN AGDATERMSORT
  \       sort    #-}\n  {-# BUILTIN AGDATERMUNSUPPORTED unknown #-}\n  ```\n\n  Reflection
  may be useful when working with internal decision\n  procedures, such as the standard
  library's ring solver.\n\n* Minor record definition improvement.\n\n  The definition
  of a record type is now available when type checking\n  record module definitions.
  This means that you can define things\n  like the following:\n\n  ```agda\n  record
  Cat : Set₁ where\n    field\n      Obj  : Set\n      _=>_ : Obj → Obj → Set\n      --
  ...\n\n    -- not possible before:\n    op : Cat\n    op = record { Obj = Obj; _=>_
  = λ A B → B => A }\n  ```\n\nTools\n-----\n\n* The `Goal type and context` command
  now shows the goal type before\n  the context, and the context is shown in reverse
  order. The `Goal\n  type, context and inferred type` command has been modified in
  a\n  similar way.\n\n* Show module contents command.\n\n  Given a module name `M`
  the Emacs mode can now display all the\n  top-level modules and names inside `M`,
  along with types for the\n  names. The command is activated using `C-c C-o` or the
  menus.\n\n* Auto command.\n\n  A command which searches for type inhabitants has
  been added. The\n  command is invoked by pressing `C-C C-a` (or using the goal menu).\n
  \ There are several flags and parameters, e.g. `-c` which enables\n  case-splitting
  in the search. For further information, see the Agda\n  wiki:\n\n    http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Main.Auto\n\n*
  HTML generation is now possible for a module with unsolved\n  meta-variables, provided
  that the `--allow-unsolved-metas` flag is\n  used.\n\nRelease notes for Agda 2 version
  2.2.6\n======================================\n\nLanguage\n--------\n\n* Universe
  polymorphism (experimental extension).\n\n  To enable universe polymorphism give
  the flag\n  `--universe-polymorphism` on the command line or (recommended) as an\n
  \ OPTIONS pragma.\n\n  When universe polymorphism is enabled `Set` takes an argument
  which is\n  the universe level. For instance, the type of universe polymorphic\n
  \ identity is\n\n  ```agda\n  id : {a : Level} {A : Set a} → A → A.\n  ```\n\n  The
  type Level is isomorphic to the unary natural numbers and should\n  be specified
  using the BUILTINs `LEVEL`, `LEVELZERO`, and\n  `LEVELSUC`:\n\n  ```agda\n  data
  Level : Set where\n    zero : Level\n    suc  : Level → Level\n\n  {-# BUILTIN LEVEL
  \    Level #-}\n  {-# BUILTIN LEVELZERO zero  #-}\n  {-# BUILTIN LEVELSUC  suc   #-}\n
  \ ```\n\n  There is an additional BUILTIN `LEVELMAX` for taking the maximum of two\n
  \ levels:\n\n  ```agda\n  max : Level → Level → Level\n  max  zero    m      = m\n
  \ max (suc n)  zero   = suc n\n  max (suc n) (suc m) = suc (max n m)\n\n  {-# BUILTIN
  LEVELMAX max #-}\n  ```\n\n  The non-polymorphic universe levels `Set`, `Set₁` and
  so on are\n  sugar for `Set zero`, `Set (suc zero)`, etc.\n\n  At present there
  is no automatic lifting of types from one level to\n  another. It can still be done
  (rather clumsily) by defining types\n  like the following one:\n\n  ```agda\n  data
  Lifted {a} (A : Set a) : Set (suc a) where\n    lift : A → Lifted A\n  ```\n\n  However,
  it is likely that automatic lifting is introduced at some\n  point in the future.\n\n*
  Multiple constructors, record fields, postulates or primitives can\n  be declared
  using a single type signature:\n\n  ```agda\n  data Bool : Set where\n    false
  true : Bool\n\n  postulate\n    A B : Set\n  ```\n\n* Record fields can be implicit:\n\n
  \ ```agda\n  record R : Set₁ where\n    field\n      {A}         : Set\n      f
  \          : A → A\n      {B C} D {E} : Set\n      g           : B → C → E\n  ```\n\n
  \ By default implicit fields are not printed.\n\n* Record constructors can be defined:\n\n
  \ ```agda\n  record Σ (A : Set) (B : A → Set) : Set where\n    constructor _,_\n
  \   field\n      proj₁ : A\n      proj₂ : B proj₁\n  ```\n\n  In this example `_,_`
  gets the type\n\n  ```agda\n   (proj₁ : A) → B proj₁ → Σ A B.\n  ```\n\n  For implicit
  fields the corresponding constructor arguments become\n  implicit.\n\n  Note that
  the constructor is defined in the *outer* scope, so any\n  fixity declaration has
  to be given outside the record definition.\n  The constructor is not in scope inside
  the record module.\n\n  Note also that pattern matching for records has not been
  implemented\n  yet.\n\n* BUILTIN hooks for equality.\n\n  The data type\n\n  ```agda\n
  \ data _≡_ {A : Set} (x : A) : A → Set where\n    refl : x ≡ x\n  ```\n\n  can be
  specified as the builtin equality type using the following\n  pragmas:\n\n  ```agda\n
  \ {-# BUILTIN EQUALITY _≡_  #-}\n  {-# BUILTIN REFL     refl #-}\n  ```\n\n  The
  builtin equality is used for the new rewrite construct and\n  the `primTrustMe`
  primitive described below.\n\n* New `rewrite` construct.\n\n  If `eqn : a ≡ b`,
  where `_≡_` is the builtin equality (see above) you\n  can now write\n\n  ```agda\n
  \ f ps rewrite eqn = rhs\n  ```\n\n  instead of\n\n  ```agda\n    f ps with a |
  eqn\n    ... | ._ | refl = rhs\n  ```\n\n  The `rewrite` construct has the effect
  of rewriting the goal and the\n  context by the given equation (left to right).\n\n
  \ You can rewrite using several equations (in sequence) by separating\n  them with
  vertical bars (|):\n\n  ```agda\n  f ps rewrite eqn₁ | eqn₂ | … = rhs\n  ```\n\n
  \ It is also possible to add `with`-clauses after rewriting:\n\n  ```agda\n  f ps
  rewrite eqns with e\n  ... | p = rhs\n  ```\n\n  Note that pattern matching happens
  before rewriting—if you want to\n  rewrite and then do pattern matching you can
  use a with after the\n  rewrite.\n\n  See `test/Succeed/Rewrite.agda` for some examples.\n\n*
  A new primitive, `primTrustMe`, has been added:\n\n  ```agda\n    primTrustMe :
  {A : Set} {x y : A} → x ≡ y\n  ```\n\n  Here `_≡_` is the builtin equality (see
  BUILTIN hooks for equality,\n  above).\n\n  If `x` and `y` are definitionally equal,
  then\n  `primTrustMe {x = x} {y = y}` reduces to `refl`.\n\n  Note that the compiler
  replaces all uses of `primTrustMe` with the\n  `REFL` builtin, without any check
  for definitional\n  equality. Incorrect uses of `primTrustMe` can potentially lead
  to\n  segfaults or similar problems.\n\n  For an example of the use of `primTrustMe`,
  see `Data.String` in\n  version 0.3 of the standard library, where it is used to
  implement\n  decidable equality on strings using the primitive boolean equality.\n\n*
  Changes to the syntax and semantics of IMPORT pragmas, which are\n  used by the
  Haskell FFI. Such pragmas must now have the following\n  form:\n\n  ```agda\n  {-#
  IMPORT <module name> #-}\n  ```\n\n  These pragmas are interpreted as *qualified*
  imports, so Haskell\n  names need to be given qualified (unless they come from the
  Haskell\n  prelude).\n\n* The horizontal tab character (U+0009) is no longer treated
  as white\n  space.\n\n* Line pragmas are no longer supported.\n\n* The `--include-path`
  flag can no longer be used as a pragma.\n\n* The experimental and incomplete support
  for proof irrelevance has\n  been disabled.\n\nTools\n-----\n\n* New `intro` command
  in the Emacs mode. When there is a canonical way\n  of building something of the
  goal type (for instance, if the goal\n  type is a pair), the goal can be refined
  in this way. The command\n  works for the following goal types:\n\n    - A data
  type where only one of its constructors can be used to\n      construct an element
  of the goal type. (For instance, if the\n      goal is a non-empty vector, a `cons`
  will be introduced.)\n\n    - A record type. A record value will be introduced.
  Implicit\n      fields will not be included unless showing of implicit arguments\n
  \     is switched on.\n\n    - A function type. A lambda binding as many variables
  as possible\n      will be introduced. The variable names will be chosen from the\n
  \     goal type if its normal form is a dependent function type,\n      otherwise
  they will be variations on `x`. Implicit lambdas will\n      only be inserted if
  showing of implicit arguments is switched\n      on.\n\n  This command can be invoked
  by using the `refine` command\n  (`C-c C-r`) when the goal is empty. (The old behaviour
  of the refine\n  command in this situation was to ask for an expression using the\n
  \ minibuffer.)\n\n* The Emacs mode displays `Checked` in the mode line if the current\n
  \ file type checked successfully without any warnings.\n\n* If a file `F` is loaded,
  and this file defines the module `M`, it is\n  an error if `F` is not the file which
  defines `M` according to the\n  include path.\n\n  Note that the command-line tool
  and the Emacs mode define the\n  meaning of relative include paths differently:
  the command-line tool\n  interprets them relative to the current working directory,
  whereas\n  the Emacs mode interprets them relative to the root directory of the\n
  \ current project. (As an example, if the module `A.B.C` is loaded\n  from the file
  `<some-path>/A/B/C.agda`, then the root directory is\n  `<some-path>`.)\n\n* It
  is an error if there are several files on the include path which\n  match a given
  module name.\n\n* Interface files are relocatable. You can move around source trees
  as\n  long as the include path is updated in a corresponding way. Note\n  that a
  module `M` may be re-typechecked if its time stamp is\n  strictly newer than that
  of the corresponding interface file\n  (`M.agdai`).\n\n* Type-checking is no longer
  done when an up-to-date interface exists.\n  (Previously the initial module was
  always type-checked.)\n\n* Syntax highlighting files for Emacs (`.agda.el`) are
  no longer used.\n  The `--emacs` flag has been removed. (Syntax highlighting\n  information
  is cached in the interface files.)\n\n* The Agate and Alonzo compilers have been
  retired. The options\n  `--agate`, `--alonzo` and `--malonzo` have been removed.\n\n*
  The default directory for MAlonzo output is the project's root\n  directory. The
  `--malonzo-dir` flag has been renamed to\n  `--compile-dir`.\n\n* Emacs mode: `C-c C-x C-d`
  no longer resets the type checking state.\n  `C-c C-x C-r` can be used for a more
  complete reset. `C-c C-x C-s`\n  (which used to reload the syntax highlighting information)
  has been\n  removed. `C-c C-l` can be used instead.\n\n* The Emacs mode used to
  define some \"abbrevs\", unless the user\n  explicitly turned this feature off.
  The new default is *not* to add\n  any abbrevs. The old default can be obtained
  by customising\n  `agda2-mode-abbrevs-use-defaults` (a customisation buffer can
  be\n  obtained by typing `M-x customize-group agda2 RET` after an Agda\n  file has
  been loaded).\n\nRelease notes for Agda 2 version 2.2.4\n======================================\n\nImportant
  changes since 2.2.2:\n\n* Change to the semantics of `open import` and `open module`.
  The\n  declaration\n\n  ```agda\n  open import M <using/hiding/renaming>\n  ```\n\n
  \ now translates to\n\n  ```agda\n  import A\n  open A <using/hiding/renaming>\n
  \ ```\n\n  instead of\n\n  ```agda\n  import A <using/hiding/renaming>\n  open A\n
  \ ```\n\n  The same translation is used for `open module M = E …`. Declarations\n
  \ involving the keywords as or public are changed in a corresponding\n  way (`as`
  always goes with import, and `public` always with open).\n\n  This change means
  that import directives do not affect the qualified\n  names when open import/module
  is used. To get the old behaviour you\n  can use the expanded version above.\n\n*
  Names opened publicly in parameterised modules no longer inherit the\n  module parameters.
  Example:\n\n  ```agda\n  module A where\n    postulate X : Set\n\n  module B (Y
  : Set) where\n    open A public\n  ```\n\n  In Agda 2.2.2 `B.X` has type `(Y : Set)
  → Set`, whereas in\n  Agda 2.2.4 `B.X` has type Set.\n\n* Previously it was not
  possible to export a given constructor name\n  through two different `open public`
  statements in the same module.\n  This is now possible.\n\n* Unicode subscript digits
  are now allowed for the hierarchy of\n  universes (`Set₀`, `Set₁`, …): `Set₁` is
  equivalent to `Set1`.\n\nRelease notes for Agda 2 version 2.2.2\n======================================\n\nTools\n-----\n\n*
  The `--malonzodir` option has been renamed to `--malonzo-dir`.\n\n* The output of
  `agda --html` is by default placed in a directory\n  called `html`.\n\nInfrastructure\n--------------\n\n*
  The Emacs mode is included in the Agda Cabal package, and installed\n  by `cabal install`.
  The recommended way to enable the Emacs mode is\n  to include the following code
  in `.emacs`:\n\n  ```elisp\n  (load-file (let ((coding-system-for-read 'utf-8))\n
  \                 (shell-command-to-string \"agda-mode locate\")))\n  ```\n\nRelease
  notes for Agda 2 version 2.2.0\n======================================\n\nImportant
  changes since 2.1.2 (which was released 2007-08-16):\n\nLanguage\n--------\n\n*
  Exhaustive pattern checking. Agda complains if there are missing\n  clauses in a
  function definition.\n\n* Coinductive types are supported. This feature is under\n
  \ development/evaluation, and may change.\n\n  http://wiki.portal.chalmers.se/agda/agda.php?n=ReferenceManual.Codatatypes\n\n*
  Another experimental feature: Sized types, which can make it easier\n  to explain
  why your code is terminating.\n\n* Improved constraint solving for functions with
  constructor headed\n  right hand sides.\n\n  http://wiki.portal.chalmers.se/agda/agda.php?n=ReferenceManual.FindingTheValuesOfImplicitArguments\n\n*
  A simple, well-typed foreign function interface, which allows use of\n  Haskell
  functions in Agda code.\n\n  http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Docs.FFI\n\n*
  The tokens `forall`, `->` and `\\` can be written as `∀`, `→` and\n  `λ`.\n\n* Absurd
  lambdas: `λ ()` and `λ {}`.\n\n  http://thread.gmane.org/gmane.comp.lang.agda/440\n\n*
  Record fields whose values can be inferred can be omitted.\n\n* Agda complains if
  it spots an unreachable clause, or if a pattern\n  variable \"shadows\" a hidden
  constructor of matching type.\n\n  http://thread.gmane.org/gmane.comp.lang.agda/720\n\nTools\n-----\n\n*
  Case-split: The user interface can replace a pattern variable with\n  the corresponding
  constructor patterns. You get one new left-hand\n  side for every possible constructor.\n\n
  \ http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Main.QuickGuideToEditingTypeCheckingAndCompilingAgdaCode\n\n*
  The MAlonzo compiler.\n\n  http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Docs.MAlonzo\n\n*
  A new Emacs input method, which contains bindings for many Unicode\n  symbols, is
  by default activated in the Emacs mode.\n\n  http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Docs.UnicodeInput\n\n*
  Highlighted, hyperlinked HTML can be generated from Agda source\n  code.\n\n  http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Main.HowToGenerateWebPagesFromSourceCode\n\n*
  The command-line interactive mode (`agda -I`) is no longer\n  supported, but should
  still work.\n\n  http://thread.gmane.org/gmane.comp.lang.agda/245\n\n* Reload times
  when working on large projects are now considerably\n  better.\n\n  http://thread.gmane.org/gmane.comp.lang.agda/551\n\nLibraries\n---------\n\n*
  A standard library is under development.\n\n  http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Libraries.StandardLibrary\n\nDocumentation\n-------------\n\n*
  The Agda wiki is better organised. It should be easier for a\n  newcomer to find
  relevant information now.\n\n  http://wiki.portal.chalmers.se/agda/\n\nInfrastructure\n--------------\n\n*
  Easy-to-install packages for Windows and Debian/Ubuntu have been\n  prepared.\n\n
  \ http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Main.Download\n\n* Agda 2.2.0
  is available from Hackage.\n\n  http://hackage.haskell.org/\n"
basic-deps:
  data-hash: ! '>=0.2.0.0 && <0.3'
  bytestring: ! '>=0.10.6.0 && <0.11'
  murmur-hash: ! '>=0.1 && <0.2'
  haskeline: ! '>=0.7.2.1 && <0.8'
  edit-distance: ! '>=0.2.1.2 && <0.3'
  stm: ! '>=2.4.4 && <2.5'
  base: ! '>=4.8.0.0 && <4.12'
  time: ! '>=1.5.0.1 && <1.9'
  unordered-containers: ! '>=0.2.5.0 && <0.3'
  text: ! '>=0.11.3.1 && <1.3'
  strict: ! '>=0.3.2 && <0.4'
  Agda: -any
  filepath: ! '>=1.4.0.0 && <1.5'
  gitrev: ! '>=1.3.1 && <2.0'
  process: ! '>=1.2.3.0 && <1.7'
  async: ! '>=2.2 && <2.3'
  array: ! '>=0.5.1.0 && <0.6'
  EdisonCore: ==1.3.1.1 || >=1.3.2.1 && <1.4
  containers: ! '>=0.5.6.2 && <0.6'
  binary: ! '>=0.7.3.0 && <0.9'
  hashtables: ! '>=1.2.0.2 && <1.3'
  regex-tdfa: ! '>=1.2.2 && <1.3'
  ieee754: ! '>=0.7.8 && <0.9'
  uri-encode: ! '>=1.5.0.4 && <1.6'
  zlib: ! '>=0.4.0.1 && <0.7'
  mtl: ! '>=2.2.1 && <2.3'
  geniplate-mirror: ! '>=0.6.0.6 && <0.8'
  hashable: ! '>=1.2.1.0 && <1.3'
  blaze-html: ! '>=0.8 && <0.10'
  transformers: ==0.5.2.0
  deepseq: ! '>=1.4.1.1 && <1.5'
  boxes: ! '>=0.1.3 && <0.2'
  equivalence: ! '>=0.3.2 && <0.4'
  pretty: ! '>=1.1.2.0 && <1.2'
  template-haskell: ! '>=2.10.0.0 && <2.14'
  directory: ! '>=1.2.2.0 && <1.4'
all-versions:
- '2.2.0'
- '2.2.2'
- '2.2.4'
- '2.2.6'
- '2.2.8'
- '2.2.10'
- '2.3.0'
- '2.3.0.1'
- '2.3.2'
- '2.3.2.1'
- '2.3.2.2'
- '2.4.0'
- '2.4.0.1'
- '2.4.0.2'
- '2.4.2'
- '2.4.2.1'
- '2.4.2.2'
- '2.4.2.3'
- '2.4.2.4'
- '2.4.2.5'
- '2.5.1'
- '2.5.1.1'
- '2.5.1.2'
- '2.5.2'
- '2.5.3'
- '2.5.4'
author: Agda 2 was originally written by Ulf Norell, partially based on code from
  Agda 1 by Catarina Coquand and Makoto Takeyama, and from Agdalight by Ulf Norell
  and Andreas Abel. Agda 2 is currently actively developed mainly by Andreas Abel,
  Guillaume Allais, Jesper Cockx, Nils Anders Danielsson, Philipp Hausmann, Fredrik
  Nordvall Forsberg, Ulf Norell, Víctor López Juan, Andrés Sicard-Ramírez, and Andrea
  Vezzosi. Further, Agda 2 has received contributions by, amongst others, Stevan Andjelkovic,
  Marcin Benke, Jean-Philippe Bernardy, Guillaume Brunerie, James Chapman, Dominique
  Devriese, Péter Diviánszki, Olle Fredriksson, Adam Gundry, Daniel Gustafsson, Kuen-Bang
  Hou (favonia), Patrik Jansson, Alan Jeffrey, Wolfram Kahl, Wen Kokke, Fredrik Lindblad,
  Francesco Mazzoli, Stefan Monnier, Darin Morrison, Guilhem Moulin, Nicolas Pouillard,
  Nobuo Yamashita, Christian Sattler, and Makoto Takeyama and many more.
latest: '2.5.4'
description-type: markdown
description: ! "Agda 2\n======\n\n[![Hackage version](https://img.shields.io/hackage/v/Agda.svg?label=Hackage)](http://hackage.haskell.org/package/Agda)\n[![Stackage
  version](https://www.stackage.org/package/Agda/badge/lts?label=Stackage)](https://www.stackage.org/package/Agda)\n[![Travis
  Status](https://travis-ci.org/agda/agda.svg?branch=stable-2.5)](https://travis-ci.org/agda/agda)\n[![Appveyor
  Status](https://ci.appveyor.com/api/projects/status/x6liln2dol0bg4qw/branch/stable-2.5?svg=true)](https://ci.appveyor.com/project/gallais/agda)\n[![Documentation
  Status](https://readthedocs.org/projects/agda/badge/?version=stable-2.5)](http://agda.readthedocs.io/en/stable-2.5/?badge=stable-2.5)\n\nNote
  that this README is only about Agda, not its standard\nlibrary. See the [Agda Wiki][agdawiki]
  for information about the\nlibrary.\n\nDocumentation\n-------------\n\n* [User manual](http://agda.readthedocs.io)\n*
  [CHANGELOG](https://github.com/agda/agda/blob/master/CHANGELOG.md)\n\nGetting Started\n----------------\n\n*
  [Prerequisites](http://agda.readthedocs.io/en/latest/getting-started/prerequisites.html)\n*
  [Installation](http://agda.readthedocs.io/en/latest/getting-started/installation.html)\n*
  [Quick guide to editing, type checking and compiling Agda\n  code](http://agda.readthedocs.io/en/latest/getting-started/quick-guide.html)\n\nHacking
  on Agda\n---------------\n\nHead to [`HACKING`](https://github.com/agda/agda/blob/master/HACKING)\n\n[agdawiki]:
  http://wiki.portal.chalmers.se/agda/pmwiki.php\n"
license-name: OtherLicense
