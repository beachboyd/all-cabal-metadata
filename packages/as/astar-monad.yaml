homepage: https://github.com/ChrisPenner/astar-monad#readme
changelog-type: markdown
hash: bb74d43e2030c468f4e4bc3b9b5e439fa20e23d67161645557fc54b2eb780fea
test-bench-deps:
  logict: -any
  base: ! '>=4.7 && <5'
  hspec: -any
  lens: -any
  mtl: -any
  astar-monad: -any
maintainer: christopher.penner@gmail.com
synopsis: ''
changelog: |
  # Changelog for astart

  ## Unreleased changes
basic-deps:
  logict: -any
  base: ! '>=4.7 && <5'
  mtl: -any
all-versions:
- 0.1.0.0
- 0.2.0.0
author: Chris Penner
latest: 0.2.0.0
description-type: markdown
description: "A\\* Monad\n=========\n\n[Hackage](http://hackage.haskell.org/package/astar-monad)\n\n**Caveat
  Emptor**; this hasn't been *battle-tested* yet; it should work, but make sure to
  test it out if you're doing anything serious.\n\nEasily do A\\* searches with use
  of arbitrary monadic effects!\n\n## Basics\n\n* Use `<|>` or `asum` (anything using
  `Alternative`) to branch into multiple possible choices.\n* Use `updateCost myCost`
  to set the value of your 'heuristic' function whenever you've done enough work to
  change your estimate.  Remember that A\\* heuristics should always be pessimistic
  (e.g. can over-estimate cost, but shouldn't UNDER estimate). \n* Every call to `updateCost`
  creates a branch; Branches with LOWER costs will run before those with higher costs.\n*
  Call `done mySolution` to short circuit ALL running branches and immediately return
  your result.\n* `AStarT` has a built-in State monad which can store branch-local
  states for you. You can store your current branch's solution-space for instance,
  or the path you've followed to get to the current solution; or both!\n\nHere's an
  example of using A\\* to find a path to a location in a 2 dimensional grid.\n\n```haskell\n--
  Track which moves we've made, up, down, left or right\ndata Move = U | D | L | R\n
  \   deriving (Show, Eq)\n\n-- Track our current position, the goal we're moving
  towards, and the moves we've taken so far.\ndata Context =\n    Context { _currentPos
  :: (Int, Int)\n            , _goal    :: (Int, Int)\n            , _moves   :: [Move]\n
  \           }\n    deriving (Show, Eq)\nmakeLenses ''Context\n\n-- The Manhattan
  distance between two points\n-- This is our A* heuristic\ndistanceTo :: (Int, Int)
  -> (Int, Int) -> Int\ndistanceTo (x, y) (x', y') = abs (x - x') + abs (y - y')\n\n--
  Move around the space looking for the destination point.\nfindPoint :: AStar Context
  Int () ()\nfindPoint = do\n    c <- use currentPos\n    gl <- use goal\n    -- I
  could return the moves we took, \n    -- but our State is automatically returned
  when we run AStar\n    when (c == gl) $ done ()\n    -- We have more work to do,
  we should update the cost estimate and continue\n    updateCost $ distanceTo gl
  c\n    if c == gl \n       then done ()\n       else updateCost $ distanceTo gl
  c\n    -- Non-deterministically choose a direction to move, \n    -- store that
  move in our state, and edit our current position.\n    asum\n        [ moves <>=
  [R] >> currentPos . _1 += 1 >> findPoint\n        , moves <>= [L] >> currentPos
  . _1 -= 1 >> findPoint\n        , moves <>= [D] >> currentPos . _2 += 1 >> findPoint\n
  \       , moves <>= [U] >> currentPos . _2 -= 1 >> findPoint\n        ]\n\n-- We
  only care about the ending state, so we use `execAStar`\n-- `runAStarT` is the most
  powerful and runs a monad-transformer version\n-- and returns both the state and
  result type.\nrun :: Maybe Context\nrun = execAStar findPoint\n             Context
  { _current = (5, 5)\n                     , _goal    = (7, 4)\n                     ,
  _moves   = []\n                     }\n\n-- run it to see if we found a solution;
  it returns the state of the the 'winning' branch.\n>>> run \nJust (Context { _current
  = (7, 4)\n              , _goal    = (7, 4)\n              , _moves   = [U, R, R]\n
  \             })\n```\n\n\n## Known Issues\n\nCurrently, computation will **hang**
  if the end of a branch \"finishes\" without calling `done` or `failure`; so don't
  do that.\n"
license-name: BSD-3-Clause
