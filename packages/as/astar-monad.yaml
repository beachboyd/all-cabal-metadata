homepage: https://github.com/ChrisPenner/astar-monad#readme
changelog-type: markdown
hash: 0cd95dc9f2f7db72d39e5775d15025a824d5ba915f7a90fe1de55154dd6933c2
test-bench-deps:
  logict: -any
  base: ! '>=4.7 && <5'
  hspec: -any
  lens: -any
  mtl: -any
  astar-monad: -any
maintainer: christopher.penner@gmail.com
synopsis: ''
changelog: |
  # Changelog for astart

  ## Unreleased changes
basic-deps:
  logict: -any
  base: ! '>=4.7 && <5'
  mtl: -any
all-versions:
- 0.1.0.0
author: Chris Penner
latest: 0.1.0.0
description-type: markdown
description: "A\\* Monad\n=========\n\nEasily do A\\* searches with use of arbitrary
  monadic effects!\n\n## Basics\n\n* Use `<|>` or `asum` (anything using `Alternative`)
  to branch into multiple possible choices.\n* Use `updateCost myCost` to set the
  value of your 'heuristic' function whenever you've done enough work to change your
  estimate.  Remember that A\\* heuristics should always be pessimistic (e.g. can
  over-estimate cost, but shouldn't UNDER estimate). \n* Every call to `updateCost`
  creates a branch; Branches with LOWER costs will run before those with higher costs.\n*
  Call `done mySolution` to short circuit ALL running branches and immediately return
  your result.\n* `AStarT` has a built-in State monad  which **automatically keeps
  state contiguous in spite of branching**. This means that your state monad will
  properly switch states when switching branches. Just use state normally, it should
  work as expected. You can store your current branch's solution-space for instance,
  or the path you've followed to get to the current solution; or both!\n\nHere's an
  example of using A\\* to find a path to a location in a 2 dimensional grid.\n\n```haskell\n--
  Track which moves we've made, up, down, left or right\ndata Move = U | D | L | R\n
  \   deriving (Show, Eq)\n\n-- Track our current position, the goal we're moving
  towards, and the moves we've taken so far.\ndata Context =\n    Context { _currentPos
  :: (Int, Int)\n            , _goal    :: (Int, Int)\n            , _moves   :: [Move]\n
  \           }\n    deriving (Show, Eq)\nmakeLenses ''Context\n\n-- The Manhattan
  distance between two points\n-- This is our A* heuristic\ndistanceTo :: (Int, Int)
  -> (Int, Int) -> Int\ndistanceTo (x, y) (x', y') = abs (x - x') + abs (y - y')\n\n--
  Move around the space looking for the destination point.\nfindPoint :: AStar Context
  Int () ()\nfindPoint = do\n    c <- use currentPos\n    gl <- use goal\n    -- I
  could return the moves we took, \n    -- but our State is automatically returned
  when we run AStar\n    when (c == gl) $ done ()\n    -- We have more work to do,
  we should update the cost estimate and continue\n    updateCost $ distanceTo gl
  c\n    if c == gl \n       then done ()\n       else updateCost $ distanceTo gl
  c\n    -- Non-deterministically choose a direction to move, \n    -- store that
  move in our state, and edit our current position.\n    asum\n        [ moves <>=
  [R] >> currentPos . _1 += 1 >> findPoint\n        , moves <>= [L] >> currentPos
  . _1 -= 1 >> findPoint\n        , moves <>= [D] >> currentPos . _2 += 1 >> findPoint\n
  \       , moves <>= [U] >> currentPos . _2 -= 1 >> findPoint\n        ]\n\n-- We
  only care about the ending state, so we use `execAStar`\n-- `runAStarT` is the most
  powerful and runs a monad-transformer version\n-- and returns both the state and
  result type.\nrun :: Maybe Context\nrun = execAStar findPoint\n             Context
  { _current = (5, 5)\n                     , _goal    = (7, 4)\n                     ,
  _moves   = []\n                     }\n\n-- run it to see if we found a solution;
  it returns the state of the the 'winning' branch.\n>>> run \nJust (Context { _current
  = (7, 4)\n              , _goal    = (7, 4)\n              , _moves   = [U, R, R]\n
  \             })\n```\n"
license-name: BSD-3-Clause
