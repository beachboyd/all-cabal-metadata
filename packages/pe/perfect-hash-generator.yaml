homepage: ''
changelog-type: ''
hash: 3ab4c9e0f98af30e9dacccb39658ff0d421c302014c5b7bf3c0d8f12d6cbd571
test-bench-deps:
  test-framework-hunit: -any
  test-framework: -any
  perfect-hash-generator: -any
  base: ! '>=4.5 && <=4.10'
  unordered-containers: -any
  HUnit: -any
  hashable: -any
  optparse-applicative: -any
  vector: -any
maintainer: kostmo@gmail.com
synopsis: Perfect minimal hashing implementation in native Haskell
changelog: ''
basic-deps:
  perfect-hash-generator: -any
  base: ! '>=4.5 && <=4.10'
  unordered-containers: -any
  filepath: -any
  containers: -any
  hashable: -any
  optparse-applicative: -any
  random: -any
  data-ordlist: -any
  vector: -any
  directory: -any
all-versions:
- '0.1.0.0'
author: Karl Ostmo
latest: '0.1.0.0'
description-type: haddock
description: ! 'A <https://en.wikipedia.org/wiki/Perfect_hash_function perfect hash
  function> for a set @S@ is a hash function that maps distinct elements in @S@ to
  a set of integers, with __no collisions__. A <https://en.wikipedia.org/wiki/Perfect_hash_function#Minimal_perfect_hash_function
  minimal perfect hash function> is a perfect hash function that maps @n@ keys to
  @n@ __consecutive__ integers, e.g. the numbers from @0@ to @n-1@.


  In contrast with the <https://hackage.haskell.org/package/PerfectHash PerfectHash
  package>, which is a binding to a C-based library, this package is a fully-native
  Haskell implementation.


  It is intended primarily for generating C code for embedded applications (compare
  to @<https://www.gnu.org/software/gperf/manual/gperf.html#Search-Structures gperf>@).
  The output of this tool is a pair of arrays that can be included in generated C
  code for __<https://en.wikipedia.org/wiki/C_dynamic_memory_allocation allocation>-free
  hash tables__.


  Though lookups also perform reasonably well for Haskell applications, it hasn''t
  been benchmarked thorougly with respect to other data structures.


  This implementation was adapted from <http://stevehanov.ca/blog/index.php?id=119
  Steve Hanov''s Blog>.


  = Usage

  The library is written generically to hash both strings and raw integers. Integers
  should be wrapped in the @Atom@ newtype:


  > import Data.PerfectHash.Construction (createMinimalPerfectHash)

  >

  > tuples = [

  >    (Atom 1000, 1)

  >  , (Atom 5555, 2)

  >  , (Atom 9876, 3)

  >  ]

  >

  > lookup_table = createMinimalPerfectHash tuples


  Generation of C code based on the arrays in @lookup_table@ is left as an exercise
  to the reader. Algorithm documentation in the "Data.PerfectHash.Hashing" and "Data.PerfectHash.Lookup"
  modules will be helpful.


  See the @hash-perfectly-strings-demo@ and @hash-perfectly-ints-demo@, as well as
  the test suite, for working examples.


  > $ stack build

  > $ stack exec hash-perfectly-strings-demo


  = Caveats

  Only integer keys of at most __32-bits__ have been demonstrated to work properly.  Since
  the hash function masks to 32 bits, colliding 64-bit integers can hang the lookup
  table construction.'
license-name: Apache-2.0
