homepage: http://github.com/himura/persistent-relational-record
changelog-type: markdown
hash: 8288b469e46732b1f1c02d84e04ccdebf4c7aab59d1a8b7e79b8ab87edbaf3e7
test-bench-deps:
  relational-query: -any
  test-framework-hunit: -any
  hlint: ! '>=1.7'
  test-framework: -any
  base: -any
  time: -any
  text: -any
  persistent-template: -any
  HUnit: -any
  test-framework-th: -any
  persistent-relational-record: -any
maintainer: taka@himura.jp
synopsis: relational-record on persisten backends.
changelog: ! '## 0.1.2.0


  - Support relational-query >= 0.10.0


  ## 0.1.1.0


  - Support persistable-record >= 0.5.0

  - Tested with GHC 8.0.2


  ## 0.1.0.0


  - Initial release

'
basic-deps:
  relational-query: ! '>=0.8.1'
  base: ! '>=4.7 && <5'
  persistent: ! '>=2.1'
  text: ! '>=0.8'
  conduit: ! '>=1.0'
  containers: -any
  mtl: -any
  persistable-record: ! '>=0.4'
  resourcet: ! '>=1.1'
  template-haskell: ! '>=2.9'
all-versions:
- '0.1.0.0'
- '0.1.1.0'
- '0.1.2.0'
author: Takahiro HIMURA
latest: '0.1.2.0'
description-type: markdown
description: ! "persistent-relational-record\n============================\n\n[![Travis](https://img.shields.io/travis/himura/persistent-relational-record/master.svg)](https://travis-ci.org/himura/persistent-relational-record)\n[![Hackage-Deps](https://img.shields.io/hackage-deps/v/persistent-relational-record.svg)](http://packdeps.haskellers.com/feed?needle=persistent-relational-record)\n\n##
  About ##\n\npersistent-relational-record build a bridge between [Haskell Relational
  Record](https://hackage.haskell.org/package/relational-query)\nand [Persistent](http://hackage.haskell.org/package/persistent).\nIt
  uses the persistent entities definition instead of obtaining schema from DB at compilation
  time.\n\n## Getting Started ##\n\nIf you already define an entities in persistent's
  manner, then you are almost ready to use this module.\nThe entities definition in
  the style of persistent-relational-record are shown below:\n\nModel.hs:\n\n~~~~
  {.haskell}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-#
  LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE
  TypeFamilies #-}\n{-# LANGUAGE QuasiQuotes #-}\n{-# LANGUAGE FlexibleInstances #-}\n\nimport
  Data.Text (Text)\nimport Database.Persist.Relational (mkHrrInstances)\nimport Database.Persist.TH\n\nshare
  [mkPersist sqlSettings, mkMigrate \"migrateAll\", mkSave \"db\", mkHrrInstances]
  [persistLowerCase|\nImage\n    title      Text\n    deriving Eq Show\nTag\n    name
  \      Text\n    deriving Eq Show\nImageTag\n    imageId    ImageId\n    tagId      TagId\n|]\n~~~~\n\nThe
  main difference from the persistent version is that `mkSave \"db\"` and `mkHrrInstances`
  are added to the 1st argument of the `share` function.\n`mkSave \"db\"` saves the
  definition of tables to \"db\" variable for later use.\n`mkHrrInstances` generates
  various instances from the entities definition to cooperate with HRR.\n\nNext, you
  should define HRR record types and their instances,\nthis package provides \"defineTableFromPersistent\"
  function to generate those types and auxiliary functnions.\nTo avoid the conflict
  of record field names, we recommend making one module per table.\n\nHere is the
  content of \"Image.hs\":\n\n~~~~ {.haskell}\n{-# LANGUAGE DeriveGeneric #-}\n{-#
  LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE MultiParamTypeClasses
  #-}\n{-# OPTIONS_GHC -fno-warn-orphans #-}\n\nmodule Image where\n\nimport Data.Text
  (Text)\nimport Database.Persist.Relational\nimport Model hiding (Image) -- Both
  of HRR and persistent generates `Image` type, so you should hide Image type generated
  by persistent.\nimport qualified Model\n\ndefineTableFromPersistent ''Model.Image
  db\n~~~~\n\nYou should create \"Tag.hs\" and \"ImageTag.hs\" in the same manner.\n\nNow,
  you can build queries in manner of HRR:\n\n~~~~ {.haskell}\nmodule Query where\n\nimport
  Data.Text (Text)\nimport Database.Relational.Query\n\nimport Model\nimport qualified
  Image\nimport qualified ImageTag\nimport qualified Tag\n\nimageIdFromTagNameList\n
  \   :: [Text] -- ^ list of tag name\n    -> Relation () ImageId\nimageIdFromTagNameList
  tagNames = aggregateRelation $ do\n   imgtag <- query $ ImageTag.imageTag\n   tag
  <- query $ Tag.tag\n   on $ tag ! Tag.id' .=. imgtag ! ImageTag.tagId'\n   wheres
  $ tag ! Tag.name' `in'` values tagNames\n   g <- groupBy $ imgtag ! ImageTag.imageId'\n
  \  let c = count $ imgtag ! ImageTag.imageId'\n   having $ c .=. value (length $
  tagNames)\n   return g\n\nselectImageByTagNameList\n    :: [Text] -- ^ list of tag
  name\n    -> Relation () Image.Image\nselectImageByTagNameList tagNames = relation
  $ do\n    img <- query Image.image\n    imgids <- query $ imageIdFromTagNameList
  tagNames\n    on $ img ! Image.id' .=. imgids\n    return img\n~~~~\n\nFinally,
  we can execute a query by runQuery:\n\n~~~~ {.haskell}\n{-# LANGUAGE OverloadedStrings
  #-}\n\nimport Control.Monad.Base\nimport Control.Monad.Logger\nimport Control.Monad.Trans.Resource\nimport
  Data.Conduit\nimport qualified Data.Conduit.List as CL\nimport Database.Persist.MySQL\nimport
  Database.Persist.Relational\nimport Database.Relational.Query\n\nimport Model\nimport
  Query\n\nsample1 :: SqlPersistT (LoggingT IO) [ImageId]\nsample1 = runResourceT
  $ runQuery (relationalQuery $ imageIdFromTagNameList [\"tokyo\", \"haskell\"]) ()
  $$ CL.consume\n\nsample2 :: SqlPersistT (LoggingT IO) [Entity Image]\nsample2 =
  runResourceT $ runQuery (relationalQuery $ selectImageByTagNameList [\"tokyo\",
  \"haskell\"]) () $$ CL.consume\n\nmain :: IO ()\nmain = runStderrLoggingT $ withMySQLPool
  defaultConnectInfo 10 $ runSqlPool $ do\n    mapM_ (liftBase . print) =<< sample1\n
  \   mapM_ (liftBase . print) =<< sample2\n~~~~\n\n`runQuery` run the HRR `Query`
  and gives the result as conduit `Source`.\nIn addition, it converts the result type
  to persistent's entity if the result type of `Query` is HRR record type.\n\nFor
  example, the expression `selectImageByTagNameList [...]` has type `Relation () Image.Image`,\nbut
  `runQuery (relationalQuery $ selectImageByTagNameList [\"tokyo\", \"haskell\"])
  ()` has type `Source m (Entity Image)`.\n\nFor a full runnable example, see [examples](https://github.com/himura/persistent-relational-record/tree/master/examples/)
  directory.\n"
license-name: BSD3
