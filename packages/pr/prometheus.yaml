homepage: http://github.com/bitnomial/prometheus
changelog-type: ''
hash: f855cfb55e04d0c82a2a9f6542c08b278e6ef27d86b7491f065f9628c7057ac9
test-bench-deps: {}
maintainer: luke@bitnomial.com, opensource@bitnomial.com
synopsis: Prometheus Haskell Client
changelog: ''
basic-deps:
  warp: ! '>=3.2 && <3.3'
  http-client: ! '>=0.4 && <0.6'
  bytestring: ! '>=0.10 && <0.11'
  wai: ! '>=3.2 && <3.3'
  base: ! '>=4.9 && <4.13'
  text: ! '>=1.2 && <1.3'
  containers: ! '>=0.5 && <0.6'
  atomic-primops: ! '>=0.8 && <0.9'
  network-uri: ! '>=2.5 && <2.7'
  transformers: ! '>=0.4 && <0.6'
  http-types: ! '>=0.8 && <0.13'
all-versions:
- 0.1.0.0
- 0.1.0.1
- 0.1.0.2
- 0.1.0.3
- 0.1.1
- 0.2.0
- 0.3.0
- 0.3.1
- 0.3.2
- 0.3.2.1
- 0.4.0
- 0.4.1
- 0.4.2
- 0.5.0
- 2.0.0
- 2.0.1
- 2.0.2
- 2.1.0
- 2.1.1
author: Luke Hoersten
latest: 2.1.1
description-type: markdown
description: |
  # Prometheus Haskell Client

  A simple and modern, type safe, idiomatic Haskell client for
  [Prometheus](http://prometheus.io) monitoring. Specifically there is
  no use of unsafe IO or manual ByteString construction from lists of
  bytes. Batteries-included web server. Version 0.* supports Prometheus v1.0
    and version 2.* supports Prometheus v2.0.

  - [Hackage Package](https://hackage.haskell.org/package/prometheus)
  - [Github](http://github.com/LukeHoersten/prometheus)

  ## Usage Example

  ```haskell
  {-# LANGUAGE OverloadedStrings #-}

  module Example where

  import           Control.Monad.IO.Class                         (liftIO)
  import           System.Metrics.Prometheus.Concurrent.Http      (serveHttpTextMetricsT)
  import           System.Metrics.Prometheus.Concurrent.RegistryT
  import           System.Metrics.Prometheus.Metric.Counter       (inc)
  import           System.Metrics.Prometheus.MetricId

  main :: IO ()
  main = runRegistryT $ do
      -- Labels can be defined as lists or added to an empty label set
      connectSuccessGauge <- registerGauge "example_connections" (fromList [("login", "success")])
      connectFailureGauge <- registerGauge "example_connections" (addLabel "login" "failure" mempty)
      connectCounter <- registerCounter "example_connection_total" mempty
      latencyHistogram <- registerHistogram "example_round_trip_latency_ms" mempty [10, 20..100]

      liftIO $ inc connectCounter -- increment a counter

      -- [...] pass metric handles to the rest of the app

      serveHttpTextMetricsT 8080 ["metrics"] -- http://localhost:8080/metric server
  ```

  ## Advanced Usage

  A `Registry` and `StateT`-based `RegistryT` are available for unit
  testing or generating lists of `[IO a]` actions that can be
  `sequenced` and returned from pure code to be applied.

  ## Tasks

  - [ ] Implement help docstrings.
  - [ ] Implement GHC-specific metrics.
  - [ ] Implement [summary metric](https://github.com/prometheus/client_golang/blob/master/prometheus/summary.go).
  - [ ] Encode name and labels on register.
  - [x] Implement ReaderT for Concurrent Registry.
  - [x] Library documentation and example.
  - [ ] [Name and label validation](http://prometheus.io/docs/concepts/data_model/#metric-names-and-labels)
license-name: BSD-3-Clause
