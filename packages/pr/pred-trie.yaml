homepage: ''
changelog-type: ''
hash: 9852203b2640f12f38dc8cd2783fb79a664cf646b6665947ef8fa592e43f683a
test-bench-deps:
  pred-trie: -any
  base: -any
  unordered-containers: -any
  text: -any
  strict: -any
  criterion: -any
  semigroups: -any
  tries: ! '>=0.0.5'
  containers: -any
  pred-set: -any
  hashtables: -any
  tasty-quickcheck: -any
  mtl: -any
  hashable: -any
  tasty-hunit: -any
  poly-arity: ! '>=0.0.7'
  attoparsec: -any
  tasty: -any
  errors: -any
  deepseq: -any
  QuickCheck: ! '>=2.9.2'
  sets: -any
maintainer: athan.clark@localcooking.com
synopsis: Predicative tries
changelog: ''
basic-deps:
  base: ! '>=4.8 && <5.0'
  unordered-containers: -any
  strict: -any
  semigroups: -any
  tries: ! '>=0.0.5'
  containers: -any
  pred-set: -any
  hashtables: -any
  mtl: -any
  hashable: -any
  poly-arity: ! '>=0.0.7'
  deepseq: -any
  QuickCheck: ! '>=2.9.2'
all-versions:
- '0.5.0'
- '0.5.1'
- '0.5.1.1'
- '0.5.1.2'
- '0.6.0'
author: Athan Clark
latest: '0.6.0'
description-type: markdown
description: ! "pred-trie\n=========\n\nA predicative trie library - use predicates
  instead of literal match to capture\nclasses of results, instead of enumerating
  distinguished ones.\n\n## Usage\n\nThe predicates are existentially quantified such
  that a predicate _creates_ an\nunknown type, while it's result must have the _necessary
  arity_, matching the\nquantified type, to fulfill the lookup:\n\n```haskell\nPredTrie
  s a\n  = PNil\n  | forall t. PCons\n      { predicate :: s -> Maybe t\n      , result
  \   :: t -> a\n      }\n```\n\n...basically.\n\nI broke the lookup phases into \"steps\",
  like the [tries](https://github.com/athanclark/tries)\npackage, and used the fastest-lookup
  `HashMapStep` trie implementation for the\nliteral lookups. For more info, read
  the code :D\n\n## How to run tests\n\n```bash\nstack test\n```\n\n## Benchmarking\n\n```bash\nstack
  bench --benchmark-arguments=\"--output profile.html\"\n```\n"
license-name: BSD3
