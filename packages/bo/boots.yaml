homepage: https://github.com/leptonyu/boots#readme
changelog-type: ''
hash: 9db301b60ba07bb5c734be02b537f5d453162ba690986ca397815d4588afd251
test-bench-deps:
  exceptions: ! '>=0.10.2 && <0.11'
  base: ! '>=4.10 && <5'
  hspec: ==2.*
  text: ! '>=1.2.3.1 && <1.3'
  salak-yaml: ! '>=0.3.1 && <0.4'
  data-default: ! '>=0.7.1.1 && <0.8'
  fast-logger: ! '>=2.4.16 && <2.5'
  salak: ! '>=0.3.1 && <0.4'
  unliftio-core: ! '>=0.1.2.0 && <0.2'
  mtl: ! '>=2.2.2 && <2.3'
  monad-logger: ! '>=0.3.30 && <0.4'
  microlens: ! '>=0.4.10 && <0.5'
maintainer: leptonyu@gmail.com
synopsis: Boot application by plugins
changelog: ''
basic-deps:
  exceptions: ! '>=0.10.2 && <0.11'
  base: ! '>=4.10 && <5'
  boots: -any
  text: ! '>=1.2.3.1 && <1.3'
  salak-yaml: ! '>=0.3.1 && <0.4'
  data-default: ! '>=0.7.1.1 && <0.8'
  fast-logger: ! '>=2.4.16 && <2.5'
  salak: ! '>=0.3.1 && <0.4'
  unliftio-core: ! '>=0.1.2.0 && <0.2'
  mtl: ! '>=2.2.2 && <2.3'
  monad-logger: ! '>=0.3.30 && <0.4'
  microlens: ! '>=0.4.10 && <0.5'
all-versions:
- 0.0.2
author: Daniel YU
latest: 0.0.2
description-type: markdown
description: |-
  # boots

  [![Hackage](https://img.shields.io/hackage/v/boots.svg)](https://hackage.haskell.org/package/boots)
  [![stackage LTS package](http://stackage.org/package/boots/badge/lts)](http://stackage.org/lts/package/boots)
  [![stackage Nightly package](http://stackage.org/package/boots/badge/nightly)](http://stackage.org/nightly/package/boots)
  [![Build Status](https://travis-ci.org/leptonyu/boots.svg?branch=master)](https://travis-ci.org/leptonyu/boots)

  Boot applications by using plugins.

  ### Motivation

  Simplify to create an application in Haskell.

  When we decide to create an application using Haskell. We may need using configurations, loggers as basic functions. If this application needs storages, caches, etc., then we have to weaving the management of connection of these facilities into the application. Connections need to be created before and be destroyed after using them. There is a common strategy to manage connections, that is using `Control.Monad.Cont`. Then we can encapsulate the management of connections separately. For example, we can write a database plugin `Plugin cxt m DBConnection`, which can manage the database connections in monad `m` with context `cxt`. Context `cxt` may be requested for configurations or logging functions. When all the components of application are encapsulated by plugins, then building an application will be simplified.

  ### Have a Try

  ```Haskell
  main :: IO ()
  main = bootApp (pluginSimple "application") go
    where
      go = forever $ do
        user <- require "user"              -- Request for configuration.
        logInfo $ "Hello, " <> user <> "!"  -- Request for logging.
        liftIO $ threadDelay 1000000
  ```
license-name: MIT
