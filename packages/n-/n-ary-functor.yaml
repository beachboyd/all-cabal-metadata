homepage: https://github.com/gelisam/n-ary-functor
changelog-type: markdown
hash: a750375ba1c3d741a03e03bea5598746a9b647aea0c4e8594c891a40fa14d4de
test-bench-deps:
  base: ! '>4 && <5'
  doctest: -any
  doctest-discover: -any
maintainer: gelisam+github@gmail.com
synopsis: An n-ary version of Functor
changelog: |
  ## New in 0.1.0.0

  * Initial release of the `NFunctor` typeclass
basic-deps:
  base: ! '>=4.9 && <5'
all-versions:
- 0.1.0.0
author: Samuel GÃ©lineau
latest: 0.1.0.0
description-type: markdown
description: |
  # N-ary Functors

  [`Functor`](https://hackage.haskell.org/package/base-4.10.1.0/docs/Prelude.html#t:Functor) and [`Bifunctor`](https://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Bifunctor.html#t:Bifunctor) are both in `base`, but what about `Trifunctor`? `Quadrifunctor`? There must be a better solution than creating an infinite tower of typeclasses. Here's the API I managed to implement:

      > nmap <#> (+1) <#> (+2) $ (0, 0)
      (1,2)

      > nmap <#> (+1) <#> (+2) <#> (+3) $ (0, 0, 0)
      (1,2,3)

      > nmap <#> (+1) <#> (+2) <#> (+3) <#> (+4) $ (0, 0, 0, 0)
      (1,2,3,4)

  For more details, see the [documentation](https://hackage.haskell.org/package/n-ary-functor-0.1.0.0/docs/NAryFunctor.html) and the [blog post](http://gelisam.blogspot.ca/2017/12/n-ary-functors.html).
license-name: LicenseRef-PublicDomain
