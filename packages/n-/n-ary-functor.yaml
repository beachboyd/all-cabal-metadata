homepage: https://github.com/gelisam/n-ary-functor
changelog-type: markdown
hash: f125ef30faaf00a86e2d6d541b70ed79f5577af38b5d97e1aa773e07d1e2bcef
test-bench-deps:
  base: ! '>4 && <5'
  doctest: -any
  doctest-discover: -any
maintainer: gelisam+github@gmail.com
synopsis: An n-ary version of Functor
changelog: ! '## New in 0.1.0.0


  * Initial release of the `NFunctor` typeclass

'
basic-deps:
  base: ! '>=4.9 && <4.11'
all-versions:
- 0.1.0.0
author: Samuel GÃ©lineau
latest: 0.1.0.0
description-type: markdown
description: ! "# N-ary Functors\n\n[`Functor`](https://hackage.haskell.org/package/base-4.10.1.0/docs/Prelude.html#t:Functor)
  and [`Bifunctor`](https://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Bifunctor.html#t:Bifunctor)
  are both in `base`, but what about `Trifunctor`? `Quadrifunctor`? There must be
  a better solution than creating an infinite tower of typeclasses. Here's the API
  I managed to implement:\n\n    > nmap <#> (+1) <#> (+2) $ (0, 0)\n    (1,2)\n\n
  \   > nmap <#> (+1) <#> (+2) <#> (+3) $ (0, 0, 0)\n    (1,2,3)\n\n    > nmap <#>
  (+1) <#> (+2) <#> (+3) <#> (+4) $ (0, 0, 0, 0)\n    (1,2,3,4)\n\nFor more details,
  see the [documentation](https://hackage.haskell.org/package/n-ary-functor-0.1.0.0/docs/NAryFunctor.html)
  and the [blog post](http://gelisam.blogspot.ca/2017/12/n-ary-functors.html).\n"
license-name: LicenseRef-PublicDomain
