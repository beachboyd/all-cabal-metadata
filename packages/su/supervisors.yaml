homepage: https://github.com/zenhack/haskell-supervisors
changelog-type: markdown
hash: e6f4f3d41cf88e8875dc77210622b9b8f8e59764065c7d89ebd14ecbd52ecaa0
test-bench-deps:
  base: ^>=4.12
  hspec: ^>=2.6.0
  supervisors: -any
maintainer: ian@zenhack.net
synopsis: Monitor groups of threads with non-hierarchical lifetimes.
changelog: ! '# Revision history for supervisors


  ## 0.1.0.0 -- YYYY-mm-dd


  * First version. Released on an unsuspecting world.

'
basic-deps:
  unliftio: ^>=0.2.8
  stm: ^>=2.5
  base: ^>=4.12
  async: ^>=2.2.1
  containers: ! '>=0.5.9 && <0.7'
all-versions:
- '0.1.0.0'
author: Ian Denhardt
latest: '0.1.0.0'
description-type: markdown
description: ! "[![hackage][hackage-img]][hackage]\n\n# Haskell Supervisors\n\nThe
  `supervisors` package provides a useful abstraction for managing the\ngroups of
  Haskell threads, which may not have a strictly hierarchical\nstructure to their
  lifetimes.\n\nOne way to think of it is that `supervisors` is to [async][async]
  as\n[resourcet][resourcet] is to [bracket][bracket].\n\nMost of the time you can
  manage these things in a hierarchical manner:\nfor bracket, acquire a resource,
  do stuff with it, and release it. For\nasync, spawn some tasks, wait for some or
  all of them, maybe kill the\nremaining ones, and return. The memory used by all
  of these threads is\nnot reclaimed until the entire subtree finishes.\n\nBut sometimes,
  your concurrency patterns don't fit neatly into a tree;\nthat is what this package
  is for.\n\nThis package was originally written for use in the rpc layer of the\n[capnp][capnp]
  package, where the various threads handling rpc calls\ncan have essentially arbitrary
  lifetimes, but we often want to make\nsure they are all shut down when a connection
  is closed.\n\nConcretely, the library provides a `Supervisor` construct, which can
  be\nused to safely spawn threads while guaranteeing that:\n\n* When the supervisor
  is killed, all of the threads it supervises will be\n  killed.\n* Child threads
  can terminate in any order, and memory usage will always\n  be proportional to the
  number of *live* supervised threads.\n\n[async]: https://hackage.haskell.org/package/async\n[bracket]:
  http://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Exception-Base.html#v:bracket\n[resourcet]:
  https://hackage.haskell.org/package/resourcet\n[capnp]: https://hackage.haskell.org/package/capnp\n\n[hackage-img]:
  https://img.shields.io/hackage/v/supervisors.svg\n[hackage]: https://hackage.haskell.org/package/supervisors\n"
license-name: MIT
