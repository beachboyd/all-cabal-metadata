homepage: https://github.com/bitemyapp/esqueleto
changelog-type: markdown
hash: 761419898d82fb63786290d51dada1e262e48ffd423f84a87f24d64d22a1f1a4
test-bench-deps:
  exceptions: -any
  bytestring: -any
  mysql: -any
  unliftio: -any
  base: ! '>=4.8 && <5.0'
  time: ! '>=1.5.0.1 && <=1.8.0.2'
  persistent: ! '>=2.10.0 && <2.11'
  postgresql-libpq: -any
  unordered-containers: ! '>=0.2'
  hspec: -any
  text: ! '>=0.11 && <1.3'
  persistent-template: -any
  persistent-postgresql: ! '>=2.10.0 && <2.11'
  conduit: ! '>=1.3'
  tagged: ! '>=0.2'
  containers: -any
  persistent-mysql: -any
  postgresql-simple: -any
  esqueleto: -any
  mtl: -any
  blaze-html: -any
  monad-logger: -any
  attoparsec: -any
  transformers: ! '>=0.2'
  resourcet: ! '>=1.2'
  persistent-sqlite: -any
  aeson: -any
  vector: -any
  mysql-simple: -any
maintainer: cma@bitemyapp.com
synopsis: Type-safe EDSL for SQL queries on persistent backends.
changelog: |
  3.3.1
  ========

  - @charukiewicz, @belevy, @joemalin95
    - [#167](https://github.com/bitemyapp/esqueleto/pull/167): Exposed functions that were added in `3.3.0`

  3.3.0
  ========

  - @charukiewicz, @belevy, @joemalin95
    - [#166](https://github.com/bitemyapp/esqueleto/pull/166): Add several common SQL string functions: `upper_`, `trim_`, `ltrim_`, `rtrim_`, `length_`, `left_`, `right_`

  3.2.3
  ========

  - @hdgarrood
    - [#163](https://github.com/bitemyapp/esqueleto/pull/163): Allow `unsafeSqlFunction` to take up to 10 arguments without needing to nest tuples.

  3.2.2
  ========

  - @parsonsmatt
    - [#161](https://github.com/bitemyapp/esqueleto/pull/161/): Fix an issue where
      nested joins didn't get the right on clause.

  3.2.1
  ========

  - @parsonsmatt
    - [#159](https://github.com/bitemyapp/esqueleto/pull/159): Add an instance of `UnsafeSqlFunction ()` for 0-argument SQL
    functions.

  3.2.0
  ========

  - @parsonsmatt
    - [#153](https://github.com/bitemyapp/esqueleto/pull/153): Deprecate
      `sub_select` and introduce `subSelect`, `subSelectMaybe`, and
      `subSelectUnsafe`.
  - @parsonsmatt
    - [#156](https://github.com/bitemyapp/esqueleto/pull/156): Remove the
      restriction that `on` clauses must appear in reverse order to the joining
      tables.

  3.1.3
  ========

  - @JoseD92
    - [#155](https://github.com/bitemyapp/esqueleto/pull/149): Added `insertSelectWithConflict` postgres function.

  3.1.2
  ========

  - @tippenein
    - [#149](https://github.com/bitemyapp/esqueleto/pull/157): Added `associateJoin` query helpers.

  3.1.1
  =======

  - @JoseD92
    - [#149](https://github.com/bitemyapp/esqueleto/pull/149): Added `upsert` support.

  - @parsonsmatt
    - [#133](https://github.com/bitemyapp/esqueleto/pull/133): Added `renderQueryToText` and related functions.

  3.1.0
  =======

  - @Vlix
    - [#128](https://github.com/bitemyapp/esqueleto/pull/128): Added `Database.Esqueleto.PostgreSQL.JSON` module with JSON operators and `JSONB` data type.
  - @ibarrae
    - [#127](https://github.com/bitemyapp/esqueleto/pull/127): Added `between` and support for composite keys in `unsafeSqlBinOp`.

  3.0.0
  =======

  - @parsonsmatt
    - [#122](https://github.com/bitemyapp/esqueleto/pull/122): Support `persistent-2.10.0`. This is a breaking change due to the removal of deprecated exports from the `persistent` library.
    - [#113](https://github.com/bitemyapp/esqueleto/pull/113): Remove the `esqueleto` type class. To migrate here, use `SqlExpr`, `SqlQuery`, and `SqlBackend` instead of using the polymorphic `Esqueleto sqlExpr sqlQuery sqlBackend => ...` types.

  2.7.0
  =======

  - @parsonsmatt
    - [#117](https://github.com/bitemyapp/esqueleto/pull/117): Removed `sqlQQ` and `executeQQ` functions from export, fixing doc build and building with `persistent` >= 2.9

  2.6.1
  =======

  - @ChrisCoffey
    - [#114](https://github.com/bitemyapp/esqueleto/pull/114): Fix Haddock by
      working around an upstream bug.

  2.6.0
  ========
  - @bitemyapp
    - Reorganized dependencies, decided to break compatibility for Conduit 1.3, Persistent 2.8, and `unliftio`.
    - Moved tests for `random()` into database-specific test suites.
    - Deprecated Language `random_`, split it into database-specific modules.
  - @parsonsmatt
    - Added support for `PersistQueryRead`/`PersistQueryWrite`, enabling type-safe differentation of read and write capabilities.
      - https://github.com/bitemyapp/esqueleto/pull/66
  - @sestrella
    - Added support for `arrayAggDistinct` and `arrayRemove`.
      - https://github.com/bitemyapp/esqueleto/pull/65
      - https://github.com/bitemyapp/esqueleto/pull/66
  - @mheinzel
    - Fixed JOIN syntax in the documentation https://github.com/bitemyapp/esqueleto/pull/60
  - @illmade
    - Added instructions for running database specific tests
      - https://github.com/bitemyapp/esqueleto/pull/64
  - @FintanH
    - Removed CPP from the test suite, split the database-specific tests into their own respective modules.
      - https://github.com/bitemyapp/esqueleto/pull/48
    - Added support for PostgreSQL's `now()`
      - https://github.com/bitemyapp/esqueleto/pull/46
    - Added a comprehensive examples project to make practical application of Esqueleto easier.
      - https://github.com/bitemyapp/esqueleto/pull/40
  - @EdwardBetts
    - Fixed a spelling error
      - https://github.com/bitemyapp/esqueleto/pull/52
basic-deps:
  bytestring: -any
  unliftio: -any
  base: ! '>=4.8 && <5.0'
  time: ! '>=1.5.0.1 && <=1.10'
  persistent: ! '>=2.10.0 && <2.11'
  unordered-containers: ! '>=0.2'
  text: ! '>=0.11 && <1.3'
  conduit: ! '>=1.3'
  tagged: ! '>=0.2'
  containers: -any
  blaze-html: -any
  monad-logger: -any
  attoparsec: ! '>=0.13 && <0.14'
  transformers: ! '>=0.2'
  resourcet: ! '>=1.2'
  aeson: ! '>=1.0'
all-versions:
- '0.1'
- '0.2'
- 0.2.1
- 0.2.2
- 0.2.3
- 0.2.4
- 0.2.5
- 0.2.6
- 0.2.7
- 0.2.8
- 0.2.9
- '1.0'
- 1.0.1
- 1.0.2
- 1.0.3
- 1.0.5
- 1.0.6
- 1.0.7
- 1.0.8
- '1.2'
- 1.2.1
- 1.2.2
- 1.2.2.1
- 1.2.3
- 1.2.4
- '1.3'
- 1.3.1
- 1.3.2
- 1.3.3
- 1.3.4
- 1.3.4.2
- 1.3.4.3
- 1.3.4.4
- 1.3.4.5
- 1.3.4.6
- 1.3.5
- 1.3.6
- 1.3.7
- 1.3.8
- 1.3.9
- 1.3.10
- 1.3.11
- 1.3.12
- '1.4'
- 1.4.1
- 1.4.1.2
- 1.4.1.3
- 1.4.2
- 1.4.3
- 1.4.4
- 2.0.0
- 2.0.1
- 2.0.2
- 2.0.3
- 2.1.0
- 2.1.1
- 2.1.2
- 2.1.2.1
- 2.1.2.2
- 2.1.2.3
- 2.1.3
- '2.2'
- 2.2.1
- 2.2.2
- 2.2.3
- 2.2.4
- 2.2.5
- 2.2.6
- 2.2.7
- 2.2.8
- 2.2.9
- 2.2.10
- 2.2.11
- 2.2.12
- 2.3.0
- 2.4.0
- 2.4.1
- 2.4.2
- 2.4.3
- 2.5.0
- 2.5.1
- 2.5.2
- 2.5.3
- 2.6.0
- 2.6.1
- 2.7.0
- 3.0.0
- 3.1.0
- 3.1.1
- 3.1.2
- 3.1.3
- 3.2.2
- 3.2.3
- 3.3.0
- 3.3.1
author: Felipe Lessa
latest: 3.3.1
description-type: markdown
description: "Esqueleto [![TravisCI](https://travis-ci.org/bitemyapp/esqueleto.svg)](https://travis-ci.org/bitemyapp/esqueleto)\n==========\n\n![Skeleton](./esqueleto.png)\n<sup>Image
  courtesy [Chrissy Long](https://www.flickr.com/photos/chrissylong/313800029/)</sup>\n\n#
  Esqueleto, a SQL DSL for Haskell\n\nEsqueleto is a bare bones, type-safe EDSL for
  SQL queries that works with unmodified persistent SQL backends. The name of this
  library means \"skeleton\" in Portuguese and contains all three SQL letters in the
  correct order =). It was inspired by Scala's Squeryl but created from scratch. Its
  language closely resembles SQL. Currently, SELECTs, UPDATEs, INSERTs and DELETEs
  are supported.\n\nIn particular, esqueleto is the recommended library for type-safe
  JOINs on persistent SQL backends. (The alternative is using raw SQL, but that's
  error prone and does not offer any composability.). For more information read [esqueleto](http://hackage.haskell.org/package/esqueleto).\n\n##
  Setup\n\nIf you're already using `persistent`, then you're ready to use `esqueleto`,
  no further setup is needed.  If you're just starting a new project and would like
  to use `esqueleto`, take a look at `persistent`'s [book](http://www.yesodweb.com/book/persistent)
  first to learn how to define your schema.\n\nIf you need to use `persistent`'s default
  support for queries as well, either import it qualified:\n\n```haskell\n-- For a
  module that mostly uses esqueleto.\nimport Database.Esqueleto\nimport qualified
  Database.Persistent as P\n```\n\nor import `esqueleto` itself qualified:\n\n```haskell\n--
  For a module that uses esqueleto just on some queries.\nimport Database.Persistent\nimport
  qualified Database.Esqueleto as E\n```\n\nOther than identifier name clashes, `esqueleto`
  does not conflict with `persistent` in any way.\n\n\n## Goals\n\nThe main goals
  of `esqueleto` are:\n\n- Be easily translatable to SQL. (You should be able to know
  exactly how the SQL query will end up.)\n- Support the most widely used SQL features.\n-
  Be as type-safe as possible.\n\nIt is _not_ a goal to be able to write portable
  SQL. We do not try to hide the differences between DBMSs from you\n\n\n## Introduction\n\nFor
  the following examples, we'll use this example schema:\n\n```haskell\nshare [mkPersist
  sqlSettings, mkMigrate \"migrateAll\"] [persist|\n  Person\n    name String\n    age
  Int Maybe\n    deriving Eq Show\n  BlogPost\n    title String\n    authorId PersonId\n
  \   deriving Eq Show\n  Follow\n    follower PersonId\n    followed PersonId\n    deriving
  Eq Show\n|]\n```\n\n## Select\n\nMost of `esqueleto` was created with `SELECT` statements
  in mind, not only because they're the most common but also because they're the most
  complex kind of statement.  The most simple kind of `SELECT` would be:\n\n```haskell\nputPersons
  :: SqlPersist m ()\nputPersons = do\n  people <- select $\n              from $
  \\person -> do\n              return person\n  liftIO $ mapM_ (putStrLn . personName
  . entityVal) people\n```\n\nwhich generates this SQL:\n\n```sql\nSELECT *\nFROM
  Person\n```\n\n`esqueleto` knows that we want an `Entity Person` just because of
  the `personName` that is printed.\n\n## Where\n\nFiltering by `PersonName`:\n\n```haskell\nselect
  $\nfrom $ \\p -> do\nwhere_ (p ^. PersonName ==. val \"John\")\nreturn p\n```\n\nwhich
  generates this SQL:\n\n```sql\nSELECT *\nFROM Person\nWHERE Person.name = \"John\"\n```\n\nThe
  `(^.)` operator is used to project a field from an entity. The field name is the
  same one generated by `persistent`s Template Haskell functions.  We use `val` to
  lift a constant Haskell value into the SQL query.\n\nAnother example:\n\nIn `esqueleto`,
  we may write the same query above as:\n\n```haskell\nselect $\nfrom $ \\p -> do\nwhere_
  (p ^. PersonAge >=. just (val 18))\nreturn p\n```\n\nwhich generates this SQL:\n\n```sql\nSELECT
  *\nFROM Person\nWHERE Person.age >= 18\n```\n\nSince `age` is an optional `Person`
  field, we use `just` to lift`val 18 :: SqlExpr (Value Int)` into `just (val 18)
  ::SqlExpr (Value (Maybe Int))`.\n\n## Joins\n\nImplicit joins are represented by
  tuples.\n\nFor example, to get the list of all blog posts and their authors, we
  could write:\n\n```haskell\nselect $\nfrom $ \\(b, p) -> do\nwhere_ (b ^. BlogPostAuthorId
  ==. p ^. PersonId)\norderBy [asc (b ^. BlogPostTitle)]\nreturn (b, p)\n```\n\nwhich
  generates this SQL:\n\n```sql\nSELECT BlogPost.*, Person.*\nFROM BlogPost, Person\nWHERE
  BlogPost.authorId = Person.id\nORDER BY BlogPost.title ASC\n```\n\n\nHowever, you
  may want your results to include people who don't have any blog posts as well using
  a `LEFT OUTER JOIN`:\n\n```haskell\nselect $\nfrom $ \\(p `LeftOuterJoin` mb) ->
  do\non (just (p ^. PersonId) ==. mb ?. BlogPostAuthorId)\norderBy [asc (p ^. PersonName),
  asc (mb ?. BlogPostTitle)]\nreturn (p, mb)\n```\n\nwhich generates this SQL:\n\n```sql\nSELECT
  Person.*, BlogPost.*\nFROM Person LEFT OUTER JOIN BlogPost\nON Person.id = BlogPost.authorId\nORDER
  BY Person.name ASC, BlogPost.title ASC\n```\n\n## Left Outer Join\n\nOn a `LEFT
  OUTER JOIN` the entity on the right hand side may not exist (i.e. there may be a
  `Person` without any `BlogPost`s), so while `p :: SqlExpr (Entity Person)`, we have
  `mb :: SqlExpr (Maybe (Entity BlogPost))`.  The whole expression above has type
  `SqlPersist m [(Entity Person, Maybe (Entity BlogPost))]`.  Instead of using `(^.)`,
  we used `(?.)` to project a field from a `Maybe (Entity a)`.\n\nWe are by no means
  limited to joins of two tables, nor by joins of different tables.  For example,
  we may want a list of the `Follow` entity:\n\n```haskell\nselect $\nfrom $ \\(p1
  `InnerJoin` f `InnerJoin` p2) -> do\non (p2 ^. PersonId ==. f ^. FollowFollowed)\non
  (p1 ^. PersonId ==. f ^. FollowFollower)\nreturn (p1, f, p2)\n```\n\nwhich generates
  this SQL:\n\n```sql\nSELECT P1.*, Follow.*, P2.*\nFROM Person AS P1\nINNER JOIN
  Follow ON P1.id = Follow.follower\nINNER JOIN Person AS P2 ON P2.id = Follow.followed\n```\n\nNote
  carefully that the order of the ON clauses is reversed! You're required to write
  your `on`s in reverse order because that helps composability (see the documentation
  of `on` for more details).\n\n## Update and Delete\n\n```haskell\ndo update $ \\p
  -> do\n     set p [ PersonName =. val \"João\" ]\n     where_ (p ^. PersonName ==.
  val \"Joao\")\n   delete $\n     from $ \\p -> do\n     where_ (p ^. PersonAge <.
  just (val 14))\n```\n\nThe results of queries can also be used for insertions. In
  `SQL`, we might write the following, inserting a new blog post for every user:\n\n```haskell\n
  insertSelect $ from $ \\p->\n return $ BlogPost <# \"Group Blog Post\" <&> (p ^.
  PersonId)\n```\n\nwhich generates this SQL:\n\n```sql\nINSERT INTO BlogPost\nSELECT
  ('Group Blog Post', id)\nFROM Person\n```\n\nIndividual insertions can be performed
  through Persistent's `insert` function, reexported for convenience.\n\n### Re-exports\n\nWe
  re-export many symbols from `persistent` for convenience:\n- \"Store functions\"
  from \"Database.Persist\".\n- Everything from \"Database.Persist.Class\" except
  for `PersistQuery` and `delete` (use `deleteKey` instead).\n- Everything from \"Database.Persist.Types\"
  except for `Update`, `SelectOpt`, `BackendSpecificFilter` and `Filter`.\n- Everything
  from \"Database.Persist.Sql\" except for `deleteWhereCount` and `updateWhereCount`.\n\n###
  RDBMS Specific\n\nThere are many differences between SQL syntax and functions supported
  by different RDBMSs.  Since version 2.2.8, `esqueleto` includes modules containing
  functions that are specific to a given RDBMS.\n\n- PostgreSQL: `Database.Esqueleto.PostgreSQL`\n-
  MySQL: `Database.Esqueleto.MySQL`\n- SQLite: `Database.Esqueleto.SQLite`\n\nIn order
  to use these functions, you need to explicitly import their corresponding modules.\n\n###
  Unsafe functions, operators and values\n\nEsqueleto doesn't support every possible
  function, and it can't - many functions aren't available on every RDBMS platform,
  and sometimes the same functionality is hidden behind different names. To overcome
  this problem, Esqueleto exports a number of unsafe functions to call any function,
  operator or value. These functions can be found in Database.Esqueleto.Internal.Sql
  module.\n\nWarning: the functions discussed in this section must always be used
  with an explicit type signature,and the user must be careful to provide a type signature
  that corresponds correctly with the underlying code. The functions have extremely
  general types, and if you allow type inference to figure everything out for you,
  it may not correspond with the underlying SQL types that you want. This interface
  is effectively the FFI to SQL database, so take care!\n\nThe most common use of
  these functions is for calling RDBMS specific or custom functions,\nfor that end
  we use `unsafeSqlFunction`. For example, if we wish to consult the postgres\n`now`
  function we could so as follow:\n\n```haskell\npostgresTime :: (MonadIO m, MonadLogger
  m) => SqlWriteT m UTCTime\npostgresTime = \n  result <- select (pure now)\n  case
  result of\n    [x] -> pure x\n    _ -> error \"now() is guaranteed to return a single
  result\"\n  where\n    now :: SqlExpr (Value UTCTime) \n    now = unsafeSqlFunction
  \"now\" ()\n```\n\nwhich generates this SQL:\n\n```sql\nSELECT now()\n```\n\nWith
  the `now` function we could now use the current time of the postgres RDBMS on any
  query.\nDo notice that `now` does not use any arguments, so we use `()` that is
  an instance of\n`UnsafeSqlFunctionArgument` to represent no arguments, an empty
  list cast to a correct value\nwill yield the same result as `()`.\n\nWe can also
  use `unsafeSqlFunction` for more complex functions with customs values using \n`unsafeSqlValue`
  which turns any string into a sql value of whatever type we want, disclaimer:\nif
  you use it badly you will cause a runtime error. For example, say we want to try
  postgres'\n`date_part` function and get the day of a timestamp, we could use:\n\n```haskell\npostgresTimestampDay
  :: (MonadIO m, MonadLogger m) => SqlWriteT m Int\npostgresTimestampDay = \n  result
  <- select (return $ dayPart date)\n  case result of\n    [x] -> pure x\n    _ ->
  error \"dayPart is guaranteed to return a single result\"\n  where\n    dayPart
  :: SqlExpr (Value UTCTime) -> SqlExpr (Value Int) \n    dayPart s = unsafeSqlFunction
  \"date_part\" (unsafeSqlValue \"\\'day\\'\" :: SqlExpr (Value String) ,s)\n    date
  :: SqlExpr (Value UTCTime)\n    date = unsafeSqlValue \"TIMESTAMP \\'2001-02-16
  20:38:40\\'\"\n```\n\nwhich generates this SQL:\n\n```sql\nSELECT date_part('day',
  TIMESTAMP '2001-02-16 20:38:40')\n```\n\nUsing `unsafeSqlValue` we were required
  to also define the type of the value.\n\nAnother useful unsafe function is `unsafeSqlCastAs`,
  which allows us to cast any type\nto another within a query. For example, say we
  want to use our previews `dayPart` function\non the current system time, we could:\n\n```haskell\npostgresTimestampDay
  :: (MonadIO m, MonadLogger m) => SqlWriteT m Int\npostgresTimestampDay = do\n  currentTime
  <- liftIO getCurrentTime\n  result <- select (return $ dayPart (toTIMESTAMP $ val
  currentTime))\n  case result of\n    [x] -> pure x\n    _ -> error \"dayPart is
  guaranteed to return a single result\"\n  where\n    dayPart :: SqlExpr (Value UTCTime)
  -> SqlExpr (Value Int) \n    dayPart s = unsafeSqlFunction \"date_part\" (unsafeSqlValue
  \"\\'day\\'\" :: SqlExpr (Value String) ,s)\n    toTIMESTAMP :: SqlExpr (Value UTCTime)
  -> SqlExpr (Value UTCTime)\n    toTIMESTAMP = unsafeSqlCastAs \"TIMESTAMP\"\n```\n\nwhich
  generates this SQL:\n\n```sql\nSELECT date_part('day', CAST('2019-10-28 23:19:39.400898344Z'
  AS TIMESTAMP))\n```\n\n### SQL injection\n\nEsqueleto uses parameterization to prevent
  sql injections on values and arguments\non all queries, for example, if we have:\n\n```haskell\nmyEvilQuery
  :: (MonadIO m, MonadLogger m) => SqlWriteT m ()\nmyEvilQuery = \n  select (return
  $ val (\"hi\\'; DROP TABLE foo; select \\'bye\\'\" :: String)) >>= liftIO . print\n```\n\nwhich
  generates this SQL(when using postgres):\n\n```sql\nSELECT 'hi''; DROP TABLE foo;
  select ''bye'''\n```\n\nAnd the printed value is `hi\\'; DROP TABLE foo; select
  \\'bye\\'` and no table is dropped. This is good\nand makes the use of strings values
  safe. Unfortunately this is not the case when using unsafe functions.\nLet's see
  an example of defining a new evil `now` function:\n\n```haskell\nmyEvilQuery ::
  (MonadIO m, MonadLogger m) => SqlWriteT m ()\nmyEvilQuery = \n  select (return nowWithInjection)
  >>= liftIO . print\n  where\n    nowWithInjection :: SqlExpr (Value UTCTime) \n
  \   nowWithInjection = unsafeSqlFunction \"0; DROP TABLE bar; select now\" ([] ::
  [SqlExpr (Value Int)])\n```\n\nwhich generates this SQL:\n\n```sql\nSELECT 0; DROP
  TABLE bar; select now()\n```\n\nIf we were to run the above code we would see the
  postgres time printed but the table `bar`\nwill be erased with no indication whatsoever.
  Another example of this behavior is seen when using\n`unsafeSqlValue`:\n\n```haskell\nmyEvilQuery
  :: (MonadIO m, MonadLogger m) => SqlWriteT m ()\nmyEvilQuery = \n  select (return
  $ dayPart dateWithInjection) >>= liftIO . print\n  where\n    dayPart :: SqlExpr
  (Value UTCTime) -> SqlExpr (Value Int) \n    dayPart s = unsafeSqlFunction \"date_part\"
  (unsafeSqlValue \"\\'day\\'\" :: SqlExpr (Value String) ,s)\n    dateWithInjection
  :: SqlExpr (Value UTCTime)\n    dateWithInjection = unsafeSqlValue \"TIMESTAMP \\'2001-02-16
  20:38:40\\');DROP TABLE bar; select (16\"\n```\n\nwhich generates this SQL:\n\n```sql\nSELECT
  date_part('day', TIMESTAMP '2001-02-16 20:38:40');DROP TABLE bar; select (16)\n```\n\nThis
  will print 16 and also erase the `bar` table. The main take away of this examples
  is to\nnever use any user or third party input inside an unsafe function without
  first parsing it or\nheavily sanitizing the input.\n\n### Tests and Postgres\n\nTo
  run the tests, do `stack test`. This tests all the backends, so you'll need\nto
  have MySQL and Postgresql installed.\n\nUsing apt-get, you should be able to do:\n\n```\nsudo
  apt-get install postgresql postgresql-contrib\nsudo apt-get install libpq-dev\n```\n\nUsing
  homebrew on OSx\n\n```\nbrew install postgresql\nbrew install libpq\n```\n\nDetailed
  instructions on the Postgres wiki [here](https://wiki.postgresql.org/wiki/Detailed_installation_guides)\n\nThe
  connection details are located near the bottom of the [test/PostgreSQL/Test.hs](test/PostgreSQL/Test.hs)
  file:\n\n```\nwithConn =\n  R.runResourceT . withPostgresqlConn \"host=localhost
  port=5432 user=esqutest password=esqutest dbname=esqutest\"\n```\n\nYou can change
  these if you like but to just get them working set up as follows on linux:\n\n```$
  sudo -u postgres createuser esqutest```\n\n```$ sudo -u postgres createdb esqutest```\n\n```\n$
  sudo -u postgres psql\npostgres=# \\password esqutest\n```\n\n\nAnd on osx\n\n```$
  createuser esqutest```\n\n```$ createdb esqutest```\n\n```\n$ psql postgres\npostgres=#
  \\password esqutest\n```\n"
license-name: BSD-3-Clause
