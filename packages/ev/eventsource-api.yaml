homepage: https://gitlab.com/YoEight/eventsource-api-hs
changelog-type: markdown
hash: 59377ab4608f0986107e977cfc7fa97910a73fcfd97e91794c0fc2b0da8b1971
test-bench-deps: {}
maintainer: yo.eight@gmail.com
synopsis: Provides an eventsourcing high level API.
changelog: ! "1.5.0\n=====\n  * Introduce a streaming interface.\n  * Remove aggregate
  interface.\n\n1.3.1\n=====\n  * Fix GHC 8.4 build.\n\n1.3.0\n=====\n  * Move `EventNumber`
  to `Int64`.\n\n1.2.0\n=====\n  * Introduce Aggregate API.\n\n1.1.1\n=====\n  * Fix
  GHC 8.2.1 and Stackage LTS-9 build.\n\n1.1.0\n=====\n  * Add `linkEvent` to `SavedEvent`.\n\n1.0.2\n=====\n
  \ * Implement essential typesclasses\n\n1.0.1\n=====\n  * Add `forSavedEvents`\n
  \ * Add `foldSavedEventsM`\n  * Add `foldSavedEvents`\n  * Add `foldSubSaved`\n
  \ * Add `foldSubSavedAsync`\n  * Expose `ForEventFailure(..)`\n"
basic-deps:
  streaming: -any
  bytestring: -any
  stm: -any
  base: ! '>=4.9 && <5'
  unordered-containers: -any
  text: -any
  uuid: -any
  enclosed-exceptions: -any
  monad-loops: ==0.4.*
  monad-control: -any
  lifted-base: -any
  containers: -any
  mtl: -any
  lifted-async: -any
  transformers-base: -any
  stm-chans: -any
  string-conversions: -any
  aeson: -any
all-versions:
- 1.0.0
- 1.0.1
- 1.0.2
- 1.1.0
- 1.1.1
- 1.2.0
- 1.3.0
- 1.3.1
- 1.5.0
author: Yorick Laupa
latest: 1.5.0
description-type: markdown
description: ! "# eventsource-api\n\nThis project provides what we think be a lean
  eventsourcing API. The goal is to\nset a common ground for eventsourcing-based application,
  yet doesn't force you\nto be trapped under a restrictive framework.\n\nThis library
  main abstraction is the `Store` typeclass.\n\n```haskell\n-- | Main event store
  abstraction. It exposes essential features expected from\n--   an event store.\nclass
  Store store where\n  -- | Appends a batch of events at the end of a stream.\n  appendEvents
  :: (EncodeEvent a, MonadBase IO m)\n               => store\n               -> StreamName\n
  \              -> ExpectedVersion\n               -> [a]\n               -> m (Async
  EventNumber)\n\n  -- | Reads a stream in a stream-processing fashion.\n  readStream
  :: MonadBase IO m\n             => store\n             -> StreamName\n             ->
  Batch\n             -> Stream (Of SavedEvent) (ExceptT ReadFailure m) ()\n\n  --
  | Subscribes to given stream.\n  subscribe :: MonadBase IO m => store -> StreamName
  -> m Subscription\n\n\n```\n\nThe idea is to use any backend of your liking as long
  as it's able to derive that typeclass with its related implicit constraints.\n\n
  \ 1. `appendEvents` MUST add events at the end of a stream without doing any other
  alteration on the stream. The order of the event's array MUST be respected within
  the store. Most important, the implementation MUST comply to the given `ExpectedVersion`
  passed by the user.\n\n  2. `readStream` SHOULD retrieve a set of event given a
  starting position and a batch size (represented by the `Batch` parameter). The returned
  array MUST have its events ordered by their `EventNumber` property.\n\n  3. `subscribe`
  SHOULD register a subscription to the given stream. An implementation MUST allow
  to subscribe to a stream that doesn't exist yet. A subscription allows the user
  to be notified of any event added to the stream. There is no mandatory timing to
  meet regarding how fast the subscription is notified by a change. We only suggest
  to dispatch new events as soon as possible.\n\n#### `ExpectedVersion`\n\nA word
  on `ExpectedVersion`. It's a mean to preserve data consistency in a concurrent setting.\n\n```haskell\n--
  | The purpose of 'ExpectedVersion' is to make sure a certain stream state is\n--
  \  at an expected point in order to carry out a write.\ndata ExpectedVersion\n  =
  AnyVersion\n    -- Stream is a any given state.\n  | NoStream\n    -- Stream shouldn't
  exist.\n  | StreamExists\n    -- Stream should exist.\n  | ExactVersion EventNumber\n
  \   -- Stream should be at givent event number.\n```\n\nOn a write, if the `ExpectedVersion`
  condition given by the user is not met within the store, the implementation should
  raise an exception. At the moment, the API doesn't capture this situation in the
  type system.\n"
license-name: BSD-3-Clause
