homepage: https://github.com/gspia/fcf-containers
changelog-type: markdown
hash: 563077208fc103ddc80262c4b006c7474ee0ad4055a6bedf9bc75f609c536e89
test-bench-deps:
  first-class-families: -any
  fcf-containers: -any
  base: -any
maintainer: iahogsp@gmail.com
synopsis: Data structures and algorithms for first-class-families
changelog: "\n# 0.2.0\n\n - remove the methods that can be found from fcf 0.7.0\n
  - fix the examples that didn't work with ghc 8.8.1 test-doc\n - add Fcf.Data.Symbol
  module (comparison + other functions)\n - change some of the examples from using
  Eval to use =<< operator\n   (less parenthesis and easier to read this way)\n -
  format the documentation a bit\n - add PowerSet and ToList into Set-module\n - add
  new test module\n\n# 0.1.0\n\nInitial version on 20200129. The next version probably
  comes out quickly after \nthis one.\n"
basic-deps:
  first-class-families: ==0.7.*
  base: ! '>=4.9 && <4.14'
all-versions:
- 0.1.0
- 0.2.0
author: gspia
latest: 0.2.0
description-type: markdown
description: "# fcf-containers\n\nFcf-containers mimicks the containers package but
  for type-level computations. \nThat is, we provide e.g. trees and maps. In addition
  to that, this package \ncontains some other type-level computation utilities. \n\nThese
  methods are based on the idea given in the\n[first-class-families](https://github.com/Lysxia/first-class-families)
  -package,\nor Fcf shortly. Fcf is the main dependency of fcf-containers. As some
  of the\nmethods fit badly under the name \"fcf-containers\", they might end up into
  \nthe Fcf or some other package to be created. So stay tuned, be patient, check
  \nthe [TODO.md](https://github.com/gspia/fcf-containers/blob/master/TODO.md) \nand
  send those PR's :)\n\n\nMotivation for calculating things on type-level or on compile-time
  \ninclude\n\n- increase the safety measures of runtime methods,\n- pre-calculate
  complex things once on compile time and not every time the\n  executable is run,
  \n- provide users a way to choose between different algorithms for solving\n  a
  problem based on problem instance properties (e.g. local vs network,\n  or small
  vs large) known in advance.\n \nWhy fcf-like? The kind of signatures used for functions
  might be easier to \nread for some people and the ability to apply partially a function
  is nice \ntool to have.\n \nIf you have other motivations, please do let us know!
  \n\nNote: some of the claims on the items in the above list are such that I \nbelieve/hope
  but really don't know at the moment nor do I know how check them. \nE.g. the matter
  of compile time vs run time. Yes, types are erased at compile \ntime but do they
  still leave something into executables: simple check by \ncomparing outputs of the
  orbit example and another program that has one method \nto print integer 42 and
  main, reveals that sizes are almost the same, but not \nexactly.\n\n\nThere are
  lot of open interesting questions. See \n[TODO.md](https://github.com/gspia/fcf-containers/blob/master/TODO.md)
  file. E.g. how combine \nthese techniques with singletons-lib and related techniques.
  \n\n\n\n## Installation and building \n\nFirst, get the repo with `git clone` and
  `cd` into the directory. \n\n```\nnix-shell \ncabal build \ncabal test \n```\n\nThe
  doc-tests both document and work as main testing mechanism for this lib. \n\nIf
  you don't use nix, `cabal install fcf-containers` should be enough. This\npackage
  has almost as good number of dependencies as the first-class-families.\n\n\n## Example\n\nSee
  [Orbits.hs](https://github.com/gspia/fcf-containers/blob/master/examples/Orbits.hs).
  \nIt shows how to solve a real problem,\nwhat PRAGMAs are probably needed etc.\n\n```\ncabal
  run orbits \n```\n\nThe `ghci` and `:kind!` command in there are your friends!\n\nSource
  also contains a lot of examples, see\n[fcf-containers](https://github.com/gspia/fcf-containers/tree/master/src/Fcf).\n\n\nHappy
  :kinding!\n"
license-name: BSD-3-Clause
