homepage: https://github.com/GaloisInc/avro#readme
changelog-type: markdown
hash: fc6f6544afd05fd375b427c47c539a5ce380a3f1f754b08dd55e7d6e20008f15
test-bench-deps:
  bytestring: -any
  lens-aeson: -any
  extra: -any
  pure-zlib: -any
  fail: -any
  base: ! '>=4.6 && <5'
  unordered-containers: -any
  hspec: -any
  text: -any
  entropy: -any
  semigroups: -any
  array: -any
  tagged: -any
  containers: -any
  lens: -any
  bifunctors: -any
  binary: -any
  avro: -any
  mtl: -any
  hashable: -any
  base16-bytestring: -any
  transformers: -any
  scientific: -any
  QuickCheck: -any
  aeson: -any
  template-haskell: -any
  vector: -any
  directory: -any
maintainer: Alexey Raga <alexey.raga@gmail.com>
synopsis: Avro serialization support for Haskell
changelog: ! '# Revision history for avro


  ## 0.4.1.1


  - Fixed bugs in handling of namespaces when parsing and printing avro types

  - Fixed a schema overlay test


  ## 0.4.1.0


  - Fixed an omitted data fixture from the cabal sdist

  - Improvements on experimental lazy decoding (up to 25% faster on our tests)

  - Useful instances for EitherN


  ## 0.4.0.0


  - Technical release to respect potentially breaking changes introduced earlier.


  ## 0.3.6.1


  - Fixed Data.Avro.Schema.extractBindings by @TikhonJelvis


  ## 0.1.0.0  -- YYYY-mm-dd


  - First version. Released on an unsuspecting world.

'
basic-deps:
  bytestring: -any
  pure-zlib: -any
  fail: -any
  base: ! '>=4.8 && <5.0'
  unordered-containers: -any
  text: -any
  entropy: -any
  semigroups: -any
  array: -any
  tagged: -any
  containers: -any
  bifunctors: -any
  binary: -any
  mtl: -any
  data-binary-ieee754: -any
  hashable: -any
  base16-bytestring: -any
  scientific: -any
  aeson: -any
  template-haskell: ! '>=2.4'
  vector: -any
all-versions:
- 0.1.0.0
- 0.1.0.1
- 0.2.0.0
- 0.2.1.0
- 0.2.1.1
- 0.3.0.0
- 0.3.0.1
- 0.3.0.2
- 0.3.0.3
- 0.3.0.4
- 0.3.0.5
- 0.3.1.0
- 0.3.1.2
- 0.3.2.0
- 0.3.3.0
- 0.3.3.1
- 0.3.4.1
- 0.3.4.2
- 0.3.4.3
- 0.3.5.0
- 0.3.5.1
- 0.3.5.2
- 0.3.6.0
- 0.3.6.1
- 0.4.0.0
- 0.4.1.0
- 0.4.1.1
author: Thomas M. DuBuisson
latest: 0.4.1.1
description-type: markdown
description: ! "# Native Haskell implementation of Avro\n\nThis is a Haskell [Avro](https://avro.apache.org/)
  library useful for decoding\nand encoding Avro data structures.  Avro can be thought
  of as a serialization\nformat and RPC specification which induces three separable
  tasks:\n\n* *Serialization*/*Deserialization* - This library has been used \"in
  anger\" for:\n  - Deserialization of avro container files\n  - Serialization/deserialization
  Avro messages to/from Kafka topics\n* *RPC* - There is currently no support for
  Avro RPC in this library.\n\nThis library also provides functionality for automatically
  generating Avro-related data types and instances from Avro schemas (using TemplateHaskell).\n\n#
  Quickstart\n\nThis library provides the following conversions between Haskell types
  and Avro types:\n\n| Haskell type      | Avro type                       |\n|:------------------|:--------------------------------|\n|
  ()                | \"null\"                          |\n| Bool              | \"boolean\"
  \                      |\n| Int, Int64        | \"long\"                          |\n|
  Int32             | \"int\"                           |\n| Double            | \"double\"
  \                       |\n| Text              | \"string\"                        |\n|
  ByteString        | \"bytes\"                         |\n| Maybe a           | [\"null\",
  \"a\"]                   |\n| Either a b        | [\"a\", \"b\"]                      |\n|
  Map Text a        | {\"type\": \"map\", \"value\": \"a\"}   |\n| Map String a      |
  {\"type\": \"map\", \"value\": \"a\"}   |\n| HashMap Text a    | {\"type\": \"map\",
  \"value\": \"a\"}   |\n| HashMap String a  | {\"type\": \"map\", \"value\": \"a\"}
  \  |\n| [a]               | {\"type\": \"array\", \"value\": \"a\"} |\n\nUser defined
  data types should provide `HasAvroSchema`/`ToAvro`/`FromAvro` instances to be encoded/decoded
  to/from Avro.\n\n## Defining types and `HasAvroSchema` / `FromAvro` / `ToAvro` manually\n\nTypically
  these imports are useful:\n```\nimport           Data.Avro\nimport           Data.Avro.Schema
  as S\nimport qualified Data.Avro.Types  as AT\n```\n\nAssuming there is a data type
  to be encoded/decoded from/to Avro:\n```\ndata Gender = Male | Female deriving (Eq,
  Ord, Show, Enum)\ndata Person = Person\n     { fullName :: Text\n     , age      ::
  Int32\n     , gender   :: Gender\n     , ssn      :: Maybe Text\n     } deriving
  (Show, Eq)\n```\n\nAvro schema for this type can be defined as:\n```\ngenderSchema
  :: Schema\ngenderSchema = mkEnum \"Gender\" [] Nothing Nothing [\"Male\", \"Female\"]\n\npersonSchema
  :: Schema\npersonSchema =\n  Record \"Person\" Nothing [] Nothing Nothing\n    [
  fld \"name\"   String       Nothing\n    , fld \"age\"    Int          Nothing\n
  \   , fld \"gender\" genderSchema Nothing\n    , fld \"ssn\" (mkUnion $ Null :|
  [String]) Nothing\n    ]\n    where\n     fld nm ty def = Field nm [] Nothing Nothing
  ty def\n\ninstance HasAvroSchema Person where\n  schema = pure personSchema\n```\n\n`ToAvro`
  instance for `Person` can be defined as:\n```\ninstance ToAvro Person where\n  schema
  = pure personSchema\n  toAvro p = record personSchema\n             [ \"name\"   .=
  fullName p\n             , \"age\"    .= age p\n             , \"gender\" .= gender
  p\n             , \"ssn\"    .= ssn p\n             ]\n```\n\n`FromAvro` instance
  for `Person` can be defined as:\n```\ninstance FromAvro Person where\n  fromAvro
  (AT.Record _ r) =\n    Person <$> r .: \"name\"\n           <*> r .: \"age\"\n           <*>
  r .: \"gender\"\n           <*> r .: \"ssn\"\n  fromAvro r = badValue r \"Person\"\n```\n\n##
  Defining types and `HasAvroSchema` / `FromAvro` / `ToAvro` \"automatically\"\nThis
  library provides functionality to derive Haskell data types and `HasAvroSchema`/`FromAvro`/`ToAvro`
  instances \"automatically\" from already existing Avro schemas (using TemplateHaskell).\n\n###
  Examples\n\n`deriveAvro` will derive data types, `FromAvro` and `ToAvro` instances
  from a provided Avro schema file:\n```\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE
  DeriveGeneric   #-}\nimport Data.Avro.Deriving\n\nderiveAvro \"schemas/contract.avsc\"\n```\n\nSimilarly,
  `deriveFromAvro` can be used to only derive data types and `FromAvro`, but not `ToAvro`
  instances.\n\nIf you prefer defining Avro schema in Haskell and not in `avsc`, then
  `deriveAvro'` can be used instead of `deriveAvro`.\n\n### Conventions\nWhen Haskell
  data types are generated, these conventions are followed:\n\n- Type and field names
  are \"sanitized\":\nall the charachers except `[a-z,A-Z,',_]` are removed from names\n-
  Field names are prefixed with the name of the record they are declared in.\n\nFor
  example, if Avro schema defines `Person` record as:\n```\n{ \"type\": \"record\",\n
  \ \"name\": \"Person\",\n  \"fields\": [\n    { \"name\": \"name\", \"type\": \"string\"}\n
  \ ]\n}\n```\n\nthen generated Haskell type will look like:\n```\ndata Person = Person\n
  \    { personName :: Text\n     } deriving (Show, Eq)\n```\n\n### Limitations\nTwo-parts
  unions like `[\"null\", \"MyType\"]` or `[\"MyType\", \"YourType\"]` are supported
  (as Haskell's `Maybe MyType` and `Either MyType YourType`), but multi-parts unions
  are currently _not_ supported.\nIt is not due to any fundamental problems but because
  it has not been done yet. PRs are welcomed! :)\n# TODO\nPlease see the [TODO](TODO)\n"
license-name: BSD-3-Clause
